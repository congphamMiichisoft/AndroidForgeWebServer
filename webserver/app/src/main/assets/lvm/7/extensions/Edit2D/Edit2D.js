/*!
 * LMV v7.34.2
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Edit2D =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Edit2D/Edit2D.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/CompGeom/bezier.js":
/*!***************************************!*\
  !*** ./extensions/CompGeom/bezier.js ***!
  \***************************************/
/*! exports provided: DefaultTessParams, SetTesselationParams, TesselateCubic, TesselateQuad, getCubeBezierPoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultTessParams", function() { return DefaultTessParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTesselationParams", function() { return SetTesselationParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateCubic", function() { return TesselateCubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateQuad", function() { return TesselateQuad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCubeBezierPoint", function() { return getCubeBezierPoint; });


var DefaultTessParams = {
  //How many forward iterations to use when approximating Bezier curves
  //More iterations are needed in case the min_seg_len setting below is smaller
  //relative to mesh size. However, the two numbers need to be tuned together
  //so that NUM_ITERATIONS is enough to result in segment lengths desired.

  //Note that those values are tuned for PDF rendering, where text characters
  //are drawn one by one. If a long piece of text is drawn all at once, then
  //its bounding box will be quite large, so the relative min_seg_len will also
  //be too large and the characters will look coarse. In such cases, we will need
  //to better estimate this by using e.g. the font height only.
  numIterations: 100,

  //What fraction of the bounding sbox should be the minimum length of
  //a segment
  minSegLenFraction: 0.05 };


function SetTesselationParams(num_iterations, min_seg_len_fraction) {
  if (num_iterations)
  DefaultTessParams.numIterations = num_iterations;

  if (min_seg_len_fraction)
  DefaultTessParams.minSegLenFraction = min_seg_len_fraction;
}

function distance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
}

function adjustMaxdim(maxdim, segLength) {
  if (maxdim > 4 * segLength && segLength > 0) {
    var time = Math.sqrt(maxdim / segLength);
    time = Math.min(4, time);
    maxdim = segLength * time;
  }
  return maxdim;
}

function TesselateCubic(ctx, px1, py1, px2, py2, px3, py3, px4, py4, maxdim, tessParams, isFont)
{
  tessParams = tessParams || DefaultTessParams;

  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3) + distance(px3, py3, px4, py4);

  // maxdim is the size of the bounds of the path
  // but for individual path, we need to use aproximateLength
  // we need to balance both performance and visual effect
  // so we leverage both value and try to balance it.
  if (!isFont) {
    maxdim = adjustMaxdim(maxdim, aproximateLength);
  }

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to 1/100 of the bounds
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  //double dt2 = dt*dt;
  var dt3 = dt * dt * dt;

  var pre1 = 3.0 * dt;
  var pre2 = pre1 * dt;
  var pre3 = pre2 + pre2;
  var pre4 = 6.0 * dt3;

  var temp1x = px1 - 2.0 * px2 + px3;
  var temp1y = py1 - 2.0 * py2 + py3;
  var temp2x = 3.0 * (px2 - px3) - px1 + px4;
  var temp2y = 3.0 * (py2 - py3) - py1 + py4;

  var fx = px1;
  var fy = py1;
  var dfx = (px2 - px1) * pre1 + temp1x * pre2 + temp2x * dt3;
  var dfy = (py2 - py1) * pre1 + temp1y * pre2 + temp2y * dt3;
  var ddfx = temp1x * pre3 + temp2x * pre4;
  var ddfy = temp1y * pre3 + temp2y * pre4;
  var dddfx = temp2x * pre4;
  var dddfy = temp2y * pre4;

  var error = 0.0;

  // forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;
    ddfy += dddfy;
    ddfx += dddfx;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) //add segment only if we have reached treshold length
      {
        // line to current
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px4, py4);
}

function TesselateQuad(ctx, px1, py1, px2, py2, px3, py3, maxdim, tessParams, isFont)
{
  tessParams = tessParams || DefaultTessParams;

  var aproximateLength = distance(px1, py1, px2, py2) + distance(px2, py2, px3, py3);

  // maxdim is the size of the bounds of the path
  // but for individual path, we need to use aproximateLength
  // we need to balance both performance and visual effect
  // so we leverage both value and try to balance it.
  if (!isFont) {
    maxdim = adjustMaxdim(maxdim, aproximateLength);
  }

  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / tessParams.minSegLenFraction;

  //minimum length of tesselation segment
  //set to a fraction of the bbox of the entire path (value chosen to work well for text at reasonable font size)
  var minSegLen = maxdim * tessParams.minSegLenFraction;

  //but for now we will iterate 100 times
  var dt = 1.0 / tessParams.numIterations;

  var dt2 = dt * dt;

  var ax = px1 - 2.0 * px2 + px3; //replace 2* by addition?
  var ay = py1 - 2.0 * py2 + py3; //replace 2* by addition?

  var bx = 2.0 * (px2 - px1);
  var by = 2.0 * (py2 - py1);

  var fx = px1;
  var fy = py1;
  var dfx = bx * dt + ax * dt2;
  var dfy = by * dt + ay * dt2;
  var ddfx = 2.0 * ax * dt2;
  var ddfy = 2.0 * ay * dt2;

  var error = 0.0;

  //forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) // how many pixels should each line be?)
      {
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px3, py3);
}

// Cubic Bezier for single points. Note that TesselateCubic is faster by using deltas.
// Result is returned as a new {x,y} or written to optionalTarget.
function getCubeBezierPoint(t, px1, py1, px2, py2, px3, py3, px4, py4, optionalTarget) {

  var result = optionalTarget || { x: x, y: y };

  var k = 1 - t;

  // Bernstein coefficients
  var bp1 = k * k * k;
  var bp2 = 3 * k * k * t;
  var bp3 = 3 * k * t * t;
  var bp4 = t * t * t;

  result.x = bp1 * px1 + bp2 * px2 + bp3 * px3 + bp4 * px4;
  result.y = bp1 * py1 + bp2 * py2 + bp3 * py3 + bp4 * py4;

  return result;
}

/***/ }),

/***/ "./extensions/Edit2D/Actions.js":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Actions.js ***!
  \**************************************/
/*! exports provided: Actions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Actions", function() { return Actions; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BooleanOps.js */ "./extensions/Edit2D/BooleanOps.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Collection of basic edit actions that support undo/redo.
//
// Each action provides undo() and redo() functions. UndoStack takes care that actions are always called in consistent order. 
// I.e., an individual action can assume that undo/redo is only called if the state allows it. (e.g. target shape exists and has expected number of vertices etc.)


var

Action = /*#__PURE__*/function () {
  function Action(layer) {_classCallCheck(this, Action);
    this.layer = layer;
  }_createClass(Action, [{ key: "undo", value: function undo()

    {
      throw new Error('Abstract method invoked');
    } }, { key: "redo", value: function redo()

    {
      throw new Error('Abstract method invoked');
    }

    // Optional: Can be be implemented to guide what should be selected before/after change.
    // @param {bool} afterUndo - If true, return recommended selection state after undo, otherwise after redo.    
    // @returns {SelectionHint|null}     
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return null;
    } }]);return Action;}();


// Struct for possible return values of getSelectionHint
var SelectioHint =
function SelectioHint() {_classCallCheck(this, SelectioHint);
  // {Shape}
  this.shape = null;

  // {Shape[]} - only needed for multiselect operations
  this.shapes = null;

  // {PolyIndex} - selected vertex
  this.vertex = null;

  // {PolyIndex} - selected edge
  this.edge = null;
};var


AddShape = /*#__PURE__*/function (_Action) {_inherits(AddShape, _Action);var _super = _createSuper(AddShape);
  function AddShape(layer, shape) {var _this;_classCallCheck(this, AddShape);
    _this = _super.call(this, layer);
    _this.shape = shape;return _this;
  }_createClass(AddShape, [{ key: "undo", value: function undo()

    {
      this.layer.removeShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.addShape(this.shape);
    }

    // After redo, new shape should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? null : { shape: this.shape };
    } }]);return AddShape;}(Action);var


AddShapes = /*#__PURE__*/function (_Action2) {_inherits(AddShapes, _Action2);var _super2 = _createSuper(AddShapes);

  // @param {Shape[]} shapes
  function AddShapes(layer, shapes) {var _this2;_classCallCheck(this, AddShapes);
    _this2 = _super2.call(this, layer);
    _this2.shapes = shapes;return _this2;
  }_createClass(AddShapes, [{ key: "undo", value: function undo()

    {var _this3 = this;
      this.shapes.forEach(function (s) {return _this3.layer.removeShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this4 = this;
      this.shapes.forEach(function (s) {return _this4.layer.addShape(s);});
    }

    // After redo, new shape should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? null : { shapes: this.shapes };
    } }]);return AddShapes;}(Action);var


MoveShapes = /*#__PURE__*/function (_Action3) {_inherits(MoveShapes, _Action3);var _super3 = _createSuper(MoveShapes);
  function MoveShapes(layer, shapes, dx, dy) {var _this5;_classCallCheck(this, MoveShapes);
    _this5 = _super3.call(this, layer);
    _this5.shapes = shapes;
    _this5.delta = { x: dx, y: dy };

    // Note that transforming back and forth is not always exactly 1:1. 
    _this5.beforeState = _this5.shapes.map(function (s) {return s.clone();});
    _this5.afterState = _this5.shapes.map(function (s) {return s.clone();});

    _this5.afterState.forEach(function (s) {return s.move(dx, dy);});return _this5;
  }_createClass(MoveShapes, [{ key: "undo", value: function undo()

    {var _this6 = this;
      this.shapes.forEach(function (s, i) {return s.copy(_this6.beforeState[i]);});
    } }, { key: "redo", value: function redo()

    {var _this7 = this;
      this.shapes.forEach(function (s, i) {return s.copy(_this7.afterState[i]);});
    }

    // After undo/redo, moved shapes should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return { shapes: this.shapes };
    } }]);return MoveShapes;}(Action);var


RemoveShape = /*#__PURE__*/function (_Action4) {_inherits(RemoveShape, _Action4);var _super4 = _createSuper(RemoveShape);
  function RemoveShape(layer, shape) {var _this8;_classCallCheck(this, RemoveShape);
    _this8 = _super4.call(this, layer);
    _this8.shape = shape;return _this8;
  }_createClass(RemoveShape, [{ key: "undo", value: function undo()

    {
      this.layer.addShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.removeShape(this.shape);
    }

    // After undo, recovered shape should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? { shape: this.shape } : null;
    } }]);return RemoveShape;}(Action);var


RemoveShapes = /*#__PURE__*/function (_Action5) {_inherits(RemoveShapes, _Action5);var _super5 = _createSuper(RemoveShapes);
  function RemoveShapes(layer, shapes) {var _this9;_classCallCheck(this, RemoveShapes);
    _this9 = _super5.call(this, layer);
    _this9.shapes = shapes.slice();return _this9;
  }_createClass(RemoveShapes, [{ key: "undo", value: function undo()

    {var _this10 = this;
      this.shapes.forEach(function (s) {return _this10.layer.addShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this11 = this;
      this.shapes.forEach(function (s) {return _this11.layer.removeShape(s);});
    }

    // After undo, recovered shapes should be selected
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return afterUndo ? { shapes: this.shapes } : null;
    } }]);return RemoveShapes;}(Action);var


AddVertex = /*#__PURE__*/function (_Action6) {_inherits(AddVertex, _Action6);var _super6 = _createSuper(AddVertex);
  function AddVertex(layer, poly, polyIndex, p) {var _this12;_classCallCheck(this, AddVertex);
    _this12 = _super6.call(this, layer);
    _this12.poly = poly;
    _this12.polyIndex = polyIndex;
    _this12.point = p.clone();return _this12;
  }_createClass(AddVertex, [{ key: "undo", value: function undo()

    {
      this.poly.removePoint(this.polyIndex.vertex, this.polyIndex.loop);
    } }, { key: "redo", value: function redo()

    {
      this.poly.insertPoint(this.polyIndex.vertex, this.point, this.polyIndex.loop);
    }

    // After redo, select the new vertex
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly,
        vertex: afterUndo ? null : this.polyIndex };

    } }]);return AddVertex;}(Action);


// Only for polygons and polylines
var MoveVertex = /*#__PURE__*/function (_Action7) {_inherits(MoveVertex, _Action7);var _super7 = _createSuper(MoveVertex);
  function MoveVertex(layer, poly, polyIndex, newPos) {var _this13;_classCallCheck(this, MoveVertex);
    _this13 = _super7.call(this, layer);
    _this13.poly = poly;
    _this13.polyIndex = polyIndex;
    _this13.posBefore = poly.getPoint(polyIndex.vertex, polyIndex.loop);
    _this13.posAfter = newPos.clone();return _this13;
  }_createClass(MoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.updatePoint(this.polyIndex.vertex, this.posBefore.x, this.posBefore.y, this.polyIndex.loop);
    } }, { key: "redo", value: function redo()
    {
      this.poly.updatePoint(this.polyIndex.vertex, this.posAfter.x, this.posAfter.y, this.polyIndex.loop);
    }

    // After undo/redo, select moved vertex
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly,
        vertex: this.polyIndex };

    } }]);return MoveVertex;}(Action);


// Returns an object that allows for recovering all arc params assoicated with a vertex
var copyArcParams = function copyArcParams(poly, index, loop) {
  if (!poly.isPath() || !poly.edgeIndexValid(index, loop)) {
    return null;
  }

  var type = poly.getEdgeType(index, loop);
  switch (type) {
    // Note that the getter already returns a copy
    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:return poly.getEllipseArcParams(index, loop);
    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:return {
        cp1: poly.getControlPoint(index, 1, loop),
        cp2: poly.getControlPoint(index, 2, loop) };

    case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:return null;
    default:console.warn('unexpected edge type');}

};

// Recover an arc based on the result returned by copyArcParam
var restoreArc = function restoreArc(poly, index, loop, arcParams) {
  if (!arcParams) {
    // nothing to restore
    return;
  }

  if (arcParams instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]) {
    // recover ellipse arc
    poly.setEllipseArc(index, arcParams);
  } else if (arcParams.cp1) {
    // recover bezier arc
    var cp1 = arcParams.cp1;
    var cp2 = arcParams.cp2;
    poly.setBezierArc(index, cp1.x, cp1.y, cp2.x, cp2.y);
  }
};var

RemoveVertex = /*#__PURE__*/function (_Action8) {_inherits(RemoveVertex, _Action8);var _super8 = _createSuper(RemoveVertex);
  function RemoveVertex(layer, poly, polyIndex) {var _this14;_classCallCheck(this, RemoveVertex);
    _this14 = _super8.call(this, layer);
    _this14.poly = poly;
    _this14.vertex = polyIndex.vertex;
    _this14.loop = polyIndex.loop;
    _this14.point = poly.getPoint(_this14.vertex, _this14.loop);

    // For consistency and simplicity, we remove arcs if start or end vertex is removed.
    _this14.arcBefore = copyArcParams(poly, poly.edgeBeforeVertex(_this14.vertex, _this14.loop), _this14.loop);
    _this14.arcAfter = copyArcParams(poly, poly.edgeAfterVertex(_this14.vertex, _this14.loop), _this14.loop);return _this14;
  }_createClass(RemoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.insertPoint(this.vertex, this.point, this.loop);

      // recover arc params
      restoreArc(this.poly, this.poly.edgeBeforeVertex(this.vertex, this.loop), this.loop, this.arcBefore);
      restoreArc(this.poly, this.poly.edgeAfterVertex(this.vertex, this.loop), this.loop, this.arcAfter);
    } }, { key: "redo", value: function redo()

    {
      // remove arcs at edges starting/ending at the vertex
      if (this.poly.isPath()) {
        this.poly.removeArc(this.poly.edgeBeforeVertex(this.vertex, this.loop), this.loop);
        this.poly.removeArc(this.poly.edgeAfterVertex(this.vertex, this.loop), this.loop);
      }

      this.poly.removePoint(this.vertex, this.loop);
    }

    // After undo, select recovered vertex
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly,
        vertex: afterUndo ? this.polyIndex : null };

    } }]);return RemoveVertex;}(Action);



// Moves an edge to a new position specified by new positions for start and end vertex.
// Optionally, start and end vertex may be duplicated before moving the edge. In this case, the neighbar edges keep unchanged and
// we introduce new intermediate edges to connect the old start/end position with the new one.
var MoveEdge = /*#__PURE__*/function (_Action9) {_inherits(MoveEdge, _Action9);var _super9 = _createSuper(MoveEdge);

  // @param {EditLayer} layer
  // @param {Polybase}  poly      - must be at start before the change
  // @param {PolyIndex} polyIndex - edge to be modified    
  // @param {Vector3}   newPosA, newPosB
  // @param {bool}      duplicateStartVertex, duplicateEndVertex - Optional, start and end vertex of the edge may be duplicated.
  function MoveEdge(layer, poly, polyIndex, newPosA, newPosB, duplicateStartVertex, duplicateEndVertex) {var _this15;_classCallCheck(this, MoveEdge);
    _this15 = _super9.call(this, layer);
    _this15.poly = poly;

    // store edge index
    _this15.edgeIndex = polyIndex.vertex;
    _this15.loopIndex = polyIndex.loop;

    // store duplicate flags
    _this15.duplicateStartVertex = duplicateStartVertex;
    _this15.duplicateEndVertex = duplicateEndVertex;

    var ia = _this15.edgeIndex;
    var ib = poly.nextIndex(ia, _this15.loopIndex);

    // get edge 
    var a = poly.getPoint(ia, _this15.loopIndex);
    var b = poly.getPoint(ib, _this15.loopIndex);

    _this15.edgeBefore = {
      a: a,
      b: b };

    _this15.edgeAfter = {
      a: newPosA.clone(),
      b: newPosB.clone() };return _this15;

  }_createClass(MoveEdge, [{ key: "undo", value: function undo()

    {
      // get current edgeIndex (after duplicating vertices)
      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get indices of the two edge vertices
      var ia = newEdgeIndex;
      var ib = this.poly.nextIndex(ia, this.loopIndex);

      // Restore original edge positions
      this.poly.updatePoint(ia, this.edgeBefore.a.x, this.edgeBefore.a.y, this.loopIndex);
      this.poly.updatePoint(ib, this.edgeBefore.b.x, this.edgeBefore.b.y, this.loopIndex);

      // Remove extra vertices
      MoveEdge.revertDuplicateVertices(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);
    } }, { key: "redo", value: function redo()

    {
      // Duplicate start/end vertex if wanted
      MoveEdge.duplicateVertices(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get edgeIndex after duplicating vertices
      var newEdgeIndex = MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // get indices of the two edge vertices
      var ia = newEdgeIndex;
      var ib = this.poly.nextIndex(ia, this.loopIndex);

      // apply new positions
      this.poly.updatePoint(ia, this.edgeAfter.a.x, this.edgeAfter.a.y, this.loopIndex);
      this.poly.updatePoint(ib, this.edgeAfter.b.x, this.edgeAfter.b.y, this.loopIndex);
    }

    // Insert a duplicate of vertex i to position i+1. Note that vertex i only copies
    // the position. If vertex i contained arc params, these will be at vertex i+1.
  }, { key: "getSelectionHint",














































































    // After undo/redo, select the moved edge. Note that its index may change due to vertex duplication.
    value: function getSelectionHint(afterUndo) {
      var edgeIndex = afterUndo ? this.edgeIndex : MoveEdge.getNewEdgeIndex(this.poly, this.edgeIndex, this.loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);
      return {
        shape: this.poly,
        edge: new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: edgeIndex, loop: this.loopIndex }) };

    } }], [{ key: "duplicateVertex", value: function duplicateVertex(poly, index) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var p = poly.getPoint(index, loopIndex);poly.insertPoint(index, { x: p.x, y: p.y }, loopIndex);} // Duplicates start and/or end vertex of a given edge in a polyline/polygon.
  }, { key: "duplicateVertices", value: function duplicateVertices(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {var startVertex = edgeIndex;if (duplicateStartVertex) {MoveEdge.duplicateVertex(poly, startVertex, loopIndex); // After duplicating, the actual edge start vertex has shifted by 1.
        startVertex++;}if (duplicateEndVertex) {var vNext = poly.nextIndex(startVertex, loopIndex);MoveEdge.duplicateVertex(poly, vNext, loopIndex);}} }, { key: "revertDuplicateVertices", // Reverts the extra vertices inserted by duplicateVertices. Note that edgeIndex refers
    // to the polygon before duplicating the vertices, i.e., should be identical with 
    // the one used in the duplicateVertices(..) to be reverted.
    value: function revertDuplicateVertices(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {// get edge index after considering vertex duplication
      var curEdgeIndex = MoveEdge.getNewEdgeIndex(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex); // If the end vertex was duplicated, revert that now
      if (duplicateStartVertex) {// Note that it is important to remove the vertex BEFORE edge start instead of the edge start itself.
        // Although both have identical positions, the edge start vertex may contain additional arc params.
        var iPrev = curEdgeIndex - 1;poly.removePoint(iPrev, loopIndex); // This shifts the edgeIndex back by 1
        curEdgeIndex--;}if (duplicateEndVertex) {// Always remove the first of the two duplicate vertices. The first one is the copy that just contains
        // the position, while the second (=original) one may contain additional arc params.
        var iNext = poly.nextIndex(curEdgeIndex, loopIndex);poly.removePoint(iNext, loopIndex);}} }, { key: "getNewEdgeIndex", // If we duplicate start/end vertex of an edge, the index of that edge may change.
    // This function returns the new index of the edge after duplicating start/end vertex.
    //
    // Note: poly is assumed to contain the duplicated vertices.
    value: function getNewEdgeIndex(poly, edgeIndex, loopIndex, duplicateStartVertex, duplicateEndVertex) {var newIndex = edgeIndex; // Duplicating the start vertex always shift the edgeIndex by 1
      if (duplicateStartVertex) {newIndex++;} // get vertexCount of the polygon before insertion of duplicated vertices.
      var vertexCountBefore = poly.getVertexCount(loopIndex) - (duplicateStartVertex ? 1 : 0) - (duplicateEndVertex ? 1 : 0); // Check if edge was the 'closing edge' of the original polygon, i.e., the edge that 
      // connects the last vertex with vertex 0
      var isClosingEdge = edgeIndex === vertexCountBefore - 1; // Duplicating the end vertex may also shift the edgeIndex. This happens if the edge start
      // vertex is the last one in a polygon.
      if (duplicateEndVertex && isClosingEdge) {newIndex++;}return newIndex;} }]);return MoveEdge;}(Action); // Change arc type of a Path edge. It can also be used to change arc params without changing the actual type.
var ChangeEdgeType = /*#__PURE__*/function (_Action10) {_inherits(ChangeEdgeType, _Action10);var _super10 = _createSuper(ChangeEdgeType); // @param {EditLayer} layer
  // @param {Path}      path  - must be in "before" state of the action
  // @param {PolyIndex} polyIndex
  // @param {EdgeType}  edgeType
  // @param {Vector2}   [cp1] - Control points. Only needed when changing to Bezier
  // @param {Vector2}   [cp2]
  // @param {EllipseArcParams} [arcParams] - only needed when changing to EllipseArc
  function ChangeEdgeType(layer, path, polyIndex, edgeType, cp1, cp2, arcParams) {var _this16;_classCallCheck(this, ChangeEdgeType);_this16 = _super10.call(this, layer);_this16.path = path;_this16.edgeIndex = polyIndex.vertex;_this16.loopIndex = polyIndex.loop; // Store previous edge props
    var isBezier = path.isBezierArc(_this16.edgeIndex, _this16.loopIndex);_this16.oldEdgeType = path.getEdgeType(_this16.edgeIndex, _this16.loopIndex);_this16.oldCp1 = isBezier && path.getControlPoint(_this16.edgeIndex, 1, _this16.loopIndex);_this16.oldCp2 = isBezier && path.getControlPoint(_this16.edgeIndex, 2, _this16.loopIndex);_this16.oldEllipseArcParams = path.getEllipseArcParams(_this16.edgeIndex, _this16.loopIndex); // Store new control points (if any)
    _this16.newEdgeType = edgeType;_this16.newCp1 = cp1;_this16.newCp2 = cp2;_this16.newEllipseArcParams = arcParams;return _this16;}_createClass(ChangeEdgeType, [{ key: "redo", value: function redo()

    {
      switch (this.newEdgeType) {
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:this.path.removeArc(this.edgeIndex, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:this.path.setEllipseArc(this.edgeIndex, this.newEllipseArcParams, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:this.path.setBezierArc(this.edgeIndex, this.newCp1.x, this.newCp1.y, this.newCp2.x, this.newCp2.y, this.loopIndex);break;}

    } }, { key: "undo", value: function undo()

    {
      switch (this.oldEdgeType) {
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line:this.path.removeArc(this.edgeIndex, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:this.path.setBezierArc(this.edgeIndex, this.oldCp1.x, this.oldCp1.y, this.oldCp2.x, this.oldCp2.y, this.loopIndex);break;
        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:this.path.setEllipseArc(this.edgeIndex, this.oldEllipseArcParams, this.loopIndex);break;}

    }

    // After undo/redo, select changed edge
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.path,
        edge: new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: this.edgeIndex, loop: this.loopIndex }) };

    } }]);return ChangeEdgeType;}(Action);var


ApplyCutOut = /*#__PURE__*/function (_Action11) {_inherits(ApplyCutOut, _Action11);var _super11 = _createSuper(ApplyCutOut);

  function ApplyCutOut(layer, cutPath) {var _this17;_classCallCheck(this, ApplyCutOut);
    _this17 = _super11.call(this, layer);

    // collect all other polygons and closed paths in the layer that overlap the cutPath bbox
    var cutBox = cutPath.getBBox();
    _this17.paths = layer.shapes.filter(function (s) {

      if (s === cutPath) {
        return false;
      }

      // cutout is only be applied on Polygons and closed Paths
      var isClosed = s instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] && s.isClosed;
      if (!isClosed) {
        return false;
      }

      var box = s.getBBox();
      return cutBox.isIntersectionBox(box);
    });

    // subtract cutPath from all overlapping shapes
    _this17.clippedPaths = _this17.paths.map(function (p) {
      return _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].apply(p, cutPath, _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].Operator.Difference);
    });

    // create backups of original paths before cutout
    _this17.originalShapes = _this17.paths.map(function (p) {return p.clone();});

    _this17.cutPath = cutPath;return _this17;
  }_createClass(ApplyCutOut, [{ key: "redo", value: function redo()

    {var _this18 = this;
      // replace geometry of all shapes by clipped versions
      this.paths.forEach(function (p, i) {return p.copyGeometry(_this18.clippedPaths[i]);});
      this.layer.update();
    } }, { key: "undo", value: function undo()

    {var _this19 = this;
      // replace all shapes by original versions
      this.paths.forEach(function (p, i) {return p.copyGeometry(_this19.originalShapes[i]);});
    }

    // After undo/redo, select shape that was used for cutout
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.cutPath };

    } }]);return ApplyCutOut;}(Action);var


RemoveLoops = /*#__PURE__*/function (_Action12) {_inherits(RemoveLoops, _Action12);var _super12 = _createSuper(RemoveLoops);

  function RemoveLoops(layer, poly, loops) {var _this20;_classCallCheck(this, RemoveLoops);
    _this20 = _super12.call(this, layer);

    _this20.poly = poly;
    _this20.loops = loops;

    // create a backup of the shape before change
    _this20.before = _this20.poly.clone();return _this20;
  }_createClass(RemoveLoops, [{ key: "redo", value: function redo()

    {
      this.poly.removeLoops(this.loops);
    } }, { key: "undo", value: function undo()

    {
      this.poly.copy(this.before);
    }

    // After undo/redo, select modified shape
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly };

    } }]);return RemoveLoops;}(Action);var


MoveLoop = /*#__PURE__*/function (_Action13) {_inherits(MoveLoop, _Action13);var _super13 = _createSuper(MoveLoop);

  function MoveLoop(layer, poly, loopIndex, dx, dy) {var _this21;_classCallCheck(this, MoveLoop);
    _this21 = _super13.call(this, layer);

    _this21.poly = poly;
    _this21.loopIndex = loopIndex;
    _this21.before = _this21.poly.clone();

    _this21.dx = dx;
    _this21.dy = dy;return _this21;
  }_createClass(MoveLoop, [{ key: "redo", value: function redo()

    {
      this.poly.moveLoop(this.dx, this.dy, this.loopIndex);
    } }, { key: "undo", value: function undo()

    {
      this.poly.copy(this.before);
    }

    // After undo/redo, select modified shape
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.poly };

    } }]);return MoveLoop;}(Action);


// Merges all shapes into the first one
var UnifyShapes = /*#__PURE__*/function (_Action14) {_inherits(UnifyShapes, _Action14);var _super14 = _createSuper(UnifyShapes);

  // @param {EditLayer}  layer 
  // @param {PolyBase[]} shapes     - shapes to merge
  // @param {number}     shapeIndex - index within shapes array. All other shapes will be merged into this one.
  function UnifyShapes(layer, shapes, shapeIndex) {var _this22;_classCallCheck(this, UnifyShapes);
    _this22 = _super14.call(this, layer);

    _this22.merged = _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].apply(shapes[0], shapes[1], _BooleanOps_js__WEBPACK_IMPORTED_MODULE_1__["BooleanOps"].Operator.Union, shapes.slice(2));
    _this22.before = shapes[shapeIndex].clone();

    _this22.mainShape = shapes[shapeIndex];
    _this22.otherShapes = shapes.filter(function (s) {return s !== _this22.mainShape;});return _this22;
  }_createClass(UnifyShapes, [{ key: "redo", value: function redo()

    {

      // Merge other shapes into main shape
      this.mainShape.copyGeometry(this.merged);

      // Remove all other shapes
      this.layer.removeShapes(this.otherShapes);
    } }, { key: "undo", value: function undo()

    {
      // Recover original main shape
      this.mainShape.copyGeometry(this.before);

      // Add other shapes back to layer
      this.layer.addShapes(this.otherShapes);
    }

    // After undo/redo, select mainShape
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return {
        shape: this.mainShape };

    } }]);return UnifyShapes;}(Action);


// Changes Bezier arc tangent at a vertex v. This may affect up to two edge adjacent to v.
var ChangeBezierTangent = /*#__PURE__*/function () {

  // @param {EditLayer} layer
  // @param {Path}      path
  // @param {number}    vertex     - index of the vertex to be changed
  // @param {number}    loopIndex
  // @param {Vector2}   pStart     - tangent start. This is cp2 of the previous bezier segment (if any)
  // @param {Vector2}   pEnd       - tangent end    
  function ChangeBezierTangent(layer, path, index, loopIndex, pStart, pEnd) {_classCallCheck(this, ChangeBezierTangent);
    this.layer = layer;
    this.path = path;
    this.index = index;
    this.loopIndex = loopIndex;
    this.pStart = pStart;
    this.pEnd = pEnd;

    // Backup of original shape
    this.before = path.clone();
  }

  // Set the two control points that define the bezier tangent. Usually, pEnd is just pStart mirrored at the vertex
  _createClass(ChangeBezierTangent, [{ key: "setTangent", value: function setTangent(pStart, pEnd) {
      this.pStart = pStart;
      this.pEnd = pEnd;
    }

    // Apply modified tangent endpoints after dragging on of the tangent vertices.
    //
    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.
  }, { key: "redo", value: function redo() {

      // Set start point: This is cp2 of previous arc segment (if any)
      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index, this.loopIndex);
      var prevExists = prevEdgeIndex !== -1;
      if (prevExists && this.path.isBezierArc(prevEdgeIndex, this.loopIndex)) {
        this.path.updateControlPoint(prevEdgeIndex, 2, this.pStart.x, this.pStart.y, this.loopIndex);
      }

      // Set end point: This is cp1 of current segment
      var nextEdgeIndex = this.path.edgeAfterVertex(this.index, this.loopIndex);
      var nextExists = nextEdgeIndex !== -1;
      if (nextExists && this.path.isBezierArc(nextEdgeIndex, this.loopIndex)) {
        this.path.updateControlPoint(this.index, 1, this.pEnd.x, this.pEnd.y, this.loopIndex);
      }
    } }, { key: "undo", value: function undo()

    {
      this.path.copyGeometry(this.before);
    }

    // ChangeBezierTangent may happen if a vertex or an edge is selected. So, the hint must be set from
    // outside when the information is available.
    //   @param {PolyIndex} vertex
    //   @param {PolyIndex} edge
  }, { key: "setSelectionItem", value: function setSelectionItem(vertex, edge) {
      this.selectionHint = {
        shape: this.path,
        vertex: vertex,
        edge: edge };

    }

    // After undo/redo, select the edge that was modified
  }, { key: "getSelectionHint", value: function getSelectionHint(afterUndo) {
      return this.selectionHint;
    } }]);return ChangeBezierTangent;}();


var Actions = {
  Action: Action,
  AddShape: AddShape,
  AddShapes: AddShapes,
  MoveShapes: MoveShapes,
  RemoveShape: RemoveShape,
  RemoveShapes: RemoveShapes,
  AddVertex: AddVertex,
  MoveVertex: MoveVertex,
  RemoveVertex: RemoveVertex,
  MoveEdge: MoveEdge,
  ChangeEdgeType: ChangeEdgeType,
  ApplyCutOut: ApplyCutOut,
  RemoveLoops: RemoveLoops,
  UnifyShapes: UnifyShapes,
  MoveLoop: MoveLoop,
  ChangeBezierTangent: ChangeBezierTangent };

/***/ }),

/***/ "./extensions/Edit2D/AngleGizmo.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/AngleGizmo.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleGizmo; });
/* harmony import */ var _Arrow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Arrow.js */ "./extensions/Edit2D/Arrow.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var Colors = {
  Black: 'rgb(0,0,0)' };


// An angle gizmo indicates a rotation angle using two arrows (start/end direction) and a connecting arc.
// The arc is drawn along the shortest connection, either cw or ccw.
var AngleGizmo = /*#__PURE__*/function () {

  function AngleGizmo(layer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, AngleGizmo);
    this.layer = layer;
    this.options = options;

    // --- Configuration params ---

    // Corner points encloding the angle
    this.center = new THREE.Vector2(); // center of the arc
    this.pStart = new THREE.Vector2(); // center->pStart indicates direction before rotation
    this.pEnd = new THREE.Vector2(); // center->pEnd indicates direction after rotation

    // sizes in pixels
    this.arrowLength = 150;
    this.arrowHeadLength = 18;
    this.arcRadius = 100;

    // Indicate which points are properly set. If only center and one point are valid, we show just an arrow.
    this.centerValid = false;
    this.pStartValid = false;
    this.pEndValid = false;

    // Optional: Show dotted line that connects the arrow with the points that define the direction.
    this.showExtendLines = true;

    // Specifies how far we shift the labelPosition away from the center. An offset of 0 would mean to center the label
    // on the center point of the angle arc line. 
    this.labelPosOffset = 30;

    // Angle text label
    this.enableLabel = true;

    // --- Maintained by the gizmo ---

    // Arrow shapes. Auto-updated based on settings
    this.arrowStart = new _Arrow_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    this.arrowEnd = new _Arrow_js__WEBPACK_IMPORTED_MODULE_0__["default"]();

    // Sharpness of arrow peaks
    this.arrowStart.headAngle = 45;
    this.arrowEnd.headAngle = 45;


    // Arc line connecting the two arrows
    this.arcLine = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Path"]().allocPoints(2);
    this.arcArrow = new _Arrow_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
    this.arcFill = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Path"]().allocPoints(3);
    this.arcFill.isClosed = true;

    // Used and auto-updated in upadte() 
    this.arcParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["EllipseArcParams"]();

    // Update shapes on camera updates
    this.onCameraChange = this.onCameraChange.bind(this);
    this.layer.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

    // arc style
    this.arcFillOpacity = 0.2;
    this.arcFill.style.lineAlpha = 0;
    this.arcFill.style.fillAlpha = this.arcFillOpacity;
    this.arcLine.style.lineWidth = 2.0;
    this.arcLine.style.lineColor = this.options.arcColor || Colors.Black;

    this.arcArrow.line.style.lineColor = this.options.arcColor || Colors.Black;
    this.arcArrow.line.style.lineWidth = 2.0;
    this.arcArrow.head.style.lineAlpha = 0;
    this.arcArrow.head.style.fillColor = this.options.arcColor || Colors.Black;
    this.arcArrow.head.style.fillAlpha = 1;
    this.arcArrowMaxHeadLength = 0.3; // If the arc arrow is very short (small angles), we restrict the headSize to a percentage of the arrow length

    // start arrow line style
    this.arrowStart.line.style.lineColor = this.options.startColor || Colors.Black;
    this.arrowStart.line.style.lineWidth = 1.5;

    // end arrow line style 
    this.arrowEnd.line.style.lineColor = this.options.endColor || Colors.Black;
    this.arrowEnd.line.style.lineWidth = 1.5;

    // start arrow head style
    this.arrowStart.head.style.lineAlpha = 0;
    this.arrowStart.head.style.fillColor = this.options.startColor || Colors.Black;
    this.arrowStart.head.style.fillAlpha = 1;

    // end arrow head style
    this.arrowEnd.head.style.lineAlpha = 0;
    this.arrowEnd.head.style.fillColor = this.options.endColor || Colors.Black;
    this.arrowEnd.head.style.fillAlpha = 1;

    this.label = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["TextLabel"](this.layer, '', this.options.labelClassName);

    // reused values for label position computation 
    this.labelPos = new THREE.Vector2(); // in layer-coords
    this.arcCurve = new Autodesk.Extensions.CompGeom.EllipseArc();
    this.visible = false;

    // For fadeIn/Out effects
    var setOpacity = function setOpacity(opacity) {
      _this.arrowStart.line.style.lineAlpha = opacity;
      _this.arrowStart.head.style.fillAlpha = _this.options.hideArrowHead ? 0 : opacity;
      _this.arrowEnd.line.style.lineAlpha = opacity;
      _this.arrowEnd.head.style.fillAlpha = _this.options.hideArrowHead ? 0 : opacity;
      _this.arcLine.style.lineAlpha = opacity;
      _this.arcArrow.line.style.lineAlpha = opacity;
      _this.arcArrow.head.style.fillAlpha = opacity;
      _this.arcFill.style.fillAlpha = opacity * _this.arcFillOpacity;
      _this.opacity = opacity;
      _this.layer.update();
    };

    this.opacityParam = new Autodesk.Viewing.Private.AnimatedParam(1.0, setOpacity, 0.5);

    // reflects current fadeIn/fadeOut state
    this.opacity = 1.0;
  }_createClass(AngleGizmo, [{ key: "setCenter", value: function setCenter(

    center) {
      if (center) {
        this.center.copy(center);
        this.centerValid = true;
      } else {
        this.centerValid = false;
      }
    } }, { key: "setStart", value: function setStart(

    pStart) {
      if (pStart) {
        this.pStart.copy(pStart);
        this.pStartValid = isFinite(pStart.x) && isFinite(pStart.y);

        // Warn on NaN/Inf values
        if (!this.pStartValid) {
          console.warn("AngleGizmo: Invalid start point");
        }

      } else {
        this.pStartValid = false;
      }
    } }, { key: "setEnd", value: function setEnd(

    pEnd) {
      if (pEnd) {
        this.pEnd.copy(pEnd);
        this.pEndValid = isFinite(pEnd.x) && isFinite(pEnd.y);

        // Warn on NaN/Inf values
        if (!this.pEndValid) {
          console.warn("AngleGizmo: Invalid end point");
        }
      } else {
        this.pEndValid = false;
      }
    } }, { key: "dtor", value: function dtor()

    {
      this.layer.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (this.visible == visible) {
        return;
      }

      this.visible = visible;
      if (visible) {
        this.layer.addShape(this.arrowStart);
        this.layer.addShape(this.arrowEnd);
        this.layer.addShape(this.arcLine);
        this.layer.addShape(this.arcArrow);
        this.layer.addShape(this.arcFill);
      } else {
        this.layer.removeShape(this.arrowStart);
        this.layer.removeShape(this.arrowEnd);
        this.layer.removeShape(this.arcLine);
        this.layer.removeShape(this.arcArrow);
        this.layer.removeShape(this.arcFill);
      }
    } }, { key: "setOpacity", value: function setOpacity(

    opacity) {
      this.opacityParam.setValue(opacity);
    } }, { key: "skipFade", value: function skipFade()

    {
      this.opacityParam.skipAnim();
    }

    // Fade in/out. This also sets the visibility, i.e. shapes are hidden when opacity reaches zero.
  }, { key: "fadeTo", value: function fadeTo(value) {
      this.opacityParam.fadeTo(value);
    }

    // Update arc label position based on center point of the arc. Note that this.arcLine must be up to 
  }, { key: "updateLabel", value: function updateLabel(pixelsPerUnit, arcRadius) {

      var arc = this.arcLine.exportEllipseArc(0, 0, this.arcCurve);
      var labelPos;

      if (this.options.centerLabel) {
        labelPos = this.center;
      } else {
        // get point at center of the angle arc
        labelPos = arc.getPoint(0.5, this.labelPos);

        // Shift label position more "outside", i.e. away from the center
        var labelPosOffset = this.labelPosOffset / pixelsPerUnit;
        labelPos.sub(this.center);
        labelPos.normalize();
        labelPos.multiplyScalar(arcRadius + labelPosOffset);
        labelPos.add(this.center);
      }

      this.label.setPosition(labelPos.x, labelPos.y);

      // update label text
      var angle = THREE.Math.radToDeg(arc.getAngleDelta());

      if (!isNaN(angle)) {
        var text = angle.toFixed(1) + "°";
        this.label.setText(text);
      }
    } }, { key: "update", value: function update()

    {

      // Note: When using the gizmo on a plane in 3D, pixelsPerUnit may vary per point.
      // Todo: Add general support for this case to Edit2D layers.
      var pixelsPerUnit = 1;

      // In case ignoreCameraDistance is set, the size of the arc won't change depending on the camera distance.
      // In fact, the gizmo will behave more like an overlay.
      if (!this.options.ignoreCameraDistance) {
        var pWorld = new THREE.Vector3(this.center.x, this.center.y, 0).applyMatrix4(this.layer.layerToWorld);
        pixelsPerUnit = this.layer.viewer.impl.camera.pixelsPerUnitAtPoint(pWorld);
      }

      // convert all sizes to layer-space
      var arrowHeadLength = this.arrowHeadLength / pixelsPerUnit;
      var arcRadius = this.arcRadius / pixelsPerUnit;

      // Check if all directions are valid
      var showGizmo = this.centerValid && this.pStartValid && this.pEndValid;

      // Update gizmo visibility
      this.arrowStart.setVisible(showGizmo);
      this.arrowEnd.setVisible(showGizmo);
      this.arcLine.setVisible(showGizmo);
      this.arcArrow.setVisible(showGizmo);
      this.arcFill.setVisible(showGizmo);

      // Update label visibility
      var showLabel = showGizmo && this.enableLabel;
      this.label.setOpacity(showLabel ? 1.0 : 0.0, true); // label fades smoothly

      // If everything is hidden now anyway, we are done here
      if (!showGizmo) {
        // Note that we still have to update in case some shapes just changed from visible to hidden.
        this.layer.update();
        return;
      }

      // arrows start at the angle center
      this.arrowStart.setFrom(this.center);
      this.arrowEnd.setFrom(this.center);

      // arrows point toward pStart/pEnd
      this.arrowStart.setTo(this.pStart);
      this.arrowEnd.setTo(this.pEnd);

      // scale arrow-head sizes for constant screen-size
      if (!this.options.hideArrowHead) {
        this.arrowStart.setHeadLength(arrowHeadLength);
        this.arrowEnd.setHeadLength(arrowHeadLength);
      }

      // Compute angle
      var startDir = this.pStart.clone().sub(this.center).normalize();
      var endDir = this.pEnd.clone().sub(this.center).normalize();
      var angle = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].angleBetweenDirections(startDir, endDir);

      // Prevent arc from being longer than the arrows
      arcRadius = Math.min(arcRadius, this.pStart.distanceTo(this.center), this.pEnd.distanceTo(this.center));

      // Configure ellpse arc
      this.arcParams.rx = arcRadius;
      this.arcParams.ry = arcRadius;
      this.arcParams.sweepFlag = angle > Math.PI;
      this.arcParams.largeArcFlag = false; // always display the shorter connection

      // Compute arc start/end
      var arcStart = startDir.clone().multiplyScalar(arcRadius).add(this.center);
      var arcEnd = endDir.clone().multiplyScalar(arcRadius).add(this.center);

      // Configure arc line
      this.arcLine.updatePoint(0, arcStart.x, arcStart.y);
      this.arcLine.updatePoint(1, arcEnd.x, arcEnd.y);
      this.arcLine.setEllipseArc(0, this.arcParams);

      // Configure arc arrow
      var poly = this.arcLine.toPoly();
      var from = poly.getPoint(poly.getVertexCount() - 2);
      this.arcArrow.setFrom(from);
      this.arcArrow.setTo(this.pEnd);

      // Prevent the arrow from being larger than the arc itself
      var arcArrowLenght = Math.min(arrowHeadLength, this.arcArrowMaxHeadLength * this.pEnd.distanceTo(this.pStart));
      this.arcArrow.setHeadLength(arcArrowLenght);

      // Configure arc fill
      this.arcFill.updatePoint(0, this.center.x, this.center.y);
      this.arcFill.updatePoint(1, arcStart.x, arcStart.y);
      this.arcFill.updatePoint(2, arcEnd.x, arcEnd.y);
      this.arcFill.setEllipseArc(1, this.arcParams);

      this.updateLabel(pixelsPerUnit, arcRadius);

      this.layer.update();
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.update();
    }

    // If true, the angle label is frozen at its current state
  }, { key: "setLabelEnabled", value: function setLabelEnabled(enabled) {
      this.enableLabel = enabled;
    } }]);return AngleGizmo;}();

/***/ }),

/***/ "./extensions/Edit2D/AngleGizmo3d.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/AngleGizmo3d.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleGizmo3d; });
/* harmony import */ var _AngleGizmo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AngleGizmo.js */ "./extensions/Edit2D/AngleGizmo.js");
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var nextId = 1;

// Extends the AngleGizmo class by the ability to be used within a 3D scene.
//
// For this, AngleGizmo3d maintains an own layer that is placed within the current 3d view.
// The layer is placed in a plane that is chosen based on selected location center and rotation axis.
var AngleGizmo3d = /*#__PURE__*/function (_AngleGizmo) {_inherits(AngleGizmo3d, _AngleGizmo);var _super = _createSuper(AngleGizmo3d);

  // @param {Viewer3d} viewer
  // @param {string}   [overlayName] - Must be the name of an existing viewer overlay. If not set, the gizmo creates its own
  function AngleGizmo3d(viewer, options) {var _this;var overlayName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;_classCallCheck(this, AngleGizmo3d);
    _this = _super.call(this, new _EditLayer_js__WEBPACK_IMPORTED_MODULE_1__["default"](viewer), options); // init own layer

    _this.viewer = viewer;

    // Rotation center in world-coords. Serves as anchor point to place the EditLayer within 3d.
    _this.center3d = new THREE.Vector3();
    _this.pStart3d = new THREE.Vector3();
    _this.pEnd3d = new THREE.Vector3();

    _this.id = nextId++;

    _this.overlayName = overlayName;
    _this.overlayOwned = false;

    // Create an own overlay if none is provided
    if (!overlayName) {
      // Create own overlay.
      _this.overlayName = 'Autodesk.Edit2d.AngleGizmo3d.' + _this.id;
      _this.viewer.impl.createOverlayScene(_this.overlayName);

      // Remember that we have to clear it later
      _this.overlayOwned = true;
    }

    // Display layer in the given overlay
    _this.viewer.impl.addOverlay(_this.overlayName, _this.layer.scene);

    // Reused for computing the layer placement
    _this.layerMatrix = new THREE.Matrix4();return _this;
  }_createClass(AngleGizmo3d, [{ key: "dtor", value: function dtor()

    {
      // Remove layer from overlay
      this.viewer.impl.removeOverlay(this.overlayName, this.layer.scene);

      // Remove overlay if own it
      if (this.overlayOwned) {
        this.viewer.impl.removeOverlayScene(this.overlayName);
      }
    }

    // Return layer coords from given 3d world position
  }, { key: "toLayer", value: function toLayer(p3d) {
      return p3d && p3d.clone().applyMatrix4(this.layer.worldToLayer);
    }

    // Set EditLayer transform so that the layer is on the same
    // plane as center.
  }, { key: "updateLayerTransform", value: function updateLayerTransform() {
      // Todo: Generalize to different axes
      this.layerMatrix.makeTranslation(0, 0, this.center3d.z);
      this.layer.setMatrix(this.layerMatrix);
    } }, { key: "setCenter3d", value: function setCenter3d(

    center3d) {

      // If not set, just clear 2d center as well. This will hide the gizmo until a proper center is set. 
      if (!center3d) {
        this.setCenter(null);
        return;
      }

      // move layer to the plane containing center3d
      this.center3d.copy(center3d);
      this.updateLayerTransform();

      // Make sure that any previously valid 2d start/end positions keep correct.
      // Note that a new center was just chosen anyway, 
      this.pStartValid && this.setStart(this.toLayer(this.pStart3d));
      this.pEndValid && this.setEnd(this.toLayer(this.pEnd3d));

      // set center in layer-coords
      this.setCenter(this.toLayer(this.center3d));
    } }, { key: "setStart3d", value: function setStart3d(

    start3d) {
      if (start3d) {
        this.pStart3d.copy(start3d);
      }
      this.setStart(this.toLayer(start3d));
    } }, { key: "setEnd3d", value: function setEnd3d(

    end3d) {
      if (end3d) {
        this.pEnd3d.copy(end3d);
      }
      this.setEnd(this.toLayer(end3d));
    } }]);return AngleGizmo3d;}(_AngleGizmo_js__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/AngleSnapper.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/AngleSnapper.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleSnapper; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// AngleSnapper is responsible for snapping based on angles and alignment on hover while choosing the position of a vertex. 
//
// If pMov is the vertex being moved, the snapping behavior includes:
//
//  1. Angle to previous edge: Snap if edge ending at pMov forms a snapAngle (0, 45, 90,...) with its predecessor edge.
//
//  2. Angle to next edge: Snap if the edge starting at pMov forms a snapAngle with its successor edge.
//
//  3. Collinear Align: Snap if for pMov is collinear with any (non-adjacent) edge.
//
//  4. Vertical Align: Snap if pMov is collinear with the edge normal at start/center/end of any non-adjacent edge.
//

// A SnapLine is a line that we consider for snapping. 
var SnapLine = /*#__PURE__*/function () {

  function SnapLine(a, b) {_classCallCheck(this, SnapLine);

    // start and end point
    this.a = a.clone();
    this.b = b.clone();

    // normalized edge direction
    this.dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b);
  }

  // Check for intersection with another SnapLine. If found, intersection point is written to outPoint.
  // @returns {bool} true on success
  _createClass(SnapLine, [{ key: "intersect", value: function intersect(line, outPoint) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(this.a, this.dir, line.a, line.dir, outPoint);
    }

    // project point to SnapLine
  }, { key: "snapToLine", value: function snapToLine(p) {
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].projectToLine(p, this.a, this.dir);
    }

    // Checks if SnapLine is close enough to p to allow snapping. snapRadius is in layer-coords.
  }, { key: "isUsable", value: function isUsable(p, snapRadius) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointLineDistance(p, this.a, this.dir) < snapRadius;
    }

    // Checks if a SnapLine is (approx.) identical with another one
  }, { key: "isEqual", value: function isEqual(snapLine, precision) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].collinear(this.a, this.dir, snapLine.a, snapLine.dir, precision);
    } }]);return SnapLine;}();
;

// Snap position based on 1 or 2 SnapLines.
//  @param {Vector2}  pos         - Initial position in layer coords. Modified in-place
//  @param {SnapLine} snapLine1   - First line to snap to
//  @param {SnapLine} [snapLine2] - If there are 2 SnapLines, we snap to the intersection of both lines.
// Preconditions:
//  - SnapLine1: Is close to pos (wrt. to snap tolerance)
//  - SnapLine2: If existing, its intersection with SnapLine1 is close to the position  
var snapToLines = function snapToLines(pos, snapLine1, snapLine2) {

  // No snaplines => keep original pos
  if (!snapLine1 && !snapLine2) {
    return;
  }

  // If only SnapLine1 exists
  if (!snapLine2) {
    // project pos to snapLine1
    snapLine1.snapToLine(pos);
    return;
  }

  // If only snapLine2 exists
  if (!snapLine1) {
    // project pos to snapLine2
    snapLine2.snapToLine(pos);
    return;
  }

  // Snap pos to line intersection.
  snapLine1.intersect(snapLine2, pos);
};

// Get point i within a polygon, whereby indices outside [0, ..., this.poly.length-1] are auto-corrected using modulo.
// Accepts negative indices up to -this.poly.length.
var getPointMod = function getPointMod(poly, index, loopIndex) {
  var vertexCount = poly.getVertexCount(loopIndex);
  index = (index + vertexCount) % vertexCount;
  return poly.getPoint(index, loopIndex);
};

// Returns an array of SnapLines used to align with each edge of the given polygon.
//  @param {Polygon}   poly
//  @param {vIndex}    vIndex - index of the vertex being moved. We exclude edges directly adjacent to this vertex, because they are not fixed.
//  @param {loopIndex} loopIndex
var findSnapLines = function findSnapLines(poly, vIndex, loopIndex) {

  // tmp vectors
  var normal = new THREE.Vector2();
  var center = new THREE.Vector2();
  var pEnd = new THREE.Vector2();

  var snapLines = [];

  // Given an edge of a polygon/polyline, this function collects snapping lines for alignment with this this edge.
  // and adds it to snapLines.
  // Generated snapLines are:
  //  - Line spanned by the edge
  //  - Orthogonal lines at start, center, and end point.
  var addEdgeSnapLines = function addEdgeSnapLines(a, b) {

    // add line spanned by the edge
    snapLines.push(new SnapLine(a, b));

    // get edge normal and center point
    normal = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].turnLeft(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b, normal));
    center = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeCenter(a, b, center);

    // add orthogonal line add edge start
    pEnd.copy(a).add(normal); // pEnd = p1 + normal
    snapLines.push(new SnapLine(a, pEnd));

    // add orthogonal line at edge center
    pEnd.copy(center).add(normal); // pEnd = center + normal
    snapLines.push(new SnapLine(center, pEnd));

    // add orthogonal line at edge end
    pEnd.copy(b).add(normal); // pEnd = p2 + normal
    snapLines.push(new SnapLine(b, pEnd));
  };var _loop = function _loop(

  l) {
    poly.enumEdges(function (a, b, ia, ib) {

      // Exclude edges containing the moved vertex: These edges are not fixed yet and should not
      // be used for alignment.
      if (l === loopIndex && (ia === vIndex || ib === vIndex)) {
        return;
      }

      // skip edge if degenerate
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(a, b)) {
        return;
      }

      addEdgeSnapLines(a, b);
    }, l);};for (var l = 0; l < poly.loopCount; l++) {_loop(l);
  }
  return snapLines;
};

// Checks if the given SnapLine candidate is suitable to be used - assuming that another snapLine1 was already chosen.
// A candidate is only suitable if...
//  1. The intersection with snapLine1 is within snapping tolerance
//  2. The angle formed with snapLine1 is as closer to 90° than all other candidates. This makes sure that we rather 
//     snap to orthogonal SnapLines than trying to snap to two nearly parallel ones.
// 
//  @param {SnapLine} candidate       - SnapLine candidates to be compared    
//  @param {SnapLine} [bestCandidate] - Best candidate found so far (may be null)
//  @param {SnapLine} snapLine1       - First SnapLine that has already been chosen to snap to.
//  @param {Vector2}  pos             - position to be snapped
//  @param {number}   snapRadius      - in layer coords
//  @returns {SnapLine} Returns the best candidate - either bestCandidate or snapLineCandidate
var checkSecondSnapCandidate = function checkSecondSnapCandidate(candidate, bestCandidate, snapLine1, pos, snapRadius) {

  // If candidate does not intersect snapLine1, we cannot use it.
  var pIntersect = new THREE.Vector2();
  if (!snapLine1.intersect(candidate, pIntersect)) {
    return bestCandidate;
  }

  // If intersection point is outside snapRadius, discard candidate
  if (pIntersect.distanceTo(pos) > snapRadius) {
    return bestCandidate;
  }

  // If there is no competitor, the candidate made it.
  if (!bestCandidate) {
    return candidate;
  }

  // Check which of the candidates is "less parallel" to snapLine1
  var dp1 = Math.abs(snapLine1.dir.dot(candidate.dir));
  var dp2 = Math.abs(snapLine1.dir.dot(bestCandidate.dir));
  return dp1 > dp2 ? candidate : bestCandidate;
};

var xAxis = new THREE.Vector2(1, 0);

var av = Autodesk.Viewing;
// AngleSnapper helps to draw right angles, parallel lines etc.
var AngleSnapper = /*#__PURE__*/function () {

  function AngleSnapper(gizmoLayer) {_classCallCheck(this, AngleSnapper);
    // Polygon/Polyline being edited. We assume that it includes the vertex being moved.
    this.poly = null;

    // Index of the vertex in this.poly that is beging moved.
    this.vIndex = -1;
    this.loopIndex = -1;

    // If an edge forms one of these angles with the previous one, we display the helper line and snap to the angle
    this.snapAngles = [0, 45, 90, 135, 180, 225, 270, 315, 360];

    // We consider an angle "close to" another one if they differ by this value or less.
    this.snapAngleTolerance = 2; // in degrees

    // Allow snapping to lines within x pixels.
    this.snapRadius = 10;

    this.gizmoLayer = gizmoLayer;
    this.setGlobalManager(gizmoLayer.globalManager);

    // reused tmp points
    this.movedPoint = new THREE.Vector2(); // the vertex being moved
    this.prevPoint = new THREE.Vector2(); // the vertex before movedPoint
    this.prevPoint2 = new THREE.Vector2(); // the vertex before prevPoint

    this.edgeDir = new THREE.Vector2(); // direction of new edge ending at movedPoint
    this.alignAxis = new THREE.Vector2(); // direction that we align to: Either the direction of the previous edge or the x-axis

    // Array of snapLines to align a vertex position with other edges
    this.edgeSnapLines = [];

    // SnapLines that contributed to last snapping call. Used to update the SnapLine gizmos.
    this.snapLine1 = null;
    this.snapLine2 = null;

    // Optional: External line constraint. This is used if we already snapped to a line geometry and
    //           want to combine the snap with angle snapping.
    this.snapLineExt = null;

    // Gizmos to display the lines considered for snapping
    this.snapLineStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineColor: 'rgb(255, 0, 0)',
      lineWidth: 1.0,
      lineStyle: 10 });

    this.snapLineGizmos = [];
    this.snapLineGizmosUsed = 0;
  }_createClass(AngleSnapper, [{ key: "onSetGlobalManager", value: function onSetGlobalManager(

    globalManager) {
      this.globalManager = globalManager;
      this.snapLineGizmos.forEach(function (g) {return g.setGloblaManager(globalManager);});
    } }, { key: "acquireSnapLineGizmo", value: function acquireSnapLineGizmo()

    {
      var gizmo = this.snapLineGizmos[this.snapLineGizmosUsed];
      if (!gizmo) {
        // Create new line gizmo
        gizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.snapLineStyle);
        gizmo.setGlobalManager(this.globalManager);
        this.snapLineGizmos[this.snapLineGizmosUsed] = gizmo;
      }
      this.snapLineGizmosUsed++;
      return gizmo;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {var _this = this;
      var removeGizmo = function removeGizmo(g) {return _this.gizmoLayer.removeShape(g);};
      this.snapLineGizmos.forEach(removeGizmo);
      this.snapLineGizmosUsed = 0;
    }

    // Configures snapping to align to edges of the given polygon/polyline
    //  @param {Polygon|Polyline} poly   - shape being edited. Expected to include the vertex being moved.
    //  @param {number}           vIndex - index into poly that marks the vertex that is moved and to which snapping should be applied.
    //  @param {number}           loopIndex
  }, { key: "startSnapping", value: function startSnapping(poly, vIndex, loopIndex) {
      this.poly = poly;
      this.vIndex = vIndex;
      this.loopIndex = loopIndex;

      // precompute snapLines for alignment. These don't change while moving a vertex.
      this.edgeSnapLines = findSnapLines(poly, vIndex, this.loopIndex);
    } }, { key: "stopSnapping", value: function stopSnapping()

    {

      this.poly = null;
      this.vIndex = -1;
      this.loopIndex = -1;

      // Discard any outdated results and hide gizmos
      this.snapLine1 = null;
      this.snapLine2 = null;
      this.clearSnappingGizmos();
    }

    // Discard latest snapping results, but polygon, vIndex, and edge snapLines. This is used when temporarily hiding the SnapLines when
    // snapping while snapping is bypassed.
  }, { key: "clearSnappingResult", value: function clearSnappingResult() {
      this.snapLine1 = null;
      this.snapLine2 = null;
    } }, { key: "getPrevSnapLine",





    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the previous edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
    value: function getPrevSnapLine(pMov) {

      // Get vertices one and two indices before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);
      var pPrev2 = getPointMod(this.poly, this.vIndex - 2, this.loopIndex);

      // Check angle between (pPrev, pMov) and its predecessor edge (pPrev2, pPrev)
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pPrev2, pPrev);
      return this.computeAngleSnapLine(pMov, pPrev, alignAxis);
    }

    // Snap angles relative to previous edge: Return a snapLine if the edge being modified forms a snapAngle (e.g. 90 degrees) with the next edge.
    //  @param {Vector2} pMov - point to be snapped
    //  @returns {null|SnapLine} Returns null if no SnapLine is within this.angleTolerance.
  }, { key: "getNextSnapLine", value: function getNextSnapLine(pMov) {

      // When moving one of the last two vertices of a polyline, there is actually no "next edge", because start and end
      // vertex are not connected. Therefore, we skip snapping to "next edge" for this case.
      var ignoreNextEdge = this.poly.isPolyline() && this.vIndex >= this.poly.getVertexCount(this.loopIndex) - 2;
      if (ignoreNextEdge) {
        return null;
      }

      var pNext = getPointMod(this.poly, this.vIndex + 1, this.loopIndex);
      var pNext2 = getPointMod(this.poly, this.vIndex + 2, this.loopIndex);

      // Snap to angle wrt. to next edge: (only for polygons)
      //   Check angle between (pNext, pMov) and its successor edge (pNext, pNext2);
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pNext, pNext2, alignAxis);
      return this.computeAngleSnapLine(pMov, pNext, alignAxis);
    }

    // Given a new position in layer-coords to be assigned to the moved vertex, this function checks if the adjacent edges of the moved
    // vertex are close to a snap angle. If so, the movedPoint is corrected to match the snap angle exactly.
    //  @param {Vector2} pMov - Position to be snapped
    //  @param {Object}  [lineConstraint] - Optional: External line-constraint {a,b}. If specified, we only allow snapping to
    //                                                intersections with angle snapLines and the line (lineConstraint.a, lineConstraint.b).
  }, { key: "snapToAngle", value: function snapToAngle(pMov, lineConstraint) {var _this2 = this;

      // Reset the two lines that we consider for snapping.
      this.snapLine1 = null;
      this.snapLine2 = null;

      // Create snapLine from external line constraint (if specified)
      this.snapLineExt = lineConstraint && new SnapLine(lineConstraint.a, lineConstraint.b);

      if (!this.active || this.poly.vertexCount <= 1) {
        return;
      }

      // Get point before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);

      // If we just have a single edge, we can only snap to angles relative to x-axis
      var isFirstEdge = this.poly.vertexCount == 2;
      if (isFirstEdge) {
        // Get closest angle-snap line relative to mainAxis (or null if no snapAngle is close enough)
        var snapAxis = this.computeAngleSnapLine(pMov, pPrev, xAxis);

        if (snapAxis && this.snapLineExt) {
          // If an external line constraint is set, snapAxis can only be considered as a secondary snap.
          // This means, we can only consider if it intersects with the costraint line and the intersection is close to pMov
          this.snapLine1 = checkSecondSnapCandidate(snapAxis, null, this.snapLineExt, pMov, snapRadiusLC);
        } else {
          // No other constraints. Just use the snapAxis (or no axis at all if snapAxis is null)
          this.snapLine1 = snapAxis;
        }

        snapToLines(pMov, this.snapLine1, this.snapLineExt);
        return;
      }

      var prevSnapLine = this.getPrevSnapLine(pMov);
      var nextSnapLine = this.getNextSnapLine(pMov);

      // get snapRadius in layer-coords. This is the maximum distance that we allow
      // between mouse pos and the final snap position that we obtain by projecting
      // to a SnapLine or by intersecting two SnapLines.
      var snapRadiusLC = this.snapRadius * this.gizmoLayer.getUnitsPerPixel();

      // Filter to lines that are close enough to pMov
      var snapLineUsable = function snapLineUsable(snapLine) {

        if (!snapLine) {
          return false;
        }

        if (_this2.snapLineExt) {
          // Consider line-constraint: Only accept snapLine if...
          //  1. ...it intersects constraint line
          //  2. ...intersection point is within snapRadius.
          return Boolean(checkSecondSnapCandidate(snapLine, null, _this2.snapLineExt, pMov, snapRadiusLC));
        }

        // No constraint: Accept any snapLines within snapRadius
        return snapLine.isUsable(pMov, snapRadiusLC);
      };

      var candidates = this.edgeSnapLines.filter(snapLineUsable);

      // Reject prevSnapLine/nextSnapLine if they are not usable
      prevSnapLine = snapLineUsable(prevSnapLine) && prevSnapLine;
      nextSnapLine = snapLineUsable(nextSnapLine) && nextSnapLine;

      // choose first snapLine
      this.snapLine1 = prevSnapLine || nextSnapLine || candidates[0];

      // Stop here if there is no snapping candidate at all
      if (!this.snapLine1) {
        return;
      }

      // If we have an external line constraint, we can only choose a single snapLine, because we already
      // have to intersect it with the external constraint line.
      if (this.snapLineExt) {
        return snapToLines(pMov, this.snapLine1, this.snapLineExt);
      }

      // If prev and next edge allow angle snapping, check if we can snap to both
      if (prevSnapLine && nextSnapLine) {
        this.snapLine2 = checkSecondSnapCandidate(nextSnapLine, null, this.snapLine1, pMov, snapRadiusLC);
      }

      // If prevEdge and nextEdge already gave us 2 SnapLines, give these two preference. Otherwise,
      // check if we can snap to another edge to be aligned with other edges.
      if (!this.snapLine2) {
        for (var i = 0; i < candidates.length; i++) {
          var c = candidates[i];
          this.snapLine2 = checkSecondSnapCandidate(c, this.snapLine2, this.snapLine1, pMov, snapRadiusLC);
        }
      }

      // We selected one or two SnapLines. Now, use them to decide snapped position
      return snapToLines(pMov, this.snapLine1, this.snapLine2);
    } }, { key: "isSnapped", value: function isSnapped()

    {
      return Boolean(this.snapLine1 || this.snapLine2);
    } }, { key: "updateSnapLineGizmos", value: function updateSnapLineGizmos(

    snappedPos) {var _this3 = this;

      // First, clear any outdated gizmos
      this.clearSnappingGizmos();

      if (!this.poly) {
        return;
      }

      // Collect all snapLines that we want to display
      //
      // Note that we don't just want to indicate SnapLines that actively affected the position,
      // but also the "accidentally" matched ones. E.g., if we snapped to a geometry intersection,
      // the actual snapping was not affected by angle snapping, but the resulting position may still
      // match with angle snapLines as well.
      var snapLinesToShow = [];

      // We consider the snapped position p to be "on a snapLine L" if the distance d(p,L) is within the tolerance below.
      var tolerance = 0.0001;
      var shouldBeShown = function shouldBeShown(sl) {return sl && sl.isUsable(snappedPos, tolerance);}; // Decides whether a SnapLine should be displayed

      // If we only have a single edge, angle snapping is only possible wrt. to main axes
      var isFirstEdge = this.poly.vertexCount == 2;

      // Collect SnapLines to display
      if (isFirstEdge) {
        // Just a single edge: Only snap if this first edge forms a snapping angle with x- or y-axis.
        var pPrev = getPointMod(this.poly, this.vIndex - 1, this.loopIndex);
        var snapAxis = this.computeAngleSnapLine(snappedPos, pPrev, xAxis);

        // Display snapAxis if the p is on this line
        if (snapAxis && shouldBeShown(snapAxis)) {
          snapLinesToShow.push(snapAxis);
        }
      } else {
        // Consider all edge snaplines that contain pSnappedPos
        snapLinesToShow = this.edgeSnapLines.filter(shouldBeShown);

        // Consider angles to previous and next edge
        var prevSnapLine = this.getPrevSnapLine(snappedPos);
        var nextSnapLine = this.getNextSnapLine(snappedPos);
        shouldBeShown(prevSnapLine) && snapLinesToShow.push(prevSnapLine);
        shouldBeShown(nextSnapLine) && snapLinesToShow.push(nextSnapLine);
      }

      // Eliminate duplicates: If a SnapLine is collinear with another one, displaying it would just cause artifacts.
      // Note: This is a brute-force n^2 loop. The number of SnapLines to display is usually small, so that this shouldn't be a problem.
      var isRelevant = function isRelevant(sl, index) {
        // Check if sl is a duplicate of any previous SnapLine
        var isDuplicate = false;
        for (var i = 0; i < index; i++) {
          var sl2 = snapLinesToShow[i];
          if (sl.isEqual(sl2, tolerance)) {
            isDuplicate = true;
            break;
          }
        }
        return !isDuplicate;
      };
      snapLinesToShow = snapLinesToShow.filter(isRelevant);

      // Choose SnapLineLength large enough to fill whole canvas
      var canvas = this.gizmoLayer.viewer.canvas;
      var diag = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
      var snapLineLength = this.gizmoLayer.getUnitsPerPixel() * diag;

      // A SnapLine indicator is constructed as follows:
      //  - It starts at the snapLine start point, which "explains where the SnapLine comes from". 
      //    This may be start/center/end of another edge.
      //  - It should always point towards the moved vertex (note that an original edge normal may point away from the moved vertex)
      //  - It is enlarged to overshoot pMov 
      var showSnapLine = function showSnapLine(line, gizmo) {
        if (!line) {
          return;
        }

        var a = line.a;

        // Let line start at a, point towards dir, and be long enough to leave screen
        gizmo.makeLine(
        a.x - snapLineLength * line.dir.x,
        a.y - snapLineLength * line.dir.y,
        a.x + snapLineLength * line.dir.x,
        a.y + snapLineLength * line.dir.y);

        _this3.gizmoLayer.addShape(gizmo);
      };

      // Add lineGizmo for each SnapLine to be displayed
      for (var i = 0; i < snapLinesToShow.length; i++) {
        var snapLine = snapLinesToShow[i];
        var gizmo = this.acquireSnapLineGizmo();
        showSnapLine(snapLine, gizmo);
      }
    } }, { key: "dtor", value: function dtor()

    {
      this.clearSnapping();
    }

    // Checks if the angle between edge (pPrev, p) and alignment direction is close to a snapping angle.
    // If so, it returns a SnapLine from pPrev towards the snapped direction, otherwise null.
    //  @param {Vector2} p              - vertex being moved
    //  @param {Vector2} pPrev          - vertex connected to p
    //  @param {Vector2} alignAxis      - direction that we align to. Must be normalized.
  }, { key: "computeAngleSnapLine", value: function computeAngleSnapLine(p, pPrev, alignAxis) {

      // Don't try angle snapping with degenerated edges
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(pPrev, p)) {
        return null;
      }

      // get direction of new edge (ending at pMov)
      var edgeDir = p.clone().sub(pPrev);

      // Compute angle between new edge and alignment direction
      var angle = THREE.Math.radToDeg(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].angleBetweenDirections(edgeDir, alignAxis));

      // Check if angle matches with any index in snapAngles array
      var snapIndex = -1;
      for (var i = 0; i < this.snapAngles.length; i++) {
        var _snapAngle = this.snapAngles[i];

        var dif = Math.abs(_snapAngle - angle);
        if (dif < this.snapAngleTolerance) {
          snapIndex = i;
          break;
        }
      }

      // Stop here if no snapAngle is found
      if (snapIndex == -1) {
        return null;
      }

      // Rotate alignment axis by selected snapAngle
      var snapAngle = THREE.Math.degToRad(this.snapAngles[snapIndex]);
      var snapDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].rotateAround(alignAxis.clone(), snapAngle);

      // scale snapLine direction to the same length as (pPrev, p)
      var dist = pPrev.distanceTo(p);
      var snapLineEnd = snapDir.multiplyScalar(dist).add(pPrev);

      // Return snapline from pPrev pointing towards snapped direction
      return new SnapLine(pPrev, snapLineEnd);
    } }, { key: "active", get: function get() {return this.poly;} }]);return AngleSnapper;}();


av.GlobalManagerMixin.call(AngleSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/Arrow.js":
/*!************************************!*\
  !*** ./extensions/Edit2D/Arrow.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Arrow; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


// Vector-shape for displaying simple arrows.
var Arrow = /*#__PURE__*/function (_Shape) {_inherits(Arrow, _Shape);var _super = _createSuper(Arrow);

  function Arrow() {var _this;_classCallCheck(this, Arrow);
    _this = _super.call(this);

    // in layer coords
    _this.from = new THREE.Vector2();
    _this.to = new THREE.Vector2();

    // extends of the arrow head in layer coords
    _this.headLength = 2; // along arrow direction
    _this.headAngle = 60; // in degrees. Angle at the tip of the arrow head.

    _this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]();
    _this.head = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]();

    // If true, head is a filled triangle, otherwise just two lines joining at the tip.
    _this.headFilled = true;
    _this.head.style.lineAlpha = 0.0;

    // Add points for triangular head. We only update point positions afterwards.
    _this.head.addPoint(0, 0);
    _this.head.addPoint(0, 0);
    _this.head.addPoint(0, 0);

    // normalized arrow directiom. Auto-updated based on from/to
    _this.dir = new THREE.Vector2();

    // tmp vectors
    _this.tmpVec1 = new THREE.Vector2();
    _this.tmpVec2 = new THREE.Vector2();
    _this.tmpVec3 = new THREE.Vector2();return _this;
  }_createClass(Arrow, [{ key: "modified", value: function modified()

    {
      _get(_getPrototypeOf(Arrow.prototype), "modified", this).call(this);
      this.needsUpdate = true;
    } }, { key: "draw", value: function draw(

    ctx) {
      this.update();

      // Todo: Concept to clarify style override for shapes with child shapes with different styles.
      this.line.draw(ctx, this.line.style);
      this.head.draw(ctx, this.head.style);
    } }, { key: "move", value: function move(

    dx, dy) {
      this.from.x += dx;
      this.from.y += dy;
      this.to.x += dx;
      this.to.y += dy;
      this.modified();
      return this;
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      this.update();
      return this.line.hitTest(x, y) || this.head.hitTest(x, y);
    } }, { key: "clone", value: function clone()

    {
      return new Arrow().copy(this);
    } }, { key: "setFrom", value: function setFrom(

    x, y, z) {
      if (_typeof(x) === 'object') {
        this.from.copy(x);
      } else {
        this.from.set(x, y, z);
      }
      this.modified();
    } }, { key: "setTo", value: function setTo(

    x, y, z) {
      if (_typeof(x) === 'object') {
        this.to.copy(x);
      } else {
        this.to.set(x, y, z);
      }
    }

    // Length of the arrow head. Should always be smaller than the full length of the arrow.
  }, { key: "setHeadLength", value: function setHeadLength(len) {
      this.headLength = len;
      this.modified();
    }

    // Angle at the tip of the arrow head. In degrees.
  }, { key: "setHeadAngle", value: function setHeadAngle(angle) {
      this.headAngle = angle;
      this.modified();
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Arrow.prototype), "copy", this).call(this, from);
      this.from = from.from.clone();
      this.to = from.to.clone();
      this.headLength = from.headLength;
      this.headAngle = from.headAngle;
      this.headFilled = from.headFilled;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.line.computeBBox();
      this.head.computeBBox();

      this.bbox.makeEmpty();
      this.bbox.union(this.line.bbox);
      this.bbox.union(this.head.bbox);
    } }, { key: "getLength", value: function getLength()






    {
      return this.to.distanceTo(this.from);
    }

    // Change arrow lenght by changing one of the points. 
    //  @param {number} l - new length
    //  @param {bool}   [changeFrom] - By default (false), we change the toPoint and keep fromPoint constant.
    //                                 If true, we keep toPoint and change fromPoint instead.
  }, { key: "setLength", value: function setLength(l, changeFrom) {

      // Scale direction by new length
      var dir = this.direction;
      var dx = dir.x * l;
      var dy = dir.y * l;

      // Reset fromPoint or toPoint
      if (changeFrom) {
        this.setFrom(this.to.x - dx, this.to.y - dy);
      } else {
        this.setTo(this.from.x + dx, this.from.y + dy);
      }
    } }, { key: "update", value: function update()

    {

      if (!this.needsUpdate) {
        return;
      }

      var dir = this.direction;

      // compute line endpoint. If the head is filled, the line ends at the
      // center of the head hypothenuse, otherwise at the to-point.
      var ex = this.to.x - (this.headFilled ? dir.x * this.headLength : 0);
      var ey = this.to.y - (this.headFilled ? dir.y * this.headLength : 0);

      // draw arrow tail
      this.line.makeLine(this.from.x, this.from.y, ex, ey);

      // compute vector perpendicular to arrow directrion
      var leftNormal = this.tmpVec2.copy(dir);
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].turnLeft(leftNormal);

      // compute distance between arrow line and left vertex of arrow head
      var halfAngle = 0.5 * THREE.Math.degToRad(this.headAngle);
      var dist = Math.tan(halfAngle) * this.headLength;

      // compute left head vertex
      var leftX = this.to.x - dir.x * this.headLength + leftNormal.x * dist;
      var leftY = this.to.y - dir.y * this.headLength + leftNormal.y * dist;

      // compute right head vertex
      var rightX = this.to.x - dir.x * this.headLength - leftNormal.x * dist;
      var rightY = this.to.y - dir.y * this.headLength - leftNormal.y * dist;

      // update the 3 head vertices
      this.head.updatePoint(0, leftX, leftY); // left vertex
      this.head.updatePoint(1, this.to.x, this.to.y); // tip of the arrow
      this.head.updatePoint(2, rightX, rightY); // right vertex

      this.needsUpdate = false;
    } }, { key: "direction", get: function get() {// Normalized arrow direction
      return this.dir.copy(this.to).sub(this.from).normalize();} }]);return Arrow;}(_EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Shape"]);

/***/ }),

/***/ "./extensions/Edit2D/BooleanOps.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/BooleanOps.js ***!
  \*****************************************/
/*! exports provided: BooleanOps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanOps", function() { return BooleanOps; });
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoopContainment.js */ "./extensions/Edit2D/LoopContainment.js");
function _toConsumableArray(arr) {return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();}function _nonIterableSpread() {throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _iterableToArray(iter) {if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);}function _arrayWithoutHoles(arr) {if (Array.isArray(arr)) return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}





var Operator = {
  Intersect: 1, // only keep regions where path1 and path2 are overlapping
  Union: 2, // unify both shapes
  Difference: 3, // path1 after removing all regions that are overlapped by path2
  Xor: 4 // only keep regions that are either covered by path1 or path2, but not both
};

// Returns all faces that are "inside the given wireBody", whereby:
//  - All wires in wireBody must be closed loops without branching
//  - A face is considered as "inside" if it is enclosed by an odd number of wires ("Even-Odd-Rule")
//
// @param {SketchRegionSolver} solver   - initialized with all edges of subject and cutLoop
// @param {SolidDef.WireBody}  wireBody - must contain closed loops.
// Returns the subset of region faces that is inside the given wireBody. 
var getFacesInside = function getFacesInside(solver, wireBody) {

  // Mark all faces as rank 0, indicating that we did not find an enclosing loop yet
  // Note: It's not perfectly clean to add extra attributes, but...
  //  a) Since faces don't have unique ids, we don't have proper way to index them without modifying
  //  b) All faces here are only temporary.
  var regionFaces = solver.getFaces();
  regionFaces.forEach(function (f) {return f.rank = 0;});

  // for each wire
  var wires = wireBody.getWires();
  wires.forEach(function (w) {

    // get faces inside this loop
    var loopEdges = w.getEdges();
    var facesInside = Object(_LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__["getFacesInsideLoop"])(solver, loopEdges);

    // increase rank for all faces inside this loop
    facesInside.forEach(function (f) {return f.rank++;});
  });

  // Return all faces whose rank is not a multiple of 2
  var hasOddRank = function hasOddRank(f) {return Boolean(f.rank & 1);};
  return regionFaces.filter(hasOddRank);
};

// Apply boolean operation on two SolidDef paths (must be closed).
//
// @param {SolidDef.Path2D}   path1           - the path to be clipped.
// @param {SolidDef.Path2D}   path2           - to be cut away. Must be a single loop.
// @param {Operator}          operator
// @param {SolidDef.Path2D[]} [extraOperands] - Unify supports more than 2 operands.
// @returns {SolidDef.Face[]} 
var applyOperation = function applyOperation(path1, path2, operator, extraOperands) {

  // get paths as wires
  var wireBody1 = path1.getWireBody();
  var wireBody2 = path2.getWireBody();

  // get both paths as edge arrays
  var edges1 = wireBody1.getEdges();
  var edges2 = wireBody2.getEdges();

  // get unified array with edges of both parts 
  var allEdges = edges1.concat(edges2);

  // add edges of additional operands
  extraOperands && extraOperands.forEach(function (p) {
    var wb = p.getWireBody();
    var edges = wb.getEdges();
    allEdges.push.apply(allEdges, _toConsumableArray(edges));
  });

  // Feed them into solver to intersect them against each other and extract the resulting region faces.
  var solver = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["SketchRegionSolver"]();
  solver.compute(allEdges);
  var allFaces = solver.getFaces();

  // check which of the faces are within path and cutPath        
  var facesInPath1 = getFacesInside(solver, wireBody1);
  var facesInPath2 = getFacesInside(solver, wireBody2);

  // check which faces are in any of the extra operands
  var facesInExtraPaths = extraOperands && extraOperands.map(function (p) {
    var wb = p.getWireBody();
    return getFacesInside(solver, wb);
  });

  // Filter faces based on operation type.
  // Note: We have a O(numEdges^2) runtime here, which might be an issue for number of faces. 
  //       If needed, this could be optimized by tagging the edges with unique IDs in advance and indexing
  //       the faces by id.
  var filter = function filter(f) {
    var inPath1 = facesInPath1.includes(f);
    var inPath2 = facesInPath2.includes(f);

    // Check if face is contained in any of the extra paths
    var inExtraPath = facesInExtraPaths && facesInExtraPaths.some(function (faceSet) {return faceSet.includes(f);});

    switch (operator) {
      case Operator.Union:return inPath1 || inPath2 || inExtraPath;
      case Operator.Intersect:return inPath1 && inPath2;
      case Operator.Difference:return inPath1 && !inPath2;
      case Operator.Xor:return inPath1 !== inPath2;}

  };
  var selectedFaces = allFaces.filter(filter);

  // Finally, merge these faces to obtain result
  return Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["mergeConnectedFaces"])(selectedFaces);
};

//  @param {PolyBase[]} [extraOperands] - For unify, we allow moore than 2 operands.
var apply = function apply(path1, path2, operator, extraOperands) {
  // Convert to SolidDef
  var path1Sd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path1);
  var path2Sd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path2);

  var extraOperandsSD = extraOperands && extraOperands.map(function (p) {return _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(p);});

  // Run operation
  var faces = applyOperation(path1Sd, path2Sd, operator, extraOperandsSD);

  // Convert SolidDef faces back to Edit2D paths
  var result = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].facesToShape(faces);

  // Let result inherit style of path1
  result.style.copy(path1.style);

  return result;
};

var BooleanOps = {
  Operator: Operator,
  apply: apply };

/***/ }),

/***/ "./extensions/Edit2D/CanvasGizmo.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/CanvasGizmo.js ***!
  \******************************************/
/*! exports provided: AlignX, AlignY, CanvasGizmoBase, CanvasGizmo, TextLabel, ShapeLabel, LengthLabel, AreaLabel, EdgeGizmo, EdgeMoveGizmo, EdgeLabel, VertexGizmo, LabelFilter, DefaultLabelFilter, LabelStyleRule, FadeOutStyleRule, ShapeLabelRule, ShapeToolTip, GizmoManager, ArcEdgeGizmo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignX", function() { return AlignX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignY", function() { return AlignY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmoBase", function() { return CanvasGizmoBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmo", function() { return CanvasGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextLabel", function() { return TextLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabel", function() { return ShapeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LengthLabel", function() { return LengthLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaLabel", function() { return AreaLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeGizmo", function() { return EdgeGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeMoveGizmo", function() { return EdgeMoveGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeLabel", function() { return EdgeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexGizmo", function() { return VertexGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelFilter", function() { return LabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLabelFilter", function() { return DefaultLabelFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LabelStyleRule", function() { return LabelStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FadeOutStyleRule", function() { return FadeOutStyleRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeLabelRule", function() { return ShapeLabelRule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeToolTip", function() { return ShapeToolTip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GizmoManager", function() { return GizmoManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcEdgeGizmo", function() { return ArcEdgeGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};

var AlignX = {
  Left: 1,
  Center: 2,
  Right: 3 };


var AlignY = {
  Top: 1,
  Center: 2,
  Bottom: 3 };


var av = Autodesk.Viewing;

// Base class for any gizmo that needs to be synchronized with the shapes of an EditLayer.
var CanvasGizmoBase = /*#__PURE__*/function () {
  function CanvasGizmoBase() {_classCallCheck(this, CanvasGizmoBase);}

  // Called whenever the layer or camera changes.
  _createClass(CanvasGizmoBase, [{ key: "update", value: function update() {} }]);return CanvasGizmoBase;}();


av.GlobalManagerMixin.call(CanvasGizmoBase.prototype);

// A CanvasGizmo is an html div anchored at a position in layer-coords
var CanvasGizmo = /*#__PURE__*/function (_CanvasGizmoBase) {_inherits(CanvasGizmo, _CanvasGizmoBase);var _super = _createSuper(CanvasGizmo);
  function CanvasGizmo(layer) {var _this;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var className = arguments.length > 2 ? arguments[2] : undefined;_classCallCheck(this, CanvasGizmo);
    _this = _super.call(this);

    _this.layer = layer;
    _this.setGlobalManager(layer.globalManager);

    // position in layer-coords. The transform origin of the div will appear at this position.
    _this.layerPos = new THREE.Vector2();

    // position in canvas-coords (updated based on this.layerPos and camera)
    _this.canvasPos = new THREE.Vector2();

    // html content to be shown
    var _document = _this.getDocument();
    _this.container = _document.createElement('div');

    // Make sure that label is displayed on top of the canvas and not "pushed away" by it.
    _this.container.style.position = 'absolute';

    // Rotate around gizmo center
    _this.container.style.transformOrigin = '50% 50%';
    _this.container.style.top = '0px';
    _this.container.style.left = "0px";

    if (className) {
      _this.container.classList.add(className);
    }

    // Show immediately if wanted
    _this.visible = false;

    _this.alignX = AlignX.Center;
    _this.alignY = AlignY.Center;

    // Clockwise rotation angle in degrees. Rotates around center.
    _this.angle = 0;

    if (visible) {
      _this.setVisible(true, false);
    }

    // For fadeIn/Out effects
    var setOpacity = function setOpacity(t) {
      _this.container.style.opacity = t;
    };
    _this.opacityParam = new Autodesk.Viewing.Private.AnimatedParam(1.0, setOpacity, 0.5);

    // By default, just delegate to viewer context menu. Edit2DContextMenu will take care
    // that it is properly configured.
    _this.container.addEventListener('contextmenu', function (e) {

      // Workaround for Mac: By default, LMV's context menu is responds to right mouse-button.
      // On Mac, Ctrl + Left also triggers context menu events. These must be ignored here, because:
      //    a) Consistency: LMV ignores them as well.
      //    b) Conflicts:   When inserting a vertex, we don't want the ContextMenu to show up.
      var isLeftButton = e.buttons == 1;
      if (!isLeftButton) {
        _this.layer.viewer.triggerContextMenu(e);
      }
    });return _this;
  }_createClass(CanvasGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
    } }, { key: "setVisible", value: function setVisible(

    visible) {var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (visible == this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:
        //       ToolController listens to events on canvasWrap. Therefore, if we would add
        //       it to viewer.container, all mouse events captured would never reach the ToolController
        //       no matter whether the gizmo handles them or not.
        this.layer.viewer.canvasWrap.appendChild(this.container);
        this.layer.addCanvasGizmo(this);

        // Make sure that position is correct
        if (autoUpdate) {
          this.update();
        }
      } else
      {
        this.layer.viewer.canvasWrap.removeChild(this.container);
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "setAlignX", value: function setAlignX(

    alignX) {
      this.alignX = alignX;
      this.update();
    } }, { key: "setAlignY", value: function setAlignY(

    alignY) {
      this.alignY = alignY;
      this.update();
    }

    // @param {number} angle - Clockwise angle in degrees
    // 
    // Note: Do not use 'position:absolute' in child html elements.
    //       Otherwise, the content box will be empty and it will not rotate around anymore.
  }, { key: "setRotation", value: function setRotation(angle) {
      this.angle = angle;
      this.update();
    } }, { key: "update", value: function update()

    {
      this.canvasPos.copy(this.layer.layerToCanvas(this.layerPos.x, this.layerPos.y));

      var p = this.canvasPos;
      var style = this.container.style;

      // set left/top to gizmo position
      var left = toPixels(p.x);
      var top = toPixels(p.y);

      // Choose translation offset in % based on X-alignment
      var tx;
      switch (this.alignX) {
        case AlignX.Left:tx = '0%';break;
        case AlignX.Center:tx = '-50%';break;
        case AlignX.Right:tx = '-100%';break;}


      var ty;
      switch (this.alignY) {
        case AlignY.Top:ty = '0%';break;
        case AlignY.Center:ty = '-50%';break;
        case AlignY.Bottom:ty = '-100%';break;}


      // Update transform based on rotation angle and alignment
      style.transform = "translate(".concat(left, ", ").concat(top, ") translate(").concat(tx, ", ").concat(ty, ") rotate(").concat(this.angle, "deg)");
    }

    // Set position in layer coords
  }, { key: "setPosition", value: function setPosition(x, y) {
      this.layerPos.set(x, y);
      this.update();
    } }, { key: "setClassEnabled", value: function setClassEnabled(

    className, enabled) {
      if (enabled) {
        this.container.classList.add(className);
      } else {
        this.container.classList.remove(className);
      }
    }

    // Selection state is managed using a css-class 'selected'. 
    // Note that this only has an effect if the css style used for the gizmo supports it.
  }, { key: "setSelected", value: function setSelected(selected) {
      this.setClassEnabled('selected', selected);
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.container.classList.contains('selected');
    }

    // Optional: Hover-effect for gizmos that can be clicked or dragged.
  }, { key: "setHoverEnabled", value: function setHoverEnabled(enabled) {
      this.setClassEnabled('enable-hover', enabled);
    }

    // Optional: Assign a name to gizmo and div element to facilitate debugging and testing.
  }, { key: "setName", value: function setName(name) {
      this.name = name;
      this.container.id = name ? name : '';
    }

    // Change css opacity. If wanted, the change can be smoothly faded.
  }, { key: "setOpacity", value: function setOpacity(value, animate) {
      if (animate) {
        this.opacityParam.fadeTo(value);
      } else {
        this.opacityParam.setValue(value);
      }
    } }]);return CanvasGizmo;}(CanvasGizmoBase);


// Configure CanvasGizmo as a text label.
var initTextLabel = function initTextLabel(gizmo) {

  // Use measure-tool styles by default
  gizmo.container.classList.add('edit2d-label');
  gizmo.container.classList.add('visible');

  // Create textDiv child div
  var _document = gizmo.getDocument();
  gizmo.textDiv = _document.createElement('div');
  gizmo.textDiv.classList.add('edit2d-label-text');
  gizmo.container.appendChild(gizmo.textDiv);

  // Add setText convenience function
  gizmo.setText = function (str) {
    this.textDiv.textContent = str;
  }.bind(gizmo);
};

// Simple TextLabel bound to a fixed position in layer coords
var TextLabel = /*#__PURE__*/function (_CanvasGizmo) {_inherits(TextLabel, _CanvasGizmo);var _super2 = _createSuper(TextLabel);

  function TextLabel(layer, text, className) {var _this2;_classCallCheck(this, TextLabel);
    _this2 = _super2.call(this, layer, true, className);
    initTextLabel(_assertThisInitialized(_this2));return _this2;
  }return TextLabel;}(CanvasGizmo);

;

// A ShapeLabel is a text label whose anchor position is synchronized with the bbox center of a shape in a layer.
var ShapeLabel = /*#__PURE__*/function (_CanvasGizmo2) {_inherits(ShapeLabel, _CanvasGizmo2);var _super3 = _createSuper(ShapeLabel);

  function ShapeLabel(shape, layer) {var _this3;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var className = arguments.length > 3 ? arguments[3] : undefined;_classCallCheck(this, ShapeLabel);
    _this3 = _super3.call(this, layer, visible, className);

    initTextLabel(_assertThisInitialized(_this3));

    _this3.shape = shape;

    // Can be set to hidden to temporarily hide the label
    _this3.valueValid = true;

    // Optional: Shift label by a couple of pixels.
    _this3.pixelOffset = new THREE.Vector2();

    _this3.update();return _this3;
  }_createClass(ShapeLabel, [{ key: "update", value: function update()

    {
      if (this.shape && this.valueValid) {
        // Set it to visible (in case polygon was null before)
        this.container.style.visibility = 'visible';

        if (this.shape.isPolyline()) {
          var edgeCount = this.shape.getEdgeCount(0);
          // For a start, simply position the label on the segment roughly in the middle of the polyline
          var edgeToLabel = Math.floor(edgeCount / 2);
          if (this.shape.edgeIndexValid(edgeToLabel)) {
            // Set layer position to center point of the segment.
            this.shape.getPointOnEdge(edgeToLabel, 0.5, 0, this.layerPos);
          }
        } else
        {
          // For a start, simply use the bbox center of the polygon. In some cases, this might end up outside the
          // polygon, so we may consider something smarter later.
          this.shape.computeBBox();
          this.shape.bbox.center(this.layerPos);
        }

        // Optional: Shift by a few pixels
        if (this.pixelOffset) {
          var toUnits = this.layer.getUnitsPerPixel();
          var shiftX = this.pixelOffset.x * toUnits;
          var shiftY = this.pixelOffset.y * toUnits;
          this.layerPos.x += shiftX;
          this.layerPos.y += shiftY;
        }

        _get(_getPrototypeOf(ShapeLabel.prototype), "update", this).call(this);
      } else {
        this.container.style.visibility = 'hidden';
      }
    } }, { key: "setShape", value: function setShape(

    shape) {
      this.shape = shape;
      this.update();
    } }]);return ShapeLabel;}(CanvasGizmo);


// Only works for shapes with getLength() function
var LengthLabel = /*#__PURE__*/function (_ShapeLabel) {_inherits(LengthLabel, _ShapeLabel);var _super4 = _createSuper(LengthLabel);

  // @param {Polyline}    polyline
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function LengthLabel(polyline, layer, unitHandler) {var _this4;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, LengthLabel);
    _this4 = _super4.call(this, polyline, layer, visible);
    _this4.unitHandler = unitHandler;return _this4;
  }_createClass(LengthLabel, [{ key: "update", value: function update()

    {
      // Get shape length (if shape supports it)
      var hasLength = this.shape && this.shape.getLength;
      var length = hasLength && this.shape.getLength(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined length.
      // We also hide it if length is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(length);

      if (this.valueValid) {
        var text = this.unitHandler.lengthToString(length);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(LengthLabel.prototype), "update", this).call(this);
    } }]);return LengthLabel;}(ShapeLabel);


// Only works for shapes with getArea() function
var AreaLabel = /*#__PURE__*/function (_ShapeLabel2) {_inherits(AreaLabel, _ShapeLabel2);var _super5 = _createSuper(AreaLabel);

  // @param {Polygon}     polygon
  // @param {EditLayer}   layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}        [visible]
  function AreaLabel(polygon, layer, unitHandler) {var _this5;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, AreaLabel);
    _this5 = _super5.call(this, polygon, layer, visible);
    _this5.unitHandler = unitHandler;
    _this5.update(); // update with proper unitHandler
    return _this5;}_createClass(AreaLabel, [{ key: "update", value: function update()

    {
      // Don't display until a unitHandler is set
      if (!this.unitHandler) {
        return;
      }

      // Handle PolyBase with self-intersections: Display an error indicator in this case.
      if (this.shape && this.shape.isSelfIntersecting && this.shape.isSelfIntersecting()) {

        // Show an error indicator instead
        this.setText('Error: Invalid shape');

        // Mark area label as error
        this.container.classList.add('error-indicator');

        // Mark sure error indicator is displayed
        this.valueValid = true;
        _get(_getPrototypeOf(AreaLabel.prototype), "update", this).call(this);

        return;
      } else {
        // Make sure that error indicator is toggled off
        this.container.classList.remove('error-indicator');
      }

      // Get shape area (if shape supports it)
      var hasArea = this.shape && this.shape.getArea;
      var area = hasArea && this.shape.getArea(this.unitHandler.measureTransform);

      // Hide label if we don't have a well-defined area.
      // We also hide it if area is 0.0, because the shape cannot be visible anyway.
      this.valueValid = Boolean(area);

      if (this.valueValid) {
        var text = this.unitHandler.areaToString(area);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(AreaLabel.prototype), "update", this).call(this);
    } }]);return AreaLabel;}(ShapeLabel);


// A html element for which position and rotation is aligned with an edge
var EdgeGizmo = /*#__PURE__*/function (_CanvasGizmo3) {_inherits(EdgeGizmo, _CanvasGizmo3);var _super6 = _createSuper(EdgeGizmo);

  // @param {EditLayer} layer
  // @param {bool} visible
  function EdgeGizmo(layer) {var _this6;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var className = arguments.length > 2 ? arguments[2] : undefined;_classCallCheck(this, EdgeGizmo);
    _this6 = _super6.call(this, layer, visible, className);

    _this6.posA = new THREE.Vector2();
    _this6.posB = new THREE.Vector2();

    // Indicates if a position has been set. If not, we temporarily hide the gizmo. If the gizmo is
    // attached to an edge, this flag is set automatically.
    _this6.posValid = false;

    // Temp vectors used in update
    _this6.edgeDir = new THREE.Vector2();

    // Optional: Positions can be synchronized with an edge of a polygon or polyline
    _this6.poly = null;
    _this6.loopIndex = 0;
    _this6.edgeIndex = 0;

    // Use measure-length css style by default
    _this6.container.classList.add('edge-gizmo');

    // Optional: By default, an EdgeGizmo is always placed on a segment, i.e., the gizmo will follow a curve for arc segments.
    //           If this flag is true, the gizmo is always placed on the direct line connection. 
    _this6.ignoreArcs = false;

    // Optional: If specified, this limits the size of the gizmo relative to the edge length on screen:
    // We hide the gizmo if it exceeds x * edgeLength on screen.
    _this6.maxRelativeLength = undefined; // in [0,1]
    return _this6;}

  // If a poly is set, the gizmo is automatically synchronized with the edge.
  // As long as the poly is visible in the same layer, the edge is automatically kept in sync with the edge.
  //
  //  @param {PolyBase} poly      - polygon or polyline containing the edge that we want to attach to. If null, positions can be set manually.
  //  @param {number} edgeIndex   - edgeIndex in poly. If not valid, gizmo is hidden.
  //  @param {number} [loopIndex] - loopIndex in poly. 0 by default
  _createClass(EdgeGizmo, [{ key: "attachToEdge", value: function attachToEdge(poly, edgeIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.poly = poly;
      this.edgeIndex = edgeIndex;
      this.loopIndex = loopIndex;
      this.update();
    } }, { key: "detachFromEdge", value: function detachFromEdge()

    {
      this.poly = null;
      this.edgeIndex = -1;
      this.loopIndex = -1;
      this.posValid = false; // hide unless a position is explicitly set
      this.update();
    } }, { key: "edgeValid", value: function edgeValid()

    {
      return this.poly && this.poly.edgeIndexValid(this.edgeIndex, this.loopIndex);
    } }, { key: "update", value: function update()

    {

      // If a polygon is set, obtain positions automatically from it - or hide gizmo if edge does not exist anymore
      if (this.poly && this.poly.edgeIndexValid(this.edgeIndex, this.loopIndex)) {
        this.poly.getEdge(this.edgeIndex, this.posA, this.posB, this.loopIndex);
        this.posValid = true;
      } else {
        // This may happen if host polygon was modified and the edge does not exist anymore.
        this.posValid = false;
      }

      // If edge is invalid or too small on screen, just hide the gizmo
      var show = this._shouldBeShown();
      this.container.style.visibility = show ? 'visible' : 'hidden';
      if (!show) {
        return;
      }

      // Center gizmo at edge center
      if (this.ignoreArcs) {
        // Place on the line segment
        _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolyBase"].prototype.getPointOnEdge.call(this.poly, this.edgeIndex, 0.5, this.loopIndex, this.layerPos);
      } else {
        // Place on line segment or arc - depending on actual edge type
        this.poly.getPointOnEdge(this.edgeIndex, 0.5, this.loopIndex, this.layerPos);
      }

      // Set rotation angle
      this._updateRotation();

      _get(_getPrototypeOf(EdgeGizmo.prototype), "update", this).call(this);
    }

    // Check if the gizmo should be shown: We hide it if the edge is too small or if the edge does not exist at all.
  }, { key: "_shouldBeShown", value: function _shouldBeShown() {

      // Positions must be properly set - either automatically from an attached edge or manually using setEdge()
      if (!this.posValid) {
        return false;
      }

      // Show/Hide gizmo depending on zoom:
      // Gizmo has constant screen-size. So, we hide it if the screen-size of the edge becomes too small.
      if (this.maxRelativeLength) {
        var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);
        var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);
        var edgeLengthScreen = aScreen.distanceTo(bScreen);
        var maxAllowedPixels = edgeLengthScreen * this.maxRelativeLength;
        var _window = this.getWindow();
        var width = parseFloat(_window.getComputedStyle(this.container).width);
        return width < maxAllowedPixels;
      }
      return true;
    }

    // Set style rotation to align gizmo along edge direction, so that 'width' is along the edge
  }, { key: "_updateRotation", value: function _updateRotation() {

      // Compute counterClockwise angle in radians that rotates the positive x-axis to the edge direction a->b
      // It's important to compute the angle in canvas space here. If we would compute it in layer space,
      // the angle orientation of the result may be inverted if the layerToCanvas() transform inverts orientation (e.g. by flipped y-axis)
      var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);
      var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);

      var dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(aScreen, bScreen, this.edgeDir);
      var angle = Math.atan2(dir.y, dir.x);

      // Avoid upside-down rotation: Flip by 180 degrees if b is left of a. This is import if gizmo contains text.
      if (dir.x < 0) {
        angle += Math.PI;
      }

      // Convert angle to clockwise degrees and apply it to style
      // Just set the angle here, but don't call setAngle, becaue we don't want to trigger auto-update.
      this.angle = THREE.Math.radToDeg(angle);
    } }]);return EdgeGizmo;}(CanvasGizmo);


var EdgeMoveGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EdgeMoveGizmo, _EdgeGizmo);var _super7 = _createSuper(EdgeMoveGizmo);

  function EdgeMoveGizmo(layer, name) {var _this7;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;var className = arguments.length > 3 ? arguments[3] : undefined;_classCallCheck(this, EdgeMoveGizmo);
    _this7 = _super7.call(this, layer, visible, className);

    _this7.setName(name);
    _this7.container.classList.add('edge-move-gizmo');

    // We place EdgeMoveGizmos always directly on the straight lines. In this way, edge moving
    // will work in the same way - no matter whether a segment is an arc or not.
    _this7.ignoreArcs = true;

    // Hide gizmo if its screenWidth exceeds 0.3 * edgeLength
    _this7.maxRelativeLength = 0.3; // in [0,1]
    return _this7;}return EdgeMoveGizmo;}(EdgeGizmo);


// An EdgeGizmo to display text
var EdgeLabel = /*#__PURE__*/function (_EdgeGizmo2) {_inherits(EdgeLabel, _EdgeGizmo2);var _super8 = _createSuper(EdgeLabel);

  function EdgeLabel(layer) {var _this8;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeLabel);
    _this8 = _super8.call(this, layer, visible);
    initTextLabel(_assertThisInitialized(_this8));

    // Hide label if it would exceed the edge length
    _this8.maxRelativeLength = 1.0;return _this8;
  }return EdgeLabel;}(EdgeGizmo);


var VertexGizmo = /*#__PURE__*/function (_CanvasGizmo4) {_inherits(VertexGizmo, _CanvasGizmo4);var _super9 = _createSuper(VertexGizmo);

  // @param {number}  x,y       - Position in layer coords
  // @param {string}  id        - id string used to tag shapes that represent this gizmo
  function VertexGizmo(layer, x, y, name, className) {var _this9;_classCallCheck(this, VertexGizmo);
    _this9 = _super9.call(this, layer, true, className);
    _this9.setPosition(x, y);
    _this9.setName(name);

    _this9.pos = new THREE.Vector2();

    // Optional: Positions can be synchronized with a vertex of a polygon or polyline
    _this9.poly = null;
    _this9.loopIndex = -1;
    _this9.vertexIndex = -1;

    _this9.container.classList.add('vertex-gizmo');return _this9;
  }

  // If a poly is set, the gizmo is automatically synchronized with the vertex.
  // As long as the poly is visible in the same layer, the vertex gizmo is automatically kept in sync with the vertex.
  //
  //  @param {PolyBase} poly      - polygon or polyline containing the vertex that we want to attach to. If null, positions can be set manually.
  //  @param {number} vertexIndex   - vertexIndex in poly. If not valid, gizmo is hidden.
  //  @param {number} [loopIndex] - loopIndex in poly. 0 by default
  _createClass(VertexGizmo, [{ key: "attachToVertex", value: function attachToVertex(poly, vertexIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.poly = poly;
      this.vertexIndex = vertexIndex;
      this.loopIndex = loopIndex;
      this.update();
    } }, { key: "detachFromVertex", value: function detachFromVertex()

    {
      this.poly = null;
      this.vertexIndex = -1;
      this.loopIndex = -1;
      this.posValid = false; // hide unless a position is explicitly set
      this.update();
    } }, { key: "update", value: function update()

    {
      // Gizmo is not attached to a polygon. Just update according to the initial position.
      if (!this.poly) {
        _get(_getPrototypeOf(VertexGizmo.prototype), "update", this).call(this);
        return;
      }

      // If a polygon is set, obtain positions automatically from it - or hide gizmo if vertex does not exist anymore
      if (this.poly.indexValid(this.vertexIndex, this.loopIndex)) {
        this.poly.getPoint(this.vertexIndex, this.loopIndex, this.pos);
        this.posValid = true;
      } else {
        // This may happen if host polygon was modified and the vertex does not exist anymore.
        this.posValid = false;
      }

      // If edge is invalid, just hide the gizmo
      var show = this.posValid;

      this.container.style.visibility = show ? 'visible' : 'hidden';

      if (!show) {
        return;
      }

      this.layerPos.set(this.pos.x, this.pos.y);

      _get(_getPrototypeOf(VertexGizmo.prototype), "update", this).call(this);
    } }]);return VertexGizmo;}(CanvasGizmo);


// A Label filter decides for which shapes we display a label
var LabelFilter = /*#__PURE__*/function () {

  function LabelFilter() {_classCallCheck(this, LabelFilter);}

  // If false, we don't need to acquire a label at all.
  _createClass(LabelFilter, [{ key: "accepts", value: function accepts(shape, text) {
      return true;
    } }]);return LabelFilter;}();
;

// Get shape width in screen-pixels
var getShapeWidth = function getShapeWidth(shape, layer) {
  // get shape size in screen-pixels
  shape.updateBBox();
  var bbox = shape.bbox;
  var shapeWidth = bbox.max.x - bbox.min.x;
  return shapeWidth * layer.getPixelsPerUnit() * shapeWidth;
};

// By default, we hide labels if text is empty or if the shape size on screen falls beyond a pixel threshold
var DefaultLabelFilter = /*#__PURE__*/function (_LabelFilter) {_inherits(DefaultLabelFilter, _LabelFilter);var _super10 = _createSuper(DefaultLabelFilter);

  // @param {number} minWidth - minimum pixel width a shape must have to receive a label
  function DefaultLabelFilter() {var _this10;var minWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;_classCallCheck(this, DefaultLabelFilter);
    _this10 = _super10.call(this);
    _this10.minWidth = minWidth;return _this10;
  }

  // Accept shape if text is not empty and its screen-width is big enough.
  _createClass(DefaultLabelFilter, [{ key: "accepts", value: function accepts(shape, text, layer) {
      var width = getShapeWidth(shape, layer);
      return Boolean(text) && width >= this.minWidth;
    } }]);return DefaultLabelFilter;}(LabelFilter);


// A LabelStyle rule allows to apply css style modifications on a label, e.g., depending on screen size
var LabelStyleRule = /*#__PURE__*/function () {

  function LabelStyleRule() {_classCallCheck(this, LabelStyleRule);}

  // Note: Labels may be reused for different shapes. So, make sure that the style parameters are 
  //       not just modified for some subset of shapes, but reset for others.
  _createClass(LabelStyleRule, [{ key: "apply", value: function apply(label, shape, layer) {} }]);return LabelStyleRule;}();
;

// Fades out based on label size
var FadeOutStyleRule = /*#__PURE__*/function (_LabelStyleRule) {_inherits(FadeOutStyleRule, _LabelStyleRule);var _super11 = _createSuper(FadeOutStyleRule);

  // @param {number} rangeStart - shape width in screen-pixels at which the label starts to fade-in
  // @param {number} rangeEnd   - shape width in screen-pixels at which the label is fully opaque.
  function FadeOutStyleRule() {var _this11;var rangeStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;var rangeEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 14;_classCallCheck(this, FadeOutStyleRule);
    _this11 = _super11.call(this);
    _this11.rangeStart = rangeStart;
    _this11.rangeEnd = rangeEnd;return _this11;
  }_createClass(FadeOutStyleRule, [{ key: "apply", value: function apply(

    label, shape, layer) {

      // compute opacity from shape screen-width
      var width = getShapeWidth(shape, layer);
      var t = (width - this.rangeStart) / (this.rangeEnd - this.rangeStart);
      var opacity = THREE.Math.clamp(t, 0, 1);

      label.container.style.opacity = opacity;
    } }]);return FadeOutStyleRule;}(LabelStyleRule);
;

// A ShapeLabelRule maintains a set of labels that is automatically synced with the shapes in a layer.
// It implements the CanvasGizmoBase to update the set of maintained labels.
var ShapeLabelRule = /*#__PURE__*/function () {

  // @param {EditLayer}               layer            - Labels are shown (and synchronized) with the content of this layer.
  // @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  // @param {LabelFilter}             [filter]         - Defines which labels to show. See DefaultLabelFilter for default behavior.
  // @param {LabelStyleRule}          [styleRule]      - Defines how label style is modified dynamically. (By default, we fade-out based on label size)
  function ShapeLabelRule(layer, shapeToLabelText) {var labelFilter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new DefaultLabelFilter();var styleRule = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new FadeOutStyleRule();_classCallCheck(this, ShapeLabelRule);
    this.layer = layer;
    this.shapeToLabelText = shapeToLabelText;

    // All labels that we created. 
    this.labels = {}; // {shapeId: ShapeLabel}

    this.layer.addCanvasGizmo(this);
    this.visible = true;
    this.layer.update();

    this.filter = labelFilter;
    this.styleRule = styleRule;
  }

  // Replace the rule to define label texts.
  //   @param {function(Shape)=>string} shapeToLabelText - A mapping that defines which text to display for a shape. If null, no label is created.
  _createClass(ShapeLabelRule, [{ key: "setTextRule", value: function setTextRule(shapeToLabelText) {
      this.shapeToLabelText = shapeToLabelText;
      this.update();
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      if (visible === this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add 'this' first and all maintained labels behind. In this way, this gizmo is updated first to
        //       configure all labels - followed by the update calls for all active labels in use.
        this.layer.addCanvasGizmo(this);
        this.update();
      } else {
        this.clearLabels();
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "dtor", value: function dtor()

    {
      // Make sure that we don't leave any of our labels in the layer
      this.setVisible(false);
    } }, { key: "removeLabelFromShape", value: function removeLabelFromShape(

    shape) {
      if (this.labels[shape.id]) {
        this.clearLabel(this.labels[shape.id]);
        delete this.labels[shape.id];
      }
    } }, { key: "clearLabel", value: function clearLabel(

    label) {
      label.setShape(null);
      label.setVisible(false);
    }

    // Hide + release all current labels, so that we can re-acquire them based on latest Layer state.
  }, { key: "clearLabels", value: function clearLabels() {var _this12 = this;
      Object.values(this.labels).forEach(function (label) {
        _this12.clearLabel(label);
      });

      this.labels = {};
    }

    // Create new label or get it from cache
  }, { key: "acquireLabel", value: function acquireLabel(shape) {
      var label = this.labels[shape.id];

      if (label) {
        return label;
      }

      label = new ShapeLabel(null, this.layer);
      label.setShape(shape);

      this.labels[shape.id] = label;

      return label;
    } }, { key: "update", value: function update()

    {var _this13 = this;
      var shapes = this.layer.shapes;
      for (var i = 0; i < shapes.length; i++) {

        var shape = shapes[i];

        // Get label text 
        var text = this.shapeToLabelText(shape);

        // Check if we want to display a label for this shape
        if (this.filter && !this.filter.accepts(shape, text, this.layer)) {
          this.removeLabelFromShape(shape);
          continue;
        }

        // Configure label
        var label = this.acquireLabel(shape);
        label.setText(text);
        label.setVisible(true);

        // Apply optional custom style rule
        this.styleRule && this.styleRule.apply(label, shape, this.layer);
      }

      // Clear labels that their shapes were removed.
      // Needed when autoUpdate is disabled.
      Object.values(this.labels).forEach(function (label) {
        // Shape no longer exists
        if (shapes.indexOf(label.shape) === -1) {
          _this13.removeLabelFromShape(label.shape);
        }
      });
    } }]);return ShapeLabelRule;}();


// A ShapeToolTip is a label that shows up when hovering a shape.
// By default, it appears a few pixels above the top-right corner of a shape's bbox.
var ShapeToolTip = /*#__PURE__*/function (_CanvasGizmoBase2) {_inherits(ShapeToolTip, _CanvasGizmoBase2);var _super12 = _createSuper(ShapeToolTip);

  // @param {EditLayer}               layer - Tooltip will appear for all shapes in the given layer.
  // @param {function(shape)=>string} getText - Function to define the text for a given shape
  function ShapeToolTip(layer) {var _this14;var getText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;_classCallCheck(this, ShapeToolTip);
    _this14 = _super12.call(this);

    _this14.layer = layer;
    _this14.textCb = getText;
    _this14.viewer = _this14.layer.viewer;

    // track latest mouse position in layer coords (init on first mouse move)
    _this14.mousePos = null;

    // distance between tooltip and shape bbox
    _this14.distanceToBox = 5; // in pixels

    // Create tooltip div
    _this14.container = _this14.getDocument().createElement('div');
    _this14.container.classList.add('adsk-control-tooltip');

    // Add div to viewer canvas container and layer
    _this14.viewer.canvasWrap.appendChild(_this14.container);

    // Update if layer changed
    _this14.layer.addCanvasGizmo(_assertThisInitialized(_this14));

    // Update if mouse moved
    _this14.onMouseMoved = _this14.onMouseMoved.bind(_assertThisInitialized(_this14));
    _this14.viewer.canvasWrap.addEventListener('mousemove', _this14.onMouseMoved);

    _this14.layer.updateCanvasGizmos();return _this14;
  }_createClass(ShapeToolTip, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeCanvasGizmo();
      this.viewer.canvasWrap.removeEventListener('mousemove', this.onMouseMoved);
      this.viewer.canvasWrap.removeChild(this.container);
    }

    // Set callback that defines which text to display for each shape. Returning '' or null will hide the tooltip.
    // @param {function(shape)=>string} getText - Function to define the text for a given shape
  }, { key: "setTextCallback", value: function setTextCallback(getText) {
      this.textCb = getText;
      this.update();
    } }, { key: "onMouseMoved", value: function onMouseMoved(

    event) {

      // Add canvas coords to event
      this.viewer.toolController.__clientToCanvasCoords(event);

      // Track mouse position
      this.mousePos = this.layer.canvasToLayer(event.canvasX, event.canvasY);

      this.update();
    } }, { key: "update", value: function update()

    {

      // If a textCb is set, check shape under mouse
      var shape = this.mousePos && this.textCb && this.layer.hitTest(this.mousePos.x, this.mousePos.y);

      // Choose label text
      var text = shape && this.textCb(shape);

      // Apply text
      this.container.textContent = text || '';

      // Stop here if nothing to display
      if (!text) {
        this.container.style.visibility = 'hidden';
        return;
      }

      // Show label
      this.container.style.visibility = 'visible';

      // Get top-right corner of bbox
      shape.updateBBox(); // Make sure bbox is up-to-date
      var corner = shape.bbox.max;

      // Get anchor in canvas coords
      var anchor = this.layer.layerToCanvas(corner.x, corner.y);

      // Add some pixels y-offset
      anchor.y -= this.distanceToBox;

      // get canvas size
      var width = this.viewer.canvas.width;
      var height = this.viewer.canvas.height;

      // Update tooltip position
      this.container.style.right = width - anchor.x + 'px';
      this.container.style.bottom = height - anchor.y + 'px';

      this.container.style.left = 'auto';
      this.container.style.top = 'auto';
    } }]);return ShapeToolTip;}(CanvasGizmoBase);


// Purpose:
// There is no efficient and simple way to ask a div whether it is under mouse or not.
// The most reliable way is document.elementFromPoint(), but it is rather expensive.
// Therefore, we don't want to do it for each and every gizmo. Instead, GizmoManager tracks
// which object is under mouse and is generally used to check which gizmo is at mouse position.
var GizmoManager = /*#__PURE__*/function () {

  function GizmoManager() {_classCallCheck(this, GizmoManager);
    // div element at mouse position
    this.elemUnderMouse = null;
  }

  // Must be triggered on mouse events.
  // @param {MouseEvent}
  _createClass(GizmoManager, [{ key: "update", value: function update(e) {
      this.elemUnderMouse = document.elementFromPoint(e.clientX, e.clientY);
    }

    // @param {CanvasGizmo}
  }, { key: "isUnderMouse", value: function isUnderMouse(gizmo) {
      return gizmo.container && gizmo.container === this.elemUnderMouse;
    }

    // Returns the index of the gizmo that matches with the element under mouse.
    // Result is -1 if none of the gizmos matches.
    //  @param {CanvasGizmo[]} gizmo
  }, { key: "getGizmoIndex", value: function getGizmoIndex(gizmos) {var _this15 = this;
      return gizmos.findIndex(function (g) {return _this15.isUnderMouse(g);});
    } }]);return GizmoManager;}();


// Display dashed lines to connect start/end of arc segments. Used by PolygonEditTool.
// It updates itself automatically whenever the shape changed.
var ArcEdgeGizmo = /*#__PURE__*/function () {
  function ArcEdgeGizmo(layer, gizmoLayer) {_classCallCheck(this, ArcEdgeGizmo);

    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // One Line shape per arc segment in the host shape
    this.shapes = [];

    this.visibility = false;
    this.setVisible(true);

    // Optional: Display one edge in another color
    this.highlightColor = undefined;
    this.highlightIndex = -1; // must be a valid edge index in this.poly
    this.highlightLoopIndex = -1; // must be a valid loop index in this.poly
  }_createClass(ArcEdgeGizmo, [{ key: "dtor", value: function dtor()

    {
      // Just make sure it is invisible, so that shapes are cleared and
      // gizmo is removed from GizmoLayer.
      this.setVisible(false);
    }

    // Set the shape for which we display lines
  }, { key: "setPoly", value: function setPoly(poly) {
      if (poly !== this.poly) {
        this.poly = poly;
        this.clearEdgeHighlighting();
        this.update();
      }
    } }, { key: "setVisible", value: function setVisible(

    visible) {

      // Do nothing if there's no change
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;

      // add/remove from layer
      if (visible) {
        this.layer.addCanvasGizmo(this);
      } else {
        this.layer.removeCanvasGizmo(this);
      }
      this.update();
    } }, { key: "clearShapes", value: function clearShapes()

    {var _this16 = this;
      this.shapes.forEach(function (s) {return _this16.gizmoLayer.removeShape(s);});
      this.shapes = [];
    } }, { key: "edgeShapeName", value: function edgeShapeName(

    index, loopIndex) {
      return 'ArcEdgeGizmo_' + loopIndex + '_' + index;
    }

    // Create a line shape that connects start/end vertex of segment i in poly.
  }, { key: "_addEdge", value: function _addEdge(index, loopIndex) {

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(index, a, b, loopIndex);

      // Create a line from it
      var line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]([a, b]);
      line.name = this.edgeShapeName(index, loopIndex);

      // Configure line style
      line.style.lineStyle = 11; // short dashes
      line.style.lineWidth = this.poly.style.lineWidth / 2.0;
      line.style.lineAlpha = this.poly.style.lineAlha / 2.0;

      // Apply optional edge highlighting color
      if (index == this.highlightIndex && this.highlightColor) {
        line.style.lineColor = this.highlightColor;
      }

      this.gizmoLayer.addShape(line);
      this.shapes.push(line);
    } }, { key: "clearEdgeHighlighting", value: function clearEdgeHighlighting()

    {

      if (this.highlightIndex === -1) {
        return;
      }

      this.highlightColor = null;
      this.highlightIndex = -1;
      this.highlight;
      this.update();
    }

    // Assign different
  }, { key: "setEdgeHighlighted", value: function setEdgeHighlighted(index, loopIndex, color) {

      // Only do work if needed
      if (index === this.highlightIndex && color === this.highlightColor) {
        return;
      }

      this.highlightColor = color;
      this.highlightIndex = index;
      this.highlightLoopIndex = loopIndex;
      this.update();
    }

    // Updates the edges for the given Path shape
  }, { key: "update", value: function update() {

      this.clearShapes();

      // Stop if there are no arcs
      if (!this.visible || !this.poly || !this.poly.isPath()) {
        return;
      }

      // For each loop...
      for (var l = 0; l < this.poly.loopCount; l++) {

        // For each edge...
        var edgeCount = this.poly.getEdgeCount(l);
        for (var i = 0; i < edgeCount; i++) {

          // Add line if it is an arc
          var isArc = this.poly.isArc(i, l);
          if (isArc) {
            this._addEdge(i, l);
          }
        }
      }
    } }]);return ArcEdgeGizmo;}();

/***/ }),

/***/ "./extensions/Edit2D/Clipboard.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Clipboard.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Clipboard; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var Clipboard = /*#__PURE__*/function () {
  function Clipboard() {_classCallCheck(this, Clipboard);
    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.shapes = [];
  }

  /**
     * Clear the contents of the clipboard
     */_createClass(Clipboard, [{ key: "clear", value: function clear()
    {
      this.shapes = [];
      this._dispatchContentChangedEvent(this.shapes);
    }

    /**
       * Check if the clipboard contains shapes
       *
       * @returns {boolean} True if there are shapes on the clipboard, false otherwise
       */ }, { key: "hasShapes", value: function hasShapes()
    {
      return this.shapes.length !== 0;
    }

    /**
       * Post shapes to the clipboard.
       *
       * The shapes will be cloned and then posted to the clipboard.
       *
       * @param {Shape[]} shapes The shapes to post to the clipboard
       */ }, { key: "postShapes", value: function postShapes(
    shapes) {
      this.shapes = shapes.map(function (s) {return s.clone();});
      this._dispatchContentChangedEvent(shapes);
    }

    /**
       * Clone the shapes on to the clipboard.
       *
       * @returns {Shape[]} Clones of shapes on the clipboard. May be empty if no shapes are on the clipboard.
       */ }, { key: "cloneShapes", value: function cloneShapes()
    {
      return this.shapes.map(function (s) {return s.clone();});
    } }, { key: "_dispatchContentChangedEvent", value: function _dispatchContentChangedEvent(

    shapes) {
      this.dispatchEvent({
        type: Clipboard.CONTENT_CHANGED,
        shapes: shapes });

    } }]);return Clipboard;}();


Clipboard.CONTENT_CHANGED = "CONTENT_CHANGED";

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.css":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Edit2D.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!../../node_modules/sass-loader/dist/cjs.js!./Edit2D.css */ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Edit2D.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DExtension; });
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
/* harmony import */ var _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Clipboard.js */ "./extensions/Edit2D/Clipboard.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Arrow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Arrow.js */ "./extensions/Edit2D/Arrow.js");
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Trackings_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Trackings.js */ "./extensions/Edit2D/Trackings.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Edit2DSnapper.js */ "./extensions/Edit2D/Edit2DSnapper.js");
/* harmony import */ var _Edit2DContextMenu_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Edit2DContextMenu.js */ "./extensions/Edit2D/Edit2DContextMenu.js");
/* harmony import */ var _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./UnitHandler.js */ "./extensions/Edit2D/UnitHandler.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
/* harmony import */ var _ScreenOverlay_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ScreenOverlay.js */ "./extensions/Edit2D/ScreenOverlay.js");
/* harmony import */ var _AngleGizmo_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./AngleGizmo.js */ "./extensions/Edit2D/AngleGizmo.js");
/* harmony import */ var _AngleGizmo3d_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./AngleGizmo3d.js */ "./extensions/Edit2D/AngleGizmo3d.js");
/* harmony import */ var _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./tools/MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./tools/PolygonTool.js */ "./extensions/Edit2D/tools/PolygonTool.js");
/* harmony import */ var _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./tools/PolygonEditTool.js */ "./extensions/Edit2D/tools/PolygonEditTool.js");
/* harmony import */ var _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./tools/InsertSymbolTool.js */ "./extensions/Edit2D/tools/InsertSymbolTool.js");
/* harmony import */ var _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./tools/RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./tools/UndoTool.js */ "./extensions/Edit2D/tools/UndoTool.js");
/* harmony import */ var _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./tools/CopyTool.js */ "./extensions/Edit2D/tools/CopyTool.js");
/* harmony import */ var _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./tools/LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
/* harmony import */ var _tools_VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./tools/VertexMoveTool.js */ "./extensions/Edit2D/tools/VertexMoveTool.js");
/* harmony import */ var _tools_EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./tools/EdgeMoveTool.js */ "./extensions/Edit2D/tools/EdgeMoveTool.js");
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _BooleanOps_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./BooleanOps.js */ "./extensions/Edit2D/BooleanOps.js");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./Edit2D.css */ "./extensions/Edit2D/Edit2D.css");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(_Edit2D_css__WEBPACK_IMPORTED_MODULE_32__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}


































 // IMPORTANT!!

var myExtensionName = 'Autodesk.Edit2D';
var namespace = AutodeskNamespace('Autodesk.Edit2D');
var av = Autodesk.Viewing;

var OverlayName = 'Edit2D';var

ToolSet =
function ToolSet(name, autoReactivate) {_classCallCheck(this, ToolSet);
  this.name = name;
  this.autoReactivate = autoReactivate;
  this.context = null;
  this.tools = {};
};


/** 
    * Edit2D extension provides API for implementing 2D vector editing. 
    * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only
    * to provide a basis for other extensions and client applications.
    * 
    * The extension id is: `Autodesk.Edit2D`
    * 
    * @example
    *   viewer.loadExtension('Autodesk.Edit2D')
    *
    * @memberof Autodesk.Viewing.Extensions
    * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
    * @alias Autodesk.Viewing.Extensions.Edit2DExtension
    * @class
    */var
Edit2DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Edit2DExtension, _av$Extension);var _super = _createSuper(Edit2DExtension);
  function Edit2DExtension(viewer, options) {var _this;_classCallCheck(this, Edit2DExtension);
    _this = _super.call(this, viewer, options);

    _this.undoStack = new _UndoStack_js__WEBPACK_IMPORTED_MODULE_9__["default"]();

    // A map containing all registered Edit 3D tools (value as ToolSet) for a specific tool set name (key)
    _this._registeredTools = new Map();
    _this._boundOnModelAdded = _this._onModelAdded.bind(_assertThisInitialized(_this));
    _this._boundOnModelRemoved = _this._onModelRemoved.bind(_assertThisInitialized(_this));
    _this._boundOnSelectionChanged = _this._onSelectionChanged.bind(_assertThisInitialized(_this));return _this;
  }_createClass(Edit2DExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:



                // The overlay "Edit2D" contains subscenes for each edit layer.
                this.viewer.impl.createOverlayScene(OverlayName);

                // We require Snapping and Autodesk.CompGeom (already a dependency of Autodesk.Snapping)
                _context.next = 3;return this.viewer.loadExtension('Autodesk.Snapping');case 3:

                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
                this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

                // activate UndoTool immediately, because it runs in parallel to other tools and for all tools
                this.undoTool = new _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_24__["default"](this.undoStack);
                this.viewer.toolController.registerTool(this.undoTool);
                this.viewer.toolController.activateTool(this.undoTool.getName());case 8:case "end":return _context.stop();}}}, _callee, this);}));function load() {return _load.apply(this, arguments);}return load;}() }, { key: "unload", value: function unload()


    {var _iterator = _createForOfIteratorHelper(
      this._registeredTools.keys()),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var toolSetName = _step.value;
          this.unregisterTools(toolSetName);
        }} catch (err) {_iterator.e(err);} finally {_iterator.f();}

      this.viewer.toolController.deregisterTool(this.undoTool);
      this.undoTool = null;

      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

      return true;
    } }, { key: "_onModelAdded", value: function _onModelAdded()

    {var _this2 = this;
      if (this.viewer.getVisibleModels().length !== 1) {
        // Do the reactivation only when the first model got loaded.
        return;
      }var _iterator2 = _createForOfIteratorHelper(

      this._registeredTools.values()),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var toolSet = _step2.value;
          if (toolSet.autoReactivate) {var _toolSet$toolsToReact;
            (_toolSet$toolsToReact = toolSet.toolsToReactivate) === null || _toolSet$toolsToReact === void 0 ? void 0 : _toolSet$toolsToReact.forEach(function (name) {return _this2.viewer.toolController.activateTool(name);});
          }
        }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}
    } }, { key: "_onModelRemoved", value: function _onModelRemoved()

    {
      if (this.viewer.getVisibleModels().length !== 0) {
        // Only deactivate tools when no model is active anymore.
        return;
      }

      var controller = this.viewer.toolController;var _iterator3 = _createForOfIteratorHelper(
      this._registeredTools.values()),_step3;try {for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {var toolSet = _step3.value;
          if (toolSet.autoReactivate) {
            // The next statement gets all possible names of all tools of a toolSet,
            // flatten the resulting array
            // and returns a list tool names that are active.
            toolSet.toolsToReactivate = Object.values(toolSet.tools).
            map(function (t) {return t.getNames();}).
            reduce(function (res, names) {return res.concat(names);}, []) // flatten
            .filter(function (name) {return controller.isToolActivated(name);});

            toolSet.toolsToReactivate.forEach(function (name) {return controller.deactivateTool(name);});
          }
        }} catch (err) {_iterator3.e(err);} finally {_iterator3.f();}
    }

    // If multiple tools are registered, we have to clear the other selections as the mouse events are handled on the first one.
  }, { key: "_onSelectionChanged", value: function _onSelectionChanged(_ref) {var selectionSource = _ref.target;var _iterator4 = _createForOfIteratorHelper(
      this._registeredTools.values()),_step4;try {for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {var toolSet = _step4.value;
          if (selectionSource !== toolSet.context.selection && !selectionSource.empty()) {
            toolSet.context.selection.clear();
          }
        }} catch (err) {_iterator4.e(err);} finally {_iterator4.f();}
    } }, { key: "registerDefaultTools", value: function registerDefaultTools()

    {
      this.defaultContext = this.registerTools('default');
    }

    // Get default tools. registerDefaultTools() must be called first, otherwise it returns null.
  }, { key: "getToolSet",




    // returns a given toolset, or null if none with the given name have been registered.
    value: function getToolSet(toolSetName) {
      return this._registeredTools.get(toolSetName);
    } }, { key: "registerTools", value: function registerTools(

    toolSetName) {var autoReactivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var toolSet = this._registeredTools.get(toolSetName);
      if (toolSet) {
        console.warn("Edit 2D tools are already registered for tool set '".concat(toolSetName, "'"));
        return toolSet.context;
      }

      toolSet = new ToolSet(toolSetName, autoReactivate);
      this._registeredTools.set(toolSetName, toolSet);

      // create context
      var context = toolSet.context = new Edit2DContext(this, toolSetName, options);
      context.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // create tools
      toolSet.tools.polygonTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"].Mode.Polygon);
      toolSet.tools.polylineTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"].Mode.Polyline);
      toolSet.tools.moveTool = new _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_19__["default"](context);
      toolSet.tools.polygonEditTool = new _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_21__["default"](context);
      toolSet.tools.insertSymbolTool = new _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_22__["default"](context);
      toolSet.tools.copyTool = new _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_25__["default"](context);

      // Enable all new shapes to be Paths, so that you can turn line segments into arc segments
      var enableArcs = Boolean(this.options.enableArcs);
      toolSet.tools.polygonTool.setArcsEnabled(enableArcs);
      toolSet.tools.polylineTool.setArcsEnabled(enableArcs);

      // Allow converting segments to ellipse arcs if wanted
      if (this.options.enableEllipseArcs) {
        toolSet.tools.polygonEditTool.enableEllipseArcs = true;
      }

      // register them
      var controller = this.viewer.toolController;
      controller.registerTool(toolSet.tools.polygonTool);
      controller.registerTool(toolSet.tools.polylineTool);
      controller.registerTool(toolSet.tools.moveTool);
      controller.registerTool(toolSet.tools.polygonEditTool);
      controller.registerTool(toolSet.tools.insertSymbolTool);
      controller.registerTool(toolSet.tools.copyTool);

      // activate CopyTool immediately, because they run parallel to other tools
      controller.activateTool(toolSet.tools.copyTool.getName());

      // create and register context mneu
      toolSet.contextMenu = new _Edit2DContextMenu_js__WEBPACK_IMPORTED_MODULE_11__["default"](this.viewer, toolSet);
      toolSet.contextMenu.register();

      return context;
    } }, { key: "unregisterDefaultTools", value: function unregisterDefaultTools()

    {
      this.unregisterTools('default');
      this.defaultContext = null;
    } }, { key: "unregisterTools", value: function unregisterTools(

    toolSetName) {
      var toolSet = this._registeredTools.get(toolSetName);
      if (!toolSet) {
        return;
      }

      var controller = this.viewer.toolController;
      controller.deregisterTool(toolSet.tools.polygonTool);
      controller.deregisterTool(toolSet.tools.polylineTool);
      controller.deregisterTool(toolSet.tools.moveTool);
      controller.deregisterTool(toolSet.tools.polygonEditTool);
      controller.deregisterTool(toolSet.tools.insertSymbolTool);
      controller.deregisterTool(toolSet.tools.copyTool);

      toolSet.context.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // Unregister and delete context menu
      toolSet.contextMenu.unregister();
      toolSet.contextMenu = null;

      this._registeredTools.delete(toolSetName);
    } }, { key: "createLayer", value: function createLayer(

    options) {

      var model = this.viewer.model;
      if (!model) {
        console.error("A 2D model is needed to adjust viewport");
      }

      // create new overlay scene to show
      var layer = new _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](this.viewer, options);

      if (!options.useSceneAfter) {
        // add layer scene to our overlay scene
        this.viewer.impl.overlayScenes[OverlayName].scene.add(layer.scene);
      }

      return layer;
    } }, { key: "defaultTools", get: function get() {var toolSet = this._registeredTools.get('default');return toolSet && toolSet.tools;} }]);return Edit2DExtension;}(av.Extension);


// Common set of objects usually needed by tools
var Edit2DContext = /*#__PURE__*/function () {

  // @param {Edit2D} ext - Edit2d extension
  function Edit2DContext(ext, toolSetName) {var _this3 = this;var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};_classCallCheck(this, Edit2DContext);
    this.toolSetName = toolSetName;
    this.viewer = ext.viewer;
    this.layer = ext.createLayer(options);
    this.gizmoLayer = ext.createLayer(options);
    this.undoStack = ext.undoStack;
    this.clipboard = new _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
    this.selection = new _Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.layer, this.undoStack);
    this.snapper = new _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_10__["default"](this.viewer, this.layer, this.gizmoLayer);
    this.unitHandler = new _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["DefaultUnitHandler"](this.viewer);

    // track mouse in Edit2D
    this.mouseTracker = ext.options.mouseTracker;

    // Update all visible labels if display units are changed
    var onUnitChange = function onUnitChange() {
      _this3.layer.updateCanvasGizmos();
      _this3.gizmoLayer.updateCanvasGizmos();
    };
    this.viewer.addEventListener(Autodesk.Viewing.MeasureCommon.Events.DISPLAY_UNITS_CHANGED, onUnitChange);
  }

  // Set matrix that is applied to all displayed geometry
  _createClass(Edit2DContext, [{ key: "setMatrix", value: function setMatrix(matrix) {
      this.layer.setMatrix(matrix);
      this.gizmoLayer.setMatrix(matrix);
      this.layer.update();
      this.gizmoLayer.update();
    }

    // Clears current layer in a way that undo-stack keeps consistent.
    // 
    //  @param {boolean} enableUndo - If false, the undoStack is cleared.
  }, { key: "clearLayer", value: function clearLayer() {var enableUndo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (enableUndo) {
        var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"].RemoveShapes(this.layer, this.layer.shapes);
        this.undoStack.run(action);
      } else {
        this.layer.clear();
        this.undoStack.clear();
      }
    } }, { key: "addShape", value: function addShape(

    shape) {
      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"].AddShape(this.layer, shape);
      this.undoStack.run(action);
    } }, { key: "removeShape", value: function removeShape(

    shape) {
      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"].RemoveShape(this.layer, shape);
      this.undoStack.run(action);
    } }]);return Edit2DContext;}();


// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Edit2DExtension);

namespace.Shape = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Shape"];
namespace.Polygon = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Polygon"];
namespace.Polyline = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Polyline"];
namespace.PolyBase = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyBase"];
namespace.Path = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Path"];
namespace.PolygonPath = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolygonPath"];
namespace.PolylinePath = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolylinePath"];
namespace.Circle = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Circle"];
namespace.Style = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Style"];
namespace.EllipseArcParams = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["EllipseArcParams"];
namespace.PolygonTool = _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_20__["default"];
namespace.Selection = _Selection_js__WEBPACK_IMPORTED_MODULE_4__["default"];
namespace.MoveTool = _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_19__["default"];
namespace.PolygonEditTool = _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_21__["default"];
namespace.VertexMoveTool = _tools_VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_27__["default"];
namespace.EdgeMoveTool = _tools_EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_28__["default"];
namespace.InsertSymbolTool = _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_22__["default"];
namespace.Math2D = _Math2D_js__WEBPACK_IMPORTED_MODULE_5__["Math2D"];
namespace.VertexGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["VertexGizmo"];
namespace.RectangleTool = _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_23__["default"];
namespace.LineTool = _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_26__["default"];
namespace.CopyTool = _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_25__["default"];
namespace.Actions = _Actions_js__WEBPACK_IMPORTED_MODULE_7__["Actions"];
namespace.UndoStack = _UndoStack_js__WEBPACK_IMPORTED_MODULE_9__["default"];
namespace.Clipboard = _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"];
namespace.UndoTool = _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_24__["default"];
namespace.Edit2DContext = Edit2DContext;
namespace.CanvasGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["CanvasGizmo"];
namespace.CanvasGizmoBase = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["CanvasGizmoBase"];
namespace.ShapeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["ShapeLabel"];
namespace.AlignX = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["AlignX"];
namespace.AlignY = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["AlignY"];
namespace.AreaLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["AreaLabel"];
namespace.EdgeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["EdgeLabel"];
namespace.UnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["UnitHandler"];
namespace.SimpleUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["SimpleUnitHandler"];
namespace.DefaultUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_12__["DefaultUnitHandler"];
namespace.ShapeLabelRule = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["ShapeLabelRule"];
namespace.ShapeWrapper = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["ShapeWrapper"];
namespace.SegmentTree = _SegmentTree_js__WEBPACK_IMPORTED_MODULE_15__["default"];
namespace.TangentGizmo = _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_14__["default"];
namespace.MeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_29__["MeasureTransform"];
namespace.DefaultMeasureTransform = _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_29__["DefaultMeasureTransform"];
namespace.ShapeToolTip = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["ShapeToolTip"];
namespace.Svg = _Svg_js__WEBPACK_IMPORTED_MODULE_6__["Svg"];
namespace.SolidDefConvert = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_30__["SolidDefConvert"];
namespace.BooleanOps = _BooleanOps_js__WEBPACK_IMPORTED_MODULE_31__["BooleanOps"];
namespace.LoopType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["LoopType"];
namespace.EdgeType = _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["EdgeType"];
namespace.FadeOutStyleRule = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["FadeOutStyleRule"];
namespace.EditLayer = _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"];
namespace.ScreenOverlay = _ScreenOverlay_js__WEBPACK_IMPORTED_MODULE_16__["default"];
namespace.Arrow = _Arrow_js__WEBPACK_IMPORTED_MODULE_3__["default"];
namespace.AngleGizmo = _AngleGizmo_js__WEBPACK_IMPORTED_MODULE_17__["default"];
namespace.AngleGizmo3d = _AngleGizmo3d_js__WEBPACK_IMPORTED_MODULE_18__["default"];
namespace.TextLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_13__["TextLabel"];
namespace.Trackings = _Trackings_js__WEBPACK_IMPORTED_MODULE_8__["Trackings"];

/***/ }),

/***/ "./extensions/Edit2D/Edit2DContextMenu.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/Edit2DContextMenu.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DContextMenu; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var

Edit2DContextMenu = /*#__PURE__*/function () {

  // @param {ToolSet} toolSet (see Edit2D.js)
  function Edit2DContextMenu(viewer, toolSet) {_classCallCheck(this, Edit2DContextMenu);

    this.viewer = viewer;
    this.toolSet = toolSet;

    // Define ContextMenu callback
    this.callbackId = "Edit2D_".concat(toolSet.name);
    this.callback = this.onContextMenu.bind(this);
  }_createClass(Edit2DContextMenu, [{ key: "register", value: function register()

    {
      this.viewer.registerContextMenuCallback(this.callbackId, this.callback);
    } }, { key: "unregister", value: function unregister()

    {
      this.viewer.unregisterContextMenuCallback(this.callbackId);
    }

    //  @param {CanvasGizmo[][]} Array of CanvasGizmo arrays per loop
    // Returns {PolyIndex} - Returns the PolyIndex of the vertex gizmo under mouse
  }, { key: "findGizmoUnderMouse", value: function findGizmoUnderMouse(gizmos, clientX, clientY) {
      // Check element under mouse
      var elem = document.elementFromPoint(clientX, clientY);

      // Check if it matches with any vertex gizmo
      for (var l = 0; l < gizmos.length; l++) {
        var index = gizmos[l].findIndex(function (g) {return g.container === elem;});
        if (index !== -1) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: index, loop: l });
        }
      }
      return null;
    }

    // Note that editTool.getVertexIndex() does not work if a context menu is already open.
    // Reason is that the evens are all consumed by an invisible full-screen-div, so that a
    // gizmos cannot detect anymore if the mouse is on it.
  }, { key: "vertexGizmoUnderMouse", value: function vertexGizmoUnderMouse(clientX, clientY) {
      // get vertex gizmos from EditTool
      var editTool = this.toolSet.tools.polygonEditTool;
      var gizmos = editTool.vertexMoveTool.vertexGizmos;
      return this.findGizmoUnderMouse(gizmos, clientX, clientY);
    } }, { key: "edgeGizmoUnderMouse", value: function edgeGizmoUnderMouse(

    clientX, clientY) {
      // get vertex gizmos from EditTool
      var editTool = this.toolSet.tools.polygonEditTool;
      var gizmos = editTool.edgeMoveTool.edgeGizmos;
      var polyIndex = this.findGizmoUnderMouse([gizmos], clientX, clientY);
      return polyIndex ? polyIndex.vertex : -1;
    }

    // Define callback to modify the viewer context menu
    //  @param {Object[]} menuItems - items to be modified
    //  @param {Object}   status    - ObjectContextMenu.js
  }, { key: "onContextMenu", value: function onContextMenu(menu, status) {var _this = this;

      var editTool = this.toolSet.tools.polygonEditTool;
      var layer = this.toolSet.context.layer;
      var event = status.event;
      var selection = this.toolSet.context.selection;
      var undoStack = this.toolSet.context.undoStack;

      // get mouse pos in layer coords
      var mousePos = layer.canvasToLayer(status.canvasX, status.canvasY);

      // Check if mouse is close to an edge of the current edit polygon
      var edgePolyIndex = editTool.findEdgeUnderMouse(mousePos);

      // Check shape under mouse. If we are close to a current edge of the editPoly, 
      // consider it as under mouse as well.
      var shapeUnderMouse = edgePolyIndex ? editTool.poly : layer.hitTest(mousePos.x, mousePos.y);

      // When right-clicking outside current selection, we select the shape under mouse or clear selection of there is none.
      // This avoids ambiguities about which shape we are modifying (selected vs. under mouse)
      var selectedShapes = selection.getSelectedShapes();
      var mouseOnSelection = selectedShapes.includes(shapeUnderMouse);
      if (!mouseOnSelection && editTool.active) {
        selection.selectOnly(shapeUnderMouse);
      }

      // Multi-select operations are allowed when right-clicking on one of the selected shapes
      var multiSelect = mouseOnSelection && selectedShapes.length > 1;
      if (multiSelect) {

        // Remove shapes
        menu.push({
          title: 'Remove Shapes',
          target: function target() {
            undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveShapes(layer, selectedShapes));
          } });


        // Unify shapes
        if (editTool.enableUnify) {

          // To allow unify, all shapes must be closed and PolyBase instances
          var canBeUnified = !selectedShapes.find(function (s) {return !s instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] || !s.isClosed;});
          if (canBeUnified) {
            menu.push({
              title: 'Unify Shapes',
              target: function target() {
                // get index of the shape under mouse within selected shapes
                var shapeIndex = selectedShapes.indexOf(shapeUnderMouse);
                undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].UnifyShapes(layer, selectedShapes, shapeIndex));
              } });

          }
        }
      }

      // Check if a shape is selected for editing
      var shapeSelected = Boolean(editTool.poly);
      if (!shapeSelected) {
        // If not, keep original viewer context menu
        return;
      }

      // Check if we hit a vertex gizmo. Note that a VertexGizmo exceeds the actual shape.
      var vertex = this.vertexGizmoUnderMouse(event.clientX, event.clientY);
      var mouseOnVertexGizmo = Boolean(vertex);

      // Check if we hit an edge gizmo.
      var edgeGizmoIndex = this.edgeGizmoUnderMouse(event.clientX, event.clientY);
      var mouseOnEdgeGizmo = edgeGizmoIndex !== -1;

      // Check if "insert vertex" is possible at the current position        
      var edgeIndex = edgePolyIndex && edgePolyIndex.vertex;
      var newVertexPos = edgePolyIndex && editTool.getNewVertexPosition(mousePos, edgePolyIndex);
      var mouseCloseToEdge = Boolean(newVertexPos);

      // If the mouse is neither on a shape nor on a vertex gizmo, exist here.
      // Note that the gizmos exceed the actual shape by a few pixels, so we may hit one without hitting the shape.        
      if (!shapeUnderMouse && !mouseOnVertexGizmo && !mouseCloseToEdge) {
        // When clicking somewhere else, leave default context menu
        return;
      }

      // If a polygon is selected for editing, we hijack the menu completely and remove the 
      // viewer default stuff (Show all layers etc.) - assuming that the user is focusing on 2D editing.
      menu.length = 0;

      if (editTool.enableCutout) {
        // add cutout menu item
        var selected = editTool.poly;
        var isClosed = selected instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"] && selected.isClosed;
        if (isClosed) {
          menu.push({
            title: 'Apply as Cutout',
            target: function target() {
              var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ApplyCutOut(layer, selected);
              _this.toolSet.context.undoStack.run(action);
            } });

        }
      }

      // If so, add RemoveVertex item
      if (mouseOnVertexGizmo) {
        menu.push({
          title: 'Remove Vertex',
          target: function target() {
            editTool.removePoint(vertex);
          } });

      } else if (edgePolyIndex && newVertexPos) {
        // Add "Insert Vertex" menu item
        menu.push({
          title: 'Insert Vertex',
          target: function target() {
            // insert new vertex after edge starting point
            var newVertex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: edgePolyIndex.vertex + 1, loop: edgePolyIndex.loop });
            editTool.insertPoint(newVertex, newVertexPos);
          } });

      }

      // Consider mouse as "onEdge" if it is hovering the edge gizmo or close to the edge itself.
      var onEdge = mouseOnEdgeGizmo || mouseCloseToEdge;

      // Check if Create/Remove arc is possible
      var enableArc = editTool.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"];

      // If mouse is close to an edge or on an edge gizmo, add edge operations
      if (!mouseOnVertexGizmo && onEdge && enableArc) {

        var currentType = editTool.poly.getEdgeType(edgeIndex, edgePolyIndex.loop);

        // Add "Change-To" operations for all edge types except the current...

        // Change-to-Line
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line) {
          menu.push({
            title: 'Change to Line Segment',
            target: function target() {
              editTool.changeEdgeToLine(edgePolyIndex);
            } });

        }

        // Change-to-Bezier
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier) {
          menu.push({
            title: 'Change to Arc Segment',
            target: function target() {
              editTool.changeEdgeToBezier(edgePolyIndex);
            } });

        }

        // Change-to-Ellipse
        if (currentType !== _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse && editTool.enableEllipseArcs) {
          menu.push({
            title: 'Change to Ellipse Segment',
            target: function target() {
              editTool.changeEdgeToEllipse(edgePolyIndex);
            } });

        }
      }

      // Check if there are loops any loops left if we remove this one
      if (edgePolyIndex && editTool.poly.isClosed) {

        // If the loop under mouse is the (only) outer loop, don't show "removeLoop", because it makes more sense to just remove the shape instead.
        var mainLoops = editTool.poly.getMainLoops();
        var isOnlyMainLoop = mainLoops.length === 1 && mainLoops[0] === edgePolyIndex.loop;

        // Check loop type
        var type = editTool.poly.getLoopType(edgePolyIndex.loop);
        var itemName;
        switch (type) {
          case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["LoopType"].Outer:itemName = 'Remove Shape Part';break;
          case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["LoopType"].Inner:itemName = 'Remove Hole';break;
          default:itemName = 'Remove Loop';}
        ;

        if (!isOnlyMainLoop) {
          menu.push({
            title: itemName,
            target: function target() {
              editTool.removeLoop(edgePolyIndex.loop);
            } });

        }
      }

      if (shapeUnderMouse) {
        menu.push({
          title: 'Remove Shape',
          target: function target() {
            undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveShape(layer, shapeUnderMouse));
          } });

      }
    } }]);return Edit2DContextMenu;}();

/***/ }),

/***/ "./extensions/Edit2D/Edit2DSnapper.js":
/*!********************************************!*\
  !*** ./extensions/Edit2D/Edit2DSnapper.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DSnapper; });
/* harmony import */ var _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AngleSnapper.js */ "./extensions/Edit2D/AngleSnapper.js");
/* harmony import */ var _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SegmentTree.js */ "./extensions/Edit2D/SegmentTree.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var SnapType = Autodesk.Viewing.MeasureCommon.SnapType;

// Edit2DSnapper combines 3 different types of snapping:
//  1. Snapping to sheet geometry
//  2. Snapping to other geometry in the same layer
//  3. Snapping to angles and alignments

var av = Autodesk.Viewing;var

Edit2DSnapper = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  // @param {Layer} layer
  // @param {EditLayer} gizmoLayer - used to add temporary snapping indicators (e.g., dashed lines for angle snapping)
  function Edit2DSnapper(viewer, layer, gizmoLayer) {_classCallCheck(this, Edit2DSnapper);

    this.viewer = viewer;
    this.setGlobalManager(viewer.globalManager);
    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // Snapper for sheet geometry and layer geometry.
    // Note: SnapResults are always stored in LMV world-coords (!=layer coords). Otherwise, SnapperIndicator would not display correctly.
    this.sheetSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);
    this.layerSnapper = new Autodesk.Viewing.Extensions.Snapping.Snapper(viewer);

    // Used for snapping to angles and alignments
    this.angleSnapper = new _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__["default"](gizmoLayer);

    // tmp box reused for snapping
    this.snapBox = new THREE.Box2();

    // make sure SnapperIndicator exists. Note that angleSnapper does not need this - only the standard LMV snapper.
    this.sheetSnapper.activate();
    this.layerSnapper.activate();

    // update Snapper indicator on camera changes (otherwise, it grows/shrinks on camera zoom)
    this.onCameraChangeCb = this.onCameraChange.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);

    // If there is a model already, compute SegmentTree right now
    this.initSegmentTrees();

    // Reused tmp vector
    this.tmpVec = new THREE.Vector3();
    // Raycaster for snapping
    this.raycaster = new THREE.Raycaster();
    this.ray = new THREE.Ray();

    // If we snapped to a line segment, this member contains
    // this line segment in layer coords. See _getGeomSnapLine().
    this.geomSnapLine = {
      a: new THREE.Vector3(),
      b: new THREE.Vector3() };

  }_createClass(Edit2DSnapper, [{ key: "dtor", value: function dtor()

    {
      this.sheetSnapper.deactivate();
      this.layerSnapper.deactivate();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.updateSnapperIndicators();
    }

    // Make sure that all visible models have a SegmentTree
  }, { key: "initSegmentTrees", value: function initSegmentTrees() {
      var models = this.viewer.getVisibleModels();
      models.forEach(function (model) {
        // Note: We have to wait until the model finished loading. Otherwise, we may end up with a segmentTree that only
        //       contains a subset of the segments.
        //       In addition, make sure to skip the segment building in case it's a leaflet (e.g. a raster PDF).
        var isLeaflet = model.isLeaflet();
        if (model.is2d() && !isLeaflet && !model.segmentTree && model.isLoadDone()) {
          model.segmentTree = new _SegmentTree_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
          model.segmentTree.buildFromModel(model);
        }
      });
    } }, { key: "updateSnapperIndicators", value: function updateSnapperIndicators()

    {
      // Note: All LMV snappers use (and clear) the same overlay scene. Therefore, we can call render() only on one of the Snapper
      // indicators. Otherwise, when snapping to sheet geometry, calling layerSnapper.indicator.render() afterwards would clear 
      // the sheet-snapping indicator again.
      if (this.sheetSnapper.isSnapped()) {
        this.sheetSnapper.indicator.render();
      } else {
        // If none is snapped, it doesn't matter which indicator we call: Both will just clear the overlay.
        this.layerSnapper.indicator.render();
      }
    }

    // Returns snapPosition as Vector2 in layer-coords. If no snapping happens, it just maps the position directly.
    //  @param {function(shape)} [snappingFilter] - Option filter to restrict EditLayer snapping to certain EditLayer shapes.
  }, { key: "getSnapPosition", value: function getSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this._getSnapPosition(canvasX, canvasY, snappingFilter);

      // keep snapping gizmos up to date
      this.angleSnapper.updateSnapLineGizmos(p);

      this.updateSnapperIndicators();

      return p;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {
      this.angleSnapper.clearSnappingGizmos();
      this.sheetSnapper.clearSnapped();
      this.sheetSnapper.indicator && this.sheetSnapper.indicator.clearOverlays();
      this.layerSnapper.clearSnapped();
      this.layerSnapper.indicator && this.layerSnapper.indicator.clearOverlays();
    }

    // Angle and Alignment snapping can only be used when explicitly activated for a given polygon.
    // Otherwise, it has no effect.
  }, { key: "startAngleSnapping", value: function startAngleSnapping(poly, draggedVertex, loopIndex) {
      this.angleSnapper.startSnapping(poly, draggedVertex, loopIndex);
    }

    // Stop snapping to angles. (No effect if angleSnapping is already off).
  }, { key: "stopAngleSnapping", value: function stopAngleSnapping() {
      this.angleSnapper.stopSnapping();
    }

    // Like getSnapPosition, but excluding Snapping gizmo updates.
  }, { key: "_getSnapPosition", value: function _getSnapPosition(canvasX, canvasY, snappingFilter) {

      // Discard any outdated snapping results
      this.angleSnapper.clearSnappingResult();
      this.sheetSnapper.clearSnapped();
      this.layerSnapper.clearSnapped();

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Check if geom-snapping is possible (pGeom is in layer-coords)
      var pGeom = this._getGeomSnapPosition(canvasX, canvasY, snappingFilter);

      // Check if we snapped to line geometry. If so, we can still allow angle-snapping - as long as we constrain it to the geometry snapLine.
      var geomSnapLine = this._getGeomSnapLine();

      if (pGeom && !geomSnapLine) {
        // We snapped to geometry and the snapType does not allow us to combine it with angle snapping
        // => Just return result of geometry snapping
        return pGeom;
      }

      // Apply angle-snapping. If we snapped to line geometry already, constrain angleSnapping to this line.
      this.angleSnapper.snapToAngle(p, geomSnapLine);

      // If there is no angle-snap, just apply the geometry snap
      if (geomSnapLine && !this.angleSnapper.isSnapped()) {
        return pGeom;
      }

      // By default, SnapperIndicator only considers the geometry snapping result. If we corrected the snap point and used the intersection with an
      // angle snapLine, we have to update the SnapResult so that the snapPoint is correctly reflected by the SnapperIndicator.
      if (geomSnapLine && this.angleSnapper.isSnapped()) {
        var result = this._getGeomSnapResult();

        // p is in 2D layer coords, but LMV Snapper snapResults are always stored in LMV world coords
        var pWorld = new THREE.Vector3(p.x, p.y, 0.0).applyMatrix4(this.layer.layerToWorld);

        result.geomType = SnapType.SNAP_INTERSECTION;
        result.snapPoint = pWorld;
        result.geomVertex = result.snapPoint; // Otherwise, snapResult.isEmpty() returns true
      }

      return p;
    }

    // Gets snap position from mouse event. 
    //  @returns {Vector2|null} Snapped position or null if not snapped.
  }, { key: "_getGeomSnapPosition", value: function _getGeomSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Compute snap position for model geom and edit layer. 
      // Both may be undefined if there was nothing to snap to.
      var pSheet = this._getSheetSnapPosition(canvasX, canvasY);
      var pLayer = this._getEditLayerSnapPosition(canvasX, canvasY, snappingFilter);

      // If nothing is snapped, don't snap
      if (!pSheet && !pLayer) {
        return null;
      }

      // If only one snap point was found, use it
      if (!pLayer) {
        return pSheet;
      } else if (!pSheet) {
        return pLayer;
      }

      // Get distances of snapPoints to accurate position
      var distSheet = THREE.Vector2.prototype.distanceToSquared.call(pSheet, p);
      var distLayer = THREE.Vector2.prototype.distanceToSquared.call(pLayer, p);

      // Choose the closer snap. If equal, prefer edit layer snap.
      // We discard unused snap results here, so that snapper indicator keeps correct
      if (distSheet < distLayer) {
        // Use sheet snap and discard the other snap result
        this.layerSnapper.clearSnapped();
        return pSheet;
      } else {
        // Use layer snap and discard the other snap result
        this.sheetSnapper.clearSnapped();
        return pLayer;
      }
    }

    // Returns the SnapResult of sheetSnapper or layerSnapper if any of them is currently snapped. Returns null otherwise.
    // Note that LMV snapResults contain values in lmv world coords.
  }, { key: "_getGeomSnapResult", value: function _getGeomSnapResult() {

      // Check which of the snappers has snapped
      var sheetSnap = this.sheetSnapper.isSnapped();
      var layerSnap = this.layerSnapper.isSnapped();
      if (!sheetSnap && !layerSnap) {
        return null;
      }

      // Get latest SnapResult
      var geomSnapper = sheetSnap ? this.sheetSnapper : this.layerSnapper;
      return geomSnapper.getSnapResult();
    }

    // If the last geometry snapping successfully snapped to a line segment, this function returns this line segment.
    // Result is in layer-coords.
    //  @returns {Object} - If we snapped to a line segment, we return r={a, b} where r.a and r.b are line start/end as Vector2.
  }, { key: "_getGeomSnapLine", value: function _getGeomSnapLine() {

      var result = this._getGeomSnapResult();
      if (!result) {
        return null;
      }

      // If we snapped to an edge, return this edge. Note that SnapType may be SNAP_EDGE, but may also be SNAP_VERTEX
      var edgeGeom = result.geomEdge;
      if (edgeGeom) {
        var verts = result.geomEdge.vertices;

        // Copy edge start/end to this.geomSnapLine
        this.geomSnapLine.a.copy(verts[0]);
        this.geomSnapLine.b.copy(verts[1]);

        // SnapResults are in world coords. We want the geomSnapLine in layer coords.
        this.geomSnapLine.a.applyMatrix4(this.layer.worldToLayer);
        this.geomSnapLine.b.applyMatrix4(this.layer.worldToLayer);

        return this.geomSnapLine;
      }

      // Another SnapType => No line constraint.
      return null;
    }

    // Snaps to 2D edit layer geometry. Returns the snapped point in layer coordinates or undefined if not snapped.
    //  @returns {Vector2} - snap position in layer coords.
  }, { key: "_getEditLayerSnapPosition", value: function _getEditLayerSnapPosition(canvasX, canvasY, snappingFilter) {

      // Note that snapper needs a Vector3 to work.
      var point = this.layer.canvasToLayer(canvasX, canvasY, this.tmpVec);

      // compute snap radius in layer coords
      var radius = this.layerSnapper.detectRadiusInPixels * this.layer.getUnitsPerPixel();

      // create bbox centered at the point and expanded by snapRadius in each direction
      this.snapBox.min.set(point.x - radius, point.y - radius);
      this.snapBox.max.set(point.x + radius, point.y + radius);

      // Build dictionary of dbIds of all shapes intersecting the snapBox
      var dbIds = {};
      this.layer.enumShapes(this.snapBox, function (shape) {
        // Collect dbId - unless shape is excluded from snapping
        if (!snappingFilter || snappingFilter(shape)) {
          dbIds[shape.id] = true;
        }
      });

      // Collect all triangulated meshes intersecting the snapBox
      var meshes = [];
      this.layer.enumMeshes(this.snapBox, function (mesh) {return meshes.push(mesh);});

      // Only consider edges/arcs/vertices within snapRadius
      var filter = function filter(dbId) {return Boolean(dbIds[dbId]);};

      // Run snapper on the given meshes/dbIds. Note that we run snapping in layer coords.
      this.layerSnapper.clearSnapped();
      this.layerSnapper.snapping2DOverlay(point, meshes, filter, radius);

      // Stop here if nothing was snapped
      if (!this.layerSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position in layer-coords
      var res = this.layerSnapper.getSnapResult();
      var snapPos = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer);

      // snapPos points to a vector inside snapResult. SnapResult will finally be converted to 
      // LMV world coords to make SnapperIndicator work. So, we copy it to a 2D vector first.
      snapPos = new THREE.Vector2().copy(snapPos);

      // SnapperIndicator requires world-coords in getSnapResult() to display correctly. 
      // Since we computed snapping in layer-coords, we finally convert it to LMV world coords.
      res.applyMatrix4(this.layer.layerToWorld);

      // Return snap position in layer coords
      return snapPos;
    }

    // Snaps to sheet geometry. Returns the snapped point in layer coordinates or undefined if not snapped.
  }, { key: "_getSheetSnapPosition", value: function _getSheetSnapPosition(canvasX, canvasY) {var _this = this;

      // Make sure that SegmentTree exists for all visible 2D models
      this.initSegmentTrees();

      var viewerImpl = this.viewer.impl;
      // Callback to enum segments of all visible models
      var enumSegments = function enumSegments() {for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
        var models = viewerImpl.get2DModels();
        models.forEach(function (model) {
          // NOTE: SegmentTree may not be available yet if a model is still loading.
          //       In this case, we exclude it from snapping until loading is done.
          if (model.segmentTree) {var _model$segmentTree;
            (_model$segmentTree = model.segmentTree).enumSegments.apply(_model$segmentTree, args);
          }
        });
      };

      var intersect2DModels = function intersect2DModels(canvasX, canvasY) {
        var models = viewerImpl.get2DModels();
        if (!models.length) {
          return;
        }

        var vpVec = viewerImpl.clientToViewport(canvasX, canvasY);
        viewerImpl.viewportToRay(vpVec, _this.ray);
        _this.raycaster.set(_this.ray.origin, _this.ray.direction);

        var results = [];
        models.forEach(function (model) {
          // Since we are not passing a getDbIdAtPointFor2D function, this will be a pure geometry comparison
          // and even entities that are hidden due to cropping will be considered
          results.push(model.rayIntersect2D(_this.raycaster));
        });

        // Get the closest hit
        results.sort(function (a, b) {return a.distance - b.distance;});

        return results[0];
      };


      // Note that we cannot use layer.canvasToLayer here, because snapper needs a Vector3 to work.
      var result = intersect2DModels(canvasX, canvasY);
      if (!result) {
        return;
      }
      // We use enumSegments in order to get SNAP_INTERSECTION support, which is not provided by the default VertexBufferReader enumeration.
      this.sheetSnapper.snapping2D(result, { enumSegments: enumSegments });

      // If not snapped, just return current position
      if (!this.sheetSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position
      var res = this.sheetSnapper.getSnapResult();
      var p3D = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer); // returns Vector3

      // convert result from LMV world coords to layer coords
      // Note that we have to copy first, because p3D is a reference into the SnapResult. 
      // The SnapResult itself must remain in world coords to keep SnapperIndicator correct.
      p3D = this.tmpVec.copy(p3D).applyMatrix4(this.layer.worldToLayer);

      // Make sure that we consistently return 2D for all snapping types. Otherwise, we produce traps when using things like distanceTo()
      return new THREE.Vector2().copy(p3D);
    } }]);return Edit2DSnapper;}();


av.GlobalManagerMixin.call(Edit2DSnapper.prototype);

/***/ }),

/***/ "./extensions/Edit2D/EditLayer.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/EditLayer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditLayer; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var nextLayerId = 1;

// Radius in pixels used for hit-tests of thin lines. Hits within this distance are always considered, even if actual lineWidth is smaller.
var DefaultLineHitRadius = 10;

var av = Autodesk.Viewing;

// A layer manages a set of 2D shapes like polygons, polylines etc. for editing and display.
var EditLayer = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer - Viewer instance needed to create materials
  function EditLayer(viewer) {var _this = this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, EditLayer);

    av.EventDispatcher.prototype.apply(this);

    this.viewer = viewer;
    this.options = options;
    // Contains the triangulated geometry ready for rendering.
    this.group = new THREE.Group();
    if (options.useSceneAfter) {
      this.viewer.sceneAfter.add(this.group);
    } else {
      this.scene = new THREE.Scene();
      this.scene.add(this.group);
    }

    // @param {Shape[]}
    this.shapes = [];

    // @param {CanvasGizmoBase[]}
    this.canvasGizmos = [];

    this.id = nextLayerId++;

    // We don't use font rendering so far
    var fontEngine = null;

    // Always use client coords for drawing
    var toPageUnits = 1.0;

    // LMVCanvasContext doesn't really need a viewport - unless it's used with Pdf.js
    var dummyViewport = { width: 0, height: 0 };
    this.context = new Autodesk.Extensions.CompGeom.LmvCanvasContext(dummyViewport, toPageUnits, this._processMesh.bind(this), fontEngine);

    // When using LMVCanvasContext for PDF, this is not needed because PDF.js takes care that mozCurrentTransform exists.
    // In our case, we must make LMVCanvasContext create it.
    this.context.addContextCurrentTransform();

    this.setGlobalManager(viewer.globalManager);

    // By default, we always update on modification operations. But it can (and should) be temporarily disabled 
    // for batch operations. 
    this.autoUpdate = true;

    this.toPageUnits = toPageUnits;

    this.styleModifiers = [];

    // Update gizmo positions on camera changes
    this.onCameraChange = function () {return _this.updateCanvasGizmos();};
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onCameraChange);

    // Use custom tesselation accuracy for Bezier arcs. We use a bit finer values than PDF does right now.
    this.context.setTessParams({
      numIterations: 100,
      minSegLenFraction: 0.01 });


    // Optional transform between layer geometry and LMV world coords (default: identity)
    this.layerToWorld = new THREE.Matrix4();
    this.worldToLayer = new THREE.Matrix4();

    // Reused tmp values
    this.tmp_pWorld = new THREE.Vector3();
    this.tmp_p0 = new THREE.Vector2();
    this.tmp_p1 = new THREE.Vector2();
    this.tmp_ray = new THREE.Ray();
    this.tmp_box = new THREE.Box2();

    // For editing on planes in 3D
    this.is3d = false;
    this.plane = new THREE.Plane();
    this._updatePlane();

    // By default, viewer cutplanes also apply to EditLayers. Optional, all cutplanes can be excluded from layer geometry.
    this.enableCutplanes = true;

    // Camera used to render overlays.
    this.overlayCamera = undefined;
  }_createClass(EditLayer, [{ key: "dtor", value: function dtor()

    {
      this._clearScene();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onCameraChange);
    }

    // @param {Shape} shape
    // @returns {number} - The id of the shape. Used to access this shape later.
  }, { key: "addShape", value: function addShape(shape) {
      this.shapes.push(shape);

      this.dispatchEvent({ type: EditLayer.SHAPE_ADDED, shape: shape });

      this._onModified();
    }

    // @param {Shape[]} shapes
  }, { key: "addShapes", value: function addShapes(shapes) {var _this2 = this;
      shapes.forEach(function (s) {return _this2.addShape(s);});
    }

    // @param {Shape} shape
    // @returns {bool} true if shape was found.
  }, { key: "hasShape", value: function hasShape(shape) {
      return this.shapes.indexOf(shape) !== -1;
    }

    // Removes the given shape. 
    //  @returns {bool} true if shape was found and removed, otherwise false.
  }, { key: "removeShape", value: function removeShape(shape) {
      var index = this.shapes.indexOf(shape);
      if (index === -1) {
        return false;
      }
      this.shapes.splice(index, 1);

      this.dispatchEvent({ type: EditLayer.SHAPE_REMOVED, shape: shape });

      this._onModified();
      return true;
    }

    // @param {Shape[]} shapes
  }, { key: "removeShapes", value: function removeShapes(shapes) {var _this3 = this;
      shapes.forEach(function (s) {return _this3.removeShape(s);});
    } }, { key: "clear", value: function clear()

    {
      this.shapes.length = 0;

      this.dispatchEvent({ type: EditLayer.LAYER_CLEARED });

      this._onModified();
    }

    // Must be called after modifications to update the scene.
  }, { key: "update", value: function update() {

      // clear scene
      this._clearScene();

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // Skip hidden shapes
        if (!shape.visible) {
          continue;
        }

        // apply override style if specified
        var overrideStyle = this._getOverrideStyle(shape);

        shape.draw(this.context, overrideStyle);
      }

      // Make sure that all shapes are processed
      this.context.flushBuffer(0, true);

      // Currently, we only draw to overlay scenes. We may generalize that if we use it for planes in 3D later.
      // There's also the option to use sceneAfter (which is helpful if we need more control over the blending method)
      // so in that case invalidating only the overlay is not enough for re-rendering.
      this.viewer.impl.invalidate(this.options.useSceneAfter, false, !this.options.useSceneAfter);

      // Update CanvasGizmos, e.g., to update polygon gizmo position if a polygon changed
      this.updateCanvasGizmos();
    } }, { key: "updateCanvasGizmos", value: function updateCanvasGizmos()

    {
      for (var i = 0; i < this.canvasGizmos.length; i++) {
        this.canvasGizmos[i].update();
      }
    }

    // @param {CanvasGizmoBase} gizmo - Must implement gizmo.update() to respond to changes.
  }, { key: "addCanvasGizmo", value: function addCanvasGizmo(gizmo) {
      this.canvasGizmos.push(gizmo);
    }

    // @param {CanvasGizmoBase} gizmo
  }, { key: "removeCanvasGizmo", value: function removeCanvasGizmo(gizmo) {
      var index = this.canvasGizmos.indexOf(gizmo);
      if (index === -1) {
        return false;
      }
      this.canvasGizmos.splice(index, 1);
      return true;
    } }, { key: "getViewport", value: function getViewport()

    {
      return this.viewport;
    }

    // Returns the topmost shape containing the point (x,y)
    //  @param {number} hitRadius - Used for hit-test of thin line-features. Points within this radius around a line are considered as hits - even if the actual lineWidth is smaller.
  }, { key: "hitTest", value: function hitTest(x, y) {var hitRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultLineHitRadius;

      // process shapes backwards to find topmost first
      for (var i = this.shapes.length - 1; i >= 0; i--) {
        var shape = this.shapes[i];

        // Skip hidden shapes
        if (!shape.visible) {
          continue;
        }

        var radiusLC = this.getLineHitRadius(shape, hitRadius);

        // Compute box centered at (x,y) with given hitRadius
        var hitBox = this.tmp_box.makeEmpty();
        hitBox.min.set(x - radiusLC, y - radiusLC);
        hitBox.max.set(x + radiusLC, y + radiusLC);

        // get (latest) shape bbox
        shape.updateBBox();

        // Skip if shape bounds and hitBounds don't intersect
        if (!shape.bbox.isIntersectionBox(hitBox)) {
          continue;
        }

        if (shape.hitTest(x, y, radiusLC)) {
          return shape;
        }
      }
    }

    // Used for line-feature hit tests: 
    // We consider a point p to be "on edge e" if p is within a certain radius around e.
    // This radius depends on style and a certain min-distance in pixels used for thin lines. Result is in layer-coords.
  }, { key: "getLineHitRadius", value: function getLineHitRadius(shape) {var hitRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultLineHitRadius;

      var unitsPerPixel = this.getUnitsPerPixel();

      // Get line-width in layer coords
      var lineWidth = (shape.style.isScreenSpace ? unitsPerPixel : 1) * shape.style.lineWidth;

      // For thin lines, consider hits as long as they are within minPixels radius
      return Math.max(lineWidth, hitRadius * unitsPerPixel);
    }

    // Optional: Sets a callback to override the style for either all or a subset of shapes.
    //  @param {function(Shape, Style)} modifier - A callback that takes a shape as input and returns undefined (=no change) or a valid override style object.
  }, { key: "addStyleModifier", value: function addStyleModifier(modifier) {
      this.styleModifiers.push(modifier);
      this._onModified();
    } }, { key: "removeStyleModifier", value: function removeStyleModifier(

    modifier) {
      var index = this.styleModifiers.indexOf(modifier);
      if (index == -1) {
        return false;
      }
      this.styleModifiers.splice(index, 1);
      this._onModified();
      return true;
    }

    // Convert layer coordinates to canvas coords.
    //  @param {Vector2|Vector3} [target]
  }, { key: "layerToCanvas", value: function layerToCanvas(x, y) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();

      // get point in LMV world coords
      var pWorld = this.tmp_pWorld.set(x, y, 0).applyMatrix4(this.layerToWorld);

      // For now, worldCoords.xy is identical with layer coords. This will change once we extend it to planes that can be embedded into 3D.
      var res = this.viewer.impl.worldToClient(pWorld, this.overlayCamera);
      return target.set(res.x, res.y, 0.0); // Set z to 0 if target is Vector3. Otherwise, the param has no effect
    }

    // Note: This function currently assumes a uniform unitPerPixel ratio. This may change if we add support for projected
    //       planes in 3D, where pixelRatio may vary across the layer and may require different values in x/y direction.
  }, { key: "getPixelsPerUnit", value: function getPixelsPerUnit() {
      var _window = this.getWindow();

      // get screen projections of two points in layer-coords that have unit-distance
      var p0 = this.layerToCanvas(0, 0, this.tmp_p0);
      var p1 = this.layerToCanvas(1, 0, this.tmp_p1);
      return p0.distanceTo(p1) / _window.devicePixelRatio;
    } }, { key: "getUnitsPerPixel", value: function getUnitsPerPixel()

    {
      return 1.0 / this.getPixelsPerUnit();
    }

    // Convert canvas coordinates (from input events) to layer viewport coordinates
    //  @param {Vector2|Vector3} [target]
  }, { key: "canvasToLayer", value: function canvasToLayer(canvasX, canvasY)
    {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      // Compute "ray through pixel" in world-coords.
      var vpVec = this.viewer.impl.clientToViewport(canvasX, canvasY);
      var ray = this.viewer.impl.viewportToRay(vpVec, this.tmp_ray, this.overlayCamera);

      // Intersect ray with plane that we edit on
      var intersect = ray.intersectPlane(this.plane, this.tmp_pWorld);

      if (!intersect) {
        // TODO: For 3D scenarios, we must properly support the case that canvasToLayer fails.
        return target.set(0, 0);
      }

      // Convert from world to layer coords
      intersect.applyMatrix4(this.worldToLayer);

      // Set 3rd-component to 0 for Vector3 targets. For 2D, the z param is ignored
      return target.set(intersect.x, intersect.y, 0);
    }

    // Runs the callback for all shapes in the layer that overlap the given bbox
    //  @param {Box2} bbox
    //  @param {function(Shape)} cb
  }, { key: "enumShapes", value: function enumShapes(bbox, cb) {
      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // Make sure that bbox is up-to-date
        shape.updateBBox();

        if (bbox.isIntersectionBox(shape.bbox)) {
          cb(shape);
        }
      }
    }

    // Runs the callback for all triangulated 2D meshes created in the last update() call.
  }, { key: "enumMeshes", value: function enumMeshes(bbox, cb) {
      for (var i = 0; i < this.group.children.length; i++) {
        var mesh = this.group.children[i];
        var meshBox = mesh.geometry.boundingBox;

        // Note: The worldMatrix is not used for triangulated Edit2D meshes, so it will always be identity. Otherwise,
        //       we would need to compute a world-box using applyMatrixWorld() here.

        // Note that meshes have a 3D box, but we are only interested in 2D check. Therefore,
        // it's important to call intersectsBox on the input box and not on the mesh.
        if (bbox.isIntersectionBox(meshBox)) {
          cb(mesh);
        }
      }
    } }, { key: "findShapeById", value: function findShapeById(

    id) {
      return this.shapes.find(function (s) {return s.id == id;});
    } }, { key: "setMatrix", value: function setMatrix(

    layerToWorld) {
      this.layerToWorld.copy(layerToWorld);
      this.worldToLayer.getInverse(layerToWorld);

      // Update projection plane
      this._updatePlane();
    }

    // By default, the viewer cutplanes are applied to EditLayers as well. This can be used, e.g., to crop them.
    //  @param {bool} enabled - If false, cutplanes are ignored for all layer geometry. 
  }, { key: "setCutPlanesEnabled", value: function setCutPlanesEnabled() {var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      if (enabled != this.enableCutplanes) {
        this.enableCutplanes = enabled;
        this.update();
      }
    }

    // 
    // --- Internal functions ---
    //

    // process meshData produced by LmvCanvasContext
  }, { key: "_processMesh", value: function _processMesh(meshData) {

      // create GeometryBuffer
      var mdata = { mesh: meshData, is2d: true, packId: "0", meshIndex: 0 };
      Autodesk.Viewing.Private.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      // create 2D material
      // Note that it is essential not to associate the material witha model. Otherwise,
      // the EditShapes will disappear if model layer 0 is switched off.
      var matman = this.viewer.impl.getMaterials();
      var matName = matman.create2DMaterial(null, meshData.material);
      var material = matman.findMaterial(null, matName);

      // Optional: Ignore cutplanes
      if (!this.enableCutplanes) {
        // Do not apply any cutplanes to the geometry
        material.cutplanes = undefined;
        material.doNotCut = true;
      }

      var mesh = new THREE.Mesh(geom, material);

      // Set mesh matrix
      mesh.matrix = this.layerToWorld;
      mesh.matrixAutoUpdate = false; // make sure matrix is not overwritten within updateMatrixWorld() later

      this.group.children.push(mesh);
    } }, { key: "_onModified", value: function _onModified()

    {
      if (this.autoUpdate) {
        this.update();
      }
    }

    // Apply one or more style modifiers
  }, { key: "_getOverrideStyle", value: function _getOverrideStyle(shape) {
      var style = shape.style;
      for (var i = 0; i < this.styleModifiers.length; i++) {
        var mod = this.styleModifiers[i];
        style = mod(shape, style) || style;
      }
      return style;
    }

    // Dispose all shapes generated by this layer.
  }, { key: "_clearScene", value: function _clearScene() {

      // Dispose any GPU resources for previous output geometry
      // Note that we construct the scene as a flat list of meshes (see _processMesh). So, we don't need a generic traversal here.
      var meshes = this.group.children;
      for (var i = 0; i < meshes.length; i++) {
        var mesh = meshes[i];
        mesh.geometry.dispose();

        // TODO: We have to take care to dispose materials here as well. However, just disposing materials here as well would produce a couple of issues:
        //
        //  1. MaterialManager caches materials based on properties. So, we cannot safely assume that the materials are solely used by ourselves.
        //     => MaterialManager currently only allows models to own 2D materials. We have to generalize it to support "ownerIDs" so
        //        that we can ensure that the materials are owned by this layer.
        //  2. Recompiling shaders on each update would be a waste. So we will need some caching.
      }
      this.group.children.length = 0;
    }

    // Only needed for 3D scenes
  }, { key: "_updatePlane", value: function _updatePlane() {
      // The layer geometry itself is in the {z=0} plane
      this.plane.normal.set(0, 0, 1);
      this.plane.constant = 0.0;

      // Transform plane to world-coords
      this.plane.applyMatrix4(this.layerToWorld);
    }

    // Used for projecting / unprojecting overlay elements. 
  }, { key: "setOverlayCamera", value: function setOverlayCamera(camera) {
      this.overlayCamera = camera;
    } }]);return EditLayer;}();


av.GlobalManagerMixin.call(EditLayer.prototype);

EditLayer.SHAPE_ADDED = 'shapeAdded';
EditLayer.SHAPE_REMOVED = 'shapeRemoved';
EditLayer.LAYER_CLEARED = 'layerCleared';

/***/ }),

/***/ "./extensions/Edit2D/EditShapes.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/EditShapes.js ***!
  \*****************************************/
/*! exports provided: Style, Shape, LoopType, PolyBase, PolyIndex, Polygon, Polyline, EdgeType, runPath, EllipseArcParams, Path, PolygonPath, PolylinePath, Circle, ShapeWrapper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Style", function() { return Style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopType", function() { return LoopType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyBase", function() { return PolyBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyIndex", function() { return PolyIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeType", function() { return EdgeType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runPath", function() { return runPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcParams", function() { return EllipseArcParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonPath", function() { return PolygonPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolylinePath", function() { return PolylinePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeWrapper", function() { return ShapeWrapper; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Svg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Svg.js */ "./extensions/Edit2D/Svg.js");
/* harmony import */ var _LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoopContainment.js */ "./extensions/Edit2D/LoopContainment.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}




var nextShapeId = 1;

var av = Autodesk.Viewing;

var toColor = function toColor(r, g, b) {
  return "rgb(" + r + "," + g + "," + b + ")";
};

var cloneVectorArray = function cloneVectorArray(src) {
  return src.map(function (p) {return { x: p.x, y: p.y };});
};

// Default arc tessellation params that we use for area computations. (see Bezier.js)
// We use smaller min segment length than for drawing, because the DefaultTessParams would cause too inaccurate measurements.
// TODO: Replace by more accurate and faster analytic computation to replace brute-force tesselation completely.
var AreaTessParam = {
  numIterations: 100,
  minSegLenFraction: 0.01 };


var tmpVec3 = new THREE.Vector3();
var tmpVec3_2 = new THREE.Vector3();
var tmpBox2 = new THREE.Box2();
var tmpVec2 = new THREE.Vector2();

var Style = /*#__PURE__*/function () {

  /**
                                              * Creates a new Style for the Edit 2D tools.
                                              * @param {object} [params]           - various style values to overwrite the default style.
                                              * @param {string} [params.color]     - sets the color for the line and fill area
                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area
                                              * @param {string} [params.lineColor] - sets the color for the line
                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line
                                              * @param {number} [params.lineWidth] - sets the line width for the line.
                                              * @param {number} [params.lineStyle] - sets the style of the line
                                              * @param {string} [params.fillColor] - sets the color for the fill area
                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area
                                              */
  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);
    this.lineColor = params.lineColor || params.color || "rgb(0,0,128)";
    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;
    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;

    this.fillColor = params.fillColor || params.color || "rgb(0,0,128)";
    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;

    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.
    // Examples:
    //   0:  Solid line:    ______________
    //   10: Dashes long:   __ __ __ __ __
    //   11: Dashes short:  _ _ _ _ _ _ _
    //   12: Dashes longer: ___ ___ ___ ___
    //   16: Dots:          . . . . . . .
    //   17: Dots dense:    ..............
    //   18: Dots sparse:   .  .  .  .  .
    this.lineStyle = params.lineStyle || 0;

    // By default, we interpret line widths in screen-space
    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;
    this.compositeOperation = 'source-over';
  }

  // Components r,b,g are in [0,255]
  _createClass(Style, [{ key: "setFillColor", value: function setFillColor(r, g, b) {
      this.fillColor = toColor(r, g, b);
    } }, { key: "setLineColor", value: function setLineColor(

    r, g, b) {
      this.lineColor = toColor(r, g, b);
    } }, { key: "clone", value: function clone()

    {
      return new Style().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.lineColor = from.lineColor;
      this.lineAlpha = from.lineAlpha;
      this.lineWidth = from.lineWidth;
      this.fillColor = from.fillColor;
      this.fillAlpha = from.fillAlpha;
      this.lineStyle = from.lineStyle;
      this.isScreenSpace = from.isScreenSpace;
      this.compositeOperation = from.compositeOperation;
      return this;
    } }]);return Style;}();


Style.toColor = toColor;

var DefaultStyle = new Style();

// Add all points to given bbox.
var addPointsToBBox = function addPointsToBBox(points, dstBox) {
  for (var i = 0; i < points.length; i++) {
    dstBox.expandByPoint(points[i]);
  }
};

var Shape = /*#__PURE__*/function (_av$EventDispatcher) {_inherits(Shape, _av$EventDispatcher);var _super = _createSuper(Shape);
  function Shape() {var _this;var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultStyle.clone();_classCallCheck(this, Shape);
    _this = _super.call(this);

    _this.style = style;

    // assign unique id
    _this.id = nextShapeId++;

    _this.bbox = new THREE.Box2();
    _this.bboxDirty = true;

    // If false, it is skipped by EditLayer traversals
    _this.visible = true;

    // Should be set by creator by something more descriptive.
    _this.name = _this.id.toString();return _this;
  }

  // Must be provided by derivaties
  _createClass(Shape, [{ key: "draw", value: function draw() /*ctx, overrideStyle*/{} }, { key: "hitTest", value: function hitTest()
    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.
  }, { key: "move", value: function move()
    /*dx, dy*/{return this;}

    // Apply a transform to each point. (assuming z=0)
    // @param {Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {return this;} }, { key: "clone", value: function clone()

    {
      return new Shape().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.style = from.style.clone();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      console.error("Must be implemented by derived class.");
    } }, { key: "modified", value: function modified()

    {
      this.bboxDirty = true;
      this.fireEvent({ type: Shape.Events.MODIFIED });
    } }, { key: "updateBBox", value: function updateBBox()

    {
      if (this.bboxDirty) {
        this.computeBBox();
        this.bboxDirty = false;
      }
    }

    // Return bbox while making sure that it's up-to-date.
  }, { key: "getBBox", value: function getBBox() {
      this.updateBBox();
      return this.bbox;
    }

    // @param {string}  svg - e.g. '<path d="M 13,4 L 14,4"/>'
  }, { key: "toSVG",



    // Convert to SVG style string, e.g., '<path d="M 13,4 L 14,4"/>'
    // See Svg.toSvg() comment for options.
    //
    // Note: The digits param is deprecated and only exists for legacy reasons. 
    //       Set digits via options.digits instead.
    value: function toSVG(options, digits) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvg(this, options, digits);
    }

    // Converts shape into a DOM element (usually a <path>).
    //  @param {Object} 
    //  @param {bool}   [options.exportStyle=true]
  }, { key: "createSvgShape", value: function createSvgShape(options) {
      return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].toSvgElement(this, options);
    } }, { key: "setVisible", value: function setVisible(

    visible) {
      this.visible = visible;
    } }], [{ key: "fromSVG", value: function fromSVG(svg) {return _Svg_js__WEBPACK_IMPORTED_MODULE_1__["Svg"].fromSvg(svg);} }]);return Shape;}(av.EventDispatcher);


Shape.Events = {
  MODIFIED: 'modified' };


av.GlobalManagerMixin.call(Shape.prototype);

var LoopType = {
  Empty: 0, // Loop is empty or does not exist
  Inner: 1,
  Outer: 2,
  Overlapping: 3 // Loop is intersecting itself or other loops
};

// Common base class for Polygons and Polylines
var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);var _super2 = _createSuper(PolyBase);

  function PolyBase() {var _this2;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);
    _this2 = _super2.call(this, style);

    // Array of Array of points, each represented as an object {x, y}
    // By default, we start with a single loop/chain
    _this2._loops = points ? [points] : [];

    // Set by derived classes
    _this2.isClosed = undefined;

    // Computed on-demand: Provides extra information about how loops are nested.
    _this2._loopInfos = null;return _this2;
  }

  // For backward compatibility
  _createClass(PolyBase, [{ key: "allocPoints",








    // acquire a number of additional points in the given loop. Each has initial coords (0,0)
    value: function allocPoints(numPoints) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      for (var i = 0; i < numPoints; ++i) {
        this.addPoint(0, 0, loopIndex);
      }
      return this;
    } }, { key: "isPolygon", value: function isPolygon()

    {return this.isClosed;} }, { key: "isPolyline", value: function isPolyline()
    {return !this.isClosed;} }, { key: "isPath", value: function isPath()

    {
      return this instanceof Path;
    } }, { key: "addPoint", value: function addPoint(

    x, y) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      // get or create loop
      var loop = this._loops[loopIndex] || (this._loops[loopIndex] = []);

      // add point to loop
      var point = { x: x, y: y };
      loop.push(point);
      this.modified();
      return point;
    } }, { key: "getPoint", value: function getPoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();

      // Legacy fallback (deprecated): This can be removed as soon as no code
      // is passing a target vector without a loop index
      if (_typeof(loopIndex) === 'object') {
        target = loopIndex;
        loopIndex = 0;
      }

      return target.copy(this._loops[loopIndex][index]);
    } }, { key: "removePoint", value: function removePoint(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this._loops[loopIndex].splice(index, 1);
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var p = this._loops[loopIndex][index];
      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this._loops[loopIndex].splice(index, 0, p);
    } }, { key: "getVertexCount",











    // Returns 0 if a loop is empty or does not exist.
    value: function getVertexCount() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // Array may not exist yet if no vertices were added to the loop yet.
      var loop = this._loops[loopIndex];
      return loop ? loop.length : 0;
    }

    // Reset back to a single empty loop
  }, { key: "clear", value: function clear() {
      this._loops = [];
      this.modified();
    }

    // Enumerate all edges (a,b).
    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.
    //                                       If cb() returns true, the traversal stops.
  }, { key: "enumEdges", value: function enumEdges(cb) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      // get edge count
      var edgeCount = this.getEdgeCount(loopIndex);

      // check for each edge whether p is close to it.
      for (var i = 0; i < edgeCount; i++) {
        // get indices
        var ai = i;
        var bi = this.nextIndex(i, loopIndex);

        // get points
        var a = this.getPoint(ai, loopIndex);
        var b = this.getPoint(bi, loopIndex);

        // pass all to cb
        var stop = cb(a, b, ai, bi);

        // allow early out
        if (stop) {
          return;
        }
      }
    }

    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.
    // If so, it returns the index of that edge, otherwise -1.
    // All values are in layer coords.
  }, { key: "findEdgeIndex", value: function findEdgeIndex(p, precision) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var edgeIndex = -1;

      // Callback to find edge containing p
      var findEdgeCb = function findEdgeCb(a, b, ai) {

        // If edge contains p, store its edge index
        var containsP = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].isPointOnEdge(p, a, b, precision);
        if (containsP) {
          edgeIndex = ai;
        }

        // Stop on success
        return containsP;
      };
      this.enumEdges(findEdgeCb, loopIndex);
      return edgeIndex;
    } }, { key: "moveLoop", value: function moveLoop(

    dx, dy, loopIndex) {
      var points = this._loops[loopIndex];
      for (var i = 0; i < points.length; i++) {
        points[i].x += dx;
        points[i].y += dy;
      }
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      for (var l = 0; l < this.loopCount; l++) {
        this.moveLoop(dx, dy, l);
      }
      return this;
    }

    // Note: Ellipse arcs only support simple transforms (translation, rotation, uniform scaling)
    // @param {THREE.Matrix4}
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      for (var l = 0; l < this.loopCount; l++) {
        var points = this._loops[l];

        for (var i = 0; i < points.length; i++) {
          var p = points[i];

          // set target to (x,y) * matrix
          var transformPoint = function transformPoint(x, y, target) {
            // convert to vec3, transform, and write back to target
            var vec3 = tmpVec3.set(x, y, 0).applyMatrix4(matrix);
            target.x = vec3.x;
            target.y = vec3.y;
            return target;
          };

          transformPoint(p.x, p.y, p);

          // transform Bezier control points
          if (this.isBezierArc(i, l)) {
            var cp = transformPoint(p.cp1x, p.cp1y, tmpVec3);
            p.cp1x = cp.x;
            p.cp1y = cp.y;

            cp = transformPoint(p.cp2x, p.cp2y, tmpVec3);
            p.cp2x = cp.x;
            p.cp2y = cp.y;
          }

          // Transform ellipse arcs
          // Note: Currently, this only works for simple transforms (translate, rotate, uniform scale)
          if (this.isEllipseArc(i, l)) {
            p.ellipseArcParams.applyMatrix4(matrix);
          }
        }
      }
      this.modified();
      return this;
    }

    // Copy a single loop from src poly and adds it to this one
    //  @param {PolyBase} srcPoly
    //  @param {number}   srcLoopIndex - must be a valid loopIndex of src
    //  @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.
  }, { key: "addLoop", value: function addLoop(srcPoly) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      // copy loop points
      var srcLoop = srcPoly._loops[srcLoopIndex];
      var newLoop = cloneVectorArray(srcLoop);

      // insert new loop
      var newIndex;
      if (dstLoopIndex === -1) {
        // find a free loop index to store the new loop
        newIndex = this.nextFreeLoop();
        this._loops[newIndex] = newLoop;
      } else {
        // insert new loop at given index
        newIndex = dstLoopIndex;
        this._loops.splice(newIndex, 0, newLoop);
      }
      this.modified();

      return newIndex;
    }

    // Removes any empty loops, so that any loop i for 0<i<this.loopCount contains points.
  }, { key: "cleanupLoops", value: function cleanupLoops() {
      this._loops = this._loops.filter(function (l) {return l && l.length > 0;});
      this.modified();
    } }, { key: "copyGeometry", value: function copyGeometry(

    srcPoly) {
      this.isClosed = srcPoly.isClosed;

      // copy loops
      this._loops = [];
      for (var i = 0; i < srcPoly.loopCount; i++) {
        this.addLoop(srcPoly, i);
      }
      return this;
    } }, { key: "copy", value: function copy(

    srcPoly) {
      _get(_getPrototypeOf(PolyBase.prototype), "copy", this).call(this, srcPoly);
      return this.copyGeometry(srcPoly);
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.makeEmpty();
      for (var i = 0; i < this.loopCount; i++) {
        var loop = this._loops[i];
        if (loop) {
          addPointsToBBox(loop, this.bbox);
        }
      }
      return this.bbox;
    } }, { key: "indexValid", value: function indexValid(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return index >= 0 && index < this.getVertexCount(loopIndex);
    }

    // Returns -1 if there is no next Index    
  }, { key: "nextIndex", value: function nextIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle last vertex
      var isLast = index === this.getVertexCount(loopIndex) - 1;
      if (isLast) {
        // If closed, restart. Otherwise, there is no next index.
        return this.isClosed ? 0 : -1;
      }

      return index + 1;
    }

    // Returns -1 if there is no previous vertex index
  }, { key: "prevIndex", value: function prevIndex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Return -1 for invalid input
      if (!this.indexValid(index, loopIndex)) {
        return -1;
      }

      // Handle first vertex
      if (index === 0) {
        // if closed, continue at end. Otherwise, there is no previous index.
        var vertexCount = this.getVertexCount(loopIndex);
        return this.isClosed ? vertexCount - 1 : -1;
      }

      return index - 1;
    }

    // Returns index of the edge ending at the given vertex or -1 if it does not exist.
  }, { key: "edgeBeforeVertex", value: function edgeBeforeVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.prevIndex(index, loopIndex);
    }

    // Returns index of the edge starting at the given vertex.
    // Returns -1 if index is the end vertex of a polyline.
  }, { key: "edgeAfterVertex", value: function edgeAfterVertex(index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(index, loopIndex) ? index : -1;
    }

    // Returns -1 if there is no previous edge.
  }, { key: "nextEdgeIndex", value: function nextEdgeIndex(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Check edgeIndex validity
      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {
        return -1;
      }

      // Return -1 for last polyline edge
      if (!this.isClosed && edgeIndex === this.getEdgeCount(loopIndex) - 1) {
        return -1;
      }

      return this.nextIndex(edgeIndex, loopIndex);
    } }, { key: "prevEdgeIndex", value: function prevEdgeIndex(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Check edgeindex validity
      if (!this.edgeIndexValid(edgeIndex, loopIndex)) {
        return -1;
      }

      // Return -1 for first polyline edge
      if (!this.isClosed && edgeIndex === 0) {
        return -1;
      }

      return this.prevIndex(edgeIndex, loopIndex);
    } }, { key: "edgeIndexValid", value: function edgeIndexValid(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var edgeCount = this.getEdgeCount(loopIndex);
      return edgeIndex >= 0 && edgeIndex < edgeCount;
    } }, { key: "prevEdgeExists", value: function prevEdgeExists(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (edgeIndex > 0 || this.isClosed);
    } }, { key: "nextEdgeExists", value: function nextEdgeExists(

    index) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      var isLastEdge = edgeIndex === vertexCount - 2;
      return this.edgeIndexValid(edgeIndex, loopIndex) && vertexCount > 2 && (!isLastEdge || this.isClosed);
    }

    // Copy start/end of an edge into outA, outB out params (Vector2).
    // edgeIndex must be valid.
  }, { key: "getEdge", value: function getEdge(edgeIndex, outA, outB) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      this.getPoint(ia, loopIndex, outA);
      this.getPoint(ib, loopIndex, outB);
    } }, { key: "getEdgeDirection", value: function getEdgeDirection(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      var loop = this._loops[loopIndex];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(loop[ia], loop[ib], target);
    } }, { key: "getEdgeLength", value: function getEdgeLength(

    edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex, loopIndex);
      var loop = this._loops[loopIndex];
      var a = loop[ia];
      var b = loop[ib];
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeLength(a, b);
    } }, { key: "getEdgeCount", value: function getEdgeCount()

    {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var vertexCount = this.getVertexCount(loopIndex);
      return this.isClosed ? vertexCount : vertexCount - 1;
    }

    // Return the summed edge length for Polygons and Polylines.
    //
    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getLength", value: function getLength(measureTransform) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      var sum = 0.0;
      for (var i = 0; i < this.getEdgeCount(loopIndex); i++) {
        this.getEdge(i, a, b, loopIndex);

        // apply optional measure transform
        if (measureTransform) {
          measureTransform.apply(a);
          measureTransform.apply(b);
        }

        sum += a.distanceTo(b);
      }
      return sum;
    }

    // Set vertices from THREE.Box2
  }, { key: "fromBox2", value: function fromBox2(box) {
      this.addPoint(box.min.x, box.min.y);
      this.addPoint(box.max.x, box.min.y);
      this.addPoint(box.max.x, box.max.y);
      this.addPoint(box.min.x, box.max.y);
      return this;
    }

    // Returns a point along an edge. Note that the edge may be an arc for Paths.
    //  @param {number} edgeIndex   - A valid edgeIndex
    //  @param {number} t           - in [0,1]. t=0: startPoint, t=1: endPoint
    //  @param {number} [loopIndex]
    //  @param {Vector2} [target]  
  }, { key: "getPointOnEdge", value: function getPointOnEdge(edgeIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();

      var loop = this._loops[loopIndex];
      var p0 = loop[edgeIndex];
      var p1 = loop[this.nextIndex(edgeIndex, loopIndex)];
      return target.lerpVectors(p0, p1, t);
    }

    // Checks if outer loop is counterclockwise. For polylines that doesn't form a loop, 
    // we assume an additional edge from end to start.
    // @returns {bool}
  }, { key: "isCCW", value: function isCCW() {var loopIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      return Autodesk.Extensions.CompGeom.polygonArea(this._loops[loopIndex]) > 0;
    }

    // Return 2D edge normal
  }, { key: "getLeftEdgeNormal", value: function getLeftEdgeNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();

      var points = this._loops[loopIndex];

      // get start/end point of the edge
      var vi1 = edgeIndex;
      var vi2 = (edgeIndex + 1) % points.length;
      var v1 = points[vi1];
      var v2 = points[vi2];

      // get edge direction
      target.subVectors(v2, v1).normalize();

      // rotate by 90 degrees
      var tmp = target.x;
      target.x = -target.y;
      target.y = tmp;

      return target;
    }

    // Get edge normal facing outside wrt. to the loop containing the edge. If the contour is not closed, we
    // assume an additional connection between endpoint and startpoint to defined "outside".
  }, { key: "getOuterNormal", value: function getOuterNormal(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new THREE.Vector2();
      var normal = this.getLeftEdgeNormal(edgeIndex, loopIndex, target);
      return this.isCCW(loopIndex) ? normal.multiplyScalar(-1) : normal;
    }

    // Returns the first loopIndex >=0 that doesn't contain any points yet.
    //  @param {number}
  }, { key: "nextFreeLoop", value: function nextFreeLoop() {
      var isFree = function isFree(l) {return !l || !l.length;};
      var index = this._loops.findIndex(isFree);
      return index >= 0 ? index : this.loopCount;
    }

    // Seaches all loops to find a vertex for which cb(vertexIndex, loopIndex) returns true.    
    //  @{function(vertexIndex, loopIndex)=>bool} searchFilter   
    //  @returns {Object|null}                    A {vertexIndex, loopIndex} pair on success. Otherwise null.
  }, { key: "findVertex", value: function findVertex(searchFilter) {
      for (var l = 0; l < this.loopCount; l++) {
        var len = this.getVertexCount(l);
        for (var i = 0; i < len; i++) {
          if (searchFilter(i, l)) {
            return {
              vertexIndex: i,
              loopIndex: l };

          }
        }
      }
      return null;
    }

    // Returns true if poly does not contain any (non-empty loops)
  }, { key: "empty", value: function empty() {
      return !this._loops.some(function (loop) {return loop && loop.length > 0;});
    } }, { key: "modified", value: function modified()

    {
      _get(_getPrototypeOf(PolyBase.prototype), "modified", this).call(this);

      // Loop containment may have changed
      this._loopInfos = null;
    }

    // Returns true if the shape has overlapping loops
  }, { key: "isSelfIntersecting", value: function isSelfIntersecting() {

      // Todo: Currently, we only detect overlaps between different loops. We also
      //       have to track self-intersections within a single loop.


      // Check if we have multiple overlapping loops
      var loopInfos = this._getLoopInfos();
      return loopInfos && loopInfos.some(function (l) {return l.error;});
    } }, { key: "_getLoopInfos", value: function _getLoopInfos()

    {
      // Loop infos are only needed for closed paths with 2 or more loops
      if (!this.isClosed || this.loopCount < 1) {
        return undefined;
      }

      // Reuse if already available
      if (!this._loopInfos) {
        this._loopInfos = Object(_LoopContainment_js__WEBPACK_IMPORTED_MODULE_2__["computeLoopContainment"])(this);
      }
      return this._loopInfos;
    }

    // Only works for closed loops.
  }, { key: "getLoopType", value: function getLoopType(loopIndex) {

      if (!this.isClosed) {
        return undefined;
      }

      if (!this.getVertexCount(loopIndex)) {
        return LoopType.Empty;
      }

      // LoopInfo should always exist for closed non-empty loops
      var infos = this._getLoopInfos();
      var info = infos[loopIndex];

      if (info.error) {
        return LoopType.Overlapping;
      }

      // Even-odd-rule: Loops with even rank are outer ones.
      return info.rank & 1 ? LoopType.Inner : LoopType.Outer;
    }

    // Get all loops (directly or indirectly) enclosed by the given one
  }, { key: "getChildLoops", value: function getChildLoops(loopIndex) {
      var infos = this._getLoopInfos();
      var info = infos && infos[loopIndex];
      return info ? info.containedLoops.slice() : [];
    }

    // Eliminiate all empty loops, so that loopCount matches the number of non-empty loops
  }, { key: "cleanupLoops", value: function cleanupLoops() {
      this._loops = this._loops.filter(function (l) {return l && l.length >= 0;});
    }

    // Returns all loops that are not enclosed by any other one. Only for closed shapes.
  }, { key: "getMainLoops", value: function getMainLoops() {
      var infos = this._getLoopInfos();
      if (!infos) {
        return [];
      }

      // Collect all rank-0 loops
      var loops = [];
      for (var i = 0; i < infos.length; i++) {
        var info = infos[i];

        // Skip empty or invalid loops
        var type = this.getLoopType(i);
        if (type !== LoopType.Outer) {
          continue;
        }

        if (info.rank === 0) {
          loops.push(i);
        }
      }
      return loops;
    }

    // Remove loop. Remaining loop indices are shifted back by one 
  }, { key: "removeLoop", value: function removeLoop(loopIndex) {
      this._loops.splice(loopIndex, 1);
      this.modified();
      return this;
    }

    // Remove multiple loop indices
    // @param {number[]}  
  }, { key: "removeLoops", value: function removeLoops(loops) {
      this._loops = this._loops.filter(function (l, i) {return !loops.includes(i);});
    }

    // Returns true if a point contains valid (i.e. finite) numbers.
  }, { key: "isPointFinite", value: function isPointFinite(vertex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (!this.indexValid(vertex, loopIndex)) {
        return false;
      }

      var points = this._loops[loopIndex];
      var p = points[vertex];
      return isFinite(p.x) && isFinite(p.y);
    } }, { key: "isLoopFinite", value: function isLoopFinite(

    loopIndex) {
      var points = this._loops[loopIndex];
      var count = points ? points.length : 0;
      for (var i = 0; i < count; i++) {
        if (!this.isPointFinite(i, loopIndex)) {
          return false;
        }
      }
      return true;
    } }, { key: "points", get: function get() {// Create empty loop 0 if needed
      return this._loops[0] || (this._loops[0] = []);} }, { key: "loopCount", get: function get() {return this._loops.length;} }, { key: "length", get: function get() {console.warn('poly.length is deprecated and will be removed. Please use poly.vertexCount property instead.');return this.points.length;} // for backwards compatibility
  }, { key: "vertexCount", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);
// Helper class to address a single vertex within a loop of a PolyBase.
// Can also be used to address edges (by indexing its start vertex).
var PolyIndex = /*#__PURE__*/function () {
  function PolyIndex(_ref) {var _ref$vertex = _ref.vertex,vertex = _ref$vertex === void 0 ? 0 : _ref$vertex,_ref$loop = _ref.loop,loop = _ref$loop === void 0 ? 0 : _ref$loop;_classCallCheck(this, PolyIndex);
    this.vertex = vertex;
    this.loop = loop;
  }_createClass(PolyIndex, [{ key: "equals", value: function equals(
    v) {
      return v && this.vertex === v.vertex && this.loop === v.loop;
    } }]);return PolyIndex;}();


var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);var _super3 = _createSuper(Polygon);

  function Polygon() {var _this3;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);
    _this3 = _super3.call(this, points, style);
    _this3.isClosed = true;return _this3;
  }

  // Draw Polygon into LmvCanvasContext
  _createClass(Polygon, [{ key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // We use even-odd rule if a polygon has multiple loops: A point is considered inside if it
    // is enclosed by an odd number of loops.
  }, { key: "hitTest", value: function hitTest(x, y) {
      if (!this.vertexCount) {
        return false;
      }

      // Compute number of loops that enclose (x,y)
      var rank = 0;
      for (var l = 0; l < this.loopCount; l++) {
        var loop = this._loops[l];
        if (!loop) {
          continue;
        }

        // set current loop as points
        var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(loop);

        // create dummy contour
        // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons
        var contour = [];
        for (var i = 0; i < loop.length; i++) {
          contour.push(i);
        }

        if (cp.pointInContour(x, y, contour)) {
          rank++;
        }
      }

      // Apply even-odd-rule
      return Boolean(rank & 1);
    } }, { key: "clone", value: function clone()

    {
      return new Polygon().copy(this);
    }

    //  @param {MeasureTransform} [measureTransform] - Optional: To allow doing calculation in another coordinate space
  }, { key: "getArea", value: function getArea(measureTransform) {

      if (!this.isClosed) {
        return undefined;
      }

      // If there are multiple loops, we need loopInfos to distinguish inner and outer loops
      var loopInfos = this._getLoopInfos();

      var sumArea = 0;
      for (var loopIndex = 0; loopIndex < this.loopCount; loopIndex++) {

        // Skip degenerate loops
        if (this.points.length < 3) {
          continue;
        }

        // determine loop rank (number of other loops containing it)
        // Note that loopInfos are null for single loops where we don't need them.
        var loopInfo = loopInfos ? loopInfos[loopIndex] : null;
        var rank = loopInfo ? loopInfo.rank : 0;

        // Even-odd rule: Loops with odd rank are holes and contribute negatively
        var sign = rank & 1 ? -1 : 1;

        var loopArea = 0.0;
        this.enumEdges(function (a, b) {
          // apply optional transform
          measureTransform && measureTransform.apply(a);
          measureTransform && measureTransform.apply(b);

          // sum up signed areas
          loopArea += a.x * b.y - b.x * a.y;
        }, loopIndex);
        sumArea += sign * Math.abs(0.5 * loopArea);
      }
      return sumArea;
    } }]);return Polygon;}(PolyBase);


var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);var _super4 = _createSuper(Polyline);

  function Polyline() {var _this4;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);
    _this4 = _super4.call(this, points, style);
    _this4.isClosed = false;return _this4;
  }_createClass(Polyline, [{ key: "makeLine", value: function makeLine()

    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (this.vertexCount !== 2) {
        this.clear();
        this.addPoint(x0, y0);
        this.addPoint(x1, y1);
      } else {
        this.updatePoint(0, x0, y0);
        this.updatePoint(1, x1, y1);
      }
      return this;
    }

    // Draw Polyline into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    } }, { key: "clone", value: function clone()

    {
      return new Polyline().copy(this);
    }

    // hitRadius is in layer-coords
  }, { key: "hitTest", value: function hitTest(x, y, hitRadius) {
      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);
      return edgeIndex !== -1;
    } }]);return Polyline;}(PolyBase);


var EdgeType = {
  Line: 0, // Simple line segment
  Bezier: 1, // Cubic Bezier Arc
  Ellipse: 2 // Ellipse Arc
};


// Tmp objct for Ellipse Arcs. We need delayed initialization, 
// because Autodesk.Extensions.CompGeom might not be available yet at compile time.
var _tmpArc = null;
var getTmpArc = function getTmpArc() {
  _tmpArc = _tmpArc || new Autodesk.Extensions.CompGeom.EllipseArc();
  return _tmpArc;
};

var tmpVec = new THREE.Vector2();

// Helper function to run moveTo/lineTo/arcTo/closePath calls for a single loop of a path on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx       - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
//  @param {number}                         loopIndex - must be a valid loop index in path
var runLoop = function runLoop(ctx, path, loopIndex) {

  var points = path._loops[loopIndex];
  if (!points || !points.length) {
    return;
  }

  // Trying to fill paths with NaN or infinite numbers may cause hangs in clipper. So, we prevent those here.
  if (!path.isLoopFinite(loopIndex)) {
    console.warn("Skipped loop, because it contains Inf or NaN values. Shape ID: ".concat(path.id, ". LoopIndex: ").concat(loopIndex));
    return;
  }

  ctx.moveTo(points[0].x, points[0].y);

  var processSegment = function processSegment(pStart, pEnd, edgeIndex) {
    switch (pStart.arcType) {
      case EdgeType.Line:break;

      case EdgeType.Bezier:{
          ctx.bezierCurveTo(pStart.cp1x, pStart.cp1y, pStart.cp2x, pStart.cp2y, pEnd.x, pEnd.y);
          return;
        }

      case EdgeType.Ellipse:{
          var params = pStart.ellipseArcParams;
          var arc = path.exportEllipseArc(edgeIndex, loopIndex, getTmpArc());

          // ignore arcs with NaN values
          if (!arc.isValid()) {
            break;
          }

          if (ctx.ellipseArcTo) {
            // Support SolidDef Path2D
            ctx.ellipseArcTo(params.rx, params.ry, THREE.Math.degToRad(params.rotation), params.largeArcFlag, params.sweepFlag, pEnd.x, pEnd.y);
          } else {
            // For Autodesk.CompGeom (Path2D and LmvCanvasContext). Also compatible to CanvasContext and Path2D in HTML5.
            ctx.ellipse(arc.cx, arc.cy, arc.rx, arc.ry, arc.rotation, arc.startAngle, arc.endAngle, arc.ccw);
          }

          return;
        }}

    ctx.lineTo(pEnd.x, pEnd.y);
  };

  for (var i = 1; i < points.length; i += 1) {
    // The segment start point defines the type (line or arc)
    var prev = points[i - 1];
    var p = points[i];

    processSegment(prev, p, i - 1);
  }

  if (path.isClosed) {
    // add closing segment
    var pLast = points[points.length - 1];
    var pFirst = points[0];
    processSegment(pLast, pFirst, points.length - 1);

    ctx.closePath();
  }
};

// Helper function to run moveTo/lineTo/arcTo/closePath calls on a given context object.
//  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
//  @param {Polyline|Polygon|Path}          path
var runPath = function runPath(ctx, path) {
  for (var i = 0; i < path.loopCount; i++) {
    runLoop(ctx, path, i);
  }
};

// Draw Path to CanvasContext. Unified implementation for Path, Polyline, and Polygon
//  @param {LmvCanvasContext}      ctx
//  @param {Polyline|Polygon|Path} path
//  @param {Style}                 [overrideStyle]
var drawPath = function drawPath(ctx, path, overrideStyle) {

  if (!path.vertexCount) {
    return;
  }

  var style = overrideStyle || path.style;
  var c = ctx.canvasContext;
  ctx.dbId = path.id;
  ctx.lineStyle = style.lineStyle;
  ctx.isScreenSpace = style.isScreenSpace;

  var currentGlobalCompositeOp = c.globalCompositeOperation;
  if (style.compositeOperation) {
    c.globalCompositeOperation = style.compositeOperation;
    // Make sure any previous shapes with a different blending are flushed first
    ctx.flushBuffer(0, true);
  }

  ctx.beginPath();

  // Run moveTo/lineTo/... commands on context
  runPath(ctx, path);

  // Draw fill for closed paths
  if (path.isClosed) {
    c.fillStyle = style.fillColor;
    // Creates a gradient fill style.
    if (style.fillColor.hasOwnProperty('colorStops')) {
      var gradientData = ctx.createGradientData(style.fillColor);
      var fillStyle = gradientData.getFillStyle(c);
      c.fillStyle = fillStyle;
    }
    c.globalAlpha = style.fillAlpha;

    ctx.fill();
  }

  // draw lines
  c.strokeStyle = style.lineColor;
  c.globalAlpha = style.lineAlpha;
  c.lineWidth = style.lineWidth;

  // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
  // For human eyes the line width is then the same width.
  if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

  ctx.stroke();

  // restore default values
  ctx.dbId = -1;
  ctx.lineStyle = 0;
  ctx.isScreenSpace = false;
  c.globalCompositeOperation = currentGlobalCompositeOp;
};

// Extra params for cubic Bezier arc edges.
var BezierArcParams = /*#__PURE__*/function () {
  function BezierArcParams() {_classCallCheck(this, BezierArcParams);
    // control point 1 that defines start tangent
    this.cp1x = 0;
    this.cp1y = 0;

    // control point 2 that defines end tangent
    this.cp2x = 0;
    this.cp2y = 0;
  }_createClass(BezierArcParams, [{ key: "copy", value: function copy(

    src) {
      this.cp1x = src.cp1x;
      this.cp1y = src.cp1y;
      this.cp2x = src.cp2x;
      this.cp2y = src.cp2y;
      return this;
    } }, { key: "clone", value: function clone()

    {
      return new BezierArcParams().copy(this);
    } }]);return BezierArcParams;}();


// SVG compatible ellipse arc params
// see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
var EllipseArcParams = /*#__PURE__*/function () {

  function EllipseArcParams() {_classCallCheck(this, EllipseArcParams);
    // {number} Radius along x-axis
    this.rx = 0;

    // {number} Radius along y-axis
    this.ry = 0;

    // {number} ccw rotation of x/y-axes in degrees
    this.rotation = 0;

    // {bool} whether to use shorter or longer path around ellipse.
    this.largeArcFlag = false;

    // {bool} Whether to go ccw (true) or cw (false) from startAngle. See SVG docs link above for details.
    this.sweepFlag = false;
  }_createClass(EllipseArcParams, [{ key: "copy", value: function copy(

    src) {
      this.rx = src.rx;
      this.ry = src.ry;
      this.rotation = src.rotation;
      this.largeArcFlag = src.largeArcFlag;
      this.sweepFlag = src.sweepFlag;
      return this;
    } }, { key: "clone", value: function clone()
    {
      return new EllipseArcParams().copy(this);
    }

    // @param {number} angle - counterclockwise in degrees
  }, { key: "rotate", value: function rotate(angle) {

      this.rotation += angle;

      // Normalize angle to keep within [0,360]
      this.rotation -= Math.trunc(this.rotation / 360) * 360;
    } }, { key: "scale", value: function scale(

    factor) {
      this.rx *= factor;
      this.ry *= factor;
    }

    // updates arc params according to a given transform.
    // Note: Transforming ellipse arcs is currently only supported for 
    //       simple transforms like translation, rotation, and uniform scaling.
  }, { key: "applyMatrix4", value: function applyMatrix4(matrix) {

      // apply transform to x-axis direction
      tmpVec3.set(1, 0, 0).applyMatrix4(matrix);
      tmpVec3_2.set(0, 0, 0).applyMatrix4(matrix);
      var axis = tmpVec3.sub(tmpVec3_2);

      // obtain rotation angle and scale (assuming uniform scaling)
      var rotAngle = THREE.Math.radToDeg(Math.atan2(axis.y, axis.x));
      var scale = axis.length();

      // update ellipse params
      this.rotate(rotAngle);
      this.scale(scale);

      // If a transform changes the orientation, we have to invert sweepFlag and rotation param
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].changesOrientation(matrix)) {
        this.sweepFlag = !this.sweepFlag;
        this.rotation = 360.0 - this.rotation;
      }
    } }]);return EllipseArcParams;}();


var Path = /*#__PURE__*/function (_PolyBase3) {_inherits(Path, _PolyBase3);var _super5 = _createSuper(Path);

  function Path(points) {var _this5;var isClosed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultStyle.clone();_classCallCheck(this, Path);
    _this5 = _super5.call(this, points, style);

    // If true, the path is automatically closed and can be filled.
    _this5.isClosed = isClosed;return _this5;
  }

  // Updates ellipse arc of an edge if vertices of the edges are going to be modified   
  // @param {number} edgeIndex   - must be valid. Edge vertices must be in state _before_ modification.
  // @param {number} loopIndex   - must be valid. 
  // @param {Vector2} newA, newB - edge vertices after modification
  _createClass(Path, [{ key: "_updateEllipseArcParams", value: function _updateEllipseArcParams(edgeIndex, loopIndex, newA, newB) {

      var params = this._loops[loopIndex][edgeIndex].ellipseArcParams;

      // compute angle by which the edge was rotated
      var oldDir = this.getEdgeDirection(edgeIndex, loopIndex);
      var newDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(newA, newB);
      var dAngle = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].angleBetweenDirections(newDir, oldDir);

      params.rotate(THREE.Math.radToDeg(dAngle));

      // get scale factor applied to the edge
      var oldLength = this.getEdgeLength(edgeIndex, loopIndex);
      var newLength = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].distance2D(newA, newB); // also works for simple {x,y} pairs
      var scale = newLength / oldLength;

      // scale ellipse radii (if scaling is valid)
      var scaleValid = isFinite(scale) && scale > 0; // zero-radii do not work
      if (scaleValid) {
        params.scale(scale);
      }
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {var loopIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var points = this._loops[loopIndex];
      var p = points[index];

      var pNew = tmpVec.set(x, y);

      // If p is adjacent to a BezierArc segment, the tangent should keep the same after changing the position
      // Therefore, we change the corresponding control points as well
      var dx = x - p.x;
      var dy = y - p.y;

      // Control point for the start tangent of the arc segment starting at p
      if (this.isBezierArc(index, loopIndex)) {
        p.cp1x += dx;
        p.cp1y += dy;
      }

      // Update ellipse arc starting at p
      if (this.isEllipseArc(index, loopIndex)) {
        // next point must exist if index is a valid ellipse-arc edge.
        var nextIndex = this.nextIndex(index, loopIndex);
        var pNext = points[nextIndex];
        this._updateEllipseArcParams(index, loopIndex, pNew, pNext);
      }

      // Update arc params of segment ending at p
      // Note: For polylines, this edge does not exist for index==0
      var prevEdge = this.edgeBeforeVertex(index, loopIndex);
      if (this.edgeIndexValid(prevEdge, loopIndex)) {

        // get previous vertex
        var pPrev = points[prevEdge];

        // Update bezier control point
        if (this.isBezierArc(prevEdge, loopIndex)) {
          pPrev.cp2x += dx;
          pPrev.cp2y += dy;
        }

        // Update ellipse arc
        if (this.isEllipseArc(prevEdge, loopIndex)) {
          this._updateEllipseArcParams(prevEdge, loopIndex, pPrev, pNew);
        }
      }

      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "getEdgeType", value: function getEdgeType(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var type = this._loops[loopIndex][segmentIndex].arcType;
      return type ? type : EdgeType.Line;
    }

    // Change segment into a cubic Bezier arc.
    // First and last control point are already given by the vertex positions.    
    //        
    //  @param {number}             segmentIndex - must be in [0, this.getEdgeCount(loopIndex)]
    //  @param {BezierArcParams}    params
    //  @param {number} [loopIndex]
  }, { key: "setBezierArc", value: function setBezierArc(segmentIndex, params) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      // Legacy support:
      // If cp1x, cp2x etc. are enlisted individually, reshape params to expected form.
      // It's a pain that JS doesn't have function overloads.
      var isParamObj = _typeof(params) === 'object';
      if (!isParamObj) {
        params = {
          cp1x: params,
          cp1y: loopIndex,
          cp2x: arguments.length <= 3 ? undefined : arguments[3],
          cp2y: arguments.length <= 4 ? undefined : arguments[4] };

        loopIndex = (arguments.length <= 5 ? undefined : arguments[5]) || 0;
      }

      var p = this._loops[loopIndex][segmentIndex];
      p.arcType = EdgeType.Bezier;
      BezierArcParams.prototype.copy.call(p, params);

      this.modified();
    } }, { key: "getBezierArcParams", value: function getBezierArcParams(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new BezierArcParams();
      // Find params
      var p = this._loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Bezier && p;

      // return a copy if found, otherwise undefined
      return srcParams && target.copy(srcParams);
    }

    // Set ellipse arc segment. Parameters are the same as for SVG ellipse arcs.
    // see https://www.w3.org/TR/svg-paths/#PathDataEllipticalArcCommands
    //
    //  @param {number}   segmentIndex - must be in [0, this.getEdgeCount()]
    //  @param {EllipseArcParams} arcParams 
  }, { key: "setEllipseArc", value: function setEllipseArc(segmentIndex, arcParams) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      var p = this._loops[loopIndex][segmentIndex];

      p.arcType = EdgeType.Ellipse;
      p.ellipseArcParams = arcParams.clone();

      this.modified();
    }

    // @param {number}           segmentIndex - must be a valid ellipse-arc edge
    // @param {EllipseArcParams} target
    // @returns {EllipseArcParams}
  }, { key: "getEllipseArcParams", value: function getEllipseArcParams(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArcParams();

      // Find params
      var p = this._loops[loopIndex][segmentIndex];
      var srcParams = p && p.arcType === EdgeType.Ellipse && p.ellipseArcParams;

      // Return a copy if found, otherwise undefined.
      return srcParams && target.copy(srcParams);
    }

    // Configures an EllipseArc curve to match with an ellipse-arc edge. This allows for sampling the arc.
    //  @param {number}     edgeIndex     - must be an ellipse arc
    //  @param {number}     [loopIndex=0] - loopIndex
    //  @param {EllipseArc} [target]      - optional
    //  @returns {EllipseArc}
  }, { key: "exportEllipseArc", value: function exportEllipseArc(edgeIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new EllipseArc();

      var points = this._loops[loopIndex];

      // get start/end points
      var nextIndex = this.nextIndex(edgeIndex, loopIndex);
      var pStart = points[edgeIndex];
      var pEnd = points[nextIndex];
      var params = pStart.ellipseArcParams;

      target.setFromSvgArc(
      params.rx,
      params.ry,
      params.rotation,
      params.largeArcFlag,
      params.sweepFlag,
      pStart,
      pEnd);

      return target;
    } }, { key: "isBezierArc", value: function isBezierArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Bezier;
    } }, { key: "isEllipseArc", value: function isEllipseArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.edgeIndexValid(segmentIndex, loopIndex) && this._loops[loopIndex][segmentIndex].arcType === EdgeType.Ellipse;
    } }, { key: "isArc", value: function isArc(

    segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.isBezierArc(segmentIndex, loopIndex) || this.isEllipseArc(segmentIndex, loopIndex);
    }

    // Get tangent vector pointing from start vertex to control point 1 of an arc segment.
    // Only allowed for Bezier arcs. Result is not normalized.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getStartTangent", value: function getStartTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var target = outTarget || new THREE.Vector2();
      var p = this.points[segmentIndex];
      target.x = p.cp1x - p.x;
      target.y = p.cp1y - p.y;
      return target;
    }

    // Get tangent vector pointing from end vertex to control point 2 of an arc segment.
    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @returns {Vector2}
  }, { key: "getEndTangent", value: function getEndTangent(segmentIndex) {var outTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var target = outTarget || new THREE.Vector2();
      var endVertex = this.nextIndex(segmentIndex);

      // get start/end point of the segment
      var pStart = this.points[segmentIndex];
      var pEnd = this.points[endVertex];
      target.x = pStart.cp2x - pEnd.x;
      target.y = pStart.cp2y - pEnd.y;
      return target;
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setStartTangent", value: function setStartTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      p.cp1x = p.x + tangent.x;
      p.cp1y = p.y + tangent.y;
      this.modified();
    }

    //  @param {number} segmentIndex - must be a valid index of an arc segment.
    //  @param {Vector2} tangent
  }, { key: "setEndTangent", value: function setEndTangent(segmentIndex, tangent) {
      var p = this.points[segmentIndex];
      var pEnd = this.points[this.nextIndex(segmentIndex)];
      p.cp2x = pEnd.x + tangent.x;
      p.cp2y = pEnd.y + tangent.y;
      this.modified();
    }

    // Change Bezier or Ellipse arc back to simple line segment
  }, { key: "removeArc", value: function removeArc(segmentIndex) {var loopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var p = this._loops[loopIndex][segmentIndex];

      if (p.arcType === EdgeType.Bezier) {
        p.cp1x = undefined;
        p.cp1y = undefined;
        p.cp2x = undefined;
        p.cp2y = undefined;
      }

      if (p.ellipseArcParams) p.ellipseArcParams = undefined;

      // reset type
      p.arcType = EdgeType.Line;

      this.modified();
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
    // @param {Vector2} [target]
    // @param {number}  [loopIndex]
  }, { key: "getControlPoint", value: function getControlPoint(segmentIndex, ctrlPointIndex) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();
      var p = this._loops[loopIndex][segmentIndex];

      if (ctrlPointIndex === 1) {
        target.x = p.cp1x;
        target.y = p.cp1y;
      } else {
        target.x = p.cp2x;
        target.y = p.cp2y;
      }
      return target;
    }

    // Return ctrl point of Bezier Arc. Only allowed if isBezierArc(segmentIndex) is true
    // @param {number} segmentIndex
    // @param {number} ctrlPointIndex - Must be 1 or 2. Note that ctrlPoints 0 and 3 are defined by
    //                                  current vertex position
  }, { key: "updateControlPoint", value: function updateControlPoint(segmentIndex, ctrlPoint, x, y) {var loopIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var p = this._loops[loopIndex][segmentIndex];
      if (ctrlPoint === 1) {
        p.cp1x = x;
        p.cp1y = y;
      } else {
        p.cp2x = x;
        p.cp2y = y;
      }
      this.modified();
    }

    // Draw Polygon into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {
      drawPath(ctx, this, overrideStyle);
    }

    // Sample path into a Polygon or Polyline.
    //  @returns {Polygon|Polyline}
  }, { key: "toPoly", value: function toPoly() {var _this6 = this;var tessParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Autodesk.Extensions.CompGeom.DefaultTessParams;

      var poly = this.isClosed ? new Polygon() : new Polyline();var _loop = function _loop(
      l) {

        // Build up a polygon from path commands
        var ctx = {
          moveTo: function moveTo(x, y) {return poly.addPoint(x, y, l);},
          lineTo: function lineTo(x, y) {return poly.addPoint(x, y, l);},
          bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {

            // get last added point. Note that it always exists, because runLoop() always starts with moveTo.
            // so we know for sure that >=1 points were already added to this polygon loop.
            var points = poly._loops[l];
            var last = points[points.length - 1];

            // compute bbox of the arc - which we use as an estimate for required accuracy
            var arcBox = tmpBox2.makeEmpty();
            arcBox.expandByPoint(last);
            arcBox.expandByPoint(tmpVec2.set(x, y));
            arcBox.expandByPoint(tmpVec2.set(cp1x, cp1y));
            arcBox.expandByPoint(tmpVec2.set(cp2x, cp2y));
            var sz = arcBox.size(tmpVec).length();

            // sample arc into lineTo() segments
            Autodesk.Extensions.CompGeom.TesselateCubic(ctx, last.x, last.y, cp1x, cp1y, cp2x, cp2y, x, y, sz, tessParams);
          },
          ellipse: function ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw) {

            // use ellipse maxRadius a reference for required accuracy
            var sz = Math.max(rx, ry);

            // determine tesselation params                    
            var maxSegments = tessParams.numIterations;
            var minSegmentLength = tessParams.minSegLenFraction * sz;

            // tesselate arc
            var arc = getTmpArc().set(cx, cy, rx, ry, rotation, startAngle, endAngle, ccw);
            arc.tesselate(ctx, maxSegments, minSegmentLength);
          },
          closePath: function closePath() {} // Polygon is closed anyway.
        };
        runLoop(ctx, _this6, l);};for (var l = 0; l < this.loopCount; l++) {_loop(l);
      }
      return poly;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      // Compute bbox of all vertices
      _get(_getPrototypeOf(Path.prototype), "computeBBox", this).call(this);

      // Consider Bezier arcs: By definition, Bezier curves are always bounded by the convex hull of their control
      // points. Therefore, we can simply add the control points to the bbox.
      //
      // Note: The bboxes obtained by this simple approach are only guaranteed to contain the curve. But, they are not guaranteed to be minimal.
      //       This is not a big issue for most uses (hitTest, drawing etc.). In case it becomes a problem anywhere, we need a better solution here, e.g.
      //       https://stackoverflow.com/questions/24809978/calculating-the-bounding-box-of-cubic-bezier-curve
      var cp = new THREE.Vector2();
      for (var l = 0; l < this.loopCount; l++) {
        for (var i = 0; i < this.getVertexCount(l); i++) {

          if (this.isBezierArc(i, l)) {
            // add control point 1
            this.getControlPoint(i, 1, l, cp);
            this.bbox.expandByPoint(cp);

            // add control point 2
            this.getControlPoint(i, 2, l, cp);
            this.bbox.expandByPoint(cp);
          } else
          if (this.isEllipseArc(i, l)) {
            var arc = this.exportEllipseArc(i, l, getTmpArc());
            this.bbox.union(arc.computeBBox(tmpBox2));
          }
        }
      }
    } }, { key: "hitTest", value: function hitTest(

    x, y, hitRadius) {
      var poly = this.toPoly();
      return poly.hitTest(x, y, hitRadius);
    } }, { key: "clone", value: function clone()

    {
      return new Path().copy(this);
    }

    // @param {Path} srcPath
    // @param {number} srcLoopIndex loop in srcPath to copy
    // @param {number} [dstLoopIndex] Optional: index where to insert the new loop. By default, we use the first free loopIndex.
  }, { key: "addLoop", value: function addLoop(srcPath) {var srcLoopIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var dstLoopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

      // If dstLoop is not set, it will be chosen by the super.addLoop().
      dstLoopIndex = _get(_getPrototypeOf(Path.prototype), "addLoop", this).call(this, srcPath, srcLoopIndex, dstLoopIndex);

      var srcPoints = srcPath._loops[srcLoopIndex];
      var dstPoints = this._loops[dstLoopIndex];

      // Copy extra information for arcs
      for (var i = 0; i < srcPoints.length; i++) {
        var type = srcPath.getEdgeType(i, srcLoopIndex);

        // Line segments are fully handled by the base class already
        if (type === EdgeType.Line) {
          continue;
        }

        var src = srcPoints[i];
        var dst = dstPoints[i];

        dst.arcType = src.arcType;

        switch (type) {
          case EdgeType.Bezier:{
              // copy control points
              dst.cp1x = src.cp1x;
              dst.cp1y = src.cp1y;
              dst.cp2x = src.cp2x;
              dst.cp2y = src.cp2y;
              break;
            }
          case EdgeType.Ellipse:{
              // copy arc params
              dst.ellipseArcParams = src.ellipseArcParams && src.ellipseArcParams.clone();
              break;
            }}

      }

      this.modified();
      return this;
    } }, { key: "moveLoop", value: function moveLoop(

    dx, dy, loopIndex) {
      _get(_getPrototypeOf(Path.prototype), "moveLoop", this).call(this, dx, dy, loopIndex);

      // Move affected control points as well
      var points = this._loops[loopIndex];
      for (var i = 0; i < points.length; i++) {
        if (!this.isBezierArc(i, loopIndex)) {
          continue;
        }

        var p = points[i];
        p.cp1x += dx;
        p.cp1y += dy;
        p.cp2x += dx;
        p.cp2y += dy;
      }

      // Note that for Ellipse arcs, it is sufficient to move start/end like for line segments.
    } }, { key: "getArea", value: function getArea(

    measureTransform) {
      if (!this.isClosed) {
        return undefined;
      }

      // Todo: If performance becomes an issue, this can be optimized by a less brute-force way.
      var poly = this.toPoly(AreaTessParam);

      // Since poly is just temporary, we can just share the loop infos to prevent poly.getArea()
      // from computing them again.
      poly._loopInfos = this._getLoopInfos();

      return poly.getArea(measureTransform);
    } }, { key: "getLength", value: function getLength(

    measureTransform) {
      var poly = this.toPoly();
      return poly.getLength(measureTransform);
    }

    // Get point on segment. This refines the implementation 
    // of PolyBase by supporting arc segments.
  }, { key: "getPointOnEdge", value: function getPointOnEdge(segmentIndex, t) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Vector2();

      var points = this._loops[loopIndex];
      var type = this.getEdgeType(segmentIndex, loopIndex);
      switch (type) {
        case EdgeType.Line:break;
        case EdgeType.Bezier:{
            // get segment start/end
            var a = points[segmentIndex];
            var b = points[this.nextIndex(segmentIndex)];

            return Autodesk.Extensions.CompGeom.getCubeBezierPoint(t, a.x, a.y, a.cp1x, a.cp1y, a.cp2x, a.cp2y, b.x, b.y, target);
          }
        case EdgeType.Ellipse:{
            var arc = this.exportEllipseArc(segmentIndex, loopIndex, getTmpArc());

            // ignore arcs with NaN values
            if (!arc.isValid()) {
              break;
            }
            return arc.getPoint(t, target);
          }
        default:avp.logger.error('unexpected edge type');}


      return _get(_getPrototypeOf(Path.prototype), "getPointOnEdge", this).call(this, segmentIndex, t, loopIndex, target);
    }

    // Run moveTo/lineTo/arcTo/closePath calls on a given context object.    
    //  @param {Path2d|LmvCanvasContext|Object} ctx    - Receives the callback calls, i.e. moveTo, lineTo, bezierCurveTo, closePath etc. (see Path2D)
  }, { key: "runPathCommands", value: function runPathCommands(ctx) {
      runPath(ctx, this);
    }

    // Returns false if all edges of all loops are line segments.
  }, { key: "hasArcs", value: function hasArcs() {var _this7 = this;
      var filter = function filter(vertexIndex, loopIndex) {return _this7.isArc(vertexIndex, loopIndex);};
      return Boolean(this.findVertex(filter));
    } }]);return Path;}(PolyBase);


// Alias that can be used for Polyline/Polygon paths. Use only if you don't intend to change the isClosed prop during lifetime.
var PolygonPath = /*#__PURE__*/function (_Path) {_inherits(PolygonPath, _Path);var _super6 = _createSuper(PolygonPath);
  function PolygonPath(points, style) {_classCallCheck(this, PolygonPath);return _super6.call(this,
    points, true, style);
  }return PolygonPath;}(Path);
;

var PolylinePath = /*#__PURE__*/function (_Path2) {_inherits(PolylinePath, _Path2);var _super7 = _createSuper(PolylinePath);
  function PolylinePath(points, style) {_classCallCheck(this, PolylinePath);return _super7.call(this,
    points, false, style);
  }return PolylinePath;}(Path);
;

var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);var _super8 = _createSuper(Circle);

  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.
  function Circle() {var _this8;var centerX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;var centerY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);
    _this8 = _super8.call(this, style);

    _this8.polygon = new Polygon([], style);

    // Force polygon.id to be the same, so that its geometry is associated with this Circle.
    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.
    _this8.polygon.id = _this8.id;

    _this8.centerX = centerX;
    _this8.centerY = centerY;
    _this8.radius = radius;
    _this8.tessSegments = tessSegments;

    _this8.needsUpdate = true;return _this8;
  }_createClass(Circle, [{ key: "draw", value: function draw(

    ctx, overrideStyle) {

      this.polygon.points.length = 0;

      // angle delta in degrees
      var stepSize = 360 / this.tessSegments;
      for (var angle = 0; angle < 360; angle += stepSize) {

        var a = angle * Math.PI / 180;
        var x = this.radius * Math.cos(a);
        var y = this.radius * Math.sin(a);

        this.polygon.addPoint(this.centerX + x, this.centerY + y);
      }

      this.needsUpdate = false;

      this.polygon.draw(ctx, overrideStyle);
    } }, { key: "setCenter", value: function setCenter(

    x, y) {
      this.centerX = x;
      this.centerY = y;
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      this.centerX += dx;
      this.centerY += dy;
      this.modified();
      return this;
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var dx = x - this.centerX;
      var dy = y - this.centerY;
      return dx * dx + dy * dy < this.radius * this.radius;
    } }, { key: "clone", value: function clone()

    {
      return new Circle().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Circle.prototype), "copy", this).call(this, from);
      this.polygon = from.polygon.clone();
      this.centerX = from.centerX;
      this.centerY = from.centerY;
      this.radius = from.radius;
      this.tessSegments = from.tessSegments;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);
      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);
    } }]);return Circle;}(Shape);


var ShapeWrapper = /*#__PURE__*/function (_Shape3) {_inherits(ShapeWrapper, _Shape3);var _super9 = _createSuper(ShapeWrapper);

  // @param {Shape} shape - must not be null
  function ShapeWrapper(shape) {var _this9;_classCallCheck(this, ShapeWrapper);
    _this9 = _super9.call(this);
    _this9.shape = shape;

    Object.defineProperty(_assertThisInitialized(_this9), 'bbox', {
      get: function get() {return _this9.shape.bbox;},
      set: function set(bbox) {_this9.shape.bbox = bbox;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'id', {
      get: function get() {return _this9.shape.id;},
      set: function set(id) {_this9.shape.id = id;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'bboxDirty', {
      get: function get() {return _this9.shape.bboxDirty;},
      set: function set(dirty) {_this9.shape.bboxDirty = dirty;} });


    Object.defineProperty(_assertThisInitialized(_this9), 'name', {
      get: function get() {return _this9.shape.name;},
      set: function set(name) {_this9.shape.name = name;} });return _this9;

  }_createClass(ShapeWrapper, [{ key: "draw", value: function draw()

    {var _this$shape;return (_this$shape = this.shape).draw.apply(_this$shape, arguments);} }, { key: "hitTest", value: function hitTest()
    {var _this$shape2;return (_this$shape2 = this.shape).hitTest.apply(_this$shape2, arguments);} }, { key: "move", value: function move()
    {var _this$shape3;return (_this$shape3 = this.shape).move.apply(_this$shape3, arguments);} }, { key: "modified", value: function modified()
    {var _this$shape4;return (_this$shape4 = this.shape).modified.apply(_this$shape4, arguments);} }, { key: "computeBBox", value: function computeBBox()
    {var _this$shape5;return (_this$shape5 = this.shape).computeBBox.apply(_this$shape5, arguments);} }, { key: "updateBBox", value: function updateBBox()
    {var _this$shape6;return (_this$shape6 = this.shape).updateBBox.apply(_this$shape6, arguments);} }, { key: "clone", value: function clone()

    {
      return new ShapeWrapper(this.shape.clone());
    } }, { key: "copy", value: function copy(

    from) {
      this.shape.copy(from.shape);
    } }]);return ShapeWrapper;}(Shape);

/***/ }),

/***/ "./extensions/Edit2D/EllipseArcGizmo.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/EllipseArcGizmo.js ***!
  \**********************************************/
/*! exports provided: getEllipseArcEdgeParams, EllipseArcGizmo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEllipseArcEdgeParams", function() { return getEllipseArcEdgeParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseArcGizmo", function() { return EllipseArcGizmo; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}




var tmpVec2 = new THREE.Vector2();

// Get ellipse arc params in a way that the edge is bended inside or outside wrt.
// to the outer loop.
//
// @param {Path}   path       - not changed   
// @param {number} edgeIndex  - edge for which we compute the arc params
// @param {number} loopIndex
// @param {number} bendRadius - Signed distance between line-segment center and arc center. 
//                                 Positive values for outside, negative for inside.   
// @param {EllipseArcParams} [target]
// @returns {EllipseArcParams}
var getEllipseArcEdgeParams = function getEllipseArcEdgeParams(path, edgeIndex, loopIndex, bendRadius, target) {

  var params = target || new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

  // compute ellipse rotation, so that ellipse x-axis is parallel to the edge
  var dir = path.getEdgeDirection(edgeIndex, loopIndex, tmpVec2);
  var angle = Math.atan2(dir.y, dir.x);
  params.rotation = THREE.Math.radToDeg(angle);

  // Compute radius in a way that ellipse center matches with line-segment center
  params.rx = 0.5 * path.getEdgeLength(edgeIndex, loopIndex);

  // Apply bending by varying y-radius
  params.ry = Math.abs(bendRadius);

  // Always use shortest connection
  params.largeArcFlag = false;

  // Make sure that positive bendRadius bends outside, negative inside
  params.sweepFlag = Boolean(path.isCCW(loopIndex) ^ bendRadius < 0);

  return params;
};

// Gizmo class to pull ellipse arc centers. The gizmo implements the full interaction, but
// the owner controls when startDrag(), moveDrag(), and endDrag() are called.
var EllipseArcGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EllipseArcGizmo, _EdgeGizmo);var _super = _createSuper(EllipseArcGizmo);

  function EllipseArcGizmo(layer, gizmoManager, undoStack, visible) {var _this;_classCallCheck(this, EllipseArcGizmo);
    _this = _super.call(this, layer, visible);

    _this.container.classList.add('ellipse-arc-gizmo');

    _this.dragging = false;

    // arc params when drag had started
    _this.dragStartParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

    // delta between exact dragStart position and gizmo-center at dragStart
    _this.dragOffset = new THREE.Vector2();

    // tmp values
    _this.tmpVec = new THREE.Vector2();
    _this.tmpVec2 = new THREE.Vector2();
    _this.tmpVec3 = new THREE.Vector2();
    _this.tmpParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();

    _this.gizmoManager = gizmoManager;
    _this.undoStack = undoStack;return _this;
  }_createClass(EllipseArcGizmo, [{ key: "isUnderMouse", value: function isUnderMouse()

    {
      return this.visible && this.edgeValid() && this.gizmoManager.isUnderMouse(this);
    } }, { key: "startDrag", value: function startDrag(

    canvasX, canvasY) {

      // Stop here if there is nothing to drag
      if (!this.edgeValid() || !this.isUnderMouse()) {
        return false;
      }

      // Usually, dragging will be false here unless in weird focus-change scenarios
      if (this.dragging) {
        return true;
      }

      this.dragging = true;

      // Highlight in green while dragging
      this.setSelected(true);

      // Store offset between exact mouse pos and the vertex we are dragging
      var pos = this.layerPos;
      var posScreen = this.layer.layerToCanvas(pos.x, pos.y);
      this.dragOffset.set(posScreen.x - canvasX, posScreen.y - canvasY);

      // Backup initial arc params
      this.poly.getEllipseArcParams(this.edgeIndex, this.loopIndex, this.dragStartParams);

      return true;
    } }, { key: "moveDrag", value: function moveDrag(

    canvasX, canvasY) {

      if (!this.dragging) {
        return false;
      }

      // Compute layer position of the gizmo after drag
      // Note that the vertex we are dragging does not always match exactly with the mouse position. 
      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;
      var p = this.layer.canvasToLayer(x, y);

      // Compute vector (a => p), where a is the edge start
      var a = this.poly.getPoint(this.edgeIndex, this.loopIndex, this.tmpVec);
      var diff = this.tmpVec2.copy(p).sub(a); // vector from edge start towards new gizmo position

      // Compute distance of the new gizmo position from edge spanned by line segment (a,b)
      var normal = this.poly.getOuterNormal(this.edgeIndex, this.loopIndex, this.tmpVec3);
      var signedDistance = diff.dot(normal);

      // Configure ellipse arc, so that the distance of the arc midpoint is the same
      var params = getEllipseArcEdgeParams(this.poly, this.edgeIndex, this.loopIndex, signedDistance, this.tmpParams);

      // Update polygon
      this.poly.setEllipseArc(this.edgeIndex, params, this.loopIndex);
      this.update();
      this.layer.update();

      return true;
    } }, { key: "endDrag", value: function endDrag(

    canvasX, canvasY) {
      this.moveDrag(canvasX, canvasY);
      this.dragging = false;

      var newParams = this.poly.getEllipseArcParams(this.edgeIndex, this.loopIndex, this.tmpParams);

      this.restoreArc();
      var polyIndex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: this.edgeIndex, loop: this.loopIndex });
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse, null, null, newParams));

      // stop highlighting
      this.setSelected(false);
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      this.restoreArc();
      this.dragging = false;
      this.layer.update();
    }

    // Restore state of the arc before dragging it
  }, { key: "restoreArc", value: function restoreArc() {
      this.poly.setEllipseArc(this.edgeIndex, this.dragStartParams, this.loopIndex);
    } }]);return EllipseArcGizmo;}(_CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeGizmo"]);

/***/ }),

/***/ "./extensions/Edit2D/LoopContainment.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/LoopContainment.js ***!
  \**********************************************/
/*! exports provided: getFacesInsideLoop, computeLoopContainment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFacesInsideLoop", function() { return getFacesInsideLoop; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeLoopContainment", function() { return computeLoopContainment; });
/* harmony import */ var _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolidDefConvert.js */ "./extensions/Edit2D/SolidDefConvert.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);
function _readOnlyError(name) {throw new Error("\"" + name + "\" is read-only");}function _createForOfIteratorHelper(o, allowArrayLike) {var it;if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {if (it) o = it;var i = 0;var F = function F() {};return { s: F, n: function n() {if (i >= o.length) return { done: true };return { done: false, value: o[i++] };}, e: function e(_e) {throw _e;}, f: F };}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion = true,didErr = false,err;return { s: function s() {it = o[Symbol.iterator]();}, n: function n() {var step = it.next();normalCompletion = step.done;return step;}, e: function e(_e2) {didErr = true;err = _e2;}, f: function f() {try {if (!normalCompletion && it.return != null) it.return();} finally {if (didErr) throw err;}} };}function _unsupportedIterableToArray(o, minLen) {if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);}function _arrayLikeToArray(arr, len) {if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {arr2[i] = arr[i];}return arr2;}



// Result values of classifySets
var SetContainment = {
  Contains: 0, // A contains B (not vice versa)
  IsContainedIn: 1, // B contains A (not vice versa)
  Disjoint: 2, // No common elements
  Overlapping: 3, // Intersecting, but not equal
  Equal: 4 // Sets are identical
};

// @param {SketchRegionSolver} solver       - initialized with all edges of subject and cutLoop
// @param {Edges[]}            loopEdges    - edges of the loop that we test against.
// @returns {Face[]} subset of solver.getFaces(). All faces encludes by the loopEdges.
var getFacesInsideLoop = function getFacesInsideLoop(solver, loopEdges) {

  // Get all faces that we obtained by intersecting all edges against each other
  var regionFaces = solver.getFaces();

  // Get ordered array of loop edges within solver that correspond to the cutLoop
  var cutRegionEdges = Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["getRegionEdges"])(solver, loopEdges);

  // Find all faces that are 
  return Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["getBoundedRegionFaces"])(regionFaces, cutRegionEdges);
};

// Tolerance for self-intersection tests: If intersections are very close to a shared vertex, we ignore them.
// Note that the tolerance is not in units but a fraction of an edge.
var Precision = 1.e-5;

// Check whether a single loop has self-intersections
// TODO: There is one edge case that we would not detect here: If a loop passes the same vertex multiple times.
var hasSelfIntersections = function hasSelfIntersections(loopEdges) {
  for (var _i = 0; _i < loopEdges.length; _i++) {
    var edge1 = loopEdges[_i];

    // Check all subsequent edges.
    for (var j = _i + 1; j < loopEdges.length; j++) {

      // Check intersections of both edges
      var edge2 = loopEdges[j];
      var cuts = Object(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["computeCurveCurveIntersections"])(edge1, edge2, false, true);

      // Check if there are any intersections (except for shared vertices)
      for (var _i2 = 0; _i2 < cuts.length; _i2++) {
        var cut = cuts[_i2];

        // Ignore intersections at a shared vertex
        // Due to accuracy issues, the cut may also be just close to a vertex
        var param1 = cut.cutInfo.param;
        var param2 = cut.cutByInfo.param;

        var range1 = edge1.getRange();
        var range2 = edge2.getRange();

        // Check if both parameters are very close to range start/end of an edge
        var dist1 = Math.min(Math.abs(param1 - range1[0]), Math.abs(param1 - range1[1]));
        var dist2 = Math.min(Math.abs(param2 - range2[0]), Math.abs(param2 - range2[1]));
        var d = Math.max(dist1, dist2);

        // If cut was not approximately equal to a shared vertex,
        // consider it as a self-intersection.
        if (d > Precision) {
          return true;
        }
      }
    }
  }
  return false;
};

// Given two sets of values, faces, each indexed by integer faceIds, this function checks how the sets are related.
var classifySets = function classifySets(A, B) {

  // Track which kind of indices we found
  var foundCommon = false; // >=0 elems are in both
  var foundAOnly = false; // >=0 elems are only in set A
  var foundBOnly = false; // >=0 elems are only in set B

  var checkElems = function checkElems(elemIndex) {
    var isInA = A.has(elemIndex);
    var isInB = B.has(elemIndex);

    if (isInA && isInB) foundCommon = true;else
    if (isInA) foundAOnly = true;else
    if (isInB) foundBOnly = true;
  };var _iterator = _createForOfIteratorHelper(

  A),_step;try {for (_iterator.s(); !(_step = _iterator.n()).done;) {var elem = _step.value;
      checkElems(elem);
    }} catch (err) {_iterator.e(err);} finally {_iterator.f();}var _iterator2 = _createForOfIteratorHelper(

  B),_step2;try {for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {var _elem = _step2.value;
      checkElems(_elem);
    }} catch (err) {_iterator2.e(err);} finally {_iterator2.f();}

  if (!foundCommon) {
    return SetContainment.Disjoint;
  }

  if (foundAOnly && !foundBOnly) {
    return SetContainment.Contains;
  }

  if (foundBOnly && !foundAOnly) {
    return SetContainment.IsContainedIn;
  }

  if (!foundAOnly && !foundBOnly) {
    return SetContainment.Equal;
  }

  return SetContainment.Overlapping;
};

// Contains loop containment for a path
var computeLoopContainment = function computeLoopContainment(path) {

  // Convert to SolidDef Path
  var pathSd = _SolidDefConvert_js__WEBPACK_IMPORTED_MODULE_0__["SolidDefConvert"].toSolidDefPath(path);

  // get path as wires
  var wireBody = pathSd.getWireBody();
  var wires = wireBody.getWires();

  // get path as edge array
  var edges = wireBody.getEdges();

  // Init empty loop infos
  var loopInfos = [];
  for (var l = 0; l < wires.length; l++) {

    // Get loop edges
    var w = wires[l];
    var loopEdges = w.getEdges();

    loopInfos[l] = {
      containedLoops: [],
      rank: 0,

      // Indicates if loop containment could not properly computed. 
      // This happens if 
      //   a) The loop has self-intersections
      //   b) The loop is overlapping with another one
      //   c) The loop is exactly matching with another one
      error: hasSelfIntersections(loopEdges) // Initially, we detect only a)
    };
  }

  // For only a single loop or less, we are done here.
  if (wires.length < 2) {
    return loopInfos;
  }

  // Feed them into solver to intersect them against each other and extract the resulting region faces.
  var solver = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["SketchRegionSolver"]();
  solver.compute(edges);

  // check which of the faces are within path and cutPath
  var faces = solver.getFaces();

  // attach arrayIndex to each face
  faces.forEach(function (f, index) {return f.arrayIndex = index;});

  // for each loop l, collect a set facesPerLoop[l] that contains the array indices of all enclosed faces.     
  var facesPerLoop = [];var _loop = function _loop(
  _l) {

    // get edges of loop i
    var w = wires[_l];
    var loopEdges = w.getEdges();

    // If a loop has self-intersections, just mark it as invalid and skip it
    if (hasSelfIntersections(loopEdges)) {
      loopInfos[_l].error = true;
      facesPerLoop[_l] = new Set();
      return "continue";
    }

    // get all faces within this loop
    var enclosedFaceIds = new Set();
    var faces = getFacesInsideLoop(solver, loopEdges);
    faces.forEach(function (f) {
      enclosedFaceIds.add(f.arrayIndex);
    });

    facesPerLoop[_l] = enclosedFaceIds;};for (var _l = 0; _l < wires.length; _l++) {var _ret = _loop(_l);if (_ret === "continue") continue;
  }

  // Use the faceId sets to derive which loop is contained in which other    
  for (var a = 0; a < facesPerLoop.length; a++) {

    // indices of all faces enclosed by loop a
    var A = facesPerLoop[a];

    for (var b = a + 1; b < facesPerLoop.length; b++) {
      // indices of all faces enclosed by loop i
      var B = facesPerLoop[b];

      // Check set relation between A and B
      var cont = classifySets(A, B);
      switch (cont) {
        case SetContainment.Disjoint:
          // No common faces at all. E.g., for two holes.
          continue;
        case SetContainment.Contains:
          loopInfos[a].containedLoops.push(b);
          loopInfos[b].rank++;
          break;
        case SetContainment.IsContainedIn:
          loopInfos[b].containedLoops.push(b);
          loopInfos[a].rank++;
          break;
        default:
          loopInfos[a].error = true;
          loopInfos[b].error = true;}

    }
  }

  // If the original paths contained empty loops, we may have to reindex the loopInfos,
  // because empty loops will not produce a corresponding wire in the SolidDef representation.
  if (wires.length !== path.loopCount) {
    var reindexed = [];
    var srcIndex = 0;
    for (var _l2 = 0; _l2 < path.loopCount; _l2++) {
      // Only non-empty loops get loopInfos
      if (path.getVertexCount(_l2)) {
        reindexed[i] = loopInfos[(_readOnlyError("srcIndex"), srcIndex++)];
      }
    }
    loopInfos = (_readOnlyError("loopInfos"), reindexed);
  }

  return loopInfos;
};

/***/ }),

/***/ "./extensions/Edit2D/Math2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Math2D.js ***!
  \*************************************/
/*! exports provided: Math2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math2D", function() { return Math2D; });
var tmpVec2d = new THREE.Vector2();
var tmpVec2d2 = new THREE.Vector2();

// Collection of simple helper functions for 2D math functions.

// Return normalized edge direction vector (b-a).normalized
var getEdgeDirection = function getEdgeDirection(a, b, target) {
  target = target || new THREE.Vector2();

  return target.copy(b).sub(a).normalize();
};

var getEdgeCenter = function getEdgeCenter(a, b, target) {
  target = target || new THREE.Vector2();

  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));
};

// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2
var getEdgeLength = function getEdgeLength(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Rotates direction vector p 90 degrees to the left. (in-place)
var turnLeft = function turnLeft(p) {
  var tmp = p.x;
  p.x = -p.y;
  p.y = tmp;
  return p;
};

// Projects a point p to a line. Works in-place
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var projectToLine = function projectToLine(p, linePoint, lineDir) {

  // dp = dot(p-linePoint, lineDir)
  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;

  // return linePoint + lineDir * dp
  p.set(
  linePoint.x + dp * lineDir.x,
  linePoint.y + dp * lineDir.y);

};

// Get distance between the point p and a line given by point and direction.
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var pointLineDistance = function () {
  var pProj = new THREE.Vector2();
  return function (p, linePoint, lineDir) {
    projectToLine(pProj.copy(p), linePoint, lineDir);
    return p.distanceTo(pProj);
  };
}();

// Calculates the intersection point of both given lines
// assumes that the lines are not parallel
// see: http://www.paulbourke.net/geometry/pointlineplane/
var intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {

  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;
  if (Math.abs(denom) < 1.0e-8) {return false;}

  // diff = linePoint1 - linePoint2
  var diffX = linePoint1.x - linePoint2.x;
  var diffY = linePoint1.y - linePoint2.y;

  var u = lineDir2.x * diffY - lineDir2.y * diffX;

  if (outPoint) {
    outPoint.x = linePoint1.x + u / denom * lineDir1.x;
    outPoint.y = linePoint1.y + u / denom * lineDir1.y;
  }
  return true;
};

// Rotate a vector p around origin or a given center. Works in-place.
//  @param {Vector2} p
//  @param {number}  angle in radians
//  @param [Vector2] center 
var rotateAround = function rotateAround(p, angle, center) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  if (center) {
    p.sub(center);
  }

  var x = p.x;
  var y = p.y;

  p.x = x * c - y * s;
  p.y = x * s + y * c;

  if (center) {
    p.add(center);
  }
  return p;
};

//  @param {Vector2} dir1, dir2           - No normalization required.
//  @returns {number} result in [0, 2*Pi] - clockwise angle in radians that you have to apply to rotate dir2 into dir1.
var angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {

  // get angle formed with positive x-axis. 
  // angle1/2 are in [-Pi, Pi]
  var angle1 = Math.atan2(dir1.y, dir1.x);
  var angle2 = Math.atan2(dir2.y, dir2.x);

  // Difference is in [-2*Pi, 2*Pi]
  var angle = angle1 - angle2;

  // Map result to [0, 2*Pi] range
  if (angle < 0) angle += 2 * Math.PI;

  return angle;
};

// see isPointOnEdge
var isPointOnLine = function isPointOnLine(p, a, b, precision) {
  return isPointOnEdge(p, a, b, precision, false);
};

// Returns true if p lies close to the edge (p1, p2). 
var isPointOnEdge = function isPointOnEdge(p, a, b, precision) {var checkInsideSegment = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  // Compute edge length
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var length = Math.sqrt(dx * dx + dy * dy);

  var e = {
    v1: a,
    dx: dx,
    dy: dy,
    length: length,
    length2: length * length };

  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, checkInsideSegment, precision);
};

var pointDelta = function pointDelta(a, b) {var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var delta = { x: b.x - a.x, y: b.y - a.y };
  if (digits)
  {
    var exp = Math.pow(10, digits);
    delta.x = Math.round(delta.x * exp) / exp;
    delta.y = Math.round(delta.y * exp) / exp;
  }
  if (!delta.x && !delta.y) {
    return;
  }
  return delta;
};

var edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;
  return a.distanceToSquared(b) < eps2;
};

// Compute target point resulting from mirroring point p
// on the given center point c.
var mirrorPointOnPoint = function mirrorPointOnPoint(p, c) {var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  target = target || new THREE.Vector2();
  target.x = c.x - (p.x - c.x);
  target.y = c.y - (p.y - c.y);
  return target;
};

var fuzzyEqual = function fuzzyEqual(a, b, precision) {
  return Math.abs(a - b) < precision;
};

// Checks if two lines are collinear.
//  @param {Vector2} p1, dir1 - First line, given as point and normalized direction.
//  @param {Vector2} p2, dir2 - Second line
//  @param {number}  precision
//  @returns {bool}
var collinear = function collinear(p1, dir1, p2, dir2, precision) {

  // Directions must be either equal or opposite
  var dirEqual = fuzzyEqual(dir1.x, dir2.x, precision) && fuzzyEqual(dir1.y, dir2.y, precision);
  var dirOpposite = fuzzyEqual(dir1.x, -dir2.x, precision) && fuzzyEqual(dir1.y, -dir2.y, precision);
  if (!dirEqual && !dirOpposite) {
    return false;
  }

  // Directions are equal or opposite => Lines are collinear if and only if p2 is on line (p1, dir1).
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  var dot = dx * dir1.x + dy * dir1.y;
  return Math.abs(dot) < precision;
};

// same as p1.distanceTo(p2), but working for any {x,y} object.
var distance2D = function distance2D(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Checks if a matrix changes the orientation.
//  @param {Matrix4} matrix
var changesOrientation = function changesOrientation(matrix) {
  return matrix.determinant() < 0;
};

// Compute a matrix that transforms fromBox into toBox.
//
//  @param {Box2}    fromBox
//  @param {Box2}    toBox
//  @param {Object}  [options]
//  @param {bool}    [options.flipY]           - include y-axis flip
//  @param {bool}    [options.preserveAspect]  - force uniform scaling (m * fromBox might be smaller than toBox in one axis)
//  @param {Matrix4} [target]
var getFitToBoxTransform = function getFitToBoxTransform(fromBox, toBox) {var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new THREE.Matrix4();
  var fromSize = fromBox.size(tmpVec2d);
  var toSize = toBox.size(tmpVec2d2);

  // compute scale   
  var sx = toSize.x / fromSize.x;
  var sy = toSize.y / fromSize.y;

  // preserveAspect
  if (options.preserveAspect) {
    sx = Math.min(sx, sy);
    sy = sx;
  }

  // anchor is the point of fromBox that will be mapped to toBox.min
  var anchorX = fromBox.min.x;
  var anchorY = fromBox.min.y;

  // apply optional y-flip
  if (options.flipY) {
    sy *= -1;
    anchorY = fromBox.max.y;
  }

  // compute translation: after scaling, anchor should move to toBox.min
  var tx = -sx * anchorX + toBox.min.x;
  var ty = -sy * anchorY + toBox.min.y;

  // Create (scale + translate)-matrix.
  var matrix = target.makeScale(sx, sy, 1.0);
  matrix.elements[12] = tx;
  matrix.elements[13] = ty;

  return matrix;
};

var Math2D = {
  getEdgeDirection: getEdgeDirection,
  projectToLine: projectToLine,
  pointLineDistance: pointLineDistance,
  intersectLines: intersectLines,
  rotateAround: rotateAround,
  angleBetweenDirections: angleBetweenDirections,
  getEdgeCenter: getEdgeCenter,
  getEdgeLength: getEdgeLength,
  turnLeft: turnLeft,
  isPointOnEdge: isPointOnEdge,
  isPointOnLine: isPointOnLine,
  pointDelta: pointDelta,
  edgeIsDegenerated: edgeIsDegenerated,
  mirrorPointOnPoint: mirrorPointOnPoint,
  fuzzyEqual: fuzzyEqual,
  collinear: collinear,
  distance2D: distance2D,
  changesOrientation: changesOrientation,
  getFitToBoxTransform: getFitToBoxTransform };

/***/ }),

/***/ "./extensions/Edit2D/MeasureTransform.js":
/*!***********************************************!*\
  !*** ./extensions/Edit2D/MeasureTransform.js ***!
  \***********************************************/
/*! exports provided: MeasureTransform, DefaultMeasureTransform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeasureTransform", function() { return MeasureTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultMeasureTransform", function() { return DefaultMeasureTransform; });
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


// Workaround to choose a viewport for a given 2d sheet.
// 
// Actually, we should choose it based on 2d-position. But, F2D doesn't give us proper data to 
// do this. Also, even with proper viewport outlines, it wouldn't always unique as viewports may overlap.
// Therefore, we have to use a workaround here to make it use for simple single-viewport sheets at least.
//
// @returns {number|-1} Either -1 or a valid viewportId.
var chooseViewportId = function chooseViewportId(model) {

  var data = model.getData();
  var viewports = data.viewports;
  if (!viewports) {
    return -1;
  }

  // find viewport with maximum number of dbIds    
  var vpIndex = -1;
  var maxDbIds = -1;
  for (var i = 0; i < viewports.length; i++) {

    // Skip viewports without transform
    var vp = viewports[i];
    if (!vp.transform) {
      continue;
    }

    // Use current vp if it has most dbIds
    var numDbIds = vp.geom_metrics.db_ids;
    if (numDbIds > maxDbIds) {
      vpIndex = i;
      maxDbIds = numDbIds;
    }
  }

  return vpIndex;
};

// A MeasureTransform allows for doing length/area measurements in another coordinate system than the actual shape geometry.
// The transform is applied to all points before doing calculations.
var MeasureTransform = /*#__PURE__*/function () {function MeasureTransform() {_classCallCheck(this, MeasureTransform);}_createClass(MeasureTransform, [{ key: "apply",

    // @param {Vector2} p - Point to be transformed in-place.
    value: function apply(p) {} }]);return MeasureTransform;}();
;


// Sets the pageToModel transform in LMV as MeasureTransform to make measurements consistent with Measure extension.
var DefaultMeasureTransform = /*#__PURE__*/function (_MeasureTransform) {_inherits(DefaultMeasureTransform, _MeasureTransform);var _super = _createSuper(DefaultMeasureTransform);

  function DefaultMeasureTransform(viewer) {var _this;_classCallCheck(this, DefaultMeasureTransform);
    _this = _super.call(this);
    _this.viewer = viewer;return _this;
  }

  // Transform geometry point to the coordinate system in which measurements should be computed and displayed.
  //
  // @param {vector2} p
  //
  // Note: Currently, we do some simplifying assumptions here that may need additional
  //       work to support scenarios with multiple viewports or multiple 2d models.
  _createClass(DefaultMeasureTransform, [{ key: "apply", value: function apply(p) {
      // Get viewportId
      var model = this.viewer.model;
      if (!model) {
        return;
      }

      var vpId = chooseViewportId(model);

      // In case there are no viewports, there still might be a pageToModelTransform,
      // which we need to take into account. This is the case for raster PDF.
      model.pageToModel(p, null, vpId);
    } }]);return DefaultMeasureTransform;}(MeasureTransform);

/***/ }),

/***/ "./extensions/Edit2D/ModifierMask.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/ModifierMask.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModifierMask; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Helper to check whether certain modifiers are currently hold or not.
// See https://developer.mozilla.org/de/docs/Web/API/KeyboardEvent/getModifierState for list of supported keys.
// E.g.:
//  "Control", "Shift", "Alt", ..
var ModifierMask = /*#__PURE__*/function () {

  function ModifierMask() {_classCallCheck(this, ModifierMask);
    // By default, don't check any modifers.
    this.checkedModifiers = {};
  }

  // Add a modifier to be checked. E.g. addCondition("Control", true).
  _createClass(ModifierMask, [{ key: "addCondition", value: function addCondition(modifierName, expectedState) {
      this.checkedModifiers[modifierName] = expectedState;
    }

    // Remove condition - accept any state of this modifier
  }, { key: "removeCondition", value: function removeCondition(modifierName) {
      delete this.checkedModifiers[modifierName];
    }

    // Check if current event meets all modifier conditions
  }, { key: "accepts", value: function accepts(event) {
      for (var key in this.checkedModifiers) {
        var state = event.getModifierState(key);
        var expected = this.checkedModifiers[key];
        if (state !== expected) {
          return false;
        }
      }
      return true;
    } }]);return ModifierMask;}();
;

/***/ }),

/***/ "./extensions/Edit2D/ScreenOverlay.js":
/*!********************************************!*\
  !*** ./extensions/Edit2D/ScreenOverlay.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScreenOverlay; });
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Arrow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Arrow.js */ "./extensions/Edit2D/Arrow.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var avp = Autodesk.Viewing.Private;

//
// Utility class for drawing vector overlays in canvas-pixel coords.
//

// Base class for line-based gizmos that can be used in screen overlays
var ScreenOverlayGizmo = /*#__PURE__*/function () {

  function ScreenOverlayGizmo() {_classCallCheck(this, ScreenOverlayGizmo);
    // current opacity value
    this.opacity = 1.0;

    // Fade-in/out transition params
    this.fullOpacity = 1.0; // opacity after full fade-in
    this.fadeTime = 0.5; // in seconds

    // Used by parent ScreenOvelay for fade in/out
    this.fadeAnim = null;
  }

  // Update layer (=screen) coords of the gizmo based latest camera 
  _createClass(ScreenOverlayGizmo, [{ key: "update", value: function update(viewer) {}

    // Return shape representing this gizmo. Used by ScreenOverlay to add/remove shapes from/to layer.
  }, { key: "getShape", value: function getShape() {}

    // Opacity for fade-in/out
  }, { key: "setOpacity", value: function setOpacity(opacity) {
      this.opacity = opacity;
    } }, { key: "getOpacity", value: function getOpacity()
    {return this.opacity;} }, { key: "stopFadeAnim", value: function stopFadeAnim()

    {
      if (this.fadeAnim) {
        this.fadeAnim.stop();
        this.fadeAnim = null;
      }
    } }]);return ScreenOverlayGizmo;}();


// A line that whose endpoints are attached to the screen-projections of 2 points in 3D.
var Line3DGizmo = /*#__PURE__*/function (_ScreenOverlayGizmo) {_inherits(Line3DGizmo, _ScreenOverlayGizmo);var _super = _createSuper(Line3DGizmo);

  function Line3DGizmo(a, b) {var _this;_classCallCheck(this, Line3DGizmo);
    _this = _super.call(this);

    // 2D shape in pixel coords
    _this.line2D = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]().makeLine(0, 0, 0, 0);

    // 3D world positions
    _this.a = a || new THREE.Vector3();
    _this.b = b || new THREE.Vector3();return _this;
  }_createClass(Line3DGizmo, [{ key: "update", value: function update(

    viewer) {
      // project points to screen
      var p1 = viewer.impl.worldToClient(this.a);
      var p2 = viewer.impl.worldToClient(this.b);

      // update line
      this.line2D.updatePoint(0, p1.x, p1.y);
      this.line2D.updatePoint(1, p2.x, p2.y);
    } }, { key: "setOpacity", value: function setOpacity(

    opacity) {
      _get(_getPrototypeOf(Line3DGizmo.prototype), "setOpacity", this).call(this, opacity);
      this.line2D.style.lineAlpha = opacity;
    } }, { key: "setLine", value: function setLine(

    a, b) {
      this.a.copy(a);
      this.b.copy(b);
    } }, { key: "getShape", value: function getShape()

    {
      return this.line2D;
    } }]);return Line3DGizmo;}(ScreenOverlayGizmo);
;

// A line that whose endpoints are attached to the screen-projections of 2 points in 3D.
var Arrow3DGizmo = /*#__PURE__*/function (_ScreenOverlayGizmo2) {_inherits(Arrow3DGizmo, _ScreenOverlayGizmo2);var _super2 = _createSuper(Arrow3DGizmo);

  function Arrow3DGizmo(a, b) {var _this2;_classCallCheck(this, Arrow3DGizmo);
    _this2 = _super2.call(this);

    // 2D shape in pixel coords
    _this2.arrow = new _Arrow_js__WEBPACK_IMPORTED_MODULE_2__["default"]();

    // 3D world positions
    _this2.a = a || new THREE.Vector3();
    _this2.b = b || new THREE.Vector3();return _this2;
  }_createClass(Arrow3DGizmo, [{ key: "update", value: function update(

    viewer) {
      // project points to screen
      var p1 = viewer.impl.worldToClient(this.a);
      var p2 = viewer.impl.worldToClient(this.b);

      // update line
      this.arrow.setFrom(p1);
      this.arrow.setTo(p2);
    } }, { key: "getOpacity", value: function getOpacity()

    {
      return this.arrow.style.lineAlpha;
    } }, { key: "setOpacity", value: function setOpacity(

    opacity) {
      this.arrow.line.style.lineAlpha = opacity;
      this.arrow.head.style.fillAlpha = opacity;
    } }, { key: "stopFadeAnim", value: function stopFadeAnim()

    {
      if (this.fadeAnim) {
        this.fadeAnim.stop();
        this.fadeAnim = null;
      }
    } }, { key: "setFrom", value: function setFrom(

    a) {
      this.a.copy(a);
    } }, { key: "setTo", value: function setTo(

    b) {
      this.b.copy(b);
    } }, { key: "getShape", value: function getShape()

    {
      return this.arrow;
    } }]);return Arrow3DGizmo;}(ScreenOverlayGizmo);
;var

ScreenOverlay = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  // @param {string}   overlayName - Overlay that is created/owned by this EditLayer. Note that it is also destroyed in dtor, so it should not be shared.
  function ScreenOverlay(viewer) {var overlayName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Edit2D.ScreenOverlay';_classCallCheck(this, ScreenOverlay);
    this.viewer = viewer;

    this.overlayName = overlayName;
    this.layer = new _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](viewer);

    // create overlay scene, with orthographic Camera
    var canvas = viewer.canvas;
    var canvasWidth = canvas.clientWidth;
    var canvasHeight = canvas.clientHeight;
    this.camera = new THREE.OrthographicCamera(0, canvasWidth, 0, canvasHeight, -1, 1);

    // Create overlay with EditLayer geometry and ortho camera
    this.viewer.impl.createOverlayScene(overlayName, null, null, this.camera);
    this.viewer.impl.overlayScenes[overlayName].scene.add(this.layer.scene);

    // Make sure that camera is updated on screen resize
    this.onResize = this.onResize.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);

    // Update line gizmos on camera changes
    this.onCameraChange = this.onCameraChange.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

    // Gizmos whose vertices are attached to 3D world positions
    this.gizmos = [];

    // Avoid default viewer cutplanes for screenspace gizmos
    this.layer.setCutPlanesEnabled(false);

    this.layer.setOverlayCamera(this.camera);
  }_createClass(ScreenOverlay, [{ key: "dtor", value: function dtor()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onResize);
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
      this.viewer.removeOverlayScene(this.overlayName);
    } }, { key: "onResize", value: function onResize()

    {
      // adjust ortho-camera to modified canvas
      this.camera.right = this.viewer.canvas.clientWidth;
      this.camera.bottom = this.viewer.canvas.clientHeight;
      this.camera.updateProjectionMatrix();
      this.update();
    }

    // Checks if a gizmo is currently shown in this overlay
  }, { key: "gizmoVisible", value: function gizmoVisible(gizmo) {
      return this.gizmos.includes(gizmo);
    }

    // Add gizmo (if needed) and fade its opacity 
  }, { key: "fadeInGizmo", value: function fadeInGizmo(gizmo) {var _this3 = this;

      // Choose start opacity
      var startOpacity = this.gizmoVisible(gizmo) ? gizmo.getOpacity() : 0.0;
      var endOpacity = gizmo.fullOpacity;

      // Make sure gizmo is visible
      this.setGizmoVisible(gizmo, true);

      // Avoid overlapping animations
      gizmo.stopFadeAnim();

      // update gizmo opacity on timer
      var onTimer = function onTimer(t) {

        t = avp.smootherStep(t);

        // blend opacity value
        var val = avp.lerp(startOpacity, endOpacity, t);
        gizmo.setOpacity(val);

        _this3.layer.update();
      };

      gizmo.setOpacity(startOpacity);
      gizmo.fadeAnim = avp.fadeValue(0, 1, gizmo.fadeTime, onTimer);
    }

    // Fade-out gizmo and sets it to invisible when done (unless interrupted by fade-In)
  }, { key: "fadeOutGizmo", value: function fadeOutGizmo(gizmo) {var _this4 = this;

      if (!this.gizmoVisible(gizmo)) {
        return;
      }

      // Choose start opacity
      var startOpacity = gizmo.getOpacity();

      // Avoid overlapping animations
      gizmo.stopFadeAnim();

      // update gizmo opacity on timer
      var onTimer = function onTimer(t) {

        t = avp.smootherStep(t);

        // blend opacity value
        var val = avp.lerp(startOpacity, 0.0, t);
        gizmo.setOpacity(val);

        _this4.layer.update();
      };

      // If animation finished without interruptions, set gizmo to invisible
      var onEnd = function onEnd() {
        _this4.setGizmoVisible(gizmo, false);
      };

      gizmo.fadeAnim = avp.fadeValue(0, 1, gizmo.fadeTime, onTimer, onEnd);
    } }, { key: "setGizmoVisible", value: function setGizmoVisible(

    gizmo, visible) {

      // If the gizmo was fading out or faded out before, make sure that the fade-out stops
      // and the full opacity is recovered.
      gizmo.stopFadeAnim();
      gizmo.setOpacity(gizmo.fullOpacity);

      // Check if gizmo is currently visible
      var index = this.gizmos.indexOf(gizmo);
      var wasVisible = index !== -1;

      if (visible == wasVisible) {
        return;
      }

      var shape = gizmo.getShape();
      if (visible) {
        // add gizmo
        this.gizmos.push(gizmo);
        this.layer.addShape(shape);
      } else {
        // remove gizmo
        this.gizmos.splice(index, 1);
        this.layer.removeShape(shape);
      }
      this.update();
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.update();
    } }, { key: "update", value: function update()

    {var _this5 = this;
      // reproject 3D gizmos
      this.gizmos.forEach(function (g) {return g.update(_this5.viewer);});
      this.layer.update();
    } }]);return ScreenOverlay;}();
;

ScreenOverlay.Line3DGizmo = Line3DGizmo;
ScreenOverlay.Arrow3DGizmo = Arrow3DGizmo;

/***/ }),

/***/ "./extensions/Edit2D/SegmentTree.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/SegmentTree.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SegmentTree; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // 
// SegmentTree is a spatial datastructure that helps to quickly find all segments (lines, arcs) within a given 2d bbox.
//

var SegmentType = {
  Line: 1,
  CircularArc: 2,
  EllipticalArc: 3 };


// A segment is an object that describes a single line or arc segment.
// Properties depend on segment type (see functions below)
var createLineSegment = function createLineSegment(x1, y1, x2, y2, vpId) {return { type: SegmentType.Line, x1: x1, y1: y1, x2: x2, y2: y2, vpId: vpId };};
var createCircularArcSegment = function createCircularArcSegment(cx, cy, start, end, radius, vpId) {return { type: SegmentType.CirularArc, cx: cx, cy: cy, start: start, end: end, radius: radius, vpId: vpId };};
var createEllipticalArcSegment = function createEllipticalArcSegment(cx, cy, start, end, major, minor, tilt, vpId) {return { type: SegmentType.EllipticalArc, cx: cx, cy: cy, start: start, end: end, major: major, minor: minor, tilt: tilt, vpId: vpId };};

// Triggers the corresponding callbacks (onLineSegment, onCircularArc...) from a given segment object.
//  @param {Object} s             - Segment object whose data are sent to geomCb
//  @param {Object} geomCallbacks - Provides handlers for different segments. Same as used by VertexBufferReader.
var processSegment = function processSegment(s, geomCallbacks) {
  switch (s.type) {
    case SegmentType.Line:geomCallbacks.onLineSegment(s.x1, s.y1, s.x2, s.y2, s.vpId);break;
    case SegmentType.CirularArc:geomCallbacks.onCircularArc(s.cx, s.cy, s.start, s.end, s.radius, s.vpId);break;
    case SegmentType.EllipticalArc:geomCallbacks.onEllipticalArc(s.cx, s.cy, s.tart, s.end, s.major, s.minor, s.tilt, s.vpId);break;}

};

// Implements required functions to allow organizing segments in a quadtree
var SegmentHandler = /*#__PURE__*/function () {

  function SegmentHandler() {_classCallCheck(this, SegmentHandler);

    // Used BoundsCallback to get segment bboxes
    this.boundsCb = new Autodesk.Viewing.Private.BoundsCallback(new THREE.Box2());

    // Reused tmp values
    this.queryBox = new THREE.Box2();
    this.tmpPoint = new THREE.Vector2();
  }_createClass(SegmentHandler, [{ key: "getSegmentBox", value: function getSegmentBox(

    segment) {
      this.boundsCb.bounds.makeEmpty();
      processSegment(segment, this.boundsCb);
      return this.boundsCb.bounds;
    } }, { key: "getQueryBox", value: function getQueryBox(

    minx, miny, maxx, maxy) {
      // get query box
      this.queryBox.min.set(minx, miny);
      this.queryBox.max.set(maxx, maxy);
      return this.queryBox;
    } }, { key: "intersectsBox", value: function intersectsBox(

    segment, minx, miny, maxx, maxy) {
      var queryBox = this.getQueryBox(minx, miny, maxx, maxy);
      var segmentBox = this.getSegmentBox(segment);
      return queryBox.isIntersectionBox(segmentBox);
    }

    // Note that outPoint is just an {x,y} pair, not a Vector2
  }, { key: "getPoint", value: function getPoint(segment, outPoint) {
      // Just use bbox center for all segment types
      var center = this.getSegmentBox(segment).center(this.tmpPoint);
      outPoint.x = center.x;
      outPoint.y = center.y;
    } }]);return SegmentHandler;}();var


SegmentTree = /*#__PURE__*/function () {function SegmentTree() {_classCallCheck(this, SegmentTree);}_createClass(SegmentTree, [{ key: "buildFromModel",

    // Build SegmentTree from 2D vector-data model (PDF or F2D).
    // Note: Make sure that the model is fully loaded - otherwise, the tree will be incomplete.
    value: function buildFromModel(model) {

      // The quadtree must know the extents in advance.
      var box = model.getBoundingBox(true);

      // Init quadtree that manages segments
      this.tree = new Autodesk.Extensions.CompGeom.QuadTree(box.min.x, box.min.y, box.max.x, box.max.y, 0.0, new SegmentHandler());

      // Add geomtry for all fragments
      var frags = model.getFragmentList();
      var count = frags.getCount();
      for (var i = 0; i < count; i++) {
        var geom = frags.getGeometry(i);
        this.addGeometry(geom);
      }
    }

    // Adds all segments from a given 2D LineShader geometry.
    //  @param {BufferGeometry} geom
    //
    // Precondition: Can only be called if tree has been initialized and geom is within the bbox used to initialize the tree
  }, { key: "addGeometry", value: function addGeometry(geom) {var _this = this;

      // GeometryCallback that just collects all segments as objects and adds them to the tree
      var collectSegment = {
        onLineSegment: function onLineSegment() {return _this.tree.addItem(createLineSegment.apply(void 0, arguments));},
        onCircularArc: function onCircularArc() {return _this.tree.addItem(createCircularArcSegment.apply(void 0, arguments));},
        onEllipticalArc: function onEllipticalArc() {return _this.tree.addItem(createEllipticalArcSegment.apply(void 0, arguments));} };


      var vbr = new Autodesk.Viewing.Private.VertexBufferReader(geom);
      vbr.enumGeoms(null, collectSegment);
    }

    //  @param {Object} geomCallbacks - Visitor that provides callbacks to handle different segments. Same as used by VertexBufferReader.
  }, { key: "enumSegments", value: function enumSegments(minx, miny, maxx, maxy, geomCallbacks) {

      // Find all segments in the tree and invoke corresponding call on GeometryCallback
      this.tree.enumInBox(minx, miny, maxx, maxy, function (s) {return processSegment(s, geomCallbacks);});
    } }]);return SegmentTree;}();

/***/ }),

/***/ "./extensions/Edit2D/Selection.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Selection.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Selection; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var av = Autodesk.Viewing;var

Selection = /*#__PURE__*/function () {

  function Selection(layer, undoStack) {var _this = this;_classCallCheck(this, Selection);

    av.EventDispatcher.prototype.apply(this);

    // Keys: shapeIds, Values: shapes
    this.isSelected = {};

    // For mouse-over highlighting. 0 = nothing highlighted (ShapeIds start at 1)
    this.hoveredId = 0;

    // Reused as temporary override style for shapes
    this.tmpStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();

    // Callback function that controls how to modify the style on selected shapes
    this.modifier = function (shape, style) {

      // only modify style for selected or hovered shapes
      var isSelected = _this.isSelected[shape.id];
      var isHovered = shape.id === _this.hoveredId;
      if (!isSelected && !isHovered) {
        return undefined;
      }

      // Create a tmp copy of the initial shape style that is modified to indicate highlighting.
      // Note that we can reuse tmpStyle for multiple shapes, because style modifiers are applied right before drawing.
      _this.tmpStyle.copy(style);

      if (isSelected) {
        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.3, 1);
        _this.tmpStyle.lineWidth *= 1.5;
      } else {
        // hovered
        _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.2, 1);
        _this.tmpStyle.lineWidth *= 1.5;
      }

      return _this.tmpStyle;
    };

    this.layer = layer;
    this.onShapeRemoved = this.onShapeRemoved.bind(this);
    this.onLayerCleared = this.onLayerCleared.bind(this);
    this.layer.addEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].SHAPE_REMOVED, this.onShapeRemoved);
    this.layer.addEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_CLEARED, this.onLayerCleared);

    this.layer.addStyleModifier(this.modifier);

    // Make sure that selection doesn't keep deleted objects, e.g., if creation has undone
    // or a RemoveShape action happened.
    this.undoStack = undoStack;
    this.onActionCb = function (a) {return _this.onAction(a);};
    this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
  }_createClass(Selection, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeStyleModifier(this.modifier);
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
      this.undoStack.removeEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].SHAPE_REMOVED, this.onShapeRemoved);
      this.undoStack.removeEventListener(_EditLayer_js__WEBPACK_IMPORTED_MODULE_2__["default"].LAYER_CLEARED, this.onLayerCleared);
    }

    // @param {Shape[]) shapes
  }, { key: "setSelection", value: function setSelection(shapes) {

      // This works for null as well (unlike ES6 default params)
      shapes = shapes || [];

      var selected = this.getSelectedShapes();

      // Check if the set of ids changed
      var changed = false;
      if (selected.length != shapes.length) {
        changed = true;
      } else {
        // Check if any new shape was not selected before
        for (var i = 0; i < shapes.length; i++) {
          var shape = shapes[i];
          if (!this.isSelected[shape.id]) {
            changed = true;
          }
        }
      }

      if (!changed) {
        return;
      }

      // Add all shapes to this.isSelected
      this.isSelected = {};
      for (var _i = 0; _i < shapes.length; _i++) {
        var _shape = shapes[_i];
        this.isSelected[_shape.id] = _shape;
      }
      this.modified();
    } }, { key: "empty", value: function empty()

    {
      return !Object.keys(this.isSelected).length;
    }

    // Set selection to a single shape. Calling with null clears the selection.
  }, { key: "selectOnly", value: function selectOnly(shape) {
      this.setSelection(shape && [shape]);
    } }, { key: "shapeIsSelected", value: function shapeIsSelected(

    shape) {
      return shape && Boolean(this.isSelected[shape.id]);
    } }, { key: "toggleSelection", value: function toggleSelection(

    shape) {
      var wasSelected = Boolean(this.isSelected[shape.id]);
      this.isSelected[shape.id] = wasSelected ? null : shape;

      this.modified();
    } }, { key: "clear", value: function clear()

    {
      this.setSelection([]);
    }

    // Passes all selected shapes to the callback
  }, { key: "getSelectedShapes", value: function getSelectedShapes() {
      return Object.values(this.isSelected).filter(Boolean);
    } }, { key: "getSelectedIds", value: function getSelectedIds()

    {
      return this.getSelectedShapes().map(function (s) {return s.id;});
    } }, { key: "modified", value: function modified()

    {
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_CHANGED });
    } }, { key: "onAction", value: function onAction()

    {

      if (this.empty()) {
        return;
      }

      // Single-selection: Clear selection if selected shape has gone
      var selected = this.getSelectedShapes();
      if (selected.length == 1) {
        var exists = this.layer.findShapeById(selected[0].id);
        if (!exists) {
          this.clear();
        }
        return;
      }

      // Multi-selection: Same principle, but avoiding n^2 runtime for large selections

      // Create dictionary of all shapes in the layer
      var shapeIdExists = {};
      this.layer.shapes.forEach(function (s) {return shapeIdExists[s.id] = true;});

      // Clear all shapes from selection that don't exist anymore
      selected = selected.filter(function (s) {return shapeIdExists[s.id];});
      this.setSelection(selected);
    } }, { key: "onShapeRemoved", value: function onShapeRemoved(_ref)

    {var shape = _ref.shape;
      if (this.empty()) {
        return;
      }

      // Remove the shape from the selection if found.
      if (this.isSelected[shape.id]) {
        delete this.isSelected[shape.id];
        this.modified();
      }
    } }, { key: "onLayerCleared", value: function onLayerCleared()

    {
      if (this.empty()) {
        return;
      }

      this.clear();
    } }, { key: "setHoveredId", value: function setHoveredId(

    id) {

      if (id === this.hoveredId) {
        return;
      }

      this.hoveredId = id;
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_HOVER_CHANGED });
    }

    // Result may be null if selection is empty
    // @returns {Shape|null}
  }, { key: "getFirstSelected", value: function getFirstSelected() {
      var selected = this.getSelectedShapes();
      return selected.length ? selected[0] : null;
    } }]);return Selection;}();


Selection.Events = {
  SELECTION_CHANGED: 'selectionChanged',
  SELECTION_HOVER_CHANGED: 'selectionHoverChanged' };

/***/ }),

/***/ "./extensions/Edit2D/SolidDefConvert.js":
/*!**********************************************!*\
  !*** ./extensions/Edit2D/SolidDefConvert.js ***!
  \**********************************************/
/*! exports provided: SolidDefConvert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SolidDefConvert", function() { return SolidDefConvert; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @adsk/solid-definition */ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js");
/* harmony import */ var _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__);





var tmpVec1 = new THREE.Vector3();
var tmpVec2 = new THREE.Vector3();

// Convert SolidDef float-array to THREE-Vector3
var toVec3 = function toVec3(ar) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new THREE.Vector3();
  return target.set(ar[0], ar[1], ar[2]);
};

// Add (directed) edge segment to an Edit2D path. If path is non-empty, it is
// assumed that it already ends at the start point of the new edge
//  @param {Path}                     path         - Edit2D path
//  @param {SolidDef.Coedge|SolidDef} ce           - Directed edge from SolidDef 
//  @param {number}                   loopIndex    - index of the loop in target path where we add the edge to
//  @param {bool}                     lastLoopEdge - For the last edge in a loop, we only copy the arc params, but don't add the end vertex.
//                                                   This is because Edit2D shapes do not repeat the start vertex at the end.
var addCoedge = function addCoedge(path, ce, loopIndex) {var lastLoopEdge = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var vertexCount = path.getVertexCount(loopIndex);

  // Add start vertex on first call
  if (vertexCount == 0) {
    var pStart = ce.getStartVertex().getPosition();
    path.addPoint(pStart[0], pStart[1], loopIndex);
  }

  // Add end point - unless this is the last edge of a loop.
  if (!lastLoopEdge) {
    var pEnd = ce.getEndVertex().getPosition();
    path.addPoint(pEnd[0], pEnd[1], loopIndex);
  }

  // This function works for Coedges as well as edges. If ce is already an edge, we just set e=ce.
  var isCoedge = ce instanceof _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["Coedge"];
  var e = isCoedge ? ce.getEdge() : ce;

  // Determine whether the curve direction is flipped. For coedges, this may happen up to twice, because
  // cedge as well as edge have their own isReversed flag.
  var ceReversed = isCoedge ? ce.isReversed() : false;
  var edgeReversed = e.isReversed();
  var isReversed = ceReversed !== edgeReversed; // logical XOR (true if exactly one of both is reversed)

  var type = e.getCurveType();

  // For line segments, we are done
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].LINE) {
    return;
  }

  // convert curve parameters for new edge
  var edgeIndex = Math.max(vertexCount - 1, 0);
  var curve = e.getCurve();

  // Bezier case
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].BCURVE) {

    // Note that we cannot simply copy the control points of the SolidDef bcurve. Reasons:
    //  1. Coedge or edge may be reversed (which may invert the order of the control points)
    //  2. The edge may not cover the whole curve, but only a part of it.
    //
    // Due to 2. we have to construct a new cubic Bezier here based start/end tangent of the edge.

    // get params at edge start/end
    var t0 = ce.t0();
    var t1 = ce.t1();

    // get start/end point
    var _pStart = ce.evaluatePosition(t0);
    var _pEnd = ce.evaluatePosition(t1);

    // get start/end tangent
    var tStart = ce.evaluateDt(t0);
    var tEnd = ce.evaluateDt(t1);

    // We are searching for a cubic Bezier B with the following properties:
    //  - Its parameter domain is [0,1], i.e. B(0)=start vertex, B(1) is end vertex
    //  - Tangents at start/end positions are the same as for the given edge.

    // Note that changing from [t0, t1] to a larger parameter domain [0,1] scales down the tangent vectors accordingly.
    var rangeScale = Math.abs(t1 - t0);
    tStart[0] *= rangeScale;
    tStart[1] *= rangeScale;
    tEnd[0] *= rangeScale;
    tEnd[1] *= rangeScale;

    // The start tangent of a cubic bezier is 3 * (cp1-cp0). So, we can obtain cp1 from the start tangent.
    // Same principle applies to cp2.
    var cp1x = _pStart[0] + tStart[0] / 3;
    var cp1y = _pStart[1] + tStart[1] / 3;
    var cp2x = _pEnd[0] - tEnd[0] / 3;
    var cp2y = _pEnd[1] - tEnd[1] / 3;

    path.setBezierArc(edgeIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);
    return;
  }

  // Ellipse arcs
  if (type === _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPES"].ELLIPSE) {

    var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
    params.rx = curve.getMajorRadius();
    params.ry = curve.getMinorRadius();

    // compute axis rotation
    var xAxis = curve.getMajorAxis();
    var angle = Math.atan2(xAxis[1], xAxis[0]);
    params.rotation = THREE.Math.radToDeg(angle);

    // determine largeArc flag
    // Note that the edge may only use a subset of the curve. 
    // So, it's essential to get the range from the directed edge.
    var range = ce.getRange();
    var startAngle = range[0];
    var endAngle = range[1];
    params.largeArcFlag = endAngle - startAngle > Math.PI; // Note that endAngle is always >startAngle

    // determine sweep flag: Ellipse curves in SolidDef always run ccw (sweepFlag = true).
    // But it may be inverted if the edge direction is flipped.
    params.sweepFlag = !isReversed;

    // Note: In Edit2D, the unrotated y-axis always points up. I.e. rotation=0 means xAxis = (1,0) and yAxis = (-1,0).
    //       In SolidDef, the axes are more flexible. As long as we don't transform the curves arbitrarily, the ellipse
    //       axes still form a 90 degree angle. However, the ellipse coordinate system may have opposite orientation.
    //       If this happens, we have to invert the ellipse orientation.
    var yAxis = curve.getMinorAxis();
    var xDir = toVec3(xAxis, tmpVec1);
    var yDir = toVec3(yAxis, tmpVec2);
    var needsExtraFlip = xDir.cross(yDir).z < 0;
    if (needsExtraFlip) {
      params.sweepFlag = !params.sweepFlag;
    }

    path.setEllipseArc(edgeIndex, params, loopIndex);
    return;
  }

  console.error("Unexpected curve type");
};

// Creates an Edit2D Path loop from a given SoliDef loop. The loop is added to the target path.
//  @param {SolidDef.Loop} loop
//  @param {Path}          [target]
//  @returns {Path}
var loopToShape = function loopToShape(loop) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // start new loop in target path
  var loopIndex = target.nextFreeLoop();

  // traverse coedges of the loop
  var coedges = loop.getCoedges();
  for (var i = 0; i < coedges.length; i++) {
    var ce = coedges[i];

    // for the last loopEdge, we only copy the arc param, but don't repeat the start vertex
    var lastLoopEdge = i == coedges.length - 1;

    // add next edge to target
    addCoedge(target, ce, loopIndex, lastLoopEdge);
  }

  return target;
};

// Convert SolidDef face into one or more Edit2D Paths.
// Todo: If we support multiple loops per Path, result will be a single Path
//  @param {SolidDef.Face} face
//  @param {Path}          [target]
//  @returns {Path}
var faceToShape = function faceToShape(face) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  // convert loops and collect them into target path
  face.getLoops().forEach(function (l) {
    target = loopToShape(l, target);
  });
  return target;
};

// Convert array of faces to array of shapes
var facesToShape = function facesToShape(faces) {var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"]();

  faces.forEach(function (f) {
    target = faceToShape(f, target);
  });
  return target;
};

// Convert SolidDef wire to an Edit2D Path.
//
// Note: This function only works for wires that don't branch and have already ordered edges.
//       This is true for wires that we get from SolidDef.Path.
//  @param {SolidDef.Wire} wire
var wireToShape = function wireToShape(wire) {

  // create empty path
  var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  path.isClosed = wire.isClosed();

  // add edges    
  var edges = wire.getOrderedEdges().edges;
  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var lastLoopEdge = wire.isClosed() && i == edges.length - 1;
    addCoedge(path, edge, 0, lastLoopEdge);
  }
  return path;
};

// Convert SolidDef path to an array of shapes
var pathToShape = function pathToShape(path) {
  var body = path.getWireBody();
  var wires = body.getWires();

  if (wires.length == 0) {
    return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();
  }

  var result = wireToShape(wires[0]);

  // convert additional loops (if any)
  for (var i = 1; i < wires.length; i++) {
    var wire = wires[i];
    var tmp = wireToShape(wire);
    result.addLoop(tmp, 0);
  }

  return result;
};

// Convert Edit2D Path to SolidDef Path2D
var toSolidDefPath = function toSolidDefPath(path) {
  var path2D = new _adsk_solid_definition__WEBPACK_IMPORTED_MODULE_1__["Path2D"]();
  Object(_EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["runPath"])(path2D, path);
  return path2D;
};

var SolidDefConvert = {
  addCoedge: addCoedge,
  loopToShape: loopToShape,
  faceToShape: faceToShape,
  facesToShape: facesToShape,
  wireToShape: wireToShape,
  pathToShape: pathToShape,
  toSolidDefPath: toSolidDefPath };

/***/ }),

/***/ "./extensions/Edit2D/Svg.js":
/*!**********************************!*\
  !*** ./extensions/Edit2D/Svg.js ***!
  \**********************************/
/*! exports provided: Svg */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Svg", function() { return Svg; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CompGeom_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CompGeom/bezier.js */ "./extensions/CompGeom/bezier.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}



var domParser = null;

// SVG (de)serialization for EditShapes

// Url of XML-Namespace for SVG
var SvgNs = "http://www.w3.org/2000/svg";

var exp4 = Math.pow(10, 4);
var limitDigits = function limitDigits(value) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!value || digits === null) {
    return value;
  }
  // like value.toFixed(), but removing trailing zeros
  var exp = digits === 4 ? exp4 : Math.pow(10, digits);
  return Math.round(value * exp) / exp;
};

var domToCircle = function domToCircle(circleNode) {

  if (!circleNode.hasAttributes || !circleNode.hasAttributes()) {
    throw 'No attributes available on the <circle/> node';
  }
  var circle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]();
  for (var i = circleNode.attributes.length - 1; i >= 0; i--) {
    var attr = circleNode.attributes[i];
    switch (attr.name) {
      case 'cx':
        circle.centerX = parseFloat(attr.value);
        break;
      case 'cy':
        circle.centerY = parseFloat(attr.value);
        break;
      case 'r':
        circle.radius = parseFloat(attr.value);
        break;}

  }
  return circle;
};

var circleToSvg = function circleToSvg(circle) {var digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;var stylePostFix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "<circle cx=\"".concat(limitDigits(circle.centerX, digits), "\" cy=\"").concat(limitDigits(circle.centerY, digits), "\" r=\"").concat(limitDigits(circle.radius, digits)).concat(stylePostFix, "\"/>");
};

var domToPath = function domToPath(pathNode) {

  var d = pathNode.getAttribute('d');
  if (!d) {
    return;
  }

  return parsePath(d);
};

// For closed paths, remove last point of each loop if it is just a repetition of the start vertex.
var removeDuplicateLoopEndPoints = function removeDuplicateLoopEndPoints(path) {

  // Bezier applied to the last point will create an additional point which is equal to the endpoint to close the path
  // see Path.toSVGPath(). Path is always closed, therefore we can remove the duplicate end point.
  if (path.isClosed) {
    var pStart = new THREE.Vector2();
    var pEnd = new THREE.Vector2();
    var loopCount = path.loopCount;
    for (var l = 0; l < loopCount; l++) {

      // skip invalid loops
      var lastIndex = path.getVertexCount(l) - 1;
      if (lastIndex < 1) {
        continue;
      }

      // get start/end
      pStart = path.getPoint(0, l, pStart);
      pEnd = path.getPoint(lastIndex, l, pEnd);

      var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(pStart, pEnd, 0);
      if (!delta) {
        path.removePoint(lastIndex, l);
      }

    }
  }
};

var parsePath = function parsePath(svgPath) {
  // split at all chars but keep the char using positive look ahead
  // sample payload for path d = M 13.882,4.8592 L 14.6757,4.738 L 13.9668,4.4896 L 14.005,4.4896 C 15.3211,5.4567,14.79,3.1599,14.6624,4.155 L 13.9189,3.8945 L 13.9189,3.8 L 14.6234,3.7516 Z
  // results into list with glyph with position array:
  // ['M 13.882,4.8592', 'L 14.6757,4.738', 'L 13.9668,4.4896', 'L 14.005,4.4896', 'C 15.3211,5.4567,14.79,3.1599,14.6624,4.155', 'L 13.9189,3.8945', 'L 13.9189,3.8', 'L 14.6234,3.7516', 'Z']
  var pointStrings = svgPath.split(/ (?=[a-zA-Z])/gi);
  var validChars = "MLHVCZA";

  // Reused per cycle
  var ellipseParams = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
  var nextPoint = new THREE.Vector2();

  // the current loop that we are adding edges to
  var loopIndex = 0;

  var path = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]();

  for (var i = 0; i < pointStrings.length; i++) {

    // Check for unexpected characters
    var pointString = pointStrings[i];
    if (validChars.indexOf(pointString[0]) === -1) {
      throw "\"".concat(pointString[0], "\" is not a supported or invalid glyph: ").concat(pointString);
    }

    var segmentIndex = path.getVertexCount(loopIndex) - 1;

    // Determine edge type, position, and extra params for arcs
    var value = pointString.substring(1);
    switch (pointString[0]) {
      case 'M':
        // start new loop
        loopIndex = path.nextFreeLoop();
      case 'L':
        var coords = value.split(',');
        nextPoint.x = parseFloat(coords[0]);
        nextPoint.y = parseFloat(coords[1]);
        break;
      case 'H':
        nextPoint.x = parseFloat(value);
        break;
      case 'V':
        nextPoint.y = parseFloat(value);
        break;
      case 'C':

        // tokenize params
        var bezierCoords = value.split(',');

        // get position
        nextPoint.x = parseFloat(bezierCoords[4]);
        nextPoint.y = parseFloat(bezierCoords[5]);

        // get bezier params                
        var cp1x = parseFloat(bezierCoords[0]);
        var cp1y = parseFloat(bezierCoords[1]);
        var cp2x = parseFloat(bezierCoords[2]);
        var cp2y = parseFloat(bezierCoords[3]);

        if (segmentIndex >= 0) {
          path.setBezierArc(segmentIndex, cp1x, cp1y, cp2x, cp2y, loopIndex);
        } else {
          console.error('SVG Parse error: Path is not expected to start with "C" command');
        }
        break;

      case 'A':
        // tokenize params
        var src = value.split(',');

        // get position
        nextPoint.x = parseFloat(src[5]);
        nextPoint.y = parseFloat(src[6]);

        // read ellipse params.                
        ellipseParams.rx = parseFloat(src[0]);
        ellipseParams.ry = parseFloat(src[1]);
        ellipseParams.rotation = parseFloat(src[2]);
        ellipseParams.largeArcFlag = Boolean(parseFloat(src[3]));
        ellipseParams.sweepFlag = Boolean(parseFloat(src[4]));

        if (segmentIndex >= 0) {
          path.setEllipseArc(segmentIndex, ellipseParams, loopIndex);
        } else {
          console.error('SVG Parse error: Path is not expected to start with "A" command');
        }
        break;
      case 'Z':
        // we are done
        path.isClosed = true;
        continue;}


    // add next point
    path.addPoint(nextPoint.x, nextPoint.y, loopIndex);
  }

  removeDuplicateLoopEndPoints(path);

  return path;
};

var pathToSvgPath = function pathToSvgPath(path) {var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var digits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!path.vertexCount) {
    return [];
  }

  // Shortcut for restricting number of digits
  var ld = function ld(num) {return limitDigits(num, digits);};

  var svgPath = [];

  // reused per loop cycle
  var p = new THREE.Vector2();
  var pPrev = new THREE.Vector2();
  var params = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EllipseArcParams"]();
  var cp1 = new THREE.Vector2();
  var cp2 = new THREE.Vector2();

  var loopCount = path.loopCount;
  for (var l = 0; l < loopCount; l++) {

    // Add M command for first vertex
    var edgeCount = path.getEdgeCount(l);
    if (edgeCount > 0) {
      p = path.getPoint(0, l, p);
      svgPath.push("M ".concat(ld(p.x), ",").concat(ld(p.y)));
    }

    for (var i = 0; i < edgeCount; i++) {

      // Vertex i is the end point of segment i-1, which defines edge type and arc params
      var segmentIndex = i;
      var edgeType = path.isPath() ? path.getEdgeType(segmentIndex, l) : _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line;

      // get next point. Note: If the path is closed, p will be the start vertex of the loop again.
      var edgeEndVertex = path.nextIndex(segmentIndex, l);
      p = path.getPoint(edgeEndVertex, l, p);

      var value = '';
      switch (edgeType) {

        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse:
          params = path.getEllipseArcParams(segmentIndex, l, params);

          // Convert boolean flags to 1/0
          var largeArc = params.largeArcFlag ? 1 : 0;
          var sweep = params.sweepFlag ? 1 : 0;

          value = "A ".concat(params.rx, ",").concat(params.ry, ",").concat(params.rotation, ",").concat(largeArc, ",").concat(sweep, ",").concat(p.x, ",").concat(p.y);
          break;

        case _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier:
          cp1 = path.getControlPoint(segmentIndex, 1, l, cp1);
          cp2 = path.getControlPoint(segmentIndex, 2, l, cp2);
          value = "C ".concat(ld(cp1.x, digits), ",").concat(ld(cp1.y, digits), ",").concat(ld(cp2.x, digits), ",").concat(ld(cp2.y, digits), ",").concat(ld(p.x, digits), ",").concat(ld(p.y, digits));
          break;

        default:
          {
            // skip empty/duplicate points
            var _pPrev = path.getPoint(i, l, _pPrev);
            var delta = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointDelta(_pPrev, p, digits);
            if (!delta) {
              continue;
            }

            if (Math.abs(delta.x) <= precision) {
              value = "V ".concat(ld(p.y));
            } else if (Math.abs(delta.y) <= precision) {
              value = "H ".concat(ld(p.x));
            } else {
              value = "L ".concat(ld(p.x), ",").concat(ld(p.y));
            }
          }}


      // For closed paths, the edge end vertex will be 0. Repeating the start vertex is only necessary if the
      // last segment is an arc: Without repeating the start vertex at the loop end, we could not store the arc parameters in SVG.
      var isRepeatedStartVertex = edgeEndVertex === 0;
      if (isRepeatedStartVertex && edgeType === _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line) {
        // Last segment of the loop is a line. We don't need to repeat the start vertex in this case.
        continue;
      }

      svgPath.push(value);
    }

    // For a closed path, repeat the end vertex. This is necessary to preserve arc params
    if (path.isClosed) {
      // close loop
      svgPath.push('Z');
    }
  }

  return svgPath;
};

// Extract dictionary of SVG style attributes from Edit2D style
//  @param {Style} style
//  @returns {Object}
var getSvgStyleAttributes = function getSvgStyleAttributes(style) {

  var target = {};
  target["stroke"] = style.lineColor;
  target["fill"] = style.fillColor;
  target["stroke-width"] = style.lineWidth;

  // omit opacities if they are 1 (default)
  if (style.lineAlpha != 1) target["stroke-opacity"] = style.lineAlpha;
  if (style.fillAlpha != 1) target["fill-opacity"] = style.fillAlpha;

  return target;
};

// Converts the result of getSvgStyleAttributes to a string postfix. Since we append it
// to other attributes, it contains a preceding space. 
// Example: ' stroke="rgb(0,0,0)" fill="rgb(0,0,255)" ... '
var getAttributePostFix = function getAttributePostFix(attribs) {
  var str = '';
  for (var key in attribs) {
    str += " ".concat(key, "=\"").concat(attribs[key], "\"");
  }
  return str;
};

// Apply all given attributes to a Dom Element
var applyAttributes = function applyAttributes(domElement, attribs) {
  for (var key in attribs) {
    domElement.setAttribute(key, attribs[key]);
  }
};

// Converts a shape into a string describing an SVG path. Note that (for legacy reasons),
// style attributes are only exported if specified in options.
//
// @param {Shape} shape
// @param {Object} [options]
// @param {number} [options.precision=0]       - accuracy for unifying duplicate points 
// @param {number} [options.digis=0]           - number of digits for number strings 
// @param {bool}   [options.exportStyle=false] - If true, we also export style attributes
//
// Note: We currently have to use function syntax, otherwise we cannot use 'arguments' for the legacy fallback below.
var toSvg = function toSvg(shape, options) {

  var precision = options && options.precision || 0;
  var digits = options && options.digits || null; // means no limitation of digits
  var exportStyle = options && options.exportStyle || false;

  // add style params if wanted
  var stylePostfix = '';
  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    stylePostfix = getAttributePostFix(attribs);
  }

  // Legacy: Keep old code using that still passes precision/digits separately
  // Todo: Remove this when checked with clients.
  if (_typeof(options) !== 'object') {
    if (typeof arguments[1] == 'number') precision = arguments[1];
    if (typeof arguments[2] == 'number') digits = arguments[2];
  }

  if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"]) {
    return circleToSvg(shape, digits, stylePostfix);
  }

  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  // PolyBase and Path are translated to SVG Path
  var path = pathToSvgPath(shape, precision, digits);

  return "<path d=\"".concat(path.join(' '), "\"").concat(stylePostfix, "/>");
};

// see toSvg for options.
var createSvgShape = function createSvgShape(shape, options) {
  var precision = options && options.precision || 0;
  var digits = options && options.digits || 0;
  var exportStyle = options && options.exportStyle || true;

  // Todo: support circles and other shapes if anyone needs it.
  if (!(shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"])) {
    console.error('SVG serialization not supported for this shape: ', shape);
    return;
  }

  var path = document.createElementNS(SvgNs, 'path');
  path.setAttribute('d', pathToSvgPath(shape, precision, digits));

  if (exportStyle) {
    var attribs = getSvgStyleAttributes(shape.style);
    applyAttributes(path, attribs);
  }

  return path;
};

// @param {string}  svg - e.g. '<path d="M 13.882,4.8592 L 14.6757,4.738"/>'
var fromSvg = function fromSvg(svg) {
  if (!svg) {
    return;
  }

  // init on first use
  domParser = domParser || new DOMParser();

  var dom = domParser.parseFromString(svg, 'application/xml');

  if (dom.childNodes.length !== 1) {
    throw 'Function does only support svg with a single element: path, circle';
  }
  var node = dom.firstChild;
  if (node.nodeName === 'circle') {
    return domToCircle(node);
  } else
  if (node.nodeName === 'path') {
    return domToPath(node);
  }

  throw "Unsupported svg node type: ".concat(node.nodeName);
};

// Converts several shapes to an SVG element.
//  @param {Object} [options]
//  @param {Box2} [dstBox] - If specified, shapes can be rescaled to fit into a destination box for the given SVG.
//  @param {Box2} [srcBox] - By default, srcBox is the union of all shapeBoxes. Shapes are uniformly rescaled from srcBox into dstBox.
// see toSvg() for other options
var createSvgElement = function createSvgElement(shapes) {var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // get summed box of all shapes
  var sumBox = new THREE.Box2();
  shapes.forEach(function (shape) {return sumBox.union(shape.getBBox());});

  var srcBox = options.srcBox || sumBox;
  var dstBox = options.dstBox || sumBox;

  // Note that we always have to swap y-axis, because the y-axis direction is flipped when 
  // converting 2D world coords in LMV to SVG.
  var scaleOptions = {
    preserveAspect: true,
    flipY: true };

  var tf = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getFitToBoxTransform(srcBox, dstBox, scaleOptions);

  // get required size of svg
  var width = dstBox.max.x - dstBox.min.x;
  var height = dstBox.max.y - dstBox.min.y;

  // create svg root element      
  var svg = document.createElementNS(SvgNs, 'svg');
  svg.setAttribute('height', width);
  svg.setAttribute('width', height);

  // rescale & convert each shape
  shapes.forEach(function (shape) {
    var scaledShape = shape.clone().applyMatrix4(tf);
    var path = createSvgShape(scaledShape, options);
    svg.appendChild(path);
  });

  return svg;
};

var Svg = {
  toSvg: toSvg,
  fromSvg: fromSvg,
  createSvgShape: createSvgShape,
  createSvgElement: createSvgElement };

/***/ }),

/***/ "./extensions/Edit2D/TangentGizmo.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/TangentGizmo.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TangentGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // A tangent gizmo is a dashed line with two vertex gizmos at the end.
// It is used to control tangents for Bezier arcs.






var tangentGizmoName = function tangentGizmoName(vertexIndex, loopIndex, sideIndex) {
  return "TangentGizmo-$loopIndex-$vertexIndex-$sideIndex";
};

// Indicates which endpoint of the tangent is being dragged
var DragIndex = {
  None: -1, // Nothing dragged
  Start: 0, // Dragging start point
  End: 1 // Dragging end point
};

var tmpVec = new THREE.Vector2();var

TangentGizmo = /*#__PURE__*/function () {

  function TangentGizmo(path, index, loopIndex, layer, gizmoLayer, gizmoManager, undoStack) {_classCallCheck(this, TangentGizmo);

    this.path = path;
    this.gizmoLayer = gizmoLayer;
    this.layer = layer;
    this.gizmoManager = gizmoManager; // Used to track which gizmo is under mouse
    this.undoStack = undoStack;

    // index of the vertex whose tangent we control
    this.index = index;
    this.loopIndex = loopIndex;

    // dashed tangent line
    this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"]();
    this.lineVisible = false;

    // configure style of dashed line
    this.line.style.isScreenSpace = true;
    this.line.style.lineColor = 'rgb(255, 0, 255)',
    this.line.style.lineWidth = 1.0,
    this.line.style.lineStyle = 10;
    this.line.style.lineAlpha = 1.0;

    // VertexGizmos at both ends of the tangent line
    this.vertexGizmo1 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, loopIndex, 1));
    this.vertexGizmo2 = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["VertexGizmo"](this.gizmoLayer, 0, 0, tangentGizmoName(index, loopIndex, 2));

    // Hide vertex gizmos until we have proper positions
    this.vertexGizmo1.setVisible(false);
    this.vertexGizmo2.setVisible(false);

    // Start/end vertex of tangent Gizmo
    this.pStart = new THREE.Vector2();
    this.pEnd = new THREE.Vector2();

    // Add this to main layer. This triggers this.update() on layer updates to respond to
    // vertex position changes.
    this.layer.addCanvasGizmo(this);

    // 0: dragging startPoint, 1: dragging endPoint, 2: nothing dragged
    this.dragIndex = DragIndex.None;

    // Last tracked dragging position for currently dragged vertex
    this.lastDragPos = new THREE.Vector2(); // in layer coords

    // When dragging vertices, we store the offset (in layer-coords) between 
    // the accurate click position and the center of the clicked vertex gizmo
    this.dragOffset = new THREE.Vector2(0, 0); // in pixels

    // An action used during a drag operation
    this.action = null;

    this.update();
  }_createClass(TangentGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
      this.layer.removeCanvasGizmo(this);
    } }, { key: "setVisible", value: function setVisible(

    visible) {

      this.vertexGizmo1.setVisible(visible);
      this.vertexGizmo2.setVisible(visible);

      // Show/Hide tangent line gizmo
      if (visible !== this.lineVisible) {
        if (visible) {
          this.gizmoLayer.addShape(this.line);
        } else {
          this.gizmoLayer.removeShape(this.line);
        }
      }
      this.lineVisible = visible;
    } }, { key: "update", value: function update()

    {

      // get index of previous edge (ending at the vertex)
      var prevEdgeIndex = this.path.edgeBeforeVertex(this.index, this.loopIndex);
      var nextEdgeIndex = this.path.edgeAfterVertex(this.index, this.loopIndex);

      // prev/next edge may not exist in case of polyline paths
      var prevEdgeExists = prevEdgeIndex !== -1;
      var nextEdgeExists = nextEdgeIndex !== -1;

      // Check which of the adjacent edges are arcs
      var prevIsArc = prevEdgeExists && this.path.isBezierArc(prevEdgeIndex, this.loopIndex);
      var nextIsArc = nextEdgeExists && this.path.isBezierArc(nextEdgeIndex, this.loopIndex);

      // If none of the edges is an Arc, just hide all gizmos
      if (!prevIsArc && !nextIsArc) {
        this.setVisible(false);
        return;
      }

      // Compute both endpoints of tangent gizmo
      var p = this.path.getPoint(this.index, this.loopIndex, tmpVec);
      if (nextIsArc) {

        // End point is first control point of the arc starting at p
        this.pEnd = this.path.getControlPoint(this.index, 1, this.loopIndex, this.pEnd);

        // In general, the start point would be cp2 of the previous arc. 
        // But, we enforce tangents to be identical for previous edge and next edge.
        // Therefore, we obtain the other endpoint by mirroring the tangent of the leaving edge
        // on point p
        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pEnd, p, this.pStart);
      } else {
        // Only previous edge is an arc: We have to obtain the tangent from
        // control point 2 of the previous edge.
        this.pStart = this.path.getControlPoint(prevEdgeIndex, 2, this.loopIndex, this.pStart);

        _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(this.pStart, p, this.pEnd);
      }

      // update vertex gizmos
      this.vertexGizmo1.setPosition(this.pStart.x, this.pStart.y);
      this.vertexGizmo2.setPosition(this.pEnd.x, this.pEnd.y);

      // update line gizmo
      this.line.makeLine(this.pStart.x, this.pStart.y, this.pEnd.x, this.pEnd.y);
      this.gizmoLayer.update();

      this.setVisible(true);
    }

    // Apply modified tangent endpoints after dragging on of the tangent vertices.
    //
    // @param {Vector2} pStart, pEnd - Tangent start/end point in layer coords.
  }, { key: "updateAction", value: function updateAction(pStart, pEnd) {

      // Init action for the current drag-interaction (if needed)
      if (!this.action) {
        this.action = new _Actions_js__WEBPACK_IMPORTED_MODULE_3__["Actions"].ChangeBezierTangent(this.layer, this.path, this.index, this.loopIndex, pStart, pEnd);
      } else {
        // However, for this specific action, it makes no difference.            
        this.action.setTangent(pStart, pEnd);
      }

      // In general, we need to undo() an action before calling redo() again. But, for this specific action,
      // it does not make a difference, because we are overwriting the same control points.
      this.action.redo();

      // update gizmos
      this.update();
    }

    // @param {Vector2} newPos - new position in layer coords
  }, { key: "onStartVertexMoved", value: function onStartVertexMoved(startPos) {
      // get new tangent end point by mirroring on vertex position
      var center = this.path.getPoint(this.index, this.loopIndex);
      var endPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(startPos, center);

      this.updateAction(startPos, endPos);
    }

    // @param {Vector2} startPos - new position in layer coords
  }, { key: "onEndVertexMoved", value: function onEndVertexMoved(endPos) {
      // get new tangent start point by mirroring on vertex position
      var center = this.path.getPoint(this.index, this.loopIndex);
      var startPos = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].mirrorPointOnPoint(endPos, center);

      this.updateAction(startPos, endPos);
    }

    // @param {DragIndex} dragIndex
  }, { key: "startDrag", value: function startDrag(canvasX, canvasY, dragIndex) {

      this.dragIndex = dragIndex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = dragIndex === DragIndex.Start ? this.pStart : this.pEnd;
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - canvasX, vposScreen.y - canvasY);

      this.lastDragPos.copy(vpos);
    }

    // process last position and finish dragging
  }, { key: "endDrag", value: function endDrag(canvasX, canvasY) {
      this.moveDrag(canvasX, canvasY);

      // Mark action as finished. It is important to do this before running the action,
      // because PolygonEditTool cancels unfinished dragging operations on external actions.
      this.dragIndex = DragIndex.None;

      // apply the action
      if (this.action) {
        this.undoStack.run(this.action);
        this.action = null;
      }
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (!this.isDragging()) {
        return;
      }

      this.dragIndex = DragIndex.None;
      this.action && this.action.undo();
      this.action = null;
    } }, { key: "moveDrag", value: function moveDrag(

    canvasX, canvasY) {

      // Compute canvas position of the gizmo after drag
      // Note that the vertex we are dragging does not always match exactly with the mouse position. 
      // E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;
      var p = this.layer.canvasToLayer(x, y);

      // Move tangent vertex by dx/dy
      if (this.dragIndex === DragIndex.Start) {
        this.onStartVertexMoved(p);
      } else if (this.dragIndex === DragIndex.End) {
        this.onEndVertexMoved(p);
      }

      this.layer.update();
    }

    // @returns {bool} true if dragging started
  }, { key: "onButtonDown", value: function onButtonDown(canvasX, canvasY) {

      var startDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo1);
      var endDragged = this.gizmoManager.isUnderMouse(this.vertexGizmo2);

      if (!startDragged && !endDragged) {
        return false;
      }

      var dragIndex = startDragged ? DragIndex.Start : DragIndex.End;
      this.startDrag(canvasX, canvasY, dragIndex);

      return true;
    } }, { key: "isDragging", value: function isDragging()

    {
      return this.dragIndex !== DragIndex.None;
    } }]);return TangentGizmo;}();
;

/***/ }),

/***/ "./extensions/Edit2D/Trackings.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Trackings.js ***!
  \****************************************/
/*! exports provided: Trackings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Trackings", function() { return Trackings; });
var Drag = 'drag';
var Click = 'click';
var ButtonDown = 'buttonDown';
var ButtonUp = 'buttonUp';

var Trackings = {
  ButtonDown: ButtonDown,
  ButtonUp: ButtonUp,
  Click: Click,
  Drag: Drag };

/***/ }),

/***/ "./extensions/Edit2D/UndoStack.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/UndoStack.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoStack; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;var

UndoStack = /*#__PURE__*/function () {

  function UndoStack() {_classCallCheck(this, UndoStack);

    av.EventDispatcher.prototype.apply(this);

    // Array of action objects
    this.stack = [];

    // By default, this simply points to the end of this.stack. Only if undo has been called, 
    // it points to the next operation to be run on a redo() call
    this.current = 0;
  }

  // Executes an action and pushes it to the undo stack
  _createClass(UndoStack, [{ key: "run", value: function run(action) {
      // If we did a couple of undos before, a new operation will clear all redo steps
      this.stack.length = this.current;

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action });

      this.stack.push(action);
      this.current = this.stack.length;
    } }, { key: "undo", value: function undo()

    {
      if (!this.current) {
        // We reached the beginning of the stack
        return false;
      }
      this.current--;

      var action = this.stack[this.current];

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: true });

      action.undo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: true });

      action.layer.update();

      return true;
    } }, { key: "redo", value: function redo()

    {
      var action = this.stack[this.current];
      if (!action) {
        // Nothing to redo
        return false;
      }

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: false });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: false });

      this.current++;

      action.layer.update();

      return true;
    } }, { key: "clear", value: function clear()

    {
      this.stack.length = 0;
      this.current = 0;
    } }]);return UndoStack;}();


// Events sent before/after any action is executed by UndoStack
UndoStack.BEFORE_ACTION = 'beforeAction';
UndoStack.AFTER_ACTION = 'afterAction';

/***/ }),

/***/ "./extensions/Edit2D/UnitHandler.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/UnitHandler.js ***!
  \******************************************/
/*! exports provided: UnitHandler, SimpleUnitHandler, DefaultUnitHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnitHandler", function() { return UnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleUnitHandler", function() { return SimpleUnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultUnitHandler", function() { return DefaultUnitHandler; });
/* harmony import */ var _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MeasureTransform.js */ "./extensions/Edit2D/MeasureTransform.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var avp = Autodesk.Viewing.Private;

// Interface to control display of length/area units.
var UnitHandler = /*#__PURE__*/function () {

  function UnitHandler() {_classCallCheck(this, UnitHandler);
    // Optional: Returns a transform that is applied to all points for length/area calculations.
    //  @returns {MeasureTransform}
    this.measureTransform = null;
  }

  // @param   {number} val - length in layer coords
  // @returns {string} String to display, including units.
  _createClass(UnitHandler, [{ key: "lengthToString", value: function lengthToString(val) {
      console.error('Not implemented');
    }

    // @param   {number} val - area in layer coords
    // @returns {string} String to display - including units.
  }, { key: "areaToString", value: function areaToString(val) {
      console.error('Not implemented');
    } }]);return UnitHandler;}();
;

// If nothing is specified, we display with 2 digits and assume all unit in inches.
var DefaultPrecision = 2;
var DefaultUnits = "inch";

// Format length / area strings based on:
//  - layerUnits:  We assume the layer to be specified in these units.
//  - displayUnit: Values are converted from layerUnits to displayUnits for display
//  - precision:   Number of digits shown
//  - scaleFactor: Optional scale factor applied to all values
var SimpleUnitHandler = /*#__PURE__*/function (_UnitHandler) {_inherits(SimpleUnitHandler, _UnitHandler);var _super = _createSuper(SimpleUnitHandler);

  function SimpleUnitHandler(viewer) {var _this;_classCallCheck(this, SimpleUnitHandler);
    _this = _super.call(this);

    _this.viewer = viewer;

    _this.config = {
      // {string} We assume layers to be in these units (in GNU units format)
      layerUnits: DefaultUnits,

      // {string} Units in which we display lengths/areas (in GNU units format)
      displayUnits: DefaultUnits,

      // {number} Number of digits that we display
      precision: DefaultPrecision,

      // {number} Optional scale factor applied to all values
      scaleFactor: 1.0,

      // {string} Optional area suffix to alter display unit
      areaSuffix: '^2',

      // {boolean} Optional flag for mixed unit measurements such as m-and-cm to fallback to the larger unit
      noMixedArea: false,

      // {boolean} Optional flag for inches and feet, use 'in' and 'ft' over ' and " respectively.
      preferLetters: false };return _this;

  }_createClass(SimpleUnitHandler, [{ key: "lengthToString", value: function lengthToString(

    val) {
      var cfg = this.config;

      // Convert length units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val);

      // Format length value with unit string
      return avp.formatValueWithUnits(val, cfg.displayUnits, 3, cfg.precision, { preferLetters: cfg.preferLetters });
    } }, { key: "areaToString", value: function areaToString(

    val) {
      var cfg = this.config;

      // Convert area units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val, 'square');

      // Format area value with unit string
      var units = cfg.displayUnits ? "".concat(cfg.displayUnits).concat(cfg.areaSuffix) : null;
      return avp.formatValueWithUnits(val, units, 3, cfg.precision, { noMixedArea: cfg.noMixedArea, preferLetters: cfg.preferLetters });
    } }]);return SimpleUnitHandler;}(UnitHandler);


// The DefaultUnitHandler synchronizes the unit configuration based on current viewer model 
// and current settings from MeasureToolExtension:
//  - If MeasureExtension is loaded, it displays in the same way as Measure tools
//  - If MeasureExtension is not loaded, it just uses units of the current model without unit conversion.
//  - If there is not even a model, it falls back to a fixed default configuration (see SimpleUnitHandler)
var DefaultUnitHandler = /*#__PURE__*/function (_SimpleUnitHandler) {_inherits(DefaultUnitHandler, _SimpleUnitHandler);var _super2 = _createSuper(DefaultUnitHandler);

  function DefaultUnitHandler(viewer) {var _this2;_classCallCheck(this, DefaultUnitHandler);
    _this2 = _super2.call(this, viewer);

    _this2.measureTransform = new _MeasureTransform_js__WEBPACK_IMPORTED_MODULE_0__["DefaultMeasureTransform"](viewer);return _this2;
  }_createClass(DefaultUnitHandler, [{ key: "updateConfig", value: function updateConfig()

    {
      var cfg = this.config;

      // Assume values to be in model units or default units
      var model = this.viewer.model;
      cfg.layerUnits = model ? model.getUnitString() : DefaultUnits;

      // Set other configuration values
      var ext = this.viewer.getExtension('Autodesk.Measure');
      var msrCfg = ext && ext.sharedMeasureConfig;
      if (msrCfg) {
        // get from measure extension
        cfg.displayUnits = msrCfg.units;
        cfg.precision = msrCfg.precision;
        cfg.scaleFactor = msrCfg.calibrationFactor;
      } else {
        // No Measure extension available => use defaults
        cfg.displayUnits = this.config.layerUnits;
        cfg.precision = DefaultPrecision;
        cfg.scaleFactor = 1.0;
      }
    } }, { key: "lengthToString", value: function lengthToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "lengthToString", this).call(this, val);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "areaToString", this).call(this, val);
    } }]);return DefaultUnitHandler;}(SimpleUnitHandler);

/***/ }),

/***/ "./extensions/Edit2D/tools/CopyTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/CopyTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CopyTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Clipboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Clipboard.js */ "./extensions/Edit2D/Clipboard.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var CopyToolName = 'Edit2_CopyTool';

var av = Autodesk.Viewing;

// Apply constant offset in x/y for each paste step, so that pasted shapes are not exactly on top of the src shapes.
var PasteOffset = 30;var

CopyTool = /*#__PURE__*/function () {

  function CopyTool(ctx) {var _this = this;_classCallCheck(this, CopyTool);

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.viewer = ctx.viewer;
    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.clipboard = ctx.clipboard;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    this.enableCut = false;

    // Track when this tool is posting shapes to the clipboard.
    // Used to avoid modifying the pasteCounter when this tool is posting shapes.
    // This is a reference to the array being posted or null. An array is used rather than
    // a flag in case a clipboard listener posts to the clipboard during a callback.
    this.shapesBeingPosted = null;
    // Tracks the number of times the clipboard contents have been pasted.
    // Pasted shapes are offset whenever the counter is greater than zero.
    // Set the counter to a negative value to prevent offsetting for some pastes.
    this.pasteCounter = 0;

    this.onClipboardContentChanged = function (event) {
      if (event.shapes !== _this.shapesBeingPosted) {
        // Do not apply offset to the first paste of content placed on the clipboard by other code
        // to preserve its location
        _this.pasteCounter = -1;
      }
    };
  }_createClass(CopyTool, [{ key: "register", value: function register()

    {
      this.clipboard.addEventListener(_Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"].CONTENT_CHANGED, this.onClipboardContentChanged);
    } }, { key: "deregister", value: function deregister()

    {
      this.clipboard.removeEventListener(_Clipboard_js__WEBPACK_IMPORTED_MODULE_1__["default"].CONTENT_CHANGED, this.onClipboardContentChanged);
    } }, { key: "_postSelectedShapesToClipboard", value: function _postSelectedShapesToClipboard()

    {
      var shapes = this.selection.getSelectedShapes();

      this.shapesBeingPosted = shapes;
      this.clipboard.postShapes(shapes);
      this.shapesBeingPosted = null;

      return shapes;
    }


    /**
       * Copy the currently selected shapes to the clipboard.
       *
       * Each time the shapes are pasted, they will be offset from their original positions (first paste)
       * or their last pasted positions. The offset currently doesn't change with the undo/redo of paste operations.
       */ }, { key: "copy", value: function copy()
    {
      this._postSelectedShapesToClipboard();
      this.pasteCounter = 0;
    }

    /**
       * Cut the currently selected shapes to the clipboard.
       *
       * Each time the shapes are pasted, they will be in their original positions (first paste)
       * or offset from their last pasted positions. The offset currently doesn't change with the
       * undo/redo of paste operations.
       */ }, { key: "cut", value: function cut()
    {
      var shapes = this._postSelectedShapesToClipboard();
      // Do not apply offset to the first paste
      this.pasteCounter = -1;

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].RemoveShapes(this.layer, shapes));
    }

    /**
       * Paste clones of the shapes from the clipboard.
       *
       * Pasting will not occur if the BEFORE_PASTE event is vetoed.
       * Shapes may be offset from their original or previously pasted positions depending on
       * how they were posted to the clipboard (whether by this tool's copy/cut operations,
       * or application code)
       */ }, { key: "paste", value: function paste()
    {
      this.pasteCounter++;
      var shapes = this.clipboard.cloneShapes();

      var beforePasteEvent = { type: CopyTool.BEFORE_PASTE, veto: false };
      this.dispatchEvent(beforePasteEvent);
      if (beforePasteEvent.veto) {
        return;
      }

      if (this.pasteCounter > 0) {
        // Compute how far we want to shift the copy that we create.
        // We shift by 30 pixels, then by 60, etc.
        var shapeOffset = this.pasteCounter * PasteOffset * this.layer.getUnitsPerPixel();
        shapes.forEach(function (shape) {return shape.move(shapeOffset, shapeOffset);});
      }

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].AddShapes(this.layer, shapes));
      // Change selection to new shapes
      this.selection.setSelection(shapes);

      this.dispatchEvent({ type: CopyTool.AFTER_PASTE, shapes: shapes });
    }

    /**
       * Delete all selected shapes
       */ }, { key: "delete", value: function _delete()
    {
      var shapes = this.selection.getSelectedShapes();
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].RemoveShapes(this.layer, shapes));
      this.selection.clear();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      // Accept command key on Mac as alternative to ctrl.
      var ctrlKey = event.ctrlKey || event.metaKey;

      if (!this.selection.empty()) {
        if (keyCode === av.KeyCode.DELETE) {
          this.delete();
          return true;
        }

        if (ctrlKey) {
          if (keyCode === av.KeyCode.c) {
            this.copy();
            return true;
          }
          if (this.enableCut && keyCode === av.KeyCode.x) {
            this.cut();
            return true;
          }
        }
      }

      if (this.clipboard.hasShapes() && ctrlKey && keyCode === av.KeyCode.v) {
        this.paste();
        return true;
      }

      return false;
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return CopyToolName + this.nameSuffix;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }]);return CopyTool;}();
;

CopyTool.BEFORE_PASTE = "BEFORE_PASTE";
CopyTool.AFTER_PASTE = "AFTER_PASTE";

/***/ }),

/***/ "./extensions/Edit2D/tools/EdgeMoveTool.js":
/*!*************************************************!*\
  !*** ./extensions/Edit2D/tools/EdgeMoveTool.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EdgeMoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}






var EdgeMoveToolName = "Edit2_EdgeMoveTool";

var av = Autodesk.Viewing;

var edgeGizmoName = function edgeGizmoName(index) {
  return 'PolygonEditTool_edgeGizmo_' + index.toString();
};

// Given a Polyline/Polygon and a vertex index, check if the two edges next to 'vertex' are collinear.
// Returns false if vertex does not have 2 different neighbor edges.
var edgesCollinear = function edgesCollinear(poly, vertex, loopIndex) {

  // If polygon/polyline just contains 0 or 1 edges, just return false.
  var vertexCount = poly.getVertexCount(loopIndex);
  if (vertexCount < 3) {
    return false;
  }

  // check if neighbor edges exist
  var isLine = poly.isPolyline();
  var prevExists = !(isLine && vertex === 0);
  var nextExists = !(isLine && vertex === vertexCount - 1);

  // If poly has only 1 edge or 'vertex' is an end vertex of a polyline, stop here.
  if (!prevExists || !nextExists) {
    return false;
  }

  // get points before and after vertex
  var prevIndex = poly.prevIndex(vertex, loopIndex);
  var nextIndex = poly.nextIndex(vertex, loopIndex);

  var precision = 1.e-5;

  var a = poly.getPoint(prevIndex, loopIndex);
  var b = poly.getPoint(vertex, loopIndex);
  var c = poly.getPoint(nextIndex, loopIndex);
  return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].isPointOnLine(b, a, c, precision);
};var

EdgeMoveTool = /*#__PURE__*/function (_EditToolBase) {_inherits(EdgeMoveTool, _EditToolBase);var _super = _createSuper(EdgeMoveTool);

  function EdgeMoveTool(ctx) {var _this;var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};_classCallCheck(this, EdgeMoveTool);
    _this = _super.call(this, ctx);

    _this.options = options;
    _this.layer = ctx.layer;
    _this.selection = ctx.selection;
    _this.nameSuffix = "_".concat(ctx.toolSetName);

    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;

    // When dragging an edge, this stores a copy of its original position
    _this.dragEdgeStartPos = {
      a: new THREE.Vector2(),
      b: new THREE.Vector2() };


    // Last drag position in layer coords
    _this.lastDragPoint = new THREE.Vector2();

    // Index of the edge being dragged or -1
    _this.draggedEdge = null; // {PolyIndex}

    // When dragging an edge, selectedEdge is the same as draggedEdge. After the interaction, draggedEdge is reset to -1, but
    // the edge keeps selected until clicking somewhere else.
    _this.selectedEdge = null; // {PolyIndex}

    // In some cases, we duplicate start/end vertex when beginning to drag an edge. This may shift this.draggedEdge by 1 or 2.
    // draggedEdgeBefore stores the original edgeIndex before duplicating vertices.
    _this.draggedEdgeBefore = null; //{PolyIndex};

    // Reused to store edge normal of dragged edge
    _this.draggedEdgeNormal = new THREE.Vector2();

    // When dragging edges, we store the offset (in layer-coords) between the accurate click position and the center of the clicked edge gizmo
    // Stored in pixels.
    _this.dragOffset = new THREE.Vector2(0, 0);

    // Used when dragging an edge: Indicates whether we had to duplicate 
    // start/end vertex of the edge in order to move it.
    _this.duplicateStartVertex = false;
    _this.duplicateEndVertex = false;

    // {EdgeGizmo[][]} Array of Gizmos per loop for moving edges. 
    _this.edgeGizmos = [];

    // Used to highlight a dragged edge in a different color by drawing a single-edge overlay.
    _this.edgeGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Polyline"]();
    _this.edgeGizmoShown = false; // indicates that gizmo is currently added to gizmoLayer

    // Displays dashed lines that connect start/end vertex of arc segments
    _this.arcEdgeGizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["ArcEdgeGizmo"](ctx.layer, ctx.gizmoLayer);

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);

    // Constant color for highlighted edges
    _this.edgeHighlightStyle = _this.options.edgeHighlightStyle || new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["Style"]({ lineColor: 'rgb(0, 255, 0)' });

    _this.gizmoClassName = _this.options.gizmoClassName;return _this;
  }_createClass(EdgeMoveTool, [{ key: "getName", value: function getName()

    {
      return EdgeMoveToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(EdgeMoveTool.prototype), "deactivate", this).call(this);
      this.reset();
    }

    // Enable the length labels (public API)
  }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      if (!this.poly) {
        return;
      }

      this.setSelectedEdge(null);

      // Handle Edge-Move: If we hit an EdgeGizmo, start dragging it
      var selectedEdgeGizmo = this.getEdgeIndex();

      if (this.edgeMovePossible() && selectedEdgeGizmo) {
        this.startedDragging = true;
        this.startDragEdge(event, selectedEdgeGizmo);
        return true;
      }

      return false;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleMouseMove", this).call(this, event);

      this.updateEdgeGizmo();

      if (!this.poly) {
        return false;
      }

      if (this.draggedEdge) {
        this.moveDragEdge(event);

        return true;
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleButtonUp", this).call(this, event, button);

      var wasDragging = this.startedDragging;
      this.startedDragging = false;

      if (!this.poly) {
        return;
      }

      if (this.draggedEdge) {
        this.endDragEdge();
        return true;
      }

      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,
      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.
      return !this.ignoreDragging && wasDragging;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(EdgeMoveTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      if (keyCode === this.keyMap.CancelEdit) {
        handled = this.cancelDrag();
      }

      return handled;
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.
      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      if (this.draggedEdge) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    }

    // Returns the index of the edge gizmo under mouse (or -1 if no EdgeGizmo is hit)
    // (x,y) are in layer-coords
    //  @returns {PolyIndex}
  }, { key: "getEdgeIndex", value: function getEdgeIndex() {
      for (var l = 0; l < this.edgeGizmos.length; l++) {
        var gizmos = this.edgeGizmos[l];
        var index = this.gizmoManager.getGizmoIndex(gizmos);
        if (index !== -1) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyIndex"]({ vertex: index, loop: l });
        }
      }
      return null;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.draggedEdge) {
        this.restoreDragEdge();
        this.draggedEdge = null;
        needsUpdate = true;
      }

      if (needsUpdate) {
        this.updateAllGizmos();
        this.layer.update();
      }

      this.snapper.clearSnappingGizmos();

      return needsUpdate;
    } }, { key: "handleExternalAction", value: function handleExternalAction(

    action, isUndo) {

      // make sure that selected edge/vertex are still valid (or switched off)
      this.updateSelectionState(action, isUndo);

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      // Sync gizmos in case vertices were modified
      this.updateAllGizmos();

      this.snapper.clearSnappingGizmos();
    }

    // Updates selection of shape(s), vertex, and edge after an action
  }, { key: "updateSelectionState", value: function updateSelectionState(action, isUndo) {

      // Check if the action provides a hint how we should update selection
      var hint = action.getSelectionHint(isUndo);
      if (hint) {
        this.setSelectedEdge(hint.edge);

        return;
      }

      // Default behavior - if we don't know anything better:
      //  - Keep shape selected if still existing
      //  - Reset vertex/edge selection

      // If shape was removed, reset state
      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      // If poly was modified from outside, we can't know if the selected vertex or edge
      // still exist or have the same meaning. E.g., when undo/redoing a vertex-insert, the indices may have shifted.
      this.setSelectedEdge(null);
    } }, { key: "startDragEdge", value: function startDragEdge(

    event, draggedEdge) {
      var edgeIndex = draggedEdge.vertex;
      var loopIndex = draggedEdge.loop;

      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // store edge normal for the edge being dragged
      this.draggedEdgeNormal = this.poly.getLeftEdgeNormal(edgeIndex, loopIndex, this.draggedEdgeNormal);

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeIndex, a, b, loopIndex);

      // get edge direction
      var edgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b);

      // compute projection of p to the line spanned by the edge
      var pointOnEdge = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].projectToLine(pointOnEdge, a, edgeDir);

      // Set inital dragging point exactly on edge
      this.lastDragPoint.copy(pointOnEdge);

      // Store offset between exact mouse pos and the edge we are dragging
      var edgePosScreen = this.layer.layerToCanvas(pointOnEdge.x, pointOnEdge.y);
      this.dragOffset.set(edgePosScreen.x - event.canvasX, edgePosScreen.y - event.canvasY);

      // store original position of the two edge vertices
      var ia = edgeIndex;
      var ib = (edgeIndex + 1) % this.poly.getVertexCount(loopIndex);
      this.dragEdgeStartPos.a.copy(this.poly.getPoint(ia, loopIndex));
      this.dragEdgeStartPos.b.copy(this.poly.getPoint(ib, loopIndex));

      // Check if we need to duplicate start and/or end vertex of the edge.
      // This happens when the neighbor edges are collinear with the ones being moved.
      this.duplicateStartVertex = edgesCollinear(this.poly, ia, loopIndex);
      this.duplicateEndVertex = edgesCollinear(this.poly, ib, loopIndex);

      // Duplicate start/end vertices if necessary
      _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge.duplicateVertices(this.poly, edgeIndex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // Store initial edge index (not considering any duplicated vertices)
      this.draggedEdgeBefore = draggedEdge;

      // Select the edge - using its index after duplicating vertices
      var newEdgeIndex = _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge.getNewEdgeIndex(this.poly, edgeIndex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);
      var polyIndex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyIndex"]({ vertex: newEdgeIndex, loop: loopIndex });
      this.setSelectedEdge(polyIndex);

      // Set the edge being dragged
      this.draggedEdge = polyIndex;

      // Make sure that all gizmos are updated if we duplicated vertices
      if (this.duplicateStartVertex || this.duplicateEndVertex) {
        this.updateAllGizmos();
      }
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();

      // Activate if exactly one shape is selected
      var shape = selected.length == 1 ? selected[0] : null;
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      this.poly = null;
      this.draggedEdge = null;
      this.selectedEdge = null;

      // Clear any gizmos from previous polygon
      this.updateAllGizmos();

      this.lengthLabel.setShape(null);

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.updateAllGizmos();
      }

      var polyline = poly && poly.isPolyline() ? poly : null;
      this.lengthLabel.setShape(polyline);
    }

    // Update edgeGizmos to this.poly or hide all if poly is null
  }, { key: "createEdgeGizmos", value: function createEdgeGizmos() {
      // Make sure that we don't leak outdated ones
      this.clearEdgeGizmos();

      var hasEdgeMoveGizmos = false;

      var loopCount = this.poly ? this.poly.loopCount : 0;
      for (var l = 0; l < loopCount; l++) {

        // Create gizmo per edge
        var edgeCount = this.poly.getEdgeCount(l);

        // For simple lines, we don't show the edge-move gizmo: It does not make sense to
        // move an edge, because you can simply move the whole shape instead.
        var needEdgeMoveGizmos = edgeCount >= 2;

        var gizmos = [];
        if (needEdgeMoveGizmos) {
          for (var i = 0; i < edgeCount; i++) {
            var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["EdgeMoveGizmo"](this.layer, edgeGizmoName(i), undefined, this.gizmoClassName);
            gizmo.attachToEdge(this.poly, i, l);
            gizmos.push(gizmo);
          }

          hasEdgeMoveGizmos = true;
        }

        // add gizmos for this loop
        this.edgeGizmos.push(gizmos);
      }

      // attach arcEdgeGizmo to current shape, so that dashed lines are displayed for its arc segments
      this.arcEdgeGizmo.setPoly(this.poly);

      this.updateEdgeGizmoHighlighting();

      // Shift label a bit up to avoid it from occluding the move-edge gizmo
      var yOffset = hasEdgeMoveGizmos ? 20 : 0;
      this.lengthLabel.pixelOffset.set(0, yOffset);
    } }, { key: "moveDragEdge", value: function moveDragEdge(

    event) {

      if (!this.draggedEdge) {
        return;
      }

      var edgeIndex = this.draggedEdge.vertex;
      var loopIndex = this.draggedEdge.loop;

      // Note that the edge we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a edge gizmo at drag-start.
      var x = event.canvasX + this.dragOffset.x;
      var y = event.canvasY + this.dragOffset.y;

      var p = this.getSnapPosition(x, y);

      // get delta between last and current position
      var delta = p.clone().sub(this.lastDragPoint);

      // get indices of prev and next edge
      var prevEdgeIndex = this.poly.prevEdgeIndex(edgeIndex, loopIndex);
      var nextEdgeIndex = this.poly.nextEdgeIndex(edgeIndex, loopIndex);

      // prev/next edge may not exist if we are at the end of a polyline
      var prevEdgeExists = prevEdgeIndex !== -1;
      var nextEdgeExists = nextEdgeIndex !== -1;

      // Will contain the new edge endpoints
      var newEdgeA = new THREE.Vector2();
      var newEdgeB = new THREE.Vector2();

      // get edge vertices
      var curEdgeA = new THREE.Vector2();
      var curEdgeB = new THREE.Vector2();
      this.poly.getEdge(edgeIndex, curEdgeA, curEdgeB, loopIndex);

      if (!prevEdgeExists && !nextEdgeExists) {
        // If prev/next are both missing, we are moving an isoldated line segment around.
        // In this case, we can just allow unconstrained moving and are done here.
        newEdgeA.copy(curEdgeA).add(delta);
        newEdgeB.copy(curEdgeB).add(delta);
      } else {

        // get next/previous edge (if existing)
        var prevEdgeA = new THREE.Vector2();
        var prevEdgeB = new THREE.Vector2();
        var nextEdgeA = new THREE.Vector2();
        var nextEdgeB = new THREE.Vector2();
        prevEdgeExists && this.poly.getEdge(prevEdgeIndex, prevEdgeA, prevEdgeB, loopIndex);
        nextEdgeExists && this.poly.getEdge(nextEdgeIndex, nextEdgeA, nextEdgeB, loopIndex);

        // Handle start edges of polylines: Choose some "assumed" previous edge if there is none. 
        if (!prevEdgeExists) {

          prevEdgeB.copy(curEdgeA);

          if (!this.duplicateEndVertex) {
            // Assume previous edge to be parallel to the next one. In this
            // way, we constrain the movement only along one direction.
            prevEdgeA.copy(nextEdgeB).sub(curEdgeB).add(curEdgeA);
          } else {
            // The second edge was collinear with the first, so we had to add an extra vertex at dragStart.
            // Therefore, nextEdge is degenerated and we cannot use it.
            // For this case, we just assume prevEdge to be perpendicular to the current edge.
            prevEdgeA.copy(curEdgeA).add(this.draggedEdgeNormal);
          }
        }

        // Handle end edges of polylines: Choose some "assumed" next edge if there is none
        if (!nextEdgeExists) {

          nextEdgeA.copy(curEdgeB);

          if (!this.duplicateStartVertex) {
            // Assume next edge to be parallel to the previous one. In this
            // way, we constrain the movement only along one direction.
            nextEdgeB.copy(prevEdgeA).sub(curEdgeA).add(curEdgeB);
          } else {
            // The previous edge was collinear with the current one, so we had to add an extra vertex at dragStart.
            // Therefore, prevEdge is degenerated and we cannot use it.
            // For this case, we just assume nextEdge to be perpendicular to the current edge.
            nextEdgeB.copy(curEdgeB).add(this.draggedEdgeNormal);
          }
        }

        // Compute directions for each edge to intersect
        var prevEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(prevEdgeA, prevEdgeB);
        var curEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(curEdgeA, curEdgeB);
        var nextEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(nextEdgeA, nextEdgeB);

        // Apply move offset
        curEdgeA.add(delta);
        curEdgeB.add(delta);

        // If we added extra vertices, the (newly inserted) neighbor edges will be degenerated
        // and the edge directions will be invalid. In this case, we choose the edge direction
        // perpendicular to the edge that we are dragging.
        if (this.duplicateStartVertex) prevEdgeDir.copy(this.draggedEdgeNormal);
        if (this.duplicateEndVertex) nextEdgeDir.copy(this.draggedEdgeNormal);

        // Compute new edge endpoints as intersection of prev/next edge with the moved line
        if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(prevEdgeA, prevEdgeDir, curEdgeA, curEdgeDir, newEdgeA) ||
        !_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(nextEdgeA, nextEdgeDir, curEdgeA, curEdgeDir, newEdgeB)) {
          // If we don't find an intersection, reject this edge move attempt, because
          // it's not possible to move the edge in this way by enlarging the neighbor edges.
          return;
        }
      }

      // get indices of the points to modify
      var ia = edgeIndex;
      var ib = this.poly.nextIndex(ia, loopIndex);

      // The intersections gives us the new position for the edge vertices
      this.poly.updatePoint(ia, newEdgeA.x, newEdgeA.y, loopIndex);
      this.poly.updatePoint(ib, newEdgeB.x, newEdgeB.y, loopIndex);

      this.gizmoLayer.update();
      this.layer.update();

      this.lastDragPoint.copy(p);

      // We moved the edge => Keep gizmo in-sync
      this.updateEdgeGizmo();
    }

    // While dragging an edge, this function restores the original position at drag start
  }, { key: "restoreDragEdge", value: function restoreDragEdge() {

      if (!this.draggedEdge) {
        return;
      }

      var edgeIndex = this.draggedEdge.vertex;
      var loopIndex = this.draggedEdge.loop;

      var a = this.dragEdgeStartPos.a;
      var b = this.dragEdgeStartPos.b;

      var ia = edgeIndex;
      var ib = this.poly.nextIndex(ia, loopIndex);

      this.poly.updatePoint(ia, a.x, a.y, loopIndex);
      this.poly.updatePoint(ib, b.x, b.y, loopIndex);

      // Revert insertion of extra vertices
      _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge.revertDuplicateVertices(this.poly, this.draggedEdgeBefore.vertex, loopIndex, this.duplicateStartVertex, this.duplicateEndVertex);

      // If we duplicated vertices at dragStart and reverted it now, 
      // the index of the selected edge may have shifted. So, we must change it to the old one to keep to (visually) keep the same 
      // edge selected as before.
      this.selectedEdge = this.draggedEdgeBefore;
    } }, { key: "endDragEdge", value: function endDragEdge()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (!this.draggedEdge) {
        return;
      }
      var edgeIndex = this.draggedEdge.vertex;
      var loopIndex = this.draggedEdge.loop;

      // get final position of the edge vertices
      var ia = edgeIndex;
      var ib = this.poly.nextIndex(ia, loopIndex);

      var newPos1 = this.poly.getPoint(ia, loopIndex);
      var newPos2 = this.poly.getPoint(ib, loopIndex);

      this.restoreDragEdge();

      // If the edge was hardly moved at all, we drop the operation. Otherwise, the only effect would be to add invisible
      // vertex duplicates.
      var delta = this.dragEdgeStartPos.a.distanceTo(newPos1) * this.layer.getPixelsPerUnit();
      if (delta >= 3) {
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveEdge(this.layer, this.poly, this.draggedEdgeBefore, newPos1, newPos2, this.duplicateStartVertex, this.duplicateEndVertex));

        // If the action duplicated vertices, make sure that the selected edge is updated to
        // the index that the selected edge has after the action.
        this.selectedEdge = this.draggedEdge;
      }

      // Reset draggedEdge, but the edge keeps selected (we don't reset this.selectedEdge)
      this.draggedEdge = null;

      // update all gizmos
      this.updateAllGizmos();
    } }, { key: "edgeMovePossible", value: function edgeMovePossible(

    loopIndex) {
      return this.poly && this.poly.getVertexCount(loopIndex) > 2;
    }

    // Make sure that EdgeGizmo is up-to-date: Its purpose is to highlight the edge being dragged.
  }, { key: "updateEdgeGizmo", value: function updateEdgeGizmo() {

      // Check if mouse is on an edge gizmo
      var edgeUnderMouse = this.getEdgeIndex(); // {PolyIndex}

      var edgeMovePossible = this.edgeMovePossible();

      // Check if we need any highlight
      var edgeSelected = Boolean(this.poly && this.selectedEdge);
      var edgeHovered = edgeMovePossible && edgeUnderMouse;

      // If edge is an arc and hovered, we just colorize the arcEdgeGizmo and don't need the extra edge-highlight gizmo
      var arcEdgeHovered = edgeHovered && this.poly.isPath() && this.poly.isArc(edgeUnderMouse.vertex, edgeUnderMouse.loop);

      // We show the gizmo if an edge is selected or a line-segment is hovered.
      var gizmoNeeded = edgeSelected || edgeHovered && !arcEdgeHovered;

      // Make sure that edge gizmo is shown if needed
      if (gizmoNeeded && !this.edgeGizmoShown) {
        this.gizmoLayer.addShape(this.edgeGizmo);
        this.edgeGizmoShown = true;
      } else
      if (!gizmoNeeded && this.edgeGizmoShown) {
        this.gizmoLayer.removeShape(this.edgeGizmo);
        this.edgeGizmoShown = false;
      }

      // get index of the edge to be highlighted
      var polyIndex = edgeSelected ? this.selectedEdge : edgeUnderMouse; // {PolyBase}
      var edgeToHighlight = polyIndex ? polyIndex.vertex : -1;
      var loopIndex = polyIndex ? polyIndex.loop : -1;

      // Only for arcs: Colorize ArcEdgeGizmo if needed. For hover, this replaces the highlight gizmo. For select, we just set it to the same color to avoid color conflicts.
      var colorizeArcEdge = this.edgeGizmoShown || arcEdgeHovered;
      colorizeArcEdge ? this.arcEdgeGizmo.setEdgeHighlighted(edgeToHighlight, loopIndex, this.edgeHighlightStyle.lineColor) : this.arcEdgeGizmo.clearEdgeHighlighting();

      // If we just had to hide it, we are done here
      if (!gizmoNeeded) {
        return;
      }

      // Update edge gizmo position...

      // get the two vertex positions of the edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeToHighlight, a, b, loopIndex);

      // copy values to edge gizmo
      this.edgeGizmo.makeLine(a.x, a.y, b.x, b.y);

      this.edgeGizmo.style = this.edgeHighlightStyle;

      // Adopt lineWidth from selected polygon
      this.edgeGizmo.style.lineWidth = this.poly.style.lineWidth;
      this.edgeGizmo.style.isScreenSpace = this.poly.style.isScreenSpace;

      if (edgeSelected) {
        this.edgeGizmo.style.lineAlpha = 1.0;
      } else {
        // Just make it a bit brighter using a semitransparent white overlay
        this.edgeGizmo.style.lineAlpha = 0.5;
      }

      this.gizmoLayer.update();
    }

    // @param {PolyIndex}
  }, { key: "setSelectedEdge", value: function setSelectedEdge(polyIndex) {
      this.selectedEdge = polyIndex;
      this.updateEdgeGizmo();
      this.updateEdgeGizmoHighlighting();
    } }, { key: "clearEdgeGizmos", value: function clearEdgeGizmos()

    {
      for (var l = 0; l < this.edgeGizmos.length; l++) {
        var gizmos = this.edgeGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          gizmos[i].dtor();
        }
      }
      this.edgeGizmos.length = 0;

      // Clear dashed lines between start/endPoint of arcs.
      this.arcEdgeGizmo.setPoly(null);
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    }

    // Update edge gizmos (for edge highlighting)
  }, { key: "updateAllGizmos", value: function updateAllGizmos() {
      this.updateEdgeGizmo();
      this.createEdgeGizmos();
      this.updateEdgeGizmoHighlighting();
      this.snapper.clearSnappingGizmos();
    }

    // Update selection highlighting for edge gizmos
  }, { key: "updateEdgeGizmoHighlighting", value: function updateEdgeGizmoHighlighting() {
      var edgeIndex = this.selectedEdge ? this.selectedEdge.vertex : -1;
      var loopIndex = this.selectedEdge ? this.selectedEdge.loop : -1;

      for (var l = 0; l < this.edgeGizmos.length; l++) {
        var gizmos = this.edgeGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          var gizmo = gizmos[i];
          var selected = i === edgeIndex && l === loopIndex;
          gizmo.setSelected(selected);
        }
      }
    } }]);return EdgeMoveTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/EditToolBase.js":
/*!*************************************************!*\
  !*** ./extensions/Edit2D/tools/EditToolBase.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditToolBase; });
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var av = Autodesk.Viewing;


// Utility class shared by Edit2D tools to facilitate snapping
var EditToolBase = /*#__PURE__*/function () {

  function EditToolBase(ctx) {var _this = this;_classCallCheck(this, EditToolBase);

    this.viewer = ctx.viewer;
    this.setGlobalManager(this.viewer.globalManager);
    this.layer = ctx.layer;
    this.gizmoLayer = ctx.gizmoLayer;
    this.snapper = ctx.snapper;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.unitHandler = ctx.unitHandler;
    this.nameSuffix = "_".concat(ctx.toolSetName);
    this.mouseTracker = ctx.mouseTracker; // needed for tracking mouse in Edit 2D

    // If true, all mouse-dragging handlers just return false, so that the events are handled by LMV navigation tools instead.
    this.ignoreDragging = false;

    // This flag is used to avoid triggering handleExternalAction if we triggered an action ourselves.
    this.ignoreActions = false;

    // If another tool applies changes while this tool is active, we want to keep the tool state consistent.
    // E.g., the UndoTool or CopyTool may be active in parallel and may modify/remove a polygon we are working on.
    // his event listener makes sure that handleExternalAction() is called in this case so that this tool can respond. 
    this.onActionCb = function (event) {
      if (!_this.ignoreActions) {
        _this.handleExternalAction(event.action, event.isUndo);
      }
    };

    // indicates if snapping is currently suppressed by hold modifier key
    this.suppressSnapping = false;

    this.keyMap = {
      SnapKey: av.KeyCode.SHIFT, // Holding this key suppresses snapping
      PanKey: av.KeyCode.SPACE // Holding space bypasses all edit tools, so that default navigation (usually panning) steps in
    };

    // When using selection, register a handler to notify about selection changed
    if (this.selection) {
      this.selectionCb = function () {

        // Only respond if tool is activated
        if (!_this.active) {
          return;
        }

        // Call handler if derived class defines one
        _this.onSelectionChanged && _this.onSelectionChanged();
      };

      this.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
    }

    this.active = false;

    // Track last mouse position in canvas coords. Note that derived classes must call
    // the base class mouse handlers to keep this value valid.
    this.canvasPos = new THREE.Vector2();

    // Tracks which gizmo is under mouse
    this.gizmoManager = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_2__["GizmoManager"]();

    // Track which keys are currently hold down
    this.keyState = {
      ctrl: false,
      shift: false,
      alt: false };

  }_createClass(EditToolBase, [{ key: "getSnapPosition", value: function getSnapPosition(

    canvasX, canvasY) {var _this2 = this;
      var useSnapper = this.snapper && !this.suppressSnapping;
      if (useSnapper) {
        return this.snapper.getSnapPosition(canvasX, canvasY, function (s) {return _this2.snappingFilter(s);});
      } else {
        // Make sure that we don't keep outdated snapping gizmos
        this.snapper.clearSnappingGizmos();

        // Just convert canvas pos to layer pos
        return this.layer.canvasToLayer(canvasX, canvasY);
      }
    } }, { key: "dtor", value: function dtor()

    {
      if (this.selectionCb) {
        this.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
      }
    } }, { key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      this.keyState[keyCode] = true;

      // Hold key to suppress snapping
      if (keyCode === this.keyMap.SnapKey && !this.suppressSnapping) {
        this.suppressSnapping = true;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      // While edit tools are active the BACKSPACE key should not make the browser go back in history, otherwise
      // the customer might lose his drawings when he's in an editing session, does a invalid selection and
      // hits backspace.
      if (keyCode === av.KeyCode.BACKSPACE) {
        return true;
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = true;
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {

      this.keyState[keyCode] = false;

      if (keyCode === this.keyMap.SnapKey && this.suppressSnapping) {
        this.suppressSnapping = false;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = false;
      }
    }

    // Invoked whenever another tool triggered 
  }, { key: "handleExternalAction", value: function handleExternalAction(action, isUndo) {}

    // Run an action without triggering handleExternalAction
  }, { key: "runAction", value: function runAction(action) {
      this.ignoreActions = true;
      this.undoStack.run(action);
      this.ignoreActions = false;
    } }, { key: "activate", value: function activate()

    {
      this.active = true;
      this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
    } }, { key: "deactivate", value: function deactivate()

    {
      this.active = false;
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);

      // Make sure we don't keep outdated snapping indicators
      this.snapper && this.snapper.clearSnappingGizmos();
    } }, { key: "register", value: function register()

    {}

    // Maps a key event to a function key in the key-map.
  }, { key: "mapKey", value: function mapKey(event, keyMap) {

      for (var key in keyMap) {
        var assigned = keyMap[key];

        // Skip disabled key commands
        if (assigned === null) {
          continue;
        }

        // If a single key is assigned to this function and it matches, return the function key
        if (event.keyCode == assigned) {
          return key;
        }

        // If multiple keys are assigned, check if one matches.
        if (Array.isArray(assigned) && assigned.includes(event.keyCode)) {
          return key;
        }

        // If it is an object, it may define modifiers and a custom filter
        if (_typeof(assigned) === 'object') {
          var ctrl = assigned.ctrlKey === undefined ? true : assigned.ctrlKey === event.ctrlKey;
          var shift = assigned.shiftKey === undefined ? true : assigned.shiftKey === event.shiftKey;
          var alt = assigned.altKey === undefined ? true : assigned.altKey === event.altKey;
          var meta = assigned.meta === undefined ? true : assigned.metaKey === event.metaKey;

          // return true if code and all (assigned) modifiers match
          var match = assigned.keyCode === event.keyCode && ctrl && shift && alt && meta;
          if (match) {
            return key;
          }
        }

        // Allow generic key-handler function
        if (typeof assigned === 'function' && assigned(event)) {
          return key;
        }
      }
      // event does not match any assigned keyCode
      return null;
    } }, { key: "snappingFilter",

    // By default, we consider all EditShapes for snapping
    value: function snappingFilter() {
      return true;
    }

    // pass mouse changes to method provided to extension
  }, { key: "trackMouseHook", value: function trackMouseHook(event) {
      if (this.mouseTracker) {
        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
        this.mouseTracker.trackMouse(event, p);
      }
    }

    // Remember last mouse position
  }, { key: "trackMousePos", value: function trackMousePos(e) {
      this.trackMouseHook(e);
      this.canvasPos.set(e.canvasX, e.canvasY);
      this.gizmoManager.update(e);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    e) {this.trackMousePos(e);} }, { key: "handleSingleClick", value: function handleSingleClick(
    e) {this.trackMousePos(e);} }, { key: "handleDoubleClick", value: function handleDoubleClick(
    e) {this.trackMousePos(e);} }, { key: "handleButtonUp", value: function handleButtonUp(
    e) {this.trackMousePos(e);} }, { key: "handleButtonDown", value: function handleButtonDown(
    e) {this.trackMousePos(e);} }]);return EditToolBase;}();
;

av.GlobalManagerMixin.call(EditToolBase.prototype);

/***/ }),

/***/ "./extensions/Edit2D/tools/InsertSymbolTool.js":
/*!*****************************************************!*\
  !*** ./extensions/Edit2D/tools/InsertSymbolTool.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InsertSymbolTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}



var InsertSymbolToolName = "Edit2_InsertSymbolTool";var

InsertSymbolTool = /*#__PURE__*/function (_EditToolBase) {_inherits(InsertSymbolTool, _EditToolBase);var _super = _createSuper(InsertSymbolTool);

  function InsertSymbolTool(ctx) {var _this;_classCallCheck(this, InsertSymbolTool);
    _this = _super.call(this, ctx);

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.symbol = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"](0, 0,
    0.2,
    new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      fillAlpha: 1.0,
      lineWidth: 0.01,
      fillColor: 'rgb(255, 255, 0)' }));return _this;

  }_createClass(InsertSymbolTool, [{ key: "getName", value: function getName()

    {
      return InsertSymbolToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "setSymbol", value: function setSymbol(

    symbol) {
      this.symbol = symbol;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event) {

      var res = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var symbol = this.symbol.clone();
      symbol.move(res.x, res.y);

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, symbol));

      this.dispatchEvent({ type: InsertSymbolTool.SYMBOL_INSERTED, symbol: symbol });

      return true;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick()

    /*event , button */{
      return true;
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return InsertSymbolTool;}(_EditToolBase__WEBPACK_IMPORTED_MODULE_2__["default"]);


InsertSymbolTool.SYMBOL_INSERTED = "symbolInserted";

/***/ }),

/***/ "./extensions/Edit2D/tools/LineTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/LineTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LineTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../CanvasGizmo */ "./extensions/Edit2D/CanvasGizmo.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}







var LineToolName = "Edit2_LineTool";

var av = Autodesk.Viewing;

// Draws lines with single drag
var LineTool = /*#__PURE__*/function (_EditToolBase) {_inherits(LineTool, _EditToolBase);var _super = _createSuper(LineTool);

  function LineTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, LineTool);
    _this = _super.call(this, ctx);

    _this.style = style;

    // New polyline created by dragging
    _this.line = null;

    // Start/Endpoint of the line being dragged
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create length label. Default hidden - showing is optional.
    _this.lengthLabel = new _CanvasGizmo__WEBPACK_IMPORTED_MODULE_4__["LengthLabel"](null, _this.layer, ctx.unitHandler, false);

    // If true, create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the length labels (public API)
  _createClass(LineTool, [{ key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.lengthLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return LineToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      // Make sure that we consider latest end-coords
      this.handleMouseMove(event);

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.line) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }
      var points = [startPos.clone(), startPos.clone()];
      var style = this.style.clone();

      this.line = this.enableArcs ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolylinePath"](points, style) : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"](points, style);
      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.line);
    } }, { key: "updateLine", value: function updateLine()

    {

      if (!this.isDragging()) {
        return;
      }

      this.line.updatePoint(1, this.endPoint.x, this.endPoint.y);
      this.gizmoLayer.update();

      this.lengthLabel.setShape(this.line);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateLine();
    } }, { key: "endDrag", value: function endDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (!this.line) {
        return false;
      }

      // Remove temporary gizmo shape
      this.gizmoLayer.removeShape(this.line);

      // Add line shape if valid
      var lineValid = !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].edgeIsDegenerated(this.startPoint, this.endPoint);
      if (lineValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.line));
      }

      this.line = null;

      this.lengthLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (this.line) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.line);
        this.line = null;

        this.dragCanceled = true;

        this.lengthLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.line);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(false);
      }
    } }]);return LineTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/MoveTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/MoveTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var MoveToolName = "Edit2_MoveTool";

var av = Autodesk.Viewing;var

MoveTool = /*#__PURE__*/function () {

  function MoveTool(ctx) {_classCallCheck(this, MoveTool);

    this.layer = ctx.layer;
    this.gizmoLayer = ctx.gizmoLayer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // Only set during dragging
    this.shapes = null; // Shape[]

    // Optioanl: Only move a single loop. Only supported if only a single shape is selected.
    this.loopIndex = -1;

    // drag-start position in layer coords
    this.dragStartPoint = new THREE.Vector2();

    // backup original shapes on drag-start as long as we are modifying it on-hover
    this.backupShapes = null; // Shape[]

    this.keyMap = {
      CancelEdit: av.KeyCode.ESCAPE };


    // Remember last mouse-pos on mouse-move events
    this.lastMousePos = new THREE.Vector2(); // in layer coords

    this.mouseTracker = ctx.mouseTracker;
  }_createClass(MoveTool, [{ key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "getName", value: function getName()

    {
      return MoveToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleSingleClick", value: function handleSingleClick()

    /*event , button */{
      var shapesToMove = this.selection.getSelectedShapes();
      return shapesToMove && shapesToMove.length > 0;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick()

    /*event , button */{
      var shapesToMove = this.selection.getSelectedShapes();
      return shapesToMove && shapesToMove.length > 0;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var hitShape = this.layer.hitTest(p.x, p.y);

      if (!hitShape) {
        this.selection.clear();
        return false;
      }

      // If shape was not selected before, select it
      var wasSelected = hitShape && this.selection.shapeIsSelected(hitShape);
      if (!wasSelected) {
        this.selection.selectOnly(hitShape);
      }

      // Move all selected shapes
      var shapesToMove = this.selection.getSelectedShapes();
      if (shapesToMove.length > 0) {
        this.startDrag(shapesToMove, p);
      }

      return true;
    }

    // Start dragging one or more shapes
    //  @param {Shape[]} shapes
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(shapes, startPos) {var loopIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      this.shapes = shapes;
      this.loopIndex = loopIndex;
      this.dragStartPoint.copy(startPos);
      this.backupShapes = shapes.map(function (s) {return s.clone();});
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p) {var _this = this;
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;

      // Apply this offset to shape. We always start with the original shape as a reference 
      // to avoid accumulating delta inaccuracies.
      this.shapes.forEach(function (shape, i) {
        shape.copy(_this.backupShapes[i]);

        if (_this.loopIndex === -1) {
          // Default: Move whole shape(s)
          shape.move(dx, dy);
        } else {
          // Only move single loop
          shape.moveLoop(dx, dy, _this.loopIndex);
        }
      });
      this.layer.update();
      this.gizmoLayer.update();
    }

    // Clean up data hold during a drag interaction
  }, { key: "resetDragging", value: function resetDragging() {
      this.shapes = null;
      this.loopIndex = -1;
      this.backupShapes = null;
    } }, { key: "endDrag", value: function endDrag(

    p) {var _this2 = this;
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // No drag active
      if (!this.shapes) {
        return;
      }

      // Revert any temporary modifications done during mouse move
      this.shapes.forEach(function (shape, i) {return shape.copy(_this2.backupShapes[i]);});

      // Apply move operation
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;

      if (this.loopIndex === -1) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveShapes(this.layer, this.shapes, dx, dy));
      } else {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveLoop(this.layer, this.shapes[0], this.loopIndex, dx, dy));
      }

      this.shapes = null;
      this.loopIndex = -1;
      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {var _this3 = this;
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (this.isDragging()) {

        // Revert shape o state when dragging was started
        this.shapes.forEach(function (shape, i) {return shape.copy(_this3.backupShapes[i]);});
        this.layer.update();
        this.gizmoLayer.update();

        this.resetDragging();

        this.startedDragging = true;

        return true;
      }

      return false;
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.shapes);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get and store latest mouse position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.lastMousePos.copy(p);

      if (!this.shapes) {
        return false;
      }

      // get delta between last and current position        
      this.moveDrag(p);

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var wasDragging = this.startedDragging;
      this.startedDragging = false;

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      return this.endDrag(p) || wasDragging;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (keyCode === this.keyMap.CancelEdit) {
        return this.cancelDrag();
      }

      return;
    }

    // Display move cursor if a shape is under mouse or if we are dragging
  }, { key: "getCursor", value: function getCursor() {
      if (this.shape) {
        return 'move';
      }

      // Show move cursor if a shape is under mouse
      var shapeAtMouse = this.layer.hitTest(this.lastMousePos.x, this.lastMousePos.y);
      return shapeAtMouse ? 'move' : undefined;
    } }]);return MoveTool;}();

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonEditTool.js":
/*!****************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonEditTool.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonEditTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../TangentGizmo.js */ "./extensions/Edit2D/TangentGizmo.js");
/* harmony import */ var _EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../EllipseArcGizmo.js */ "./extensions/Edit2D/EllipseArcGizmo.js");
/* harmony import */ var _MoveTool_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./VertexMoveTool.js */ "./extensions/Edit2D/tools/VertexMoveTool.js");
/* harmony import */ var _EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./EdgeMoveTool.js */ "./extensions/Edit2D/tools/EdgeMoveTool.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}












var PolygonEditToolName = 'Edit2_PolygonEditTool';

var av = Autodesk.Viewing;

// Allow to pick an edge within 
var EdgeSelectTolerance = 17;var

PolygonEditTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonEditTool, _EditToolBase);var _super = _createSuper(PolygonEditTool);

  function PolygonEditTool(ctx) {var _this;_classCallCheck(this, PolygonEditTool);
    _this = _super.call(this, ctx);

    _this.moveTool = new _MoveTool_js__WEBPACK_IMPORTED_MODULE_6__["default"](ctx);
    _this.edgeMoveTool = new _EdgeMoveTool_js__WEBPACK_IMPORTED_MODULE_8__["default"](ctx);
    _this.vertexMoveTool = new _VertexMoveTool_js__WEBPACK_IMPORTED_MODULE_7__["default"](ctx);

    // Only set during dragging
    _this.poly = null;

    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;
    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;
    _this.keyMap.ChangeToArc = av.KeyCode.a; // Change selected edge to arc
    _this.keyMap.ChangeToLine = av.KeyCode.l; // Change selected edge to line
    _this.keyMap.ChangeToEllipse = av.KeyCode.e; // Change selected edge to ellipse arc

    // Track mouse position in layer-coords
    _this.mousePos = new THREE.Vector2();

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);

    // {TangentGizmo[]} Array of TangentGizmos for BezierArcs
    _this.tangentGizmos = [];

    // If true, we apply hover-highlight on shape under mouse.
    _this.hoverEnabled = true;

    // If true, we allow changing edge type to ellipse arcs.
    _this.enableEllipseArcs = false;

    // Ellipse-arc gizmo. Only shown if an ellipse-edge is selected
    _this.ellipseArcGizmo = new _EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__["EllipseArcGizmo"](ctx.layer, _this.gizmoManager, ctx.undoStack, false);

    // Used in mouseDown handler: Indicates that mouse-down has been consumed by this tool, so that
    // other LMV tools shouldn't handle the singleClick either. This avoids unwanted LMV object selection
    // after ctrl-click on Edit2D shapes.
    _this.clickConsumed = false;return _this;
  }_createClass(PolygonEditTool, [{ key: "setHoverEnabled", value: function setHoverEnabled(

    enabled) {

      // On disable, make sure that we don't leave any highlight behind
      if (this.hoverEnabled && !enabled) {
        this.selection.setHovered(null);
      }

      this.hoverEnabled = enabled;
    }

    // Enable the area labels (public API)
  }, { key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    }

    // Enable the length labels (public API)
  }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(visible) {
      this.edgeMoveTool.setLengthLabelVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return PolygonEditToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "deactivate", this).call(this);
      this.reset();
    }

    // Update vertex-gizmos, and tangent gizmos.
  }, { key: "updateAllGizmos", value: function updateAllGizmos() {
      this.updateTangentGizmos();
      this.updateEllipseArcGizmo();
      this.updateMouseOverHighlights();
      this.vertexMoveTool.updateAllGizmos();
      this.edgeMoveTool.updateAllGizmos();
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      this.poly = null;

      this.vertexMoveTool.reset();
      this.edgeMoveTool.reset();

      // Clear any gizmos from previous polygon
      this.updateAllGizmos();

      // Cleanup area and length labels
      this.areaLabel.setShape(null);

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.updateAllGizmos();
      }

      // Sync label with polygon or polyline. If this.poly is null, it will be hidden
      var polygon = poly && poly.isPolygon() ? poly : null;
      this.areaLabel.setShape(polygon);
    } }, { key: "insertPoint", value: function insertPoint(

    polyIndex, p) {

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddVertex(this.layer, this.poly, polyIndex, p));

      // removeupdate edge gizmos and tangent gizmos
      this.updateAllGizmos();

      // Display polygon change and new gizmo
      this.layer.update();
    }

    // Remove loop (including any other loop it contains)
  }, { key: "removeLoop", value: function removeLoop(loopIndex) {

      // Collect all loops to remove
      var loopsToRemove = this.poly.getChildLoops(loopIndex);
      loopsToRemove.push(loopIndex);

      var action = new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveLoops(this.layer, this.poly, loopsToRemove);
      this.runAction(action);

      // Reset vertex/edge selection. We cannot keep it because the meaning of loopIndices has changed.
      this.vertexMoveTool.setSelectedVertex(null);
      this.edgeMoveTool.setSelectedEdge(null);

      this.updateAllGizmos();
      this.layer.update();
    } }, { key: "removePoint", value: function removePoint(

    polyIndex) {var

      loop = polyIndex.loop;

      // If removing a vertex would make the loop degenerate, remove it completely        
      var minVerts = this.poly.isPolygon() ? 3 : 2;
      if (this.poly.getVertexCount(loop) <= minVerts) {
        this.removeLoop(loop);
        return;
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveVertex(this.layer, this.poly, polyIndex));

      // update vertex gizmos
      this.vertexMoveTool.updateVertexGizmos();

      // update edge gizmos and tangent gizmos
      this.updateAllGizmos();

      // Make sure that this vertex is not selected anymore
      if (polyIndex.equals(this.vertexMoveTool.selectedVertex)) {
        this.vertexMoveTool.setSelectedVertex(null);
      }

      // Unselect edge if edgeIndex got invalid        
      this.edgeMoveTool.setSelectedEdge(null);

      this.layer.update();
    } }, { key: "isSingleLine", value: function isSingleLine()

    {
      return this.poly && this.poly.loopCount === 1 && this.poly.getVertexCount(0) === 2;
    }

    // If the given mousePos (in layerCoords) is located close to an edge (not edge gizmo), 
    // the edge index is returned, otherwise null.
    //  @returns {PolyIndex|null}
  }, { key: "findEdgeUnderMouse", value: function findEdgeUnderMouse(pos) {
      if (!this.poly) {
        return null;
      }

      var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
      for (var l = 0; l < this.poly.loopCount; l++) {
        var index = this.poly.findEdgeIndex(pos, precision, l);
        if (index !== -1) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: index, loop: l });
        }
      }
      return null;
    }

    // Checks if a point p can be inserted to split the given edge. If so, it returns the projected
    // position that is located exactly on edge to be split.
    //
    //  @param {Vector2} p           - pos in layer coords - usually close to given edge.
    //  @param {PolyIndex} polyIndex - index of the edge to be split by this vertex
    //  @returns {Vector2|null} Adjusted position where the new point will be added.
  }, { key: "getNewVertexPosition", value: function getNewVertexPosition(p, polyIndex) {

      if (!this.poly || !polyIndex) {
        return null;
      }

      var edgeIndex = polyIndex.vertex;
      var loopIndex = polyIndex.loop;
      if (!this.poly.edgeIndexValid(edgeIndex, loopIndex)) {
        return null;
      }

      // get edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeIndex, a, b, loopIndex);

      // get edge direction
      var edgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(a, b);

      // compute projection of p to the line spanned by the edge
      var newPos = p.clone();
      _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].projectToLine(newPos, a, edgeDir);

      // Reject position if the projection is outside the segment
      if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].isPointOnEdge(newPos, a, b, 0.0001)) {
        return null;
      }

      // Return position where to insert the new vertex
      return newPos;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.mousePos.copy(p);

      if (this.vertexMoveTool.handleButtonDown(event, button)) {
        this.edgeMoveTool.setSelectedEdge(null);
        return true;
      }

      // Note: In LMV, ToolController handles command key and ctrl key in the same way.
      //       For consistency, we do the same here.
      var ctrlHold = event.ctrlKey || event.metaKey;

      // Handle Vertex-Add: Check if we hold ctrl and hit an edge
      var newVertex = -1;
      if (ctrlHold) {
        // Is mouse close to an edge and can be projected onto that edge?
        var _edgeIndex = this.findEdgeUnderMouse(this.mousePos);
        var newVertexPos = this.getNewVertexPosition(this.mousePos, _edgeIndex);
        if (newVertexPos) {
          // We don't insert exactly at the mouse position. Instead, new vertices
          // are always located exactly on the edge being split. Therefore, newVertexPos is
          // usually slightly different from mousePos.

          // insert new vertex after edge starting point
          newVertex = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: _edgeIndex.vertex + 1, loop: _edgeIndex.loop });
          this.insertPoint(newVertex, newVertexPos);

          // Allow to drag the new vertex immediately
          if (this.mouseTracker) {
            this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonDown);
          }
          this.vertexMoveTool.startDragVertex(event, newVertex);

          return true;
        }
      }

      // Handle dragging of TangentGizmo control points for Bezier arcs.
      for (var i = 0; i < this.tangentGizmos.length; i++) {
        var gizmo = this.tangentGizmos[i];
        if (gizmo.onButtonDown(event.canvasX, event.canvasY)) {
          // We started dragging of a Bezier control point
          return true;
        }
      }

      // Handle dragging of EllipseArc gizmo
      if (this.ellipseArcGizmo.startDrag(event.canvasX, event.canvasY)) {
        if (this.mouseTracker) {
          this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonDown);
        }
        // We started dragging an ellipse arc
        return true;
      }

      // Reset selection highlighting of vertices.
      this.vertexMoveTool.setSelectedVertex(null);

      if (this.edgeMoveTool.handleButtonDown(event, button)) {
        this.updateTangentGizmos();
        this.updateEllipseArcGizmo();
        return true;
      }

      // Check which polygon was hit
      var newPolygon = this.layer.hitTest(p.x, p.y);

      // Handle multiselect
      if (this.enableMultiselection && ctrlHold && newPolygon) {
        this.selection.toggleSelection(newPolygon);

        // eat mouseUp event as well. Otherwise, LMV defaultHandler will select objects in the background in parallel
        this.clickConsumed = true;
        return true;
      }

      // Check if click was close to an edge of the current polygon.
      var edgeIndex = this.poly && this.findEdgeUnderMouse(this.mousePos);

      // Since tolerance for edge selection is higher, the edge shape hitTest may slightly miss
      // the polygon, but we may be close to an edge. In this case, consider the shape as being it as well.
      if (!newPolygon && edgeIndex) {
        newPolygon = this.poly;
      }

      // If we just clicked inside the already selected polygon, delegate it to MoveTool.        
      if (this.selection.shapeIsSelected(newPolygon)) {

        var loopIndex = edgeIndex ? edgeIndex.loop : -1;

        // Allow moving loops - unless it is a single outer one
        var mainLoops = this.poly && this.poly.getMainLoops();
        var isOnlyMainLoop = mainLoops && mainLoops.length === 1 && mainLoops[0] === loopIndex;

        // Handle single-loop move
        var moveLoop = edgeIndex && !isOnlyMainLoop;
        if (moveLoop) {
          // Move single loop
          this.moveTool.startDrag([this.poly], p, loopIndex);
        } else {
          // Move selected shape(s)
          var shapesToMove = this.selection.getSelectedShapes();
          this.moveTool.startDrag(shapesToMove, p);
        }
        return true;
      }

      // If the clicked object is neither polygon nor polyline, ignore it.
      var isPolygon = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"];
      var isPolyline = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"];
      var isPath = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"];
      if (!isPolygon && !isPolyline && !isPath) {
        newPolygon = null;
      }

      // Set selection to current polygon. This will also trigger setEditPoly() 
      // via selectionChanged event.
      this.selection.selectOnly(newPolygon);

      return false;
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    e) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleSingleClick", this).call(this, e);

      var handled = this.clickConsumed || Boolean(this.poly);

      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      this.clickConsumed = false;
      return handled;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleMouseMove", this).call(this, event);

      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));
      this.updateMouseOverHighlights();

      if (this.moveTool.isDragging()) {
        this.moveTool.moveDrag(this.mousePos);
      }

      if (!this.poly) {
        return false;
      }

      if (this.vertexMoveTool.handleMouseMove(event)) {
        return true;
      }

      if (this.edgeMoveTool.handleMouseMove(event)) {
        return true;
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        tangentGizmo.moveDrag(event.canvasX, event.canvasY);
      }

      // Check if we are dragging the ellipseArc gizmo
      if (this.ellipseArcGizmo.dragging) {
        return this.ellipseArcGizmo.moveDrag(event.canvasX, event.canvasY);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonUp", this).call(this, event, button);

      // Avoid triggering the handler for external modifications, because we control the EdgeMoveTool ourselves
      this.ignoreActions = true;
      var handled = this.vertexMoveTool.handleButtonUp(event, button);
      this.ignoreActions = false;

      if (handled) {
        return true;
      }

      // Avoid triggering the handler for external modifications, because we control the EdgeMoveTool ourselves
      this.ignoreActions = true;
      handled = this.edgeMoveTool.handleButtonUp(event, button);
      this.ignoreActions = false;

      if (handled) {
        return true;
      }

      if (this.moveTool.isDragging()) {
        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);

        // Avoid triggering the handler for external modifications, because we control the MoveTool ourselves
        this.ignoreActions = true;
        this.moveTool.endDrag(p);
        this.ignoreActions = false;

        return true;
      }

      // Check if we are dragging an endpoint of any tangent gizmo
      var tangentGizmo = this.findDraggedTangentGizmo();
      if (tangentGizmo) {
        if (this.mouseTracker) {
          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonUp);
        }
        tangentGizmo.endDrag(event.canvasX, event.canvasY);
      }

      // Check if we are dragging the center of an ellipse arc
      if (this.ellipseArcGizmo.dragging) {
        if (this.mouseTracker) {
          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.ButtonUp);
        }
        this.ellipseArcGizmo.endDrag(event.canvasX, event.canvasY);

      }

      // We let other tools down the stack such as the MoveTool and EdgeMoveTool handle the button up.
      return false;
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();

      // Activate if exactly one shape is selected
      var shape = selected.length == 1 ? selected[0] : null;
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }

      this.vertexMoveTool.onSelectionChanged();
      this.edgeMoveTool.onSelectionChanged();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      // Needed in order to update suppressSnapping
      this.vertexMoveTool.handleKeyDown(event, keyCode);
      this.edgeMoveTool.handleKeyDown(event, keyCode);

      if (keyCode === this.keyMap.DeleteSelectedVertex) {
        if (this.poly && this.vertexMoveTool.selectedVertex) {
          this.removePoint(this.vertexMoveTool.selectedVertex);
          handled = true;
        }
      }

      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
        return true;
      }

      // Check if we have an edge to work on
      var targetEdge = this.isSingleLine() ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyIndex"]({ vertex: 0, loop: 0 }) : this.edgeMoveTool.selectedEdge; // If we have just a single segment, we don't need edge selection.
      var targetEdgeValid = Boolean(this.poly && targetEdge && this.poly.edgeIndexValid(targetEdge.vertex, targetEdge.loop));

      if (keyCode === this.keyMap.ChangeToArc) {

        // If a line segment is selected, convert it to an arc
        var lineSegmentSelected = targetEdgeValid && !this.poly.isBezierArc(targetEdge.vertex, targetEdge.loop);
        if (lineSegmentSelected) {
          this.changeEdgeToBezier(targetEdge);
        }
        return true;
      }

      if (keyCode === this.keyMap.ChangeToEllipse) {

        // If a line segment is selected, convert it to an arc
        var segmentSelected = targetEdgeValid && !this.poly.isEllipseArc(targetEdge.vertex, targetEdge.loop);
        if (segmentSelected) {
          this.changeEdgeToEllipse(targetEdge);
        }
        return true;
      }

      if (keyCode === this.keyMap.ChangeToLine) {
        // If an arc segment is selected, convert it to a line
        var arcSegmentSelected = targetEdgeValid && this.poly.isArc(targetEdge.vertex, targetEdge.loop);
        if (arcSegmentSelected) {
          this.changeEdgeToLine(targetEdge);
        }
      }

      return handled;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), "handleKeyUp", this).call(this, event, keyCode);

      // Needed in order to update suppressSnapping
      this.vertexMoveTool.handleKeyUp(event, keyCode);
      this.edgeMoveTool.handleKeyUp(event, keyCode);

      return handled;
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {
      this.vertexMoveTool.onSnappingToggled(canvasX, canvasY);
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.vertexMoveTool.cancelDrag()) {
        needsUpdate = true;
      }

      if (this.edgeMoveTool.cancelDrag()) {
        needsUpdate = true;
      }

      if (this.moveTool.cancelDrag()) {
        needsUpdate = true;
      }

      this.tangentGizmos.forEach(function (tg) {
        if (tg.isDragging()) {
          tg.cancelDrag();
          needsUpdate = true;
        }
      });

      if (needsUpdate) {
        this.updateAllGizmos();
        this.layer.update();
      }

      if (this.ellipseArcGizmo.dragging) {
        if (this.mouseTracker) {
          this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
        }
        this.ellipseArcGizmo.cancelDrag();
        this.updateAllGizmos();
      }

      this.snapper.clearSnappingGizmos();
    }

    // Updates selection of shape(s), vertex, and edge after an action
  }, { key: "updateSelectionState", value: function updateSelectionState(action, isUndo) {

      // If the action is invoked by our own TangentGizmo, attach the currently selected item on first run.
      // This allows us to recover later whether a vertex or an edge was selected.
      if (action instanceof _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeBezierTangent) {
        var _hint = action.getSelectionHint(isUndo);
        if (!_hint) {
          action.setSelectionItem(
          this.vertexMoveTool.selectedVertex,
          this.edgeMoveTool.selectedEdge);

        }
      }

      // Check if the action provides a hint how we should update selection
      var hint = action.getSelectionHint(isUndo);
      if (hint) {

        // apply shape selection
        var shapes = hint.shape ? [hint.shape] : hint.shapes;
        this.selection.setSelection(shapes);

        this.vertexMoveTool.setSelectedVertex(hint.vertex);
        this.edgeMoveTool.setSelectedEdge(hint.edge);

        return;
      }

      // Default behavior - if we don't know anything better:
      //  - Keep shape selected if still existing
      //  - Reset vertex/edge selection

      // If shape was removed, reset state
      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      // If poly was modified from outside, we can't know if the selected vertex or edge
      // still exist or have the same meaning. E.g., when undo/redoing a vertex-insert, the indices may have shifted.
      this.vertexMoveTool.setSelectedVertex(null);
      this.edgeMoveTool.setSelectedEdge(null);
    } }, { key: "handleExternalAction", value: function handleExternalAction(

    action, isUndo) {

      // make sure that selected edge/vertex are still valid (or switched off)
      this.updateSelectionState(action, isUndo);

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      // Sync gizmos in case vertices were modified
      this.updateAllGizmos();

      this.snapper.clearSnappingGizmos();
    } }, { key: "updateMouseOverHighlights", value: function updateMouseOverHighlights()


    {
      // Handle mouse-over highlighting for shapes
      if (this.hoverEnabled) {
        var shape = this.layer.hitTest(this.mousePos.x, this.mousePos.y);
        this.selection.setHoveredId(shape ? shape.id : 0);
      }
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.

      var p = this.mousePos;

      // Indicate: "Moving whole shape"
      // While dragging, keep the move-cursor, even if the mouse is temporarily leaving polygon and gizmos
      if (this.moveTool.isDragging()) {
        return 'move';
      }

      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      var vertexEdgeCursor = this.vertexMoveTool.getCursor() || this.edgeMoveTool.getCursor();
      if (vertexEdgeCursor) {
        return vertexEdgeCursor;
      }

      // Indicate: "Moving a ellipse-arc gizmo" to modify radius of an ellipse arc.
      if (this.ellipseArcGizmo.dragging) {
        return 'move';
      }

      // Check if mouse is close to an edge
      var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
      var edgeIndex = this.findEdgeUnderMouse(this.mousePos, precision);

      // Indicate: "Click to insert new vertex"
      //
      // If we are holding down Ctrl (or command) and hover over an edge, clicking would insert a vertex.
      var ctrlHold = this.keyState[av.KeyCode.CONTROL];
      if (ctrlHold) {
        if (edgeIndex) {
          return 'copy';
        }
      }

      // Are we about to move a shape?
      var hitRadius = this.layer.getLineHitRadius(this.poly);
      var moveShape = edgeIndex || this.poly.hitTest(p.x, p.y, hitRadius);
      if (moveShape) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    } }, { key: "clearTangentGizmos", value: function clearTangentGizmos()

    {
      this.tangentGizmos.forEach(function (g) {return g.dtor();});
      this.tangentGizmos.length = 0;
    } }, { key: "updateTangentGizmos", value: function updateTangentGizmos()

    {

      // Clear any previous gizmos (if any)
      this.clearTangentGizmos();

      if (!this.poly || !this.poly.isPath()) {
        return;
      }

      // We only show a tangent gizmo if it has relevance for the selected vertex or edge:
      // For a vertex v with neighbor edges prevEdge und nextEdge, we show a tangent gizmo if...
      //  - v, prevEdge, or nextEdge is selected
      //  - If an edge is selected, the selected edge is an arc
      //  - If v is selected, prevEdge or nextEdge is an arc
      for (var l = 0; l < this.poly.loopCount; l++) {
        var vertexCount = this.poly.getVertexCount(l);
        for (var i = 0; i < vertexCount; i++) {

          var sv = this.vertexMoveTool.selectedVertex;
          var vertexSelected = Boolean(sv && sv.vertex === i && sv.loop === l);

          // get prev/next edge. 
          var prevEdge = this.poly.edgeBeforeVertex(i, l);
          var nextEdge = this.poly.edgeAfterVertex(i, l);

          // edges may not exist at polyline ends
          var prevExists = prevEdge !== -1;
          var nextExists = nextEdge !== -1;

          // check if any neighbor edge is selected
          var se = this.edgeMoveTool.selectedEdge;
          var prevSelected = Boolean(prevExists && se && se.vertex === prevEdge && se.loop === l);
          var nextSelected = Boolean(nextExists && se && se.vertex === nextEdge && se.loop === l);

          // check if any neighbor edge is an arc
          var prevIsArc = prevExists && this.poly.isBezierArc(prevEdge, l);
          var nextIsArc = nextExists && this.poly.isBezierArc(nextEdge, l);

          // If we just have a single line segment, always show the tangent gizmos
          var isSingleLine = this.isSingleLine();

          // Check if we selected an arc edge or a vertex of one
          var arcVertexSelected = vertexSelected && (prevIsArc || nextIsArc);
          var arcEdgeSelected = prevSelected && prevIsArc || nextSelected && nextIsArc;

          // show the gizmo if anything is selected and one of the edges is an arc
          var showTangents = isSingleLine || arcVertexSelected || arcEdgeSelected;
          if (showTangents) {
            this.tangentGizmos.push(new _TangentGizmo_js__WEBPACK_IMPORTED_MODULE_4__["default"](this.poly, i, l, this.layer, this.gizmoLayer, this.gizmoManager, this.undoStack));
          }
        }
      }
    } }, { key: "updateEllipseArcGizmo", value: function updateEllipseArcGizmo()

    {
      var se = this.edgeMoveTool.selectedEdge;

      var edgeSelected = Boolean(se);
      var showGizmo = edgeSelected && this.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"] && this.poly.isEllipseArc(se.vertex, se.loop);
      this.ellipseArcGizmo.setVisible(showGizmo);

      if (!showGizmo) {
        // Make sure that ellipseArcGizmo doesn't keep bound to an edge. Oterhwise, it may
        // cause an error later if that edge is removed.
        this.ellipseArcGizmo.detachFromEdge();
        return;
      }

      this.ellipseArcGizmo.attachToEdge(this.poly, se.vertex, se.loop);
    }

    // If any tangent gizmo is being dragged, it is returned.
    // Result is null if nothing is dragged.
  }, { key: "findDraggedTangentGizmo", value: function findDraggedTangentGizmo() {
      return this.tangentGizmos.find(function (gizmo) {return gizmo.isDragging();});
    }

    // Heuristic for choosing the tangent length when turning a line segment into an arc.
    // The basic idea here is
    //  - When turning all 4 lines of a square into arcs, we should get something that approximates a circle.
    //  - When generalizing that to more fancy cases, it should at least behave consistent and sort-of reasonable (e.g. always keep within a reasonable ratio to segment lengths)
    //
    // Note: It's probably cleaner to always approximate some sort of elliptical arcs for the general case. But that will make things a lot harder (and possibly slower).
    //       So let's get away with the linear-scale cheating for now.
  }, { key: "getVertexTangentLength", value: function getVertexTangentLength(prevLength, nextLength) {

      // Given a square of edge length sqrt(2), the circle passing through all 4 vertices can be
      // approximated by 4 cubic bezier arc segments. The tangents for these bezier arcs all have this length:
      // (See here: http://spencermortensen.com/articles/bezier-circle/)
      var c = 0.551915024494;

      // Scaling down the quad/beziers to a unit quad, we obtain the corresponding tangent lengths for a unit quad as:
      var unitQuadTangentLength = c / Math.SQRT2;

      // For a square of length l, the tangent length scales up accordingly.
      // For different segment lengths, we simply use the average of both lengths.
      var l = 0.5 * (prevLength + nextLength);

      return l * unitQuadTangentLength;
    }

    // Given a corner vertex p and its previous and next neighbor, this function computes an averaged tangent
    // vector that we use if (prev, p) and (p, next) are replaced by Bezier arcs.
  }, { key: "getVertexTangent", value: function getVertexTangent(prev, p, next) {

      // get tangent direction by averaging the edge directions.
      var tangent = new THREE.Vector2().copy(next).sub(prev).normalize();

      // Scale tangent direction
      var prevLength = p.distanceTo(prev);
      var nextLength = p.distanceTo(next);
      var tangentLength = this.getVertexTangentLength(prevLength, nextLength);

      return tangent.multiplyScalar(tangentLength);
    } }, { key: "changeEdgeToEllipse", value: function changeEdgeToEllipse(

    polyIndex) {

      var edgeIndex = polyIndex.vertex;
      var loopIndex = polyIndex.loop;

      // By default, bend outsidde by half of the edge length. In this way, we get a circle centered
      // at the line-segment midpoint.
      var bendRadius = 0.5 * this.poly.getEdgeLength(edgeIndex, loopIndex);
      var arcParams = Object(_EllipseArcGizmo_js__WEBPACK_IMPORTED_MODULE_5__["getEllipseArcEdgeParams"])(this.poly, edgeIndex, loopIndex, bendRadius);
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Ellipse, null, null, arcParams));

      this.layer.update();
      this.edgeMoveTool.setSelectedEdge(polyIndex);
      this.updateAllGizmos();
    } }, { key: "changeEdgeToBezier", value: function changeEdgeToBezier(

    polyIndex) {

      var edgeIndex = polyIndex.vertex;
      var loopIndex = polyIndex.loop;

      var path = this.poly;

      // get neighbor edges
      var prevEdgeIndex = path.prevEdgeIndex(edgeIndex, loopIndex);
      var nextEdgeIndex = path.nextEdgeIndex(edgeIndex, loopIndex);

      // check if neighbor edge exist (usually true unless at the end of a polyline)
      var prevExists = prevEdgeIndex !== -1;
      var nextExists = nextEdgeIndex !== -1;

      // get start/end position of the segment
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      path.getEdge(edgeIndex, a, b, loopIndex);

      // If previous/next edge exist, get their start/endVertex as well
      var prevEdgeA = prevExists && path.getPoint(prevEdgeIndex, loopIndex);
      var nextEdgeB = nextExists && path.getPoint(path.nextIndex(nextEdgeIndex, loopIndex), loopIndex);

      // If prev/nextEdge do not exist, we simply assume length and angle of the missing edge to be the same as the current edge.
      if (!prevExists) prevEdgeA = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(b, a);
      if (!nextExists) nextEdgeB = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(a, b);

      // Control points 0 and 3 are already given by edge a and b
      // Below, we have to determine cp1, cp2 to define the tangents
      var cp1 = null;
      var cp2 = null;

      // Check if previous and next edges are arcs as well
      var prevIsArc = prevExists && path.isBezierArc(prevEdgeIndex, loopIndex);
      var nextIsArc = nextExists && path.isBezierArc(nextEdgeIndex, loopIndex);

      // Determine control point for start tangent cp1
      if (prevIsArc) {
        // Previous edge is an arc: Get start tangent by mirroring the end tangent of that arc.
        var prevCp2 = path.getControlPoint(prevEdgeIndex, 2, loopIndex);
        cp1 = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(prevCp2, a);
      } else {
        // Previous edge is a line: Use average direction of both segments to choose the new tangent
        cp1 = this.getVertexTangent(prevEdgeA, a, b).add(a);
      }

      // Analog for end tangent cp2
      if (nextIsArc) {
        // Next edge is an arc: Get end tangent by mirroring the start tangent of that arc.
        var nextCp1 = path.getControlPoint(nextEdgeIndex, 1, loopIndex);
        cp2 = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].mirrorPointOnPoint(nextCp1, b);
      } else {
        // Next edge is a line: Use average direction of both segments to choose the new tangent
        // Note that we must pass the points in backward order for the end tangent.
        cp2 = this.getVertexTangent(nextEdgeB, b, a).add(b);
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Bezier, cp1, cp2));

      this.layer.update();

      // select the edge so that you can edit its tangents
      this.edgeMoveTool.setSelectedEdge(polyIndex);
      this.updateAllGizmos();
    } }, { key: "changeEdgeToLine", value: function changeEdgeToLine(

    polyIndex) {
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].ChangeEdgeType(this.layer, this.poly, polyIndex, _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["EdgeType"].Line));
      this.layer.update();

      this.edgeMoveTool.setSelectedEdge(polyIndex);
      this.updateAllGizmos();
    } }]);return PolygonEditTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_9__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonTool.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonTool.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _LineTool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}







var Mode = {
  Polyline: 1,
  Polygon: 2 };


var PolygonToolName = "Edit2_PolygonTool";
var PolylineToolName = "Edit2_PolylineTool";

var av = Autodesk.Viewing;
var DefaultStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();var

PolygonTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonTool, _EditToolBase);var _super = _createSuper(PolygonTool);

  function PolygonTool(ctx) {var _this;var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Mode.Polygon;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, PolygonTool);
    _this = _super.call(this, ctx);

    // Delegate single-drag interactions: 
    _this.lineRectTool = mode === Mode.Polygon ?
    new _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__["default"](ctx, style) : // PolygonMode: Draw rect/quad on drag
    new _LineTool_js__WEBPACK_IMPORTED_MODULE_5__["default"](ctx, style) // PolylineMode: Draw simple line on drag
    ;

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    // Circle shapes per vertex
    _this.vertexGizmos = [];

    // The polygon/polyline we are currently creating (if tool is active)
    _this.poly = undefined;

    // Style used for polygon creation
    _this.style = style;

    // Style used to display the thin line to connect last added vertex with current mouse position.        
    _this.edgePreviewStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineWidth: 2,
      isScreenSpace: true,
      lineStyle: 11 // dashed line
    });

    // whether editing Polylines or Polygons
    _this.mode = mode;

    // last canvas position where we added a vertex
    _this.lastClickX = undefined;
    _this.lastClickY = undefined;

    _this.keyMap.CANCEL_EDIT = av.KeyCode.ESCAPE;
    _this.keyMap.REMOVE_LAST_VERTEX = av.KeyCode.BACKSPACE;
    _this.keyMap.FINISH_EDIT = [av.KeyCode.ENTER, av.KeyCode.c];

    // FillGizmo: When editing a polygon, fillGizmo displays the polygon formed by all vertices + mousePos
    _this.fillGizmo = null;

    // OutlineGizmo: Polyline that connects all added vertices
    _this.outlineGizmo = null;

    // Line to connect last added vertex with mouse position
    _this.edgePreviewGizmo = null;

    // Last tracked mouse-pos in layer-coords (after considering snapping)
    _this.mousePos = new THREE.Vector2();

    // Label to display polygon area - hidden by default
    // Note that the polygon preview is in the gizmoLayer. So we add the areaLabel there as well to keep it in sync.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["AreaLabel"](null, _this.gizmoLayer, _this.unitHandler, false);

    // Label to display polyline length
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeLabel"](_this.gizmoLayer, false);

    // If true, we always create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the area labels (public API)
  _createClass(PolygonTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "setLengthLabelVisible", value: function setLengthLabelVisible(

    visible) {
      this.lengthLabel.setVisible(visible);
    }

    // If true, all new shapes are Paths instead of Polygons/Polylines.
  }, { key: "setArcsEnabled", value: function setArcsEnabled(enable) {
      this.enableArcs = enable;
      this.lineRectTool.enableArcs = enable;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonTool.prototype), "deactivate", this).call(this);
      this.cancelEdit();
    }

    // Returns true when editing a Polygon, false when editing a Polyline or nothing.
  }, { key: "isPolygon", value: function isPolygon() {
      return this.poly && this.poly.isPolygon();
    }

    /**
       * Set depending styles for the polygon / polyline tool. It will also set most of the styles to the temporary lines
       * that appear during drawing. Style.isScreenSpace won't be considered.
       * @param {Style} style         - a Style instance
       * @param {boolean} skipDefault - If set (default) just apply the style that differ from the default Style
       */ }, { key: "setStyles", value: function setStyles(
    style) {var skipDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (style.lineColor !== DefaultStyle.lineColor || !skipDefault) {
        this.style.lineColor = style.lineColor;
      }
      if (style.lineAlpha !== DefaultStyle.lineAlpha || !skipDefault) {
        this.style.lineAlpha = style.lineAlpha;
      }
      if (style.lineWidth !== DefaultStyle.lineWidth || !skipDefault) {
        this.style.lineWidth = style.lineWidth;
        this.lineRectTool.style.lineWidth = style.lineWidth;
        this.edgePreviewStyle.lineWidth = style.lineWidth * 2 / 3;
      }
      if (style.lineStyle !== DefaultStyle.lineStyle || !skipDefault) {
        this.style.lineStyle = style.lineStyle;
        this.lineRectTool.style.lineStyle = style.lineStyle;
        // skip this.edgePreviewStyle.lineStyle
      }

      if (style.fillColor !== DefaultStyle.fillColor || !skipDefault) {
        this.style.fillColor = style.fillColor;
      }
      if (style.fillAlpha !== DefaultStyle.fillAlpha || !skipDefault) {
        this.style.fillAlpha = style.fillAlpha;
      }

      // skip isScreenSpace
    }

    // Initialize all gizmos when starting to edit a Polygon/Polyline
  }, { key: "initGizmos", value: function initGizmos() {

      // FillGizmo: Draw fill of polygon formed by added vertices + mousePos
      if (this.isPolygon()) {
        this.fillGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        this.fillGizmo.style.lineAlpha = 0;
        this.gizmoLayer.addShape(this.fillGizmo);
      }

      // OutlineGizmo: Connect added vertices
      this.outlineGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
      this.gizmoLayer.addShape(this.outlineGizmo);

      // CurrentEdgeGizmo: Draw dashed line from last vertex to mousePos.
      this.edgePreviewGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.edgePreviewStyle);
      this.edgePreviewGizmo.style.lineColor = this.poly.style.lineColor;
      this.gizmoLayer.addShape(this.edgePreviewGizmo);

      this.areaLabel.setShape(this.fillGizmo);

      // For Polylines, attach label to preview edge that displays the summed length
      if (this.poly && this.poly.isPolyline()) {
        this.lengthLabel.attachToEdge(this.edgePreviewGizmo, 0);
      }
    } }, { key: "clearGizmos", value: function clearGizmos()

    {
      if (this.fillGizmo) {
        this.gizmoLayer.removeShape(this.fillGizmo);
        this.fillGizmo = null;
      }

      this.areaLabel.setShape(null);
      this.lengthLabel.detachFromEdge();

      if (this.outlineGizmo) {
        this.gizmoLayer.removeShape(this.outlineGizmo);
        this.outlineGizmo = null;
      }

      if (this.edgePreviewGizmo) {
        this.gizmoLayer.removeShape(this.edgePreviewGizmo);
        this.edgePreviewGizmo = null;
      }

      // clear vertex gizmos
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    }

    // Update gizmos and snapping if polygon was modified
  }, { key: "polyModified", value: function polyModified() {
      this.updateGizmos();

      // Configure angle snapping to consider latest state of the polygon
      // Note that angleSnapper requires the shape including "vertex under mouse", while
      // this.poly only contains the already added/clicked vertices.
      // Note that we cannot use fillGizmo here, because it does not exist for polylines.
      var snapGeom = this.poly.clone();
      snapGeom.addPoint(this.mousePos.x, this.mousePos.y);
      this.snapper.startAngleSnapping(snapGeom, this.poly.vertexCount, 0); // For new polygons, loopIndex is always 0
    }

    // Update gizmos if vertices of current polygon/polyline have changed
  }, { key: "updateGizmos", value: function updateGizmos() {

      // FillGizmo: Show fill without outline for the polygon formed by all added
      // vertices + current mousePos
      if (this.fillGizmo) {
        // copy vertices of main polygon (not geom, not style)
        this.fillGizmo.clear();
        for (var i = 0; i < this.poly.vertexCount; i++) {
          var p = this.poly.getPoint(i);
          this.fillGizmo.addPoint(p.x, p.y);
        }
        // add additional point that traces mouse-pos
        this.fillGizmo.addPoint(this.mousePos.x, this.mousePos.y);
      }

      // OutlineGizmo: Solid polyline that connects all added vertices
      this.outlineGizmo.clear();
      if (this.poly.vertexCount >= 2) {
        for (var _i = 0; _i < this.poly.vertexCount; _i++) {
          var _p = this.poly.getPoint(_i);
          this.outlineGizmo.addPoint(_p.x, _p.y);
        }
      }

      // currentEdgeGizmo: Dashed line to connect last added vertex with mouse position
      this.edgePreviewGizmo.clear();
      if (this.poly.vertexCount >= 1) {
        var pLast = this.poly.getPoint(this.poly.vertexCount - 1);
        this.edgePreviewGizmo.addPoint(pLast.x, pLast.y);
        this.edgePreviewGizmo.addPoint(this.mousePos.x, this.mousePos.y);

        this.updateLengthLabel();
      }

      this.gizmoLayer.update();
    } }, { key: "updateLengthLabel", value: function updateLengthLabel()

    {
      // Compute resulting length of polyline including previewEdge
      if (this.poly && this.poly.isPolyline()) {
        // get transform from geometry coords to measure coordinate system
        var transform = this.unitHandler.measureTransform;

        var length = this.poly.getLength(transform) + this.edgePreviewGizmo.getLength(transform);
        var lengthStr = this.unitHandler.lengthToString(length);
        this.lengthLabel.setText(lengthStr);
      }
    } }, { key: "getName", value: function getName()

    {
      return (this.mode === Mode.Polygon ? PolygonToolName : PolylineToolName) + this.nameSuffix;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleMouseMove", this).call(this, event);

      if (!event.buttons) {
        // When not dragging, we always return false here. Otherwise, the event will not propagated
        // to navigation tools, so that the zoom focus is not updated properly.
        this.onHover(event.canvasX, event.canvasY);
        return false;
      }
      return this.lineRectTool.handleMouseMove(event);
    } }, { key: "onHover", value: function onHover(

    canvasX, canvasY) {
      // Check if shape editing is already in progress
      if (!this.poly) {

        // Perform snapping check, so that SnappingIndicator reflects if the start point would be snapped.
        this.getSnapPosition(canvasX, canvasY);
        return;
      }

      var pLayer = this.layer.canvasToLayer(canvasX, canvasY);

      // When hovering the start vertex that will close the polygon (or line-loop), don't show any snapping indicators
      var closingAllowed = this.poly.vertexCount >= 3;
      var startVertexHit = closingAllowed && this.gizmoManager.isUnderMouse(this.vertexGizmos[0]);
      this.setStartVertexHighlighted(startVertexHit); // indicate when hoving closing-vertex
      if (startVertexHit) {
        // Remove snapping indicators
        this.snapper.clearSnappingGizmos();

        // snap position to vertex center
        pLayer.copy(this.vertexGizmos[0].layerPos);
      } else {
        // Standard case: If mouse is not on start vertex, allow standard snapping
        pLayer = this.getSnapPosition(canvasX, canvasY);
      }

      // track last mouse pos
      this.mousePos.copy(pLayer);

      // Just hover: Only update vertex-positions for fillGizmo, edgePreview and alignmentGizmo
      this.edgePreviewGizmo.updatePoint(1, pLayer.x, pLayer.y);
      this.fillGizmo && this.fillGizmo.updatePoint(this.fillGizmo.vertexCount - 1, pLayer.x, pLayer.y); // will be null if this.poly is a Polyline
      this.gizmoLayer.update();
      this.updateLengthLabel();
    }

    // If we have enough vertices, clicking on the first vertex gizmo again will finish the shape.
  }, { key: "handleStartVertexClicked", value: function handleStartVertexClicked(event) {

      if (!this.poly && this.poly.vertexCount < 3) {
        return;
      }

      // For polylines, we have to repeat the first vertex to close it
      if (this.poly.isPolyline()) {
        var pStart = this.poly.getPoint(0);
        this.addVertex(pStart.x, pStart.y);
      }

      // Finish editing
      this.finishPolygon();

      // Make sure that the event is not passed on to ToolManager. Otherwise,
      // we would evaluate it a second time in handleSingleClick()
      event.stopPropagation();
    }

    // Add vertex on single-click
  }, { key: "handleSingleClick", value: function handleSingleClick(event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleSingleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      // Avoid duplicate vertices on double-clicks
      if (this.vertexGizmos.length > 0 && event.canvasX === this.lastClickX && event.canvasY === this.lastClickY) {
        return true;
      }

      this.lastClickX = event.canvasX;
      this.lastClickY = event.canvasY;

      this.mousePos.copy(this.getSnapPosition(event.canvasX, event.canvasY));

      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      // Init polygon on first click
      if (!this.poly) {
        this.startPoly(this.mousePos.x, this.mousePos.y);
      }

      this.addVertex(this.mousePos.x, this.mousePos.y);
      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key. Note that we only need that for dragging operations.
      if (this.ignoreDragging) {
        return false;
      }

      // If no clicks have been made so far, allow to drag line/rectangle.
      if (!this.poly) {
        // Clear the selection, this will make sure all other gizmos get removed
        this.selection.clear();

        return this.lineRectTool.handleButtonDown(event, button);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      return this.lineRectTool.handleButtonUp(event, button);
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleDoubleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      this.finishPolygon();
      return true;
    }

    // Start new polyline or polygon
  }, { key: "startPoly", value: function startPoly(x, y) {

      if (this.enableArcs) {
        // Arcs enabled: Always create Paths
        var isClosed = this.mode === Mode.Polygon;
        this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Path"]([], isClosed, this.style.clone());
      } else {
        // No arcs enabled: Create Polygons or Polylines
        if (this.mode === Mode.Polygon) {
          this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        } else {
          this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
        }
      }

      this.initGizmos();
    } }, { key: "addVertex", value: function addVertex(

    x, y) {var _this2 = this;

      // add "next" point - which will follow the mouse motion 
      // until next click
      this.poly.addPoint(x, y);

      // add vertex-gizmo
      var name = 'PolygonTool_vertexGizmo_' + this.vertexGizmos.length;
      var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["VertexGizmo"](this.gizmoLayer, x, y, name);
      this.vertexGizmos.push(vertex);

      // For the start vertex-gizmo, we register a handler to finish the polygon when clicking it again
      var isStartVertex = this.vertexGizmos.length === 1;
      if (isStartVertex) {
        vertex.container.addEventListener('click', function (e) {return _this2.handleStartVertexClicked(e);});
      }

      this.polyModified();
    } }, { key: "removeLastVertex", value: function removeLastVertex()

    {
      if (!this.poly || !this.poly.vertexCount) {
        return;
      }

      // Cancel edit if there was only the starting point.
      if (this.poly.vertexCount <= 1) {
        this.cancelEdit();
        return;
      }

      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      this.poly.removePoint(this.poly.vertexCount - 1);

      // remove last added vertex gizmo
      var lastGizmo = this.vertexGizmos[this.vertexGizmos.length - 1];
      lastGizmo.dtor();
      this.vertexGizmos.pop();

      this.polyModified();
    } }, { key: "finishPolygon", value: function finishPolygon()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      // remove all vertex gizmos
      this.clearGizmos();

      // Stop snapping to edges of this polygon
      this.snapper.stopAngleSnapping();

      // move polygon to main layer
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].AddShape(this.layer, this.poly));

      this.dispatchEvent({ type: PolygonTool.POLYGON_ADDED, polygon: this.poly });

      // Start another polygon on next click
      this.poly = null;
    } }, { key: "cancelEdit", value: function cancelEdit()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Click);
      }

      if (this.lineRectTool.isDragging()) {
        this.lineRectTool.cancelDrag();
      }

      if (this.poly) {
        this.gizmoLayer.removeShape(this.poly);
        this.poly = null;
      }

      this.clearGizmos();
      this.snapper.stopAngleSnapping();
    } }, { key: "handleFinishKey", value: function handleFinishKey(

    event) {
      if (!this.poly) {
        return false;
      }

      // Avoid closing if it would result in a polygon that is degenerated to a line.
      if (this.isPolygon() && this.poly.vertexCount < 3) {
        return false;
      }

      this.finishPolygon();
      return true;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      // delegate to rectTool
      handled = this.lineRectTool.handleKeyDown(event, keyCode) || handled;

      // Map event to any known key in this.keyMap
      var funcKey = this.mapKey(event, this.keyMap);
      switch (funcKey) {
        case 'CANCEL_EDIT':this.cancelEdit();handled = true;break;
        case 'REMOVE_LAST_VERTEX':this.removeLastVertex();handled = true;break;
        case 'FINISH_EDIT':handled = this.handleFinishKey(event);break;}

      return handled;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyUp", this).call(this, event, keyCode);
      this.lineRectTool.handleKeyUp(event, keyCode);
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {
      this.onHover(canvasX, canvasY);
    } }, { key: "mouseOnStartVertex", value: function mouseOnStartVertex()

    {
      if (!this.vertexGizmos[0]) {
        return false;
      }

      // Check if start vertex was clicked
      return this.gizmoManager(this.this.vertexGizmos[0]);
    } }, { key: "setStartVertexHighlighted", value: function setStartVertexHighlighted(

    enable) {
      if (this.vertexGizmos[0]) {
        this.vertexGizmos[0].setSelected(enable);
      }
    } }, { key: "getCursor", value: function getCursor()

    {
      return 'crosshair';
    } }]);return PolygonTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


PolygonTool.POLYGON_ADDED = "polygonAdded";
PolygonTool.Mode = Mode;

/***/ }),

/***/ "./extensions/Edit2D/tools/RectangleTool.js":
/*!**************************************************!*\
  !*** ./extensions/Edit2D/tools/RectangleTool.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RectangleTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _ModifierMask_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ModifierMask.js */ "./extensions/Edit2D/ModifierMask.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}








var RectangleToolName = "Edit2_RectangleTool";

var av = Autodesk.Viewing;

// Creates rectangles by dragging
var RectangleTool = /*#__PURE__*/function (_EditToolBase) {_inherits(RectangleTool, _EditToolBase);var _super = _createSuper(RectangleTool);

  function RectangleTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, RectangleTool);
    _this = _super.call(this, ctx);

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_this));

    _this.style = style;

    // New polygon created by dragging
    _this.rect = null;

    // First corner of the new rectangle
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, ctx.unitHandler, false);

    // Allow to enable/disable tool based on modifiers
    _this.modifiers = new _ModifierMask_js__WEBPACK_IMPORTED_MODULE_4__["default"]();

    // If true, create Paths instead of Polygons
    _this.enableArcs = true;return _this;
  }

  // Enable the area labels (public API)
  _createClass(RectangleTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return RectangleToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Check if modifers allow starting an interaction
      if (!this.modifiers.accepts(event)) {
        return false;
      }

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return false;
      }

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      // Make sure that we consider latest mouse position
      this.handleMouseMove(event);

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.rect) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }
      var points = [startPos.clone(), startPos.clone(), startPos.clone(), startPos.clone()];
      var style = this.style.clone();

      this.rect = this.enableArcs ? new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolygonPath"](points, style) : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"](points, style);

      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.rect);
    } }, { key: "updateRect", value: function updateRect(

    forceQuad) {

      if (!this.isDragging()) {
        return;
      }

      var p0 = this.startPoint;
      var p1 = this.endPoint;

      if (forceQuad) {

        // Use maximum of dx/dy as edge length
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;

        var edgeLength = Math.max(Math.abs(dx), Math.abs(dy));

        // Consider drag direction to span quad right/left resp. up/down
        var sx = Math.sign(dx);
        var sy = Math.sign(dy);

        this.rect.updatePoint(1, p0.x + edgeLength * sx, p0.y);
        this.rect.updatePoint(2, p0.x + edgeLength * sx, p0.y + edgeLength * sy);
        this.rect.updatePoint(3, p0.x, p0.y + edgeLength * sy);

      } else {
        this.rect.updatePoint(1, p1.x, p0.y);
        this.rect.updatePoint(2, p1.x, p1.y);
        this.rect.updatePoint(3, p0.x, p1.y);
      }

      this.gizmoLayer.update();

      this.areaLabel.setShape(this.rect);
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateRect(forceQuad);
    } }, { key: "endDrag", value: function endDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (!this.rect) {
        return false;
      }

      // Check if rect is valid
      var dx = this.endPoint.x - this.startPoint.x;
      var dy = this.endPoint.y - this.startPoint.y;
      var Eps = 1.e-10;
      var rectValid = Math.abs(dx) > Eps && Math.abs(dy) > Eps;

      // Move shape to main layer (or just remove if invalid)
      this.gizmoLayer.removeShape(this.rect);
      if (rectValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.rect));
      }

      this.rect = null;

      this.areaLabel.setShape(null);

      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      if (this.rect) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.rect);
        this.rect = null;

        this.dragCanceled = true;

        this.areaLabel.setShape(null);
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.rect);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(false);
      }
    } }]);return RectangleTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/UndoTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/UndoTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var UndoToolName = 'Edit2_UndoTool';

var av = Autodesk.Viewing;

// Simple tool that triggers undo/redo in response to a keyboard shortcut
var UndoTool = /*#__PURE__*/function () {

  function UndoTool(undoStack) {_classCallCheck(this, UndoTool);
    this.undoStack = undoStack;
  }_createClass(UndoTool, [{ key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Undo
      //  - Ctrl + Z (Windows)
      //  - Command + Z (Mac)
      // Redo
      // - Ctrl + Shift + Z (Windows)
      // - Command + Shift + Z (Mac)
      // - Ctrl + Y (Used on Windows but not Mac)

      if ((event.ctrlKey || event.metaKey) && keyCode === av.KeyCode.z) {
        if (event.shiftKey) {
          this.undoStack.redo();
        } else {
          this.undoStack.undo();
        }

        return true;
      }

      if (event.ctrlKey && keyCode === av.KeyCode.y) {
        this.undoStack.redo();
        return true;
      }

      return false;
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return UndoToolName;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return UndoTool;}();
;

/***/ }),

/***/ "./extensions/Edit2D/tools/VertexMoveTool.js":
/*!***************************************************!*\
  !*** ./extensions/Edit2D/tools/VertexMoveTool.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexMoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}






var VertexMoveToolName = "Edit2_VertexMoveTool";

var av = Autodesk.Viewing;

var vertexGizmoName = function vertexGizmoName(index, loopIndex) {
  return 'PolygonEditTool_vertexGizmo_' + loopIndex.toString() + '_' + index.toString();
};var

VertexMoveTool = /*#__PURE__*/function (_EditToolBase) {_inherits(VertexMoveTool, _EditToolBase);var _super = _createSuper(VertexMoveTool);

  function VertexMoveTool(ctx) {var _this;_classCallCheck(this, VertexMoveTool);
    _this = _super.call(this, ctx);

    _this.layer = ctx.layer;
    _this.selection = ctx.selection;
    _this.nameSuffix = "_".concat(ctx.toolSetName);

    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;
    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;

    // Track mouse position in layer-coords
    _this.mousePos = new THREE.Vector2();

    // Array of VertexGizmo per loop
    _this.vertexGizmos = []; // VertexGizmo[][]

    // Index of the vertex currently being dragged (or -1 if no dragging is active)
    _this.draggedVertex = null; // {PolyIndex}

    // When dragging a vertex, this stores a copy of its original position
    _this.dragVertexStartPos = new THREE.Vector2();

    // selectedVertex is the one that was last clicked on. It is set together with draggedVertex, 
    // but (unlike draggedVertex) keeps the same after dragEnd.
    // selectedVertex is the one that is highlighted and which will be deleted when pressing backspace.
    _this.selectedVertex = null; // {PolyIndex}       

    // When dragging vertices, we store the offset (in layer-coords) between the accurate click position and the center of the clicked vertex gizmo
    // Stored in pixels.
    _this.dragOffset = new THREE.Vector2(0, 0);

    // Last drag position in layer coords
    _this.lastDragPoint = new THREE.Vector2();return _this;
  }_createClass(VertexMoveTool, [{ key: "getName", value: function getName()

    {
      return VertexMoveToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(VertexMoveTool.prototype), "deactivate", this).call(this);
      this.reset();
    }

    // create VertexGizmos for a single loop
  }, { key: "updateVertexGizmoLoop", value: function updateVertexGizmoLoop(loopIndex) {

      var gizmos = [];
      var vertexCount = this.poly.getVertexCount(loopIndex);
      for (var i = 0; i < vertexCount; i++) {

        // create new vertex gizmo
        var p = this.poly.getPoint(i, loopIndex);
        var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, vertexGizmoName(i, loopIndex));
        vertex.attachToVertex(this.poly, i, loopIndex);
        gizmos.push(vertex);

        // We implement drag-behavior, so we want hover-highlight
        vertex.setHoverEnabled(true);
      }

      this.vertexGizmos[loopIndex] = gizmos;
    }

    // Create VertexGizmos for all loops
  }, { key: "updateVertexGizmos", value: function updateVertexGizmos() {
      // clear any outdated ones
      this.clearVertexGizmos();

      if (this.poly) {
        for (var l = 0; l < this.poly.loopCount; l++) {
          this.updateVertexGizmoLoop(l);
        }
      }

      // Make sure that vertex-highlighting is up to date
      this.updateVertexHighlighting();
    } }, { key: "clearVertexGizmos", value: function clearVertexGizmos()

    {
      for (var l = 0; l < this.vertexGizmos.length; l++) {
        var gizmos = this.vertexGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          gizmos[i].dtor();
        }
      }
      this.vertexGizmos.length = 0;
    }

    // Make sure that only the vertexGizmo is only highlighted for the selectedVertex (if any)
  }, { key: "updateVertexHighlighting", value: function updateVertexHighlighting() {
      var selected = this.selectedVertex;
      for (var l = 0; l < this.vertexGizmos.length; l++) {
        var gizmos = this.vertexGizmos[l];
        for (var i = 0; i < gizmos.length; i++) {
          gizmos[i].setSelected(selected && selected.vertex === i && selected.loop === l);
        }
      }
    }

    // Update vertex-gizmos, and tangent gizmos.
  }, { key: "updateAllGizmos", value: function updateAllGizmos() {
      this.updateVertexGizmos();
    }

    // @param{PolyIndex} polyIndex
  }, { key: "setSelectedVertex", value: function setSelectedVertex(polyIndex) {
      this.selectedVertex = this.poly ? polyIndex : null;
      this.updateVertexHighlighting();
    }

    // Return index of the vertex gizmo under mouse. (or null if no vertexGizmo is hit)
    // returns {PolyIndex} 
  }, { key: "findVertexUnderMouse", value: function findVertexUnderMouse() {
      var vertexIndex = -1;
      for (var l = 0; l < this.vertexGizmos.length; l++) {
        var gizmos = this.vertexGizmos[l];
        vertexIndex = this.gizmoManager.getGizmoIndex(gizmos);

        // Return vertex index if we found one.
        if (vertexIndex >= 0) {
          return new _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyIndex"]({
            loop: l,
            vertex: vertexIndex });

        }
      }
      return null;
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      this.poly = null;
      this.draggedVertex = null;
      this.selectedVertex = null;

      // Clear any gizmos from previous polygon
      this.updateAllGizmos();

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.updateAllGizmos();
      }
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();

      // Activate if exactly one shape is selected
      var shape = selected.length == 1 ? selected[0] : null;
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_2__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(VertexMoveTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.mousePos.copy(p);

      // If we hit an existing vertex, start dragging it
      var draggedVertex = this.findVertexUnderMouse();
      if (draggedVertex) {
        this.startDragVertex(event, draggedVertex);
        this.startedDragging = true;
        return true;
      }

      return false;
    }


    // @param {Event} event
    // @param {PolyIndex} draggedVertex
  }, { key: "startDragVertex", value: function startDragVertex(event, draggedVertex) {
      if (this.mouseTracker) {
        this.mouseTracker.startTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // Configure angle snapping to consider latest state of the polygon
      this.snapper.startAngleSnapping(this.poly.clone(), draggedVertex.vertex, draggedVertex.loop);

      this.draggedVertex = draggedVertex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = this.poly.getPoint(this.draggedVertex.vertex, this.draggedVertex.loop);
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - event.canvasX, vposScreen.y - event.canvasY);

      // highlight the vertex we clicked on
      this.setSelectedVertex(this.draggedVertex);

      this.lastDragPoint.copy(vpos);
      this.dragVertexStartPos.copy(vpos);
    } }, { key: "moveDragVertex", value: function moveDragVertex(

    canvasX, canvasY) {var _this$draggedVertex =

      this.draggedVertex,loop = _this$draggedVertex.loop,vertex = _this$draggedVertex.vertex;

      // Note that the vertex we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;

      // get delta between last and current position
      var p = this.getSnapPosition(x, y);
      var dx = p.x - this.lastDragPoint.x;
      var dy = p.y - this.lastDragPoint.y;

      // apply this offset to polygon point
      var point = this.poly.getPoint(vertex, loop);
      this.poly.updatePoint(vertex, point.x + dx, point.y + dy, loop);

      // re-center gizmo at new point position
      var vertexGizmo = this.vertexGizmos[loop][vertex];
      vertexGizmo.setPosition(point.x, point.y);

      this.gizmoLayer.update(); // we moved the vertex gizmo
      this.layer.update(); // we changed the main polygon

      this.lastDragPoint.copy(p);
    } }, { key: "restoreDragVertex", value: function restoreDragVertex()

    {
      this.poly.updatePoint(this.draggedVertex.vertex, this.dragVertexStartPos.x, this.dragVertexStartPos.y, this.draggedVertex.loop);
    } }, { key: "endDragVertex", value: function endDragVertex()

    {
      if (this.mouseTracker) {
        this.mouseTracker.stopTracking(this.getName(), Autodesk.Edit2D.Trackings.Drag);
      }

      // First, restore "before move" position of the vertex
      this.restoreDragVertex();

      var pBefore = this.dragVertexStartPos;
      var pAfter = this.lastDragPoint;

      // don't add extra undo-operation if the vertex was hardly moved at all
      var minDist = this.layer.getUnitsPerPixel() * 0.5;
      var moved = pBefore.distanceTo(pAfter) > minDist;

      if (moved) {
        // Finalize vertex-move
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveVertex(this.layer, this.poly, this.draggedVertex, pAfter));
      }

      this.draggedVertex = null;
      this.snapper.clearSnappingGizmos();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(VertexMoveTool.prototype), "handleMouseMove", this).call(this, event);

      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));

      if (!this.poly) {
        return false;
      }

      if (this.draggedVertex) {
        this.moveDragVertex(event.canvasX, event.canvasY);
        return true;
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(VertexMoveTool.prototype), "handleButtonUp", this).call(this, event, button);

      var wasDragging = this.startedDragging;
      this.startedDragging = false;

      if (this.draggedVertex) {
        this.endDragVertex();
        return true;
      }

      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,
      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.
      return !this.ignoreDragging && wasDragging;
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(VertexMoveTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      if (keyCode === this.keyMap.CancelEdit) {
        handled = this.cancelDrag();
      }

      return handled;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.draggedVertex) {
        this.restoreDragVertex();
        this.draggedVertex = null;
        needsUpdate = true;
      }

      if (needsUpdate) {
        this.updateAllGizmos();
        this.layer.update();
      }

      this.snapper.clearSnappingGizmos();

      return needsUpdate;
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {

      // If we are dragging a vertex, toggling snapping will affect the result and 
      // we should update line gizmos and snapping lines.
      if (this.draggedVertex) {
        this.moveDragVertex(canvasX, canvasY);
      }
    }

    // Updates selection of shape(s), vertex, and edge after an action
  }, { key: "updateSelectionState", value: function updateSelectionState(action, isUndo) {
      // Check if the action provides a hint how we should update selection
      var hint = action.getSelectionHint(isUndo);
      if (hint) {
        this.setSelectedVertex(hint.vertex);
        return;
      }

      // Default behavior - if we don't know anything better:
      //  - Keep shape selected if still existing
      //  - Reset vertex/edge selection

      // If shape was removed, reset state
      var shapeFound = Boolean(this.poly && this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      this.setSelectedVertex(null);
    } }, { key: "handleExternalAction", value: function handleExternalAction(

    action, isUndo) {

      // make sure that selected edge/vertex are still valid (or switched off)
      this.updateSelectionState(action, isUndo);

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      // Sync gizmos in case vertices were modified
      this.updateAllGizmos();

      this.snapper.clearSnappingGizmos();
    } }, { key: "getCursor", value: function getCursor()

    {

      if (!this.poly) {
        return;
      }

      // Note: Vertex gizmos and edge gizmos are separate DomElements and define own mouse cursors via style.
      // Indicate: "Moving a gizmo". Currently, we use the same as for shape move. Note that
      //           the cursor for gizmo dragging must be consistent with the one we have if the mouse is on the gizmo.
      //           Otherwise, the mouse cursor would change its state when temporarily leaving the gizmo on fast moves.
      if (this.draggedVertex) {
        return 'move';
      }

      // => Just default cursor
      return undefined;
    } }]);return VertexMoveTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

/***/ }),

/***/ "./node_modules/@adsk/solid-definition/dist/solid-definition.min.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@adsk/solid-definition/dist/solid-definition.min.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);} /*!
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright 2017 Autodesk, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * This computer source code and related instructions and comments are the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * unpublished confidential and proprietary information of Autodesk, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * and are protected under applicable copyright and trade secret law. They
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * may not be disclosed to, copied or used by any third party without the
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * prior written consent of Autodesk, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */
!function (e, t) {"object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports["solid-definition"] = t() : e.SolidDefinition = t();}("undefined" != typeof self ? self : this, function () {return function (e) {var t = {};function r(n) {if (t[n]) return t[n].exports;var o = t[n] = { i: n, l: !1, exports: {} };return e[n].call(o.exports, o, o.exports, r), o.l = !0, o.exports;}return r.m = e, r.c = t, r.d = function (e, t, n) {r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n });}, r.r = function (e) {"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });}, r.t = function (e, t) {if (1 & t && (e = r(e)), 8 & t) return e;if (4 & t && "object" == _typeof(e) && e && e.__esModule) return e;var n = Object.create(null);if (r.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var o in e) {r.d(n, o, function (t) {return e[t];}.bind(null, o));}return n;}, r.n = function (e) {var t = e && e.__esModule ? function () {return e.default;} : function () {return e;};return r.d(t, "a", t), t;}, r.o = function (e, t) {return Object.prototype.hasOwnProperty.call(e, t);}, r.p = "", r(r.s = 86);}([function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = !1;"undefined" != typeof window && window.isJaguar && (t.isSceneComposerEnv = n = !0);var o = !1;n && (t.USE_LEGACY_LEIDS = o = window.isJaguar && window.isJaguar() || !!JSON.parse(localStorage.getItem("USE_LEGACY_LEIDS"))), t.KERNEL_TOLERANCE = 1e-6, t.KERNEL_ANGULAR_TOLERANCE = 1e-10, t.PARAMETER_SPACE_TOLERANCE = 1e-10, t.SPLINE_TANGENT_HANDLE_SCALE = 1, t.SPLINE_DISTANCE_TOLERANCE = 1e-4, t.DEFAULT_CURVE_RESOLUTION = 64, t.isSceneComposerEnv = n, t.NO_ID = "", t.USE_LEGACY_LEIDS = o, t.TESSELLATION = { LINEAR_PRECISION: 1e-4, ANGULAR_PRECISION: 1e-5 }, t.GEOMETRY_TYPES = { POINT: 1, BCURVE: 2, CIRCLE: 3, ELLIPSE: 4, HAPCURVE: 5, LINE: 6, BSURFACE: 7, CONE: 8, CYLINDER: 9, ELLIPTICAL_CONE: 10, ELLIPTICAL_CYLINDER: 11, PLANE: 12, SPHERE: 13, TORUS: 14, toString: function toString(e) {switch (e) {case this.POINT:return "Point";case this.BCURVE:return "BCurve";case this.CIRCLE:return "Circle";case this.ELLIPSE:return "Ellipse";case this.HAPCURVE:return "HapCurve";case this.LINE:return "Line";case this.BSURFACE:return "BSurface";case this.CONE:return "Cone";case this.CYLINDER:return "Cylinder";case this.ELLIPTICAL_CONE:return "EllipticalCone";case this.ELLIPTICAL_CYLINDER:return "EllipticalCylinder";case this.PLANE:return "Plane";case this.SPHERE:return "Sphere";case this.TORUS:return "Torus";default:return "unknown";}} }, t.TOPOLOGY_TYPES = { VERTEX: 1, EDGE: 2, COEDGE: 3, LOOP: 4, FACE: 5, SHELL: 6, LUMP: 7, BODY: 8, WIRE: 9, WIREBODY: 10, toString: function toString(e) {switch (e) {case this.VERTEX:return "Vertex";case this.EDGE:return "Edge";case this.COEDGE:return "Coedge";case this.LOOP:return "Loop";case this.FACE:return "Face";case this.SHELL:return "Shell";case this.LUMP:return "Lump";case this.BODY:return "Body";case this.WIRE:return "Wire";case this.WIREBODY:return "WireBody";default:return "unknown";}} };}, function (e, t, r) {"use strict";r.r(t), r.d(t, "Vector2", function () {return s;}), r.d(t, "Vector3", function () {return c;}), r.d(t, "Vector4", function () {return l;}), r.d(t, "Matrix22", function () {return d;}), r.d(t, "Matrix33", function () {return p;}), r.d(t, "Matrix44", function () {return v;}), r.d(t, "Quat", function () {return y;}), r.d(t, "ProjectionUtils", function () {return m;}), r.d(t, "FLOAT64_TOLERANCE", function () {return n;}), r.d(t, "FLOAT32_TOLERANCE", function () {return o;});var n = 1e-12,o = 1e-6;var i = { createFloat32: function createFloat32() {var e = new Float32Array(2);return e[0] = 0, e[1] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(2);return e[0] = 0, e[1] = 0, e;}, createNumber: function createNumber() {return [0, 0];}, clone: function clone(e) {var t = new e.constructor(2);return t[0] = e[0], t[1] = e[1], t;}, createFloat32FromValues: function createFloat32FromValues(e, t) {var r = new Float32Array(2);return r[0] = e, r[1] = t, r;} };i.asFloat32 = i.createFloat32FromValues, i.createFloat64FromValues = function (e, t) {var r = new Float64Array(2);return r[0] = e, r[1] = t, r;}, i.asFloat64 = i.createFloat64FromValues, i.createNumberFromValues = function (e, t) {return [e, t];}, i.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e;}, i.set = function (e, t, r) {return e[0] = t, e[1] = r, e;}, i.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;}, i.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;}, i.sub = i.subtract, i.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;}, i.mul = i.multiply, i.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;}, i.div = i.divide, i.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e;}, i.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e;}, i.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;}, i.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;}, i.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e;}, i.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e;}, i.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;}, i.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return Math.sqrt(r * r + n * n);}, i.dist = i.distance, i.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1];return r * r + n * n;}, i.sqrDist = i.squaredDistance, i.length = function (e) {var t = e[0],r = e[1];return Math.sqrt(t * t + r * r);}, i.len = i.length, i.squaredLength = function (e) {var t = e[0],r = e[1];return t * t + r * r;}, i.sqrLen = i.squaredLength, i.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e;}, i.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e;}, i.normalize = function (e, t) {var r = t[0],n = t[1],o = r * r + n * n;return o > 0 && (o = 1 / Math.sqrt(o), e[0] = t[0] * o, e[1] = t[1] * o), e;}, i.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1];}, i.cross = function (e, t, r) {var n = t[0] * r[1] - t[1] * r[0];return e[0] = e[1] = 0, e[2] = n, e;}, i.lerp = function (e, t, r, n) {var o = t[0],i = t[1];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e;}, i.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI;return e[0] = Math.cos(r) * t, e[1] = Math.sin(r) * t, e;}, i.transformMatrix22 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[2] * o, e[1] = r[1] * n + r[3] * o, e;}, i.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[3] * o + r[6], e[1] = r[1] * n + r[4] * o + r[7], e;}, i.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1];return e[0] = r[0] * n + r[4] * o + r[12], e[1] = r[1] * n + r[5] * o + r[13], e;}, i.angle = function (e, t) {var r = i.clone(e),n = i.clone(t);i.normalize(r, r), i.normalize(n, n);var o = i.dot(r, n),s = Math.abs(r[0] * n[1] - r[1] * n[0]);return Math.atan2(s, o);}, i.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var s = e[0] * t[1] - e[1] * t[0];return !(s * s > o * o * i.squaredLength(e) * i.squaredLength(t)) && (r > 0 ? i.dot(e, t) > 0 : !(r < 0) || i.dot(e, t) < 0);}, i.isOrthogonal = function (e, t, r) {r = r || n;var o = i.dot(e, t);return o * o <= r * r * i.squaredLength(e) * i.squaredLength(t);}, i.toString = function (e) {return "[" + e[0] + ", " + e[1] + "]";}, i.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1];}, i.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r;};var s = i,a = { createFloat32: function createFloat32() {var e = new Float32Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(3);return e[0] = 0, e[1] = 0, e[2] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(3);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r) {var n = new Float32Array(3);return n[0] = e, n[1] = t, n[2] = r, n;} };a.asFloat32 = a.createFloat32FromValues, a.createFloat64FromValues = function (e, t, r) {var n = new Float64Array(3);return n[0] = e, n[1] = t, n[2] = r, n;}, a.asFloat64 = a.createFloat64FromValues, a.createNumberFromValues = function (e, t, r) {return [e, t, r];}, a.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;}, a.set = function (e, t, r, n) {return e[0] = t, e[1] = r, e[2] = n, e;}, a.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e;}, a.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e;}, a.sub = a.subtract, a.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e;}, a.mul = a.multiply, a.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e;}, a.div = a.divide, a.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e;}, a.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e;}, a.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e;}, a.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e;}, a.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e;}, a.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e;}, a.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e;}, a.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return Math.sqrt(r * r + n * n + o * o);}, a.dist = a.distance, a.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2];return r * r + n * n + o * o;}, a.sqrDist = a.squaredDistance, a.length = function (e) {var t = e[0],r = e[1],n = e[2];return Math.sqrt(t * t + r * r + n * n);}, a.len = a.length, a.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2];return t * t + r * r + n * n;}, a.sqrLen = a.squaredLength, a.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e;}, a.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e;}, a.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = r * r + n * n + o * o;return i > 0 && (i = 1 / Math.sqrt(i), e[0] = t[0] * i, e[1] = t[1] * i, e[2] = t[2] * i), e;}, a.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];}, a.cross = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2];return e[0] = o * c - i * a, e[1] = i * s - n * c, e[2] = n * a - o * s, e;}, a.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e;}, a.hermite = function (e, t, r, n, o, i) {var s = i * i,a = s * (2 * i - 3) + 1,c = s * (i - 2) + i,u = s * (i - 1),l = s * (3 - 2 * i);return e[0] = t[0] * a + r[0] * c + n[0] * u + o[0] * l, e[1] = t[1] * a + r[1] * c + n[1] * u + o[1] * l, e[2] = t[2] * a + r[2] * c + n[2] * u + o[2] * l, e;}, a.bezier = function (e, t, r, n, o, i) {var s = 1 - i,a = s * s,c = i * i,u = a * s,l = 3 * i * a,h = 3 * c * s,d = c * i;return e[0] = t[0] * u + r[0] * l + n[0] * h + o[0] * d, e[1] = t[1] * u + r[1] * l + n[1] * h + o[1] * d, e[2] = t[2] * u + r[2] * l + n[2] * h + o[2] * d, e;}, a.random = function (e, t) {t = t || 1;var r = 2 * Math.random() * Math.PI,n = 2 * Math.random() - 1,o = Math.sqrt(1 - n * n) * t;return e[0] = Math.cos(r) * o, e[1] = Math.sin(r) * o, e[2] = n * t, e;}, a.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12], e[1] = r[1] * n + r[5] * o + r[9] * i + r[13], e[2] = r[2] * n + r[6] * o + r[10] * i + r[14], e;}, a.transformAsDirectionMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = r[0] * n + r[4] * o + r[8] * i, e[1] = r[1] * n + r[5] * o + r[9] * i, e[2] = r[2] * n + r[6] * o + r[10] * i, e;}, a.transformMatrix33 = function (e, t, r) {var n = t[0],o = t[1],i = t[2];return e[0] = n * r[0] + o * r[3] + i * r[6], e[1] = n * r[1] + o * r[4] + i * r[7], e[2] = n * r[2] + o * r[5] + i * r[8], e;}, a.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e;}, a.setFromMatrixScale = function (e, t) {var r = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = r, e[1] = n, e[2] = o, e;}, a.rotateX = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0], i[1] = o[1] * Math.cos(n) - o[2] * Math.sin(n), i[2] = o[1] * Math.sin(n) + o[2] * Math.cos(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateY = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[2] * Math.sin(n) + o[0] * Math.cos(n), i[1] = o[1], i[2] = o[2] * Math.cos(n) - o[0] * Math.sin(n), e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.rotateZ = function (e, t, r, n) {var o = [],i = [];return o[0] = t[0] - r[0], o[1] = t[1] - r[1], o[2] = t[2] - r[2], i[0] = o[0] * Math.cos(n) - o[1] * Math.sin(n), i[1] = o[0] * Math.sin(n) + o[1] * Math.cos(n), i[2] = o[2], e[0] = i[0] + r[0], e[1] = i[1] + r[1], e[2] = i[2] + r[2], e;}, a.angle = function (e, t) {var r = a.clone(e),n = a.clone(t);a.normalize(r, r), a.normalize(n, n);var o = a.dot(r, n),i = a.length(a.cross(r, r, n));return Math.atan2(i, o);}, a.isParallel = function (e, t, r, o) {o = o || n, r = r || 0;var i = a.createFloat64();return a.cross(i, e, t), !(a.squaredLength(i) > o * o * a.squaredLength(e) * a.squaredLength(t)) && (r > 0 ? a.dot(e, t) > 0 : !(r < 0) || a.dot(e, t) < 0);}, a.isOrthogonal = function (e, t, r) {r = r || n;var o = a.dot(e, t);return o * o <= r * r * a.squaredLength(e) * a.squaredLength(t);}, a.computeOrthogonal = function (e, t) {return t[0] * t[0] > t[2] * t[2] ? a.set(e, t[1], -t[0], 0) : a.set(e, 0, t[2], -t[1]), e;}, a.setEulerFromRotationMatrix = function (e, t, r) {var o = 1 - n;function i(e) {return Math.min(Math.max(e, -1), 1);}var s = t[0],a = t[4],c = t[8],u = t[1],l = t[5],h = t[9],d = t[2],g = t[6],p = t[10];return void 0 === r || "XYZ" === r ? (e[1] = Math.asin(i(c)), Math.abs(c) < o ? (e[0] = Math.atan2(-h, p), e[2] = Math.atan2(-a, s)) : (e[0] = Math.atan2(g, l), e[2] = 0)) : "YXZ" === r ? (e[0] = Math.asin(-i(h)), Math.abs(h) < o ? (e[1] = Math.atan2(c, p), e[2] = Math.atan2(u, l)) : (e[1] = Math.atan2(-d, s), e[2] = 0)) : "ZXY" === r ? (e[0] = Math.asin(i(g)), Math.abs(g) < o ? (e[1] = Math.atan2(-d, p), e[2] = Math.atan2(-a, l)) : (e[1] = 0, e[2] = Math.atan2(u, s))) : "ZYX" === r ? (e[1] = Math.asin(-i(d)), Math.abs(d) < o ? (e[0] = Math.atan2(g, p), e[2] = Math.atan2(u, s)) : (e[0] = 0, e[2] = Math.atan2(-a, l))) : "YZX" === r ? (e[2] = Math.asin(i(u)), Math.abs(u) < o ? (e[0] = Math.atan2(-h, l), e[1] = Math.atan2(-d, s)) : (e[0] = 0, e[1] = Math.atan2(c, p))) : "XZY" === r && (e[2] = Math.asin(-i(a)), Math.abs(a) < o ? (e[0] = Math.atan2(g, l), e[1] = Math.atan2(c, s)) : (e[0] = Math.atan2(-h, p), e[1] = 0)), e;}, a.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + "]";}, a.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];}, a.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r;};var c = a,u = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e;}, createNumber: function createNumber() {return [0, 0, 0, 0];}, clone: function clone(e) {var t = new e.constructor(4);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };u.asFloat32 = u.createFloat32FromValues, u.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, u.asFloat64 = u.createFloat64FromValues, u.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, u.copy = function (e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, u.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, u.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, u.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, u.sub = u.subtract, u.multiply = function (e, t, r) {return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e[2] = t[2] * r[2], e[3] = t[3] * r[3], e;}, u.mul = u.multiply, u.divide = function (e, t, r) {return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e[2] = t[2] / r[2], e[3] = t[3] / r[3], e;}, u.div = u.divide, u.ceil = function (e, t) {return e[0] = Math.ceil(t[0]), e[1] = Math.ceil(t[1]), e[2] = Math.ceil(t[2]), e[3] = Math.ceil(t[3]), e;}, u.floor = function (e, t) {return e[0] = Math.floor(t[0]), e[1] = Math.floor(t[1]), e[2] = Math.floor(t[2]), e[3] = Math.floor(t[3]), e;}, u.min = function (e, t, r) {return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e[2] = Math.min(t[2], r[2]), e[3] = Math.min(t[3], r[3]), e;}, u.max = function (e, t, r) {return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e[2] = Math.max(t[2], r[2]), e[3] = Math.max(t[3], r[3]), e;}, u.round = function (e, t) {return e[0] = Math.round(t[0]), e[1] = Math.round(t[1]), e[2] = Math.round(t[2]), e[3] = Math.round(t[3]), e;}, u.scale = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, u.scaleAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, u.distance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return Math.sqrt(r * r + n * n + o * o + i * i);}, u.dist = u.distance, u.squaredDistance = function (e, t) {var r = t[0] - e[0],n = t[1] - e[1],o = t[2] - e[2],i = t[3] - e[3];return r * r + n * n + o * o + i * i;}, u.sqrDist = u.squaredDistance, u.length = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return Math.sqrt(t * t + r * r + n * n + o * o);}, u.len = u.length, u.squaredLength = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3];return t * t + r * r + n * n + o * o;}, u.sqrLen = u.squaredLength, u.negate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = -t[3], e;}, u.inverse = function (e, t) {return e[0] = 1 / t[0], e[1] = 1 / t[1], e[2] = 1 / t[2], e[3] = 1 / t[3], e;}, u.normalize = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i;return s > 0 && (s = 1 / Math.sqrt(s), e[0] = r * s, e[1] = n * s, e[2] = o * s, e[3] = i * s), e;}, u.dot = function (e, t) {return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];}, u.lerp = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3];return e[0] = o + n * (r[0] - o), e[1] = i + n * (r[1] - i), e[2] = s + n * (r[2] - s), e[3] = a + n * (r[3] - a), e;}, u.random = function (e, t) {return t = t || 1, e[0] = Math.random(), e[1] = Math.random(), e[2] = Math.random(), e[3] = Math.random(), u.normalize(e, e), u.scale(e, e, t), e;}, u.transformMatrix44 = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3];return e[0] = r[0] * n + r[4] * o + r[8] * i + r[12] * s, e[1] = r[1] * n + r[5] * o + r[9] * i + r[13] * s, e[2] = r[2] * n + r[6] * o + r[10] * i + r[14] * s, e[3] = r[3] * n + r[7] * o + r[11] * i + r[15] * s, e;}, u.transformQuat = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[0],a = r[1],c = r[2],u = r[3],l = u * n + a * i - c * o,h = u * o + c * n - s * i,d = u * i + s * o - a * n,g = -s * n - a * o - c * i;return e[0] = l * u + g * -s + h * -c - d * -a, e[1] = h * u + g * -a + d * -s - l * -c, e[2] = d * u + g * -c + l * -a - h * -s, e[3] = t[3], e;}, u.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, u.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, u.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[2] - t[2]) <= r;};var l = u,h = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n) {var o = new Float32Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;} };h.asFloat32 = h.createFloat32FromValues, h.createFloat64FromValues = function (e, t, r, n) {var o = new Float64Array(4);return o[0] = e, o[1] = t, o[2] = r, o[3] = n, o;}, h.asFloat64 = h.createFloat64FromValues, h.createNumberFromValues = function (e, t, r, n) {return [e, t, r, n];}, h.set = function (e, t, r, n, o) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e;}, h.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e;}, h.transpose = function (e, t) {if (e === t) {var r = t[1];e[1] = t[2], e[2] = r;} else e[0] = t[0], e[1] = t[2], e[2] = t[1], e[3] = t[3];return e;}, h.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * i - o * n;return s ? (s = 1 / s, e[0] = i * s, e[1] = -n * s, e[2] = -o * s, e[3] = r * s, e) : null;}, h.determinant = function (e) {return e[0] * e[3] - e[2] * e[1];}, h.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * a + i * c, e[1] = o * a + s * c, e[2] = n * u + i * l, e[3] = o * u + s * l, e;}, h.mul = h.multiply, h.scale = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1];return e[0] = n * a, e[1] = o * a, e[2] = i * c, e[3] = s * c, e;}, h.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, h.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e;}, h.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e;}, h.sub = h.subtract, h.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e;}, h.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e;}, h.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];}, h.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r;};var d = h,g = { createFloat32: function createFloat32() {var e = new Float32Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(9);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 1, 0, 0, 0, 1];}, fromMatrix44: function fromMatrix44(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8], e[7] = t[9], e[8] = t[10], e;}, clone: function clone(e) {var t = new e.constructor(9);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c) {var u = new Float32Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;} };g.asFloat32 = g.createFloat32FromValues, g.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c) {var u = new Float64Array(9);return u[0] = e, u[1] = t, u[2] = r, u[3] = n, u[4] = o, u[5] = i, u[6] = s, u[7] = a, u[8] = c, u;}, g.asFloat64 = g.createFloat64FromValues, g.createNumberFromValues = function (e, t, r, n, o, i, s, a, c) {return [e, t, r, n, o, i, s, a, c];}, g.set = function (e, t, r, n, o, i, s, a, c, u) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e;}, g.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[5];e[1] = t[3], e[2] = t[6], e[3] = r, e[5] = t[7], e[6] = n, e[7] = o;} else e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8];return e;}, g.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = l * s - a * u,d = -l * i + a * c,g = u * i - s * c,p = r * h + n * d + o * g;return p ? (p = 1 / p, e[0] = h * p, e[1] = (-l * n + o * u) * p, e[2] = (a * n - o * s) * p, e[3] = d * p, e[4] = (l * r - o * c) * p, e[5] = (-a * r + o * i) * p, e[6] = g * p, e[7] = (-u * r + n * c) * p, e[8] = (s * r - n * i) * p, e) : null;}, g.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8];return t * (u * i - s * c) + r * (-u * o + s * a) + n * (c * o - i * a);}, g.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = r[0],g = r[1],p = r[2],f = r[3],v = r[4],_ = r[5],y = r[6],m = r[7],E = r[8];return e[0] = d * n + g * s + p * u, e[1] = d * o + g * a + p * l, e[2] = d * i + g * c + p * h, e[3] = f * n + v * s + _ * u, e[4] = f * o + v * a + _ * l, e[5] = f * i + v * c + _ * h, e[6] = y * n + m * s + E * u, e[7] = y * o + m * a + E * l, e[8] = y * i + m * c + E * h, e;}, g.mul = g.multiply, g.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t[0], e[7] = t[1], e[8] = 1, e;}, g.fromRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = -r, e[4] = n, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = t[1], e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;}, g.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[3] = l - _, e[6] = d + v, e[1] = l + _, e[4] = 1 - u - p, e[7] = g - f, e[2] = d - v, e[5] = g + f, e[8] = 1 - u - h, e;}, g.normalFromMatrix44 = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (c * T - s * L - u * V) * O, e[2] = (s * b - a * T + u * P) * O, e[3] = (o * b - n * L - i * C) * O, e[4] = (r * L - o * T + i * V) * O, e[5] = (n * T - r * b - i * P) * O, e[6] = (f * A - v * R + _ * x) * O, e[7] = (v * E - p * A - _ * m) * O, e[8] = (p * R - f * E + _ * y) * O, e) : null;}, g.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + "]";}, g.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e;}, g.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e;}, g.sub = g.subtract, g.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e;}, g.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e;}, g.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8];}, g.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r;};var p = g,f = { createFloat32: function createFloat32() {var e = new Float32Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(16);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, createNumber: function createNumber() {return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];}, clone: function clone(e) {var t = new e.constructor(16);return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;}, copy: function copy(e, t) {return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;}, createFloat32FromValues: function createFloat32FromValues(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float32Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;} };f.asFloat32 = f.createFloat32FromValues, f.createFloat64FromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {var v = new Float64Array(16);return v[0] = e, v[1] = t, v[2] = r, v[3] = n, v[4] = o, v[5] = i, v[6] = s, v[7] = a, v[8] = c, v[9] = u, v[10] = l, v[11] = h, v[12] = d, v[13] = g, v[14] = p, v[15] = f, v;}, f.asFloat64 = f.createFloat64FromValues, f.createNumberFromValues = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f) {return [e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f];}, f.set = function (e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {return e[0] = t, e[1] = r, e[2] = n, e[3] = o, e[4] = i, e[5] = s, e[6] = a, e[7] = c, e[8] = u, e[9] = l, e[10] = h, e[11] = d, e[12] = g, e[13] = p, e[14] = f, e[15] = v, e;}, f.identity = function (e) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.transpose = function (e, t) {if (e === t) {var r = t[1],n = t[2],o = t[3],i = t[6],s = t[7],a = t[11];e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = r, e[6] = t[9], e[7] = t[13], e[8] = n, e[9] = i, e[11] = t[14], e[12] = o, e[13] = s, e[14] = a;} else e[0] = t[0], e[1] = t[4], e[2] = t[8], e[3] = t[12], e[4] = t[1], e[5] = t[5], e[6] = t[9], e[7] = t[13], e[8] = t[2], e[9] = t[6], e[10] = t[10], e[11] = t[14], e[12] = t[3], e[13] = t[7], e[14] = t[11], e[15] = t[15];return e;}, f.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = t[4],a = t[5],c = t[6],u = t[7],l = t[8],h = t[9],d = t[10],g = t[11],p = t[12],f = t[13],v = t[14],_ = t[15],y = r * a - n * s,m = r * c - o * s,E = r * u - i * s,x = n * c - o * a,R = n * u - i * a,A = o * u - i * c,P = l * f - h * p,V = l * v - d * p,T = l * _ - g * p,C = h * v - d * f,b = h * _ - g * f,L = d * _ - g * v,O = y * L - m * b + E * C + x * T - R * V + A * P;return O ? (O = 1 / O, e[0] = (a * L - c * b + u * C) * O, e[1] = (o * b - n * L - i * C) * O, e[2] = (f * A - v * R + _ * x) * O, e[3] = (d * R - h * A - g * x) * O, e[4] = (c * T - s * L - u * V) * O, e[5] = (r * L - o * T + i * V) * O, e[6] = (v * E - p * A - _ * m) * O, e[7] = (l * A - d * E + g * m) * O, e[8] = (s * b - a * T + u * P) * O, e[9] = (n * T - r * b - i * P) * O, e[10] = (p * R - f * E + _ * y) * O, e[11] = (h * E - l * R - g * y) * O, e[12] = (a * V - s * C - c * P) * O, e[13] = (r * C - n * V + o * P) * O, e[14] = (f * m - p * x - v * y) * O, e[15] = (l * x - h * m + d * y) * O, e) : null;}, f.determinant = function (e) {var t = e[0],r = e[1],n = e[2],o = e[3],i = e[4],s = e[5],a = e[6],c = e[7],u = e[8],l = e[9],h = e[10],d = e[11],g = e[12],p = e[13],f = e[14],v = e[15];return (t * s - r * i) * (h * v - d * f) - (t * a - n * i) * (l * v - d * p) + (t * c - o * i) * (l * f - h * p) + (r * a - n * s) * (u * v - d * g) - (r * c - o * s) * (u * f - h * g) + (n * c - o * a) * (u * p - l * g);}, f.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = t[4],c = t[5],u = t[6],l = t[7],h = t[8],d = t[9],g = t[10],p = t[11],f = t[12],v = t[13],_ = t[14],y = t[15],m = r[0],E = r[1],x = r[2],R = r[3];return e[0] = m * n + E * a + x * h + R * f, e[1] = m * o + E * c + x * d + R * v, e[2] = m * i + E * u + x * g + R * _, e[3] = m * s + E * l + x * p + R * y, m = r[4], E = r[5], x = r[6], R = r[7], e[4] = m * n + E * a + x * h + R * f, e[5] = m * o + E * c + x * d + R * v, e[6] = m * i + E * u + x * g + R * _, e[7] = m * s + E * l + x * p + R * y, m = r[8], E = r[9], x = r[10], R = r[11], e[8] = m * n + E * a + x * h + R * f, e[9] = m * o + E * c + x * d + R * v, e[10] = m * i + E * u + x * g + R * _, e[11] = m * s + E * l + x * p + R * y, m = r[12], E = r[13], x = r[14], R = r[15], e[12] = m * n + E * a + x * h + R * f, e[13] = m * o + E * c + x * d + R * v, e[14] = m * i + E * u + x * g + R * _, e[15] = m * s + E * l + x * p + R * y, e;}, f.mul = f.multiply, f.fromTranslation = function (e, t) {return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = t[0], e[13] = t[1], e[14] = t[2], e[15] = 1, e;}, f.fromScaling = function (e, t) {return e[0] = t[0], e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = t[1], e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = t[2], e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotation = function (e, t, r) {var o,i,s,a = r[0],c = r[1],u = r[2],l = Math.sqrt(a * a + c * c + u * u);return Math.abs(l) < n ? null : (a *= l = 1 / l, c *= l, u *= l, o = Math.sin(t), s = 1 - (i = Math.cos(t)), e[0] = a * a * s + i, e[1] = c * a * s + u * o, e[2] = u * a * s - c * o, e[3] = 0, e[4] = a * c * s - u * o, e[5] = c * c * s + i, e[6] = u * c * s + a * o, e[7] = 0, e[8] = a * u * s + c * o, e[9] = c * u * s - a * o, e[10] = u * u * s + i, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e);}, f.fromXRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = n, e[6] = r, e[7] = 0, e[8] = 0, e[9] = -r, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromYRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = 0, e[2] = -r, e[3] = 0, e[4] = 0, e[5] = 1, e[6] = 0, e[7] = 0, e[8] = r, e[9] = 0, e[10] = n, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromZRotation = function (e, t) {var r = Math.sin(t),n = Math.cos(t);return e[0] = n, e[1] = r, e[2] = 0, e[3] = 0, e[4] = -r, e[5] = n, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.fromRotationTranslation = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = n + n,c = o + o,u = i + i,l = n * a,h = n * c,d = n * u,g = o * c,p = o * u,f = i * u,v = s * a,_ = s * c,y = s * u;return e[0] = 1 - (g + f), e[1] = h + y, e[2] = d - _, e[3] = 0, e[4] = h - y, e[5] = 1 - (l + f), e[6] = p + v, e[7] = 0, e[8] = d + _, e[9] = p - v, e[10] = 1 - (l + g), e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.getTranslation = function (e, t) {return e[0] = t[12], e[1] = t[13], e[2] = t[14], e;}, f.extractRotation = function (e, t) {var r = 1 / Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]),n = 1 / Math.sqrt(t[4] * t[4] + t[5] * t[5] + t[6] * t[6]),o = 1 / Math.sqrt(t[8] * t[8] + t[9] * t[9] + t[10] * t[10]);return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = 0, e[4] = t[4] * n, e[5] = t[5] * n, e[6] = t[6] * n, e[7] = 0, e[8] = t[8] * o, e[9] = t[9] * o, e[10] = t[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;}, f.getRotation = function (e, t) {var r = t[0] + t[5] + t[10],n = 0;return r > 0 ? (n = 2 * Math.sqrt(r + 1), e[3] = .25 * n, e[0] = (t[6] - t[9]) / n, e[1] = (t[8] - t[2]) / n, e[2] = (t[1] - t[4]) / n) : t[0] > t[5] && t[0] > t[10] ? (n = 2 * Math.sqrt(1 + t[0] - t[5] - t[10]), e[3] = (t[6] - t[9]) / n, e[0] = .25 * n, e[1] = (t[1] + t[4]) / n, e[2] = (t[8] + t[2]) / n) : t[5] > t[10] ? (n = 2 * Math.sqrt(1 + t[5] - t[0] - t[10]), e[3] = (t[8] - t[2]) / n, e[0] = (t[1] + t[4]) / n, e[1] = .25 * n, e[2] = (t[6] + t[9]) / n) : (n = 2 * Math.sqrt(1 + t[10] - t[0] - t[5]), e[3] = (t[1] - t[4]) / n, e[0] = (t[8] + t[2]) / n, e[1] = (t[6] + t[9]) / n, e[2] = .25 * n), e;}, f.fromRotationTranslationScale = function (e, t, r, n) {var o = t[0],i = t[1],s = t[2],a = t[3],c = o + o,u = i + i,l = s + s,h = o * c,d = o * u,g = o * l,p = i * u,f = i * l,v = s * l,_ = a * c,y = a * u,m = a * l,E = n[0],x = n[1],R = n[2];return e[0] = (1 - (p + v)) * E, e[1] = (d + m) * E, e[2] = (g - y) * E, e[3] = 0, e[4] = (d - m) * x, e[5] = (1 - (h + v)) * x, e[6] = (f + _) * x, e[7] = 0, e[8] = (g + y) * R, e[9] = (f - _) * R, e[10] = (1 - (h + p)) * R, e[11] = 0, e[12] = r[0], e[13] = r[1], e[14] = r[2], e[15] = 1, e;}, f.fromRotationTranslationScaleOrigin = function (e, t, r, n, o) {var i = t[0],s = t[1],a = t[2],c = t[3],u = i + i,l = s + s,h = a + a,d = i * u,g = i * l,p = i * h,f = s * l,v = s * h,_ = a * h,y = c * u,m = c * l,E = c * h,x = n[0],R = n[1],A = n[2],P = o[0],V = o[1],T = o[2];return e[0] = (1 - (f + _)) * x, e[1] = (g + E) * x, e[2] = (p - m) * x, e[3] = 0, e[4] = (g - E) * R, e[5] = (1 - (d + _)) * R, e[6] = (v + y) * R, e[7] = 0, e[8] = (p + m) * A, e[9] = (v - y) * A, e[10] = (1 - (d + f)) * A, e[11] = 0, e[12] = r[0] + P - (e[0] * P + e[4] * V + e[8] * T), e[13] = r[1] + V - (e[1] * P + e[5] * V + e[9] * T), e[14] = r[2] + T - (e[2] * P + e[6] * V + e[10] * T), e[15] = 1, e;}, f.fromQuat = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r + r,a = n + n,c = o + o,u = r * s,l = n * s,h = n * a,d = o * s,g = o * a,p = o * c,f = i * s,v = i * a,_ = i * c;return e[0] = 1 - h - p, e[1] = l + _, e[2] = d - v, e[3] = 0, e[4] = l - _, e[5] = 1 - u - p, e[6] = g + f, e[7] = 0, e[8] = d + v, e[9] = g - f, e[10] = 1 - u - h, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;}, f.setRotationFromEuler = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = Math.cos(n),a = Math.sin(n),c = Math.cos(o),u = Math.sin(o),l = Math.cos(i),h = Math.sin(i);if (void 0 === r || "XYZ" === r) {var d = s * l,g = s * h,p = a * l,f = a * h;e[0] = c * l, e[4] = -c * h, e[8] = u, e[1] = g + p * u, e[5] = d - f * u, e[9] = -a * c, e[2] = f - d * u, e[6] = p + g * u, e[10] = s * c;} else if ("YXZ" === r) {var v = c * l,_ = c * h,y = u * l,m = u * h;e[0] = v + m * a, e[4] = y * a - _, e[8] = s * u, e[1] = s * h, e[5] = s * l, e[9] = -a, e[2] = _ * a - y, e[6] = m + v * a, e[10] = s * c;} else if ("ZXY" === r) v = c * l, _ = c * h, y = u * l, m = u * h, e[0] = v - m * a, e[4] = -s * h, e[8] = y + _ * a, e[1] = _ + y * a, e[5] = s * l, e[9] = m - v * a, e[2] = -s * u, e[6] = a, e[10] = s * c;else if ("ZYX" === r) d = s * l, g = s * h, p = a * l, f = a * h, e[0] = c * l, e[4] = p * u - g, e[8] = d * u + f, e[1] = c * h, e[5] = f * u + d, e[9] = g * u - p, e[2] = -u, e[6] = a * c, e[10] = s * c;else if ("YZX" === r) {var E = s * c,x = s * u,R = a * c,A = a * u;e[0] = c * l, e[4] = A - E * h, e[8] = R * h + x, e[1] = h, e[5] = s * l, e[9] = -a * l, e[2] = -u * l, e[6] = x * h + R, e[10] = E - A * h;} else "XZY" === r && (E = s * c, x = s * u, R = a * c, A = a * u, e[0] = c * l, e[4] = -h, e[8] = u * l, e[1] = E * h + A, e[5] = s * l, e[9] = x * h - R, e[2] = R * h - x, e[6] = a * l, e[10] = A * h + E);return e;}, f.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + ", " + e[4] + ", " + e[5] + ", " + e[6] + ", " + e[7] + ", " + e[8] + ", " + e[9] + ", " + e[10] + ", " + e[11] + ", " + e[12] + ", " + e[13] + ", " + e[14] + ", " + e[15] + "]";}, f.add = function (e, t, r) {return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e[2] = t[2] + r[2], e[3] = t[3] + r[3], e[4] = t[4] + r[4], e[5] = t[5] + r[5], e[6] = t[6] + r[6], e[7] = t[7] + r[7], e[8] = t[8] + r[8], e[9] = t[9] + r[9], e[10] = t[10] + r[10], e[11] = t[11] + r[11], e[12] = t[12] + r[12], e[13] = t[13] + r[13], e[14] = t[14] + r[14], e[15] = t[15] + r[15], e;}, f.subtract = function (e, t, r) {return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e[2] = t[2] - r[2], e[3] = t[3] - r[3], e[4] = t[4] - r[4], e[5] = t[5] - r[5], e[6] = t[6] - r[6], e[7] = t[7] - r[7], e[8] = t[8] - r[8], e[9] = t[9] - r[9], e[10] = t[10] - r[10], e[11] = t[11] - r[11], e[12] = t[12] - r[12], e[13] = t[13] - r[13], e[14] = t[14] - r[14], e[15] = t[15] - r[15], e;}, f.sub = f.subtract, f.multiplyScalar = function (e, t, r) {return e[0] = t[0] * r, e[1] = t[1] * r, e[2] = t[2] * r, e[3] = t[3] * r, e[4] = t[4] * r, e[5] = t[5] * r, e[6] = t[6] * r, e[7] = t[7] * r, e[8] = t[8] * r, e[9] = t[9] * r, e[10] = t[10] * r, e[11] = t[11] * r, e[12] = t[12] * r, e[13] = t[13] * r, e[14] = t[14] * r, e[15] = t[15] * r, e;}, f.multiplyScalarAndAdd = function (e, t, r, n) {return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e[2] = t[2] + r[2] * n, e[3] = t[3] + r[3] * n, e[4] = t[4] + r[4] * n, e[5] = t[5] + r[5] * n, e[6] = t[6] + r[6] * n, e[7] = t[7] + r[7] * n, e[8] = t[8] + r[8] * n, e[9] = t[9] + r[9] * n, e[10] = t[10] + r[10] * n, e[11] = t[11] + r[11] * n, e[12] = t[12] + r[12] * n, e[13] = t[13] + r[13] * n, e[14] = t[14] + r[14] * n, e[15] = t[15] + r[15] * n, e;}, f.exactEquals = function (e, t) {return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];}, f.equals = function (e, t, r) {return r = r || n, Math.abs(e[0] - t[0]) <= r && Math.abs(e[1] - t[1]) <= r && Math.abs(e[2] - t[2]) <= r && Math.abs(e[3] - t[3]) <= r && Math.abs(e[4] - t[4]) <= r && Math.abs(e[5] - t[5]) <= r && Math.abs(e[6] - t[6]) <= r && Math.abs(e[7] - t[7]) <= r && Math.abs(e[8] - t[8]) <= r && Math.abs(e[9] - t[9]) <= r && Math.abs(e[10] - t[10]) <= r && Math.abs(e[11] - t[11]) <= r && Math.abs(e[12] - t[12]) <= r && Math.abs(e[13] - t[13]) <= r && Math.abs(e[14] - t[14]) <= r && Math.abs(e[15] - t[15]) <= r;};var v = f,_ = { createFloat32: function createFloat32() {var e = new Float32Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createFloat64: function createFloat64() {var e = new Float64Array(4);return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, createNumber: function createNumber() {return [0, 0, 0, 1];} };_.rotationTo = function () {var e = c.createFloat64(),t = c.createFloat64FromValues(1, 0, 0),r = c.createFloat64FromValues(0, 1, 0);return function (o, i, s) {var a = c.dot(i, s);return a < -1 + n ? (c.cross(e, t, i), c.length(e) < n && c.cross(e, r, i), c.normalize(e, e), _.setAxisAngle(o, e, Math.PI), o) : a > 1 - n ? (o[0] = 0, o[1] = 0, o[2] = 0, o[3] = 1, o) : (c.cross(e, i, s), o[0] = e[0], o[1] = e[1], o[2] = e[2], o[3] = 1 + a, _.normalize(o, o));};}(), _.setAxes = function () {var e = p.createFloat64();return function (t, r, n, o) {return e[0] = n[0], e[3] = n[1], e[6] = n[2], e[1] = o[0], e[4] = o[1], e[7] = o[2], e[2] = -r[0], e[5] = -r[1], e[8] = -r[2], _.normalize(t, _.fromMatrix33(t, e));};}(), _.clone = l.clone, _.createFloat32FromValues = l.createFloat32FromValues, _.createFloat64FromValues = l.createFloat64FromValues, _.createNumberFromValues = l.createNumberFromValues, _.asFloat32 = l.createFloat32FromValues, _.asFloat64 = l.createFloat64FromValues, _.copy = l.copy, _.set = l.set, _.identity = function (e) {return e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, e;}, _.setAxisAngle = function (e, t, r) {r *= .5;var n = Math.sin(r);return e[0] = n * t[0], e[1] = n * t[1], e[2] = n * t[2], e[3] = Math.cos(r), e;}, _.getAxisAngle = function (e, t) {var r = 2 * Math.acos(t[3]),n = Math.sin(r / 2);return 0 !== n ? (e[0] = t[0] / n, e[1] = t[1] / n, e[2] = t[2] / n) : (e[0] = 1, e[1] = 0, e[2] = 0), r;}, _.add = l.add, _.multiply = function (e, t, r) {var n = t[0],o = t[1],i = t[2],s = t[3],a = r[0],c = r[1],u = r[2],l = r[3];return e[0] = n * l + s * a + o * u - i * c, e[1] = o * l + s * c + i * a - n * u, e[2] = i * l + s * u + n * c - o * a, e[3] = s * l - n * a - o * c - i * u, e;}, _.mul = _.multiply, _.scale = l.scale, _.rotateX = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + s * a, e[1] = o * c + i * a, e[2] = i * c - o * a, e[3] = s * c - n * a, e;}, _.rotateY = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c - i * a, e[1] = o * c + s * a, e[2] = i * c + n * a, e[3] = s * c - o * a, e;}, _.rotateZ = function (e, t, r) {r *= .5;var n = t[0],o = t[1],i = t[2],s = t[3],a = Math.sin(r),c = Math.cos(r);return e[0] = n * c + o * a, e[1] = o * c - n * a, e[2] = i * c + s * a, e[3] = s * c - i * a, e;}, _.calculateW = function (e, t) {var r = t[0],n = t[1],o = t[2];return e[0] = r, e[1] = n, e[2] = o, e[3] = Math.sqrt(Math.abs(1 - r * r - n * n - o * o)), e;}, _.dot = l.dot, _.lerp = l.lerp, _.slerp = function (e, t, r, o) {var i,s,a,c,u,l = t[0],h = t[1],d = t[2],g = t[3],p = r[0],f = r[1],v = r[2],_ = r[3];return (s = l * p + h * f + d * v + g * _) < 0 && (s = -s, p = -p, f = -f, v = -v, _ = -_), 1 - s > n ? (i = Math.acos(s), a = Math.sin(i), c = Math.sin((1 - o) * i) / a, u = Math.sin(o * i) / a) : (c = 1 - o, u = o), e[0] = c * l + u * p, e[1] = c * h + u * f, e[2] = c * d + u * v, e[3] = c * g + u * _, e;}, _.sqlerp = function () {var e = _.createFloat64(),t = _.createFloat64();return function (r, n, o, i, s, a) {return _.slerp(e, n, s, a), _.slerp(t, o, i, a), _.slerp(r, e, t, 2 * a * (1 - a)), r;};}(), _.invert = function (e, t) {var r = t[0],n = t[1],o = t[2],i = t[3],s = r * r + n * n + o * o + i * i,a = s ? 1 / s : 0;return e[0] = -r * a, e[1] = -n * a, e[2] = -o * a, e[3] = i * a, e;}, _.conjugate = function (e, t) {return e[0] = -t[0], e[1] = -t[1], e[2] = -t[2], e[3] = t[3], e;}, _.length = l.length, _.len = _.length, _.squaredLength = l.squaredLength, _.sqrLen = _.squaredLength, _.normalize = l.normalize, _.fromMatrix33 = function (e, t) {var r,n = t[0] + t[4] + t[8];if (n > 0) r = Math.sqrt(n + 1), e[3] = .5 * r, r = .5 / r, e[0] = (t[5] - t[7]) * r, e[1] = (t[6] - t[2]) * r, e[2] = (t[1] - t[3]) * r;else {var o = 0;t[4] > t[0] && (o = 1), t[8] > t[3 * o + o] && (o = 2);var i = (o + 1) % 3,s = (o + 2) % 3;r = Math.sqrt(t[3 * o + o] - t[3 * i + i] - t[3 * s + s] + 1), e[o] = .5 * r, r = .5 / r, e[3] = (t[3 * i + s] - t[3 * s + i]) * r, e[i] = (t[3 * i + o] + t[3 * o + i]) * r, e[s] = (t[3 * s + o] + t[3 * o + s]) * r;}return e;}, _.toString = function (e) {return "[" + e[0] + ", " + e[1] + ", " + e[2] + ", " + e[3] + "]";}, _.exactEquals = l.exactEquals, _.equals = l.equals;var y = _,m = { frustum: function frustum(e, t, r, n, o, i, s) {var a = 1 / (r - t),c = 1 / (o - n),u = 1 / (i - s);return e[0] = 2 * i * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 2 * i * c, e[6] = 0, e[7] = 0, e[8] = (r + t) * a, e[9] = (o + n) * c, e[10] = (s + i) * u, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = s * i * 2 * u, e[15] = 0, e;}, perspective: function perspective(e, t, r, n, o) {var i = 1 / Math.tan(t / 2),s = 1 / (n - o);return e[0] = i / r, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = i, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (o + n) * s, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * o * n * s, e[15] = 0, e;}, ortho: function ortho(e, t, r, n, o, i, s) {var a = 1 / (t - r),c = 1 / (n - o),u = 1 / (i - s);return e[0] = -2 * a, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * u, e[11] = 0, e[12] = (t + r) * a, e[13] = (o + n) * c, e[14] = (s + i) * u, e[15] = 1, e;}, lookAt: function lookAt(e, t, r, o) {var i,s,a,c,u,l,h,d,g,p,f = t[0],_ = t[1],y = t[2],m = o[0],E = o[1],x = o[2],R = r[0],A = r[1],P = r[2];return Math.abs(f - R) < n && Math.abs(_ - A) < n && Math.abs(y - P) < n ? v.identity(e) : (h = f - R, d = _ - A, g = y - P, i = E * (g *= p = 1 / Math.sqrt(h * h + d * d + g * g)) - x * (d *= p), s = x * (h *= p) - m * g, a = m * d - E * h, (p = Math.sqrt(i * i + s * s + a * a)) ? (i *= p = 1 / p, s *= p, a *= p) : (i = 0, s = 0, a = 0), c = d * a - g * s, u = g * i - h * a, l = h * s - d * i, (p = Math.sqrt(c * c + u * u + l * l)) ? (c *= p = 1 / p, u *= p, l *= p) : (c = 0, u = 0, l = 0), e[0] = i, e[1] = c, e[2] = h, e[3] = 0, e[4] = s, e[5] = u, e[6] = d, e[7] = 0, e[8] = a, e[9] = l, e[10] = g, e[11] = 0, e[12] = -(i * f + s * _ + a * y), e[13] = -(c * f + u * _ + l * y), e[14] = -(h * f + d * _ + g * y), e[15] = 1, e);}, transformProjectionMatrix: function transformProjectionMatrix(e, t, r) {var n = t[0],o = t[1],i = t[2],s = r[3] * n + r[7] * o + r[11] * i + r[15];return s = s || 1, e[0] = (r[0] * n + r[4] * o + r[8] * i + r[12]) / s, e[1] = (r[1] * n + r[5] * o + r[9] * i + r[13]) / s, e[2] = (r[2] * n + r[6] * o + r[10] * i + r[14]) / s, e;} };t.default = { Vector2: s, Vector3: c, Vector4: l, Matrix22: d, Matrix33: p, Matrix44: v, Quat: y, ProjectionUtils: m, FLOAT64_TOLERANCE: n, FLOAT32_TOLERANCE: o };}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = { assert: function assert(e, t) {if (!e) throw new Error(t);} };t.ConsoleUtils = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.definePlaneThroughPoints = t.getPlaneTransforms = t.limitRange = t.PI2 = t.sortedIndex = t.clamp = t.orient2D = t.signedDistanceTo2DLine = t.intersectIntervals = t.solveTwoEquationsTwoVariables = t.closestPointToTriangle = t.closestPointToPolyline = t.distancePointToLineSegment = t.projectPointToLineSegment = t.angleDifference = t.periodicDifference = t.minMaxCosSinFunc = t.convertToOtherPeriodicRange = t.adjustParameterToPeriodicRange = t.getShortestParametricRange = t.isParameterWithinPeriodicRange = t.normalizeSegmentsToPeriodicRange = t.normalizeParametricRange = t.normalizeParametricRangeToShiftedRange = t.normalizeParameterToShiftedRange = t.adjustAngleToRange = t.normalizeAngleRange = t.normalizeAngle = t.normalizeParameter = t.foldNearTo = t.foldAbove = t.fold = t.modulus = t.getSignedAngle = t.isPointInsidePolygon2D = t.binomialCoefficients = void 0;var n = r(1),o = r(0),i = r(2),s = 2 * Math.PI,a = [];!function () {for (var e = 0; e < 8; ++e) {a[e] = [1];for (var t = 1; t < e; ++t) {a[e][t] = a[e - 1][t - 1] + a[e - 1][t];}a[e][e] = 1;}}();var c = function c(e, t, r) {return Math.min(Math.max(t, e), r);},u = function u(e, t) {return e - t * Math.floor(e / t);},l = function l(e, t) {var r = e % t;return r < 0 ? r + t : r;},h = function h(e, t, r) {return l(e - t, r) + t;},d = function d(e, t) {return e < 0 ? t + e % t : e % t;},g = function g(e, t) {return d(e - t[0], t[1] - t[0]) + t[0];},p = function p(e, t) {i.ConsoleUtils.assert(e[1] >= e[0], "normalizeParametricRange: in_range ends not in order.");var r = e[1] - e[0],n = d(e[0], t);return [n, n + r];},f = function f(e, t, r, n, o) {if (!isFinite(r)) return e;var i = p(t, r),s = d(e, r),a = s + r;if (n = !!n, s >= i[0] && s <= i[1]) return t[0] + (s - i[0]);if (a >= i[0] && a <= i[1]) return t[0] + (a - i[0]);var c = Math.abs(i[0] - s),u = Math.abs(s - i[1]),l = Math.abs(i[0] - a),h = Math.abs(a - i[1]);return o ? Math.min(c, l) < Math.min(u, h) ? t[0] : t[1] : Math.min(c, u) > Math.min(l, h) && !n ? t[0] + (a - i[0]) : t[0] + (s - i[0]);},v = function v(e, t, r) {var n = Math.abs(e - t);return isFinite(r) && (n %= r) > r / 2 ? r - n : n;},_ = function _(e, t, r) {var i = n.Vector3.sub(n.Vector3.createFloat64(), t, e),s = n.Vector3.dot(i, i);if (s < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var a = n.Vector3.sub(n.Vector3.createFloat64(), r, e);return n.Vector3.dot(a, i) / s;};t.binomialCoefficients = a, t.isPointInsidePolygon2D = function (e, t) {for (var r = !1, n = t.length, o = 0, i = n - 2; o < n; o += 2) {t[o + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[o]) * (e[1] - t[o + 1]) / (t[i + 1] - t[o + 1]) + t[o] && (r = !r), i = o;}return r;}, t.getSignedAngle = function (e, t) {var r = c(n.Vector2.dot(e, t), -1, 1),o = t[0] * e[1] - t[1] * e[0];return 0 === o ? .5 * Math.PI * (r - 1) : o < 0 ? -Math.acos(r) : Math.acos(r);}, t.modulus = u, t.fold = l, t.foldAbove = h, t.foldNearTo = function (e, t, r) {return h(e, t - r / 2, r);}, t.normalizeParameter = d, t.normalizeAngle = function (e) {return d(e, s);}, t.normalizeAngleRange = function (e) {return p(e, 2 * Math.PI);}, t.adjustAngleToRange = function (e, t) {return f(e, t, 2 * Math.PI);}, t.normalizeParameterToShiftedRange = g, t.normalizeParametricRangeToShiftedRange = function (e, t) {i.ConsoleUtils.assert(e[1] >= e[0], "normalizeParametricRangeToShiftedRange: in_range ends not in order.");var r = e[1] - e[0],n = g(e[0], t);return [n, n + r];}, t.normalizeParametricRange = p, t.normalizeSegmentsToPeriodicRange = function (e, t, r, n, i) {for (var s = void 0 !== n ? n : o.KERNEL_TOLERANCE, a = void 0 !== i ? i : t[1] - t[0], c = [], u = 0; u < e.length; u++) {var l = g(e[u][0], t),h = e[u][1] - e[u][0];if (h >= a) return [[t[0], t[1]]];var d = l + h;d < t[1] ? c.push([l, d]) : (c.push([l, t[1]]), c.push([t[0], d - t[1] + t[0]]));}var p = [];for (c.sort(function (e, t) {return e[0] - t[0];}), u = 0; u < c.length; u++) {for (var f = c[u]; u + 1 < c.length && c[u + 1][0] < f[1];) {f[1] = Math.max(f[1], c[u + 1][1]), u++;}(Math.abs(f[1] - f[0]) > s || !r) && p.push(f);}return p;}, t.isParameterWithinPeriodicRange = function (e, t, r, n) {var o = f(e, t, r);return n = n || 0, o > t[0] - n && o < t[1] + n;}, t.getShortestParametricRange = function (e, t, r) {if ((e = d(e, r)) > (t = d(t, r))) {var n = e;e = t, t = n;}return e - t + r < t - e ? [t, e + r] : [e, t];}, t.adjustParameterToPeriodicRange = f, t.convertToOtherPeriodicRange = function (e, t, r, n) {if (!isFinite(r)) return i.ConsoleUtils.assert(e[0] >= t[0] - n, "The start of the input range doesn't lie in the target range."), i.ConsoleUtils.assert(e[1] <= t[1] + n, "The input range doesn't lie within the target range."), e;if (n = n || 0, e[1] - e[0] >= r - n) return t[1] - t[0] < r - n && console.error("The input range is larger than the target range."), t;var o = f(e[0], t, r);i.ConsoleUtils.assert(o >= t[0] - n, "The start of the input range doesn't lie in the target range.");var s = o + e[1] - e[0];return i.ConsoleUtils.assert(s <= t[1] + n, "The input range doesn't lie within the target range."), [o, s];}, t.minMaxCosSinFunc = function (e, t, r, n) {if (0 === e && 0 === t) return [r, r];var o,i = p(n, 2 * Math.PI),s = f(Math.atan(t / e), i, Math.PI, !0),a = [];for (o = 0; o < 3; ++o) {i[0] <= s && i[1] >= s && a.push(e * Math.cos(s) + t * Math.sin(s)), s += Math.PI;}if (n[1] - n[0] < 2 * Math.PI) for (o = 0; o < 2; o++) {a.push(e * Math.cos(n[o]) + t * Math.sin(n[o]));}return [Math.min.apply(null, a) + r, Math.max.apply(null, a) + r];}, t.periodicDifference = v, t.angleDifference = function (e, t) {return v(e, t, 2 * Math.PI);}, t.projectPointToLineSegment = _, t.distancePointToLineSegment = function (e, t, r, o) {var i = _(e, t, r);i = c(i, 0, 1);var s = o || n.Vector3.createFloat64();return n.Vector3.lerp(s, e, t, i), n.Vector3.distance(s, r);}, t.closestPointToPolyline = function (e, t, r, o, i) {for (var s = "number" == typeof t[0], a = s ? t.length / 3 : t.length, u = void 0, l = Number.POSITIVE_INFINITY, h = n.Vector3.createFloat64(), d = 0; d < a - 1; ++d) {var g = r ? r[d] : d,p = r ? r[d + 1] : d + 1,f = 0,v = 1;if (!(o && (o[0] > g && (f = (o[0] - g) / (p - g)), o[1] < p && (v = (o[1] - g) / (p - g)), v < f))) {var y, m;s ? (y = [t[3 * d], t[3 * d + 1], t[3 * d + 2]], m = [t[3 * d + 3], t[3 * d + 4], t[3 * d + 5]]) : (y = t[d], m = t[d + 1]);var E = _(y, m, e);E = c(E, f, v), n.Vector3.lerp(h, y, m, E);var x = n.Vector3.squaredDistance(h, e);x < l && (u = (1 - E) * g + E * p, l = x, i && n.Vector3.copy(i, h));}}return u;}, t.closestPointToTriangle = function (e, t, r, i, s) {var a,u,l = n.Vector3.sub(n.Vector3.createFloat64(), r, t),h = n.Vector3.sub(n.Vector3.createFloat64(), i, t),d = n.Vector3.sub(n.Vector3.createFloat64(), e, t),g = n.Vector3.squaredLength(l),p = n.Vector3.squaredLength(h),f = n.Vector3.dot(l, h),v = n.Vector3.dot(d, l),y = n.Vector3.dot(d, h);if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = u = 0;else if (g < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = 0, u = c(y / p, 0, 1);else if (p < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) a = c(v / g, 0, 1), u = 0;else {var m = n.Matrix22.createFloat64FromValues(g, f, f, p);if (Math.abs(n.Matrix22.determinant(m)) > n.FLOAT64_TOLERANCE) {n.Matrix22.invert(m, m);var E = [v, y];n.Vector2.transformMatrix22(E, E, m), a = E[0], u = E[1];} else u = y / p, (a = v / g) <= 0 || u <= 0 ? (a = c(a, 0, 1), u = c(u, 0, 1)) : a < u ? (a = c(a, 0, 1), u = 0) : (a = 0, u = c(u, 0, 1));}if (a < 0 && y >= 0 && y <= p && (a = 0, u = y / p), u < 0 && v >= 0 && v <= g && (a = v / g, u = 0), a + u > 1) {var x = _(r, i, e);x >= 0 && x <= 1 && (a = 1 - x, u = x);}if (a < 0 || u < 0 || a + u > 1) {var R = n.Vector3.squaredLength(d),A = n.Vector3.squaredDistance(e, r),P = n.Vector3.squaredDistance(e, i);A <= R && A <= P ? (a = 1, u = 0) : P <= R && P <= A ? (a = 0, u = 1) : a = u = 0;}return s && (n.Vector3.scaleAndAdd(s, t, l, a), n.Vector3.scaleAndAdd(s, s, h, u)), { coordA: a, coordB: u };}, t.solveTwoEquationsTwoVariables = function (e) {var t = e[0][0],r = e[0][1],n = e[1][0],o = e[1][1],i = t * o - r * n;if (0 !== i) {var s = o * e[0][2] - r * e[1][2],a = -n * e[0][2] + t * e[1][2];return [s /= i, a /= i];}}, t.intersectIntervals = function (e, t, r) {r = r || 0;for (var n = [], o = 0; o < e.length; o++) {for (var i = 0; i < t.length; i++) {var s = Math.max(e[o][0], t[i][0]),a = Math.min(e[o][1], t[i][1]);a - r > s && (a > s ? n.push([s, a]) : n.push([a, a]));}}return n;}, t.signedDistanceTo2DLine = function (e, t, r) {var n = r[0] - e[0],o = r[1] - e[1];return t[1] * n - t[0] * o;}, t.orient2D = function (e, t, r) {var n = e[0] - r[0],o = t[0] - r[0],i = e[1] - r[1];return n * (t[1] - r[1]) - i * o;}, t.clamp = c, t.sortedIndex = function (e, t) {for (var r = 0, n = e.length; n > r;) {var o = Math.floor((r + n) / 2);t > e[o] ? r = o + 1 : n = o;}return n;}, t.PI2 = s, t.limitRange = function (e, t, r, o) {if (i.ConsoleUtils.assert(2 === t.length), i.ConsoleUtils.assert(t[0] <= t[1]), r) return t[1] - t[0] < o + n.FLOAT64_TOLERANCE ? [t[0], t[1]] : (console.warn("limitRange : in_limitRange length cannot be greater than in_period"), [t[0], t[0] + o]);var s = Math.max(e[0], t[0]),a = Math.min(e[1], t[1]);return s > a && (s > a + n.FLOAT64_TOLERANCE && console.warn("limitRange : requested range must overlap in_oldRange"), s = a = t[0] > e[1] ? e[1] : e[0]), [s, a];}, t.getPlaneTransforms = function (e) {var t,r,o = e.evaluateDu(0, 0),i = e.evaluateDv(0, 0),s = e.getOrigin();if (!n.Vector3.isParallel(o, [1, 0, 0], 1) || !n.Vector3.isParallel(i, [0, 1, 0], 1) || Math.abs(s[2]) > n.FLOAT64_TOLERANCE) {var a = e.evaluateNormal(0, 0);t = n.Matrix44.createFloat64FromValues(o[0], o[1], o[2], 0, i[0], i[1], i[2], 0, a[0], a[1], a[2], 0, s[0], s[1], s[2], 1), r = n.Matrix44.createFloat64(), n.Matrix44.invert(r, t);}return { uvToThreeSpace: t, threeSpaceToUV: r };}, t.definePlaneThroughPoints = function (e) {var t,r,i,s = [0, 0, 0],a = [0, 0, 0];if (!(e.length < 3)) {var c = [0, 0, 0];for (t = 0; t < e.length; ++t) {n.Vector3.add(c, c, e[t]);}n.Vector3.scale(c, c, 1 / e.length);var l = [0, 0, 0];r = 0;var h = 0,d = 0;for (t = 0; t < e.length; ++t) {(i = n.Vector3.squaredDistance(c, e[t])) > d && (d = i, h = t), (i /= 100) > r && (r = i, n.Vector3.sub(l, e[t], c));var g = (t + 1) % e.length;(i = n.Vector3.squaredDistance(e[t], e[g])) > r && (r = i, n.Vector3.sub(l, e[g], e[t]));}if (!(d < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(l, l);var p = [0, 0, 0];for (r = 0, t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c), n.Vector3.cross(s, s, l), (i = n.Vector3.squaredLength(s)) > r && (r = i, n.Vector3.copy(p, s));}if (!(r < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE)) {n.Vector3.normalize(p, p);var f = e[h],v = e[u(h - 1, e.length)],_ = e[u(h + 1, e.length)];n.Vector3.sub(s, v, f), n.Vector3.sub(a, _, f), n.Vector3.dot(n.Vector3.cross(a, a, s), p) < 0 && n.Vector3.negate(p, p);var y = [0, 0, 0];n.Vector3.cross(y, p, l), n.Vector3.normalize(y, y);var m = Number.POSITIVE_INFINITY,E = Number.NEGATIVE_INFINITY,x = Number.POSITIVE_INFINITY,R = Number.NEGATIVE_INFINITY;for (t = 0; t < e.length; ++t) {n.Vector3.sub(s, e[t], c);var A = n.Vector3.dot(s, l),P = n.Vector3.dot(s, y);m = Math.min(m, A), E = Math.max(E, A), x = Math.min(x, P), R = Math.max(R, P);}return { origin: c, normal: p, uAxis: l, vAxis: y, uRange: [m, E], vRange: [x, R] };}}}};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BoundingBox = void 0;var n = r(1),o = r(0),i = function i(e, t) {this.min = e ? n.Vector3.createFloat64FromValues(e[0], e[1], e[2]) : n.Vector3.createFloat64FromValues(1 / 0, 1 / 0, 1 / 0), this.max = t ? n.Vector3.createFloat64FromValues(t[0], t[1], t[2]) : n.Vector3.createFloat64FromValues(-1 / 0, -1 / 0, -1 / 0);};i.prototype.toString = function () {return "(x:" + this.min[0] + ", y:" + this.min[1] + ", z:" + this.min[2] + ") -> (x:" + this.max[0] + ", y:" + this.max[1] + ", z:" + this.max[2] + ")";}, i.prototype.copy = function (e) {return n.Vector3.copy(this.min, e.min), n.Vector3.copy(this.max, e.max), this;}, i.prototype.clone = function () {return new i(this.min, this.max);}, i.prototype.getWidth = function (e) {var t = 0;return 0 <= e && e <= 2 ? (t = this.max[e] - this.min[e], isFinite(t) ? t : 0) : (console.error("wrong axis argument supplied to BoundingBox.getWidth(): " + e), 0);}, i.prototype.getMaxMinAligned = function (e, t, r) {for (var o, s, a, c = this.getCorners(), u = [], l = [], h = [], d = 0; d < c.length; ++d) {o = n.Vector3.dot(c[d], e), s = n.Vector3.dot(c[d], t), a = n.Vector3.dot(c[d], r), u.push(o), l.push(s), h.push(a);}var g = Math.min.apply(void 0, u),p = Math.min.apply(void 0, l),f = Math.min.apply(void 0, h),v = Math.max.apply(void 0, u),_ = Math.max.apply(void 0, l),y = Math.max.apply(void 0, h);return new i([g, p, f], [v, _, y]);}, i.prototype.include = function (e) {return this.includeX(e.min[0], e.max[0]), this.includeY(e.min[1], e.max[1]), this.includeZ(e.min[2], e.max[2]), this;}, i.prototype.includeX = function (e, t) {return this.min[0] = Math.min(this.min[0], e), this.max[0] = Math.max(this.max[0], t), this;}, i.prototype.includeY = function (e, t) {return this.min[1] = Math.min(this.min[1], e), this.max[1] = Math.max(this.max[1], t), this;}, i.prototype.includeZ = function (e, t) {return this.min[2] = Math.min(this.min[2], e), this.max[2] = Math.max(this.max[2], t), this;}, i.prototype.includeSphere = function (e) {var t = e.getCenter(),r = e.getRadius();return this.includeX(t[0] - r, t[0] + r), this.includeY(t[1] - r, t[1] + r), this.includeZ(t[2] - r, t[2] + r), this;}, i.prototype.translate = function (e) {return n.Vector3.add(this.min, this.min, e), n.Vector3.add(this.max, this.max, e), this;}, i.prototype.getCorners = function () {var e = this.getDiagonal();return [n.Vector3.clone(this.min), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1] + e[1], this.min[2]), n.Vector3.createFloat64FromValues(this.min[0] + e[0], this.min[1], this.min[2] + e[2]), n.Vector3.createFloat64FromValues(this.min[0], this.min[1] + e[1], this.min[2] + e[2]), n.Vector3.clone(this.max)];}, i.prototype.transform = function (e) {if (!this.isEmpty()) {var t = this.getCorners();this.max[0] = -1 / 0, this.max[1] = -1 / 0, this.max[2] = -1 / 0, this.min[0] = 1 / 0, this.min[1] = 1 / 0, this.min[2] = 1 / 0;for (var r = 0; r < t.length; ++r) {n.Vector3.transformMatrix44(t[r], t[r], e), n.Vector3.max(this.max, this.max, t[r]), n.Vector3.min(this.min, this.min, t[r]);}}return this;}, i.prototype.includePointXYZ = function (e) {return this.includeX(e.x, e.x), this.includeY(e.y, e.y), this.includeZ(e.z, e.z), this;}, i.prototype.includePoint = function (e) {return this.includeX(e[0], e[0]), this.includeY(e[1], e[1]), this.includeZ(e[2], e[2]), this;}, i.prototype.getCenter = function () {var e = n.Vector3.createFloat64();return n.Vector3.add(e, this.min, this.max), n.Vector3.scale(e, e, .5), e;}, i.prototype.getDiagonal = function () {var e = n.Vector3.createFloat64();return n.Vector3.sub(e, this.max, this.min), e;}, i.prototype.isPointInside = function (e) {return !(e[0] < this.min[0] || e[0] > this.max[0] || e[1] < this.min[1] || e[1] > this.max[1] || e[2] < this.min[2] || e[2] > this.max[2]);}, i.prototype.isPointInsideWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e[0] < this.min[0] - t || e[0] > this.max[0] + t || e[1] < this.min[1] - t || e[1] > this.max[1] + t || e[2] < this.min[2] - t || e[2] > this.max[2] + t);}, i.prototype.intersects = function (e) {return !(e.min[0] > this.max[0] || e.max[0] < this.min[0] || e.min[1] > this.max[1] || e.max[1] < this.min[1] || e.min[2] > this.max[2] || e.max[2] < this.min[2]);}, i.prototype.intersectsWithTolerance = function (e, t) {return t || (t = o.KERNEL_TOLERANCE), !(e.min[0] > this.max[0] + t || e.max[0] < this.min[0] - t || e.min[1] > this.max[1] + t || e.max[1] < this.min[1] - t || e.min[2] > this.max[2] + t || e.max[2] < this.min[2] - t);}, i.prototype.isEmpty = function () {return this.max[0] < this.min[0] || this.max[1] < this.min[1] || this.max[2] < this.min[2];}, i.prototype.setEmpty = function () {return this.max[0] = -1 / 0, this.min[0] = 1 / 0, this.max[1] = -1 / 0, this.min[1] = 1 / 0, this.max[2] = -1 / 0, this.min[2] = 1 / 0, this;}, i.prototype.isBounded = function () {return isFinite(this.max[0]) && isFinite(this.max[1]) && isFinite(this.max[2]) && isFinite(this.min[0]) && isFinite(this.min[1]) && isFinite(this.min[2]);}, t.BoundingBox = i;}, function (e, t, r) {"use strict";var n,o,i = e.exports = r(10),s = r(61);i.codegen = r(99), i.fetch = r(100), i.path = r(101), i.fs = i.inquire("fs"), i.toArray = function (e) {if (e) {for (var t = Object.keys(e), r = new Array(t.length), n = 0; n < t.length;) {r[n] = e[t[n++]];}return r;}return [];}, i.toObject = function (e) {for (var t = {}, r = 0; r < e.length;) {var n = e[r++],o = e[r++];void 0 !== o && (t[n] = o);}return t;};var a = /\\/g,c = /"/g;i.isReserved = function (e) {return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(e);}, i.safeProp = function (e) {return !/^[$\w_]+$/.test(e) || i.isReserved(e) ? '["' + e.replace(a, "\\\\").replace(c, '\\"') + '"]' : "." + e;}, i.ucFirst = function (e) {return e.charAt(0).toUpperCase() + e.substring(1);};var u = /_([a-z])/g;i.camelCase = function (e) {return e.substring(0, 1) + e.substring(1).replace(u, function (e, t) {return t.toUpperCase();});}, i.compareFieldsById = function (e, t) {return e.id - t.id;}, i.decorateType = function (e, t) {if (e.$type) return t && e.$type.name !== t && (i.decorateRoot.remove(e.$type), e.$type.name = t, i.decorateRoot.add(e.$type)), e.$type;n || (n = r(63));var o = new n(t || e.name);return i.decorateRoot.add(o), o.ctor = e, Object.defineProperty(e, "$type", { value: o, enumerable: !1 }), Object.defineProperty(e.prototype, "$type", { value: o, enumerable: !1 }), o;};var l = 0;i.decorateEnum = function (e) {if (e.$type) return e.$type;o || (o = r(11));var t = new o("Enum" + l++, e);return i.decorateRoot.add(t), Object.defineProperty(e, "$type", { value: t, enumerable: !1 }), t;}, Object.defineProperty(i, "decorateRoot", { get: function get() {return s.decorated || (s.decorated = new (r(71))());} });}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Point = void 0;var n = r(1),o = r(43),i = r(4),s = r(0),a = function a(e) {o.BaseGeometry.call(this), this._position = n.Vector3.createFloat64(), e && n.Vector3.copy(this._position, e);};(a.prototype = Object.create(o.BaseGeometry.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.POINT;}, a.prototype.clone = function () {var e = new a();return e.copy(this), e;}, a.prototype.copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this.copyPosition(e.getPosition());}, a.prototype.getPosition = function () {return this._position;}, a.prototype.copyPosition = function (e) {n.Vector3.copy(this._position, e);}, a.prototype.setPosition = function (e, t, r) {n.Vector3.set(this._position, e, t, r);}, a.prototype.getBoundingBox = function () {var e = new i.BoundingBox();return e.includePoint(this.getPosition()), e;}, a.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e);}, a.prototype.toObject = function () {return { position: this.vectorToObject(this._position) };}, t.Point = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Line = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = function l() {a.Curve.call(this), this._position = n.Vector3.createFloat64FromValues(0, 0, 0), this._direction = n.Vector3.createFloat64FromValues(1, 0, 0);};(l.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.LINE;}, l.prototype.set = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.copy(this._position, e), n.Vector3.copy(this._direction, t);}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.tessellate = function (e, t) {var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);var n = e[0];r.positions.push(this.evaluatePosition(n));for (var o = 1; o < e.length; ++o) {var i = e[o];r.positions.push(this.evaluatePosition(i)), r.offsets.push(r.positions.length - 1), n = i;}return r;}, l.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._position, e._position), n.Vector3.copy(this._direction, e._direction);}, l.prototype.getRangeUnlimited = function () {return [-1 / 0, 1 / 0];}, l.prototype.isPeriodicUnlimited = function () {return !1;}, l.prototype.isClosedUnlimited = function () {return !1;}, l.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(t, this._position, this._direction, e);}, l.prototype.evaluateDt = function (e) {return n.Vector3.clone(this._direction);}, l.prototype.tangentLength = function (e) {return n.Vector3.length(this._direction);}, l.prototype.getTangentCone = function (e) {var t = n.Vector3.createFloat64();return new i.TangentCone(n.Vector3.normalize(t, this.evaluateDt(0)), 0);}, l.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), isFinite(e[0]) && isFinite(e[1]) ? (e[1] - e[0]) * n.Vector3.length(this._direction) : 1 / 0;}, l.prototype.getParameterFromArcLength = function (e, t) {if (void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), isFinite(t[0]) && isFinite(t[1])) {var r = t[0] + e / n.Vector3.length(this._direction);return (0, c.clamp)(r, t[0], t[1]);}return NaN;}, l.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = new o.BoundingBox();return isFinite(e[0]) && isFinite(e[1]) ? (t.includePoint(this.evaluatePosition(e[0])), t.includePoint(this.evaluatePosition(e[1]))) : (t.includePoint([1 / 0, 1 / 0, 1 / 0]), t.includePoint([-1 / 0, -1 / 0, -1 / 0])), t;}, l.prototype.closestToRayParam = function (e, t, r, o) {var i = n.Vector3.createFloat64();n.Vector3.sub(i, this._position, e);var s = n.Vector3.squaredLength(this._direction),a = n.Vector3.squaredLength(t),c = n.Vector3.dot(this._direction, t),u = n.Vector3.dot(i, this._direction),l = n.Vector3.dot(i, t),h = s * a - c * c,d = (c * l - a * u) / h,g = (c * u - s * l) / h;if (isFinite(d) && isFinite(g)) {if (r) if (d < r[0]) {if (d = r[0], void 0 !== o) {var p = this.evaluatePosition(r[0]),f = n.Vector3.createFloat64();n.Vector3.sub(f, p, e), g = n.Vector3.dot(f, t) / a;}} else if (d > r[1] && (d = r[1], void 0 !== o)) {var v = this.evaluatePosition(r[1]);f = n.Vector3.createFloat64(), n.Vector3.sub(f, v, e), g = n.Vector3.dot(f, t) / a;}if (void 0 !== o) {var _ = this.evaluatePosition(d),y = n.Vector3.createFloat64();if (n.Vector3.scaleAndAdd(y, e, t, g), n.Vector3.squaredDistance(_, y) > o * o) return;}return d;}}, l.prototype.setFromEndpoints = function (e, t) {u.ConsoleUtils.assert(n.Vector3.squaredDistance(e, t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._position = n.Vector3.clone(e), n.Vector3.normalize(this._direction, n.Vector3.sub(this._direction, t, e)), this.unlimitRange();}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._position, this._position, e), n.Vector3.transformAsDirectionMatrix44(this._direction, this._direction, e);}, l.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._position);var o = this._direction,i = n.Vector3.dot(r, o) / n.Vector3.squaredLength(o);return isFinite(t[0]) && isFinite(t[1]) ? (0, c.clamp)(i, t[0], t[1]) : i;}, l.prototype.suggestSplittingParam = function (e) {}, l.prototype.toObject = function () {return { position: this.vectorToObject(this._position), direction: this.vectorToObject(this._direction), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Line = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = !1,o = !1,i = {},s = { init3D: function init3D(e) {for (var t in n = !0, e) {"function" == typeof e[t] && (s[t] = e[t].bind(e));}}, setLevel: function setLevel(e, t) {var r = i[e];return i[e] = t, console.log("Debug of " + e + " set to level " + t), r;}, level: function level(e) {if (!n) return 0;var t = i[e];return void 0 === t ? 0 : t;}, setConsoleWarnings: function setConsoleWarnings(e) {o = e;}, warn: function warn(e) {o && console.warn(e);} };t.DebugUtils = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseTopology = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this), this._attributes = [];};(i.prototype = Object.create(n.Base.prototype)).getTopologyType = function () {console.warn("BaseTopology.getTopologyType : abstract method invoked!");}, i.prototype.getBoundingBox = function () {console.warn("BaseTopology.getBoundingBox : abstract method invoked!");}, i.prototype.getBody = function () {console.warn("BaseTopology.getBody : abstract method invoked!");}, i.prototype.collectFaces = function (e) {return console.warn("BaseTopology.collectFaces : abstract method invoked!"), e || new Set();}, i.prototype.collectEdges = function (e) {return console.warn("BaseTopology.collectEdges : abstract method invoked!"), e || new Set();}, i.prototype.collectVertices = function (e) {return console.warn("BaseTopology.collectVertices : abstract method invoked!"), e || new Set();}, i.prototype.getAttributes = function () {return this._attributes;}, i.prototype.addAttribute = function (e) {this._attributes ? this._attributes.push(e) : this._attributes = [e], e.addTopology(this);}, i.prototype.removeAttribute = function (e) {var t = this._attributes.indexOf(e);return t > -1 && (this._attributes.splice(t, 1), e.removeTopology(this), !0);}, i.prototype.removeAllAttributes = function () {if (this._attributes) for (var _e2 = 0; _e2 < this._attributes.length; _e2++) {this.removeAttribute(this._attributes[_e2]);}}, i.prototype.isVertex = function () {return this.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX;}, i.prototype.getFaces = function () {return Array.from(this.collectFaces());}, i.prototype.getEdges = function () {return Array.from(this.collectEdges());}, i.prototype.getVertices = function () {return Array.from(this.collectVertices());}, i.prototype.addAllToModelObject = function (e, t) {if (!e.topologies[this.getGuid()]) {var _t2 = {};_t2[o.TOPOLOGY_TYPES.toString(this.getTopologyType()).toLowerCase()] = this.toObject(), e.topologies[this.getGuid()] = _t2;}t.forEach(function (t) {null != t && (Array.isArray(t) ? t.forEach(function (t) {t.addToModelObject(e);}) : t.addToModelObject(e));});}, t.BaseTopology = i;}, function (e, t, r) {"use strict";(function (e) {var n = t;function o(e, t, r) {for (var n = Object.keys(t), o = 0; o < n.length; ++o) {void 0 !== e[n[o]] && r || (e[n[o]] = t[n[o]]);}return e;}function i(e) {function t(e, r) {if (!(this instanceof t)) return new t(e, r);Object.defineProperty(this, "message", { get: function get() {return e;} }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), r && o(this, r);}return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, "name", { get: function get() {return e;} }), t.prototype.toString = function () {return this.name + ": " + this.message;}, t;}n.asPromise = r(58), n.base64 = r(90), n.EventEmitter = r(91), n.float = r(92), n.inquire = r(59), n.utf8 = r(93), n.pool = r(94), n.LongBits = r(95), n.global = "undefined" != typeof window && window || void 0 !== e && e || "undefined" != typeof self && self || this, n.emptyArray = Object.freeze ? Object.freeze([]) : [], n.emptyObject = Object.freeze ? Object.freeze({}) : {}, n.isNode = Boolean(n.global.process && n.global.process.versions && n.global.process.versions.node), n.isInteger = Number.isInteger || function (e) {return "number" == typeof e && isFinite(e) && Math.floor(e) === e;}, n.isString = function (e) {return "string" == typeof e || e instanceof String;}, n.isObject = function (e) {return e && "object" == _typeof(e);}, n.isset = n.isSet = function (e, t) {var r = e[t];return !(null == r || !e.hasOwnProperty(t)) && ("object" != _typeof(r) || (Array.isArray(r) ? r.length : Object.keys(r).length) > 0);}, n.Buffer = function () {try {var e = n.inquire("buffer").Buffer;return e.prototype.utf8Write ? e : null;} catch (e) {return null;}}(), n._Buffer_from = null, n._Buffer_allocUnsafe = null, n.newBuffer = function (e) {return "number" == typeof e ? n.Buffer ? n._Buffer_allocUnsafe(e) : new n.Array(e) : n.Buffer ? n._Buffer_from(e) : "undefined" == typeof Uint8Array ? e : new Uint8Array(e);}, n.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, n.Long = n.global.dcodeIO && n.global.dcodeIO.Long || n.global.Long || n.inquire("long"), n.key2Re = /^true|false|0|1$/, n.key32Re = /^-?(?:0|[1-9][0-9]*)$/, n.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, n.longToHash = function (e) {return e ? n.LongBits.from(e).toHash() : n.LongBits.zeroHash;}, n.longFromHash = function (e, t) {var r = n.LongBits.fromHash(e);return n.Long ? n.Long.fromBits(r.lo, r.hi, t) : r.toNumber(Boolean(t));}, n.merge = o, n.lcFirst = function (e) {return e.charAt(0).toLowerCase() + e.substring(1);}, n.newError = i, n.ProtocolError = i("ProtocolError"), n.oneOfGetter = function (e) {for (var t = {}, r = 0; r < e.length; ++r) {t[e[r]] = 1;}return function () {for (var e = Object.keys(this), r = e.length - 1; r > -1; --r) {if (1 === t[e[r]] && void 0 !== this[e[r]] && null !== this[e[r]]) return e[r];}};}, n.oneOfSetter = function (e) {return function (t) {for (var r = 0; r < e.length; ++r) {e[r] !== t && delete this[e[r]];}};}, n.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, n._configure = function () {var e = n.Buffer;e ? (n._Buffer_from = e.from !== Uint8Array.from && e.from || function (t, r) {return new e(t, r);}, n._Buffer_allocUnsafe = e.allocUnsafe || function (t) {return new e(t);}) : n._Buffer_from = n._Buffer_allocUnsafe = null;};}).call(this, r(57));}, function (e, t, r) {"use strict";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = "Enum";var o = r(30),i = r(5);function s(e, t, r, o, i) {if (n.call(this, e, r), t && "object" != _typeof(t)) throw TypeError("values must be an object");if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = o, this.comments = i || {}, this.reserved = void 0, t) for (var s = Object.keys(t), a = 0; a < s.length; ++a) {"number" == typeof t[s[a]] && (this.valuesById[this.values[s[a]] = t[s[a]]] = s[a]);}}s.fromJSON = function (e, t) {var r = new s(e, t.values, t.options, t.comment, t.comments);return r.reserved = t.reserved, r;}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", t ? this.comment : void 0, "comments", t ? this.comments : void 0]);}, s.prototype.add = function (e, t, r) {if (!i.isString(e)) throw TypeError("name must be a string");if (!i.isInteger(t)) throw TypeError("id must be an integer");if (void 0 !== this.values[e]) throw Error("duplicate name '" + e + "' in " + this);if (this.isReservedId(t)) throw Error("id " + t + " is reserved in " + this);if (this.isReservedName(e)) throw Error("name '" + e + "' is reserved in " + this);if (void 0 !== this.valuesById[t]) {if (!this.options || !this.options.allow_alias) throw Error("duplicate id " + t + " in " + this);this.values[e] = t;} else this.valuesById[this.values[e] = t] = e;return this.comments[e] = r || null, this;}, s.prototype.remove = function (e) {if (!i.isString(e)) throw TypeError("name must be a string");var t = this.values[e];if (null == t) throw Error("name '" + e + "' does not exist in " + this);return delete this.valuesById[t], delete this.values[e], delete this.comments[e], this;}, s.prototype.isReservedId = function (e) {return o.isReservedId(this.reserved, e);}, s.prototype.isReservedName = function (e) {return o.isReservedName(this.reserved, e);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Surface = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = function a() {o.BaseGeometry.call(this), this._subrangeU = [], this._subrangeV = [];};(a.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrangeU = e.isLimitedU() ? [e._subrangeU[0], e._subrangeU[1]] : [], this._subrangeV = e.isLimitedV() ? [e._subrangeV[0], e._subrangeV[1]] : [];}, a.prototype.isLimitedU = function () {return this._subrangeU.length > 0;}, a.prototype.isLimitedV = function () {return this._subrangeV.length > 0;}, a.prototype.getRangeU = function () {return this.isLimitedU() ? this._subrangeU : this.getRangeUnlimitedU();}, a.prototype.getRangeV = function () {return this.isLimitedV() ? this._subrangeV : this.getRangeUnlimitedV();}, a.prototype.getRangeUnlimitedU = function () {console.warn("Surface.getRangeUnlimitedU : abstract method invoked!");}, a.prototype.getRangeUnlimitedV = function () {console.warn("Surface.getRangeUnlimitedV : abstract method invoked!");}, a.prototype.limitRangeU = function (e) {var t = this.getRangeU();this._subrangeU = (0, s.limitRange)(t, e, this.isPeriodicU(), this.getPeriodU());}, a.prototype.limitRangeV = function (e) {var t = this.getRangeV();this._subrangeV = (0, s.limitRange)(t, e, this.isPeriodicV(), this.getPeriodV());}, a.prototype.unlimitRangeU = function () {this._subrangeU = [];}, a.prototype.unlimitRangeV = function () {this._subrangeV = [];}, a.prototype.isPeriodicU = function () {return this.isPeriodicUnlimitedU() && !this.isLimitedU();}, a.prototype.isPeriodicV = function () {return this.isPeriodicUnlimitedV() && !this.isLimitedV();}, a.prototype.isPeriodicUnlimitedU = function () {console.warn("Surface.isPeriodicUnlimitedU : abstract method invoked!");}, a.prototype.isPeriodicUnlimitedV = function () {console.warn("Surface.isPeriodicUnlimitedV : abstract method invoked!");}, a.prototype.getPeriodU = function () {return this.isLimitedU() ? void 0 : this.getPeriodUnlimitedU();}, a.prototype.getPeriodV = function () {return this.isLimitedV() ? void 0 : this.getPeriodUnlimitedV();}, a.prototype.getPeriodUnlimitedU = function () {if (this.isPeriodicUnlimitedU()) {var e = this.getRangeUnlimitedU();return e[1] - e[0];}}, a.prototype.getPeriodUnlimitedV = function () {if (this.isPeriodicUnlimitedV()) {var e = this.getRangeUnlimitedV();return e[1] - e[0];}}, a.prototype.isClosedU = function () {if (this.isClosedUnlimitedU()) {if (this.isLimitedU()) {var e = this.getRangeUnlimitedU(),t = e[1] - e[0];return this._subrangeU[1] - this._subrangeU[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedV = function () {if (this.isClosedUnlimitedV()) {if (this.isLimitedV()) {var e = this.getRangeUnlimitedV(),t = e[1] - e[0];return this._subrangeV[1] - this._subrangeV[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, a.prototype.isClosedUnlimitedU = function () {console.warn("Surface.isClosedUnlimitedU : abstract method invoked!");}, a.prototype.isClosedUnlimitedV = function () {console.warn("Surface.isClosedUnlimitedV : abstract method invoked!");}, a.prototype.evaluatePosition = function (e, t) {console.warn("Surface.evaluatePosition : abstract method invoked");}, a.prototype.evaluateDu = function (e, t) {console.warn("Surface.evaluateDu : abstract method invoked");}, a.prototype.evaluateDv = function (e, t) {console.warn("Surface.evaluateDv : abstract method invoked");}, a.prototype.evaluateNormal = function (e, t) {var r = this.evaluateDu(e, t);return n.Vector3.cross(r, r, this.evaluateDv(e, t)), n.Vector3.normalize(r, r), r;}, a.prototype.closestParam = function (e) {console.warn("Surface.closestParam : abstract method invoked");}, a.prototype.vParamLine = function (e) {console.warn("Surface.vParamLine : abstract method invoked, returning undefined");}, a.prototype.uParamLine = function (e) {console.warn("Surface.uParamLine : abstract method invoked, returning undefined");}, a.prototype.getBoundingBox = function (e, t) {console.warn("Surface.getBoundingBox : abstract method invoked, returning undefined");}, a.prototype.transform = function (e) {console.warn("Surface.transform : abstract method invoked");}, t.Surface = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Loop = void 0;var n = r(9),o = r(0),i = function i() {n.BaseTopology.call(this), this._coedges = [], this._face = void 0;};(i.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LOOP;}, i.prototype.getFace = function () {return this._face;}, i.prototype.setFace = function (e) {this._face = e;}, i.prototype.getCoedges = function () {return this._coedges;}, i.prototype.setCoedges = function (e) {this._coedges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._coedges[t] = e[t];}}, i.prototype.addCoedge = function (e) {this._coedges ? this._coedges.push(e) : this._coedges = [e], e.setLoop(this);}, i.prototype.addCoedges = function (e) {this._coedges || (this._coedges = []);for (var t = 0; t < e.length; ++t) {e[t].setLoop(this);}this._coedges = this._coedges.concat(e);}, i.prototype.removeCoedge = function (e) {var t = this._coedges.indexOf(e);return t > -1 && (this._coedges.splice(t, 1), e.getLoop() === this && e.setLoop(void 0), !0);}, i.prototype.getBody = function () {return this._face ? this._face.getBody() : void 0;}, i.prototype.collectFaces = function (e) {return e = e || new Set(), this._face && e.add(this._face), e;}, i.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectEdges(e);}return e;}, i.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._coedges.length; ++t) {this._coedges[t].collectVertices(e);}return e;}, i.prototype.toString = function () {return "Loop";}, i.prototype.toObject = function () {return { coedges: this.refsToStrings(this._coedges), attributes: this.refsToStrings(this._attributes) };}, i.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._coedges, this._attributes]);}, t.Loop = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Circle = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(2),l = r(50),h = function h() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._radius = 1;};(h.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.CIRCLE;}, h.prototype.set = function (e, t, r) {u.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._radius = n.Vector3.length(r), this._computeYAxis();}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.getNormal = function () {return this._normal;}, h.prototype.setNormal = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis());}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.setOrigin = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, h.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimited = function () {return !0;}, h.prototype.isClosedUnlimited = function () {return !0;}, h.prototype._computeRadiusVector = function () {return n.Vector3.scale(n.Vector3.createFloat64(), this._xAxis, this._radius);}, h.prototype.tessellate = function (e, t) {t = t || s.TESSELLATION.LINEAR_PRECISION;var r = { positions: [], offsets: [], tolerance: 0 };r.offsets.push(0);for (var n = e[0], o = 1; o < e.length; ++o) {var i = e[o],a = l.CurveTessellator.getCircularArcRenderPoints(this, [n, i], t, 1 === o, r.positions);r.offsets.push(r.positions.length - 1), n = i, r.tolerance = Math.max(r.tolerance, a);}return r;}, h.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._radius), n.Vector3.add(t, t, this._center), t;}, h.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._radius), t;}, h.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._radius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._radius), t;}, h.prototype.tangentLength = function (e) {return this.getRadius();}, h.prototype.getArcLength = function (e) {return void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited()), this.getRadius() * (e[1] - e[0]);}, h.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = t[0] + e / this.getRadius();return (0, c.clamp)(r, t[0], t[1]);}, h.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._radius, this._yAxis[0] * this._radius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._radius, this._yAxis[1] * this._radius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._radius, this._yAxis[2] * this._radius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, h.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = .5 * (e[0] + e[1]),r = n.Vector3.createFloat64FromValues(0, 0, 0);n.Vector3.scaleAndAdd(r, r, this._xAxis, -Math.sin(t)), n.Vector3.scaleAndAdd(r, r, this._yAxis, Math.cos(t));var o = Math.min(Math.PI, .5 * (e[1] - e[0]));return new i.TangentCone(r, o);}, h.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, h.prototype.getRadiusAndRangeFromEndpoints = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var i = n.Vector3.createFloat64();n.Vector3.sub(i, t, this._center);var a,u = .5 * (n.Vector3.length(o) + n.Vector3.length(i)),l = n.Vector3.dot(o, this._xAxis),h = n.Vector3.dot(o, this._yAxis),d = (0, c.normalizeAngle)(Math.atan2(h, l));if (e === t || n.Vector3.squaredDistance(e, t) < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) a = d + c.PI2;else {var g = n.Vector3.dot(i, this._xAxis),p = n.Vector3.dot(i, this._yAxis);if ((a = (0, c.normalizeAngle)(Math.atan2(p, g))) < d && (a += c.PI2), r) {var f = a;a = d, d = f - c.PI2;}}return { radius: u, range: [d, a] };}, h.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o,i = n.Vector3.dot(r, this._xAxis),a = n.Vector3.dot(r, this._yAxis);return o = i * i + a * a < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE ? .5 * Math.PI : Math.atan2(a, i), o = (0, c.foldNearTo)(o, .5 * (t[0] + t[1]), 2 * Math.PI), (0, c.clamp)(o, t[0], t[1]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._radius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), this._radius = n.Vector3.length(this._xAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis();}, h.prototype.suggestSplittingParam = function (e) {}, h.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Circle = h;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Face = void 0;var n = r(1),o = r(9),i = r(0),s = r(8),a = function a(e) {o.BaseTopology.call(this), this._surface = e, this._reversed = !1, this._loops = [], this._shell = void 0;};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.FACE;}, a.prototype.getSurfaceType = function () {return this._surface ? this._surface.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._surface = this._surface ? this._surface.clone() : void 0, e._reversed = this._reversed, e.setLoops(this._loops), e._shell = this._shell, e._vertexUvData = void 0, e;}, a.prototype.getSurface = function () {return this._surface;}, a.prototype.setSurface = function (e) {this._surface = e;}, a.prototype.getShell = function () {return this._shell;}, a.prototype.setShell = function (e) {this._shell = e;}, a.prototype.getLoops = function () {return this._loops;}, a.prototype.setLoops = function (e) {this._loops = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._loops[t] = e[t];}}, a.prototype.addLoop = function (e) {this._loops ? this._loops.push(e) : this._loops = [e], e.setFace(this);}, a.prototype.addLoops = function (e) {this._loops || (this._loops = []);for (var t = 0; t < e.length; ++t) {e[t].setFace(this);}this._loops = this._loops.concat(e);}, a.prototype.removeLoop = function (e) {var t = this._loops.indexOf(e);return t > -1 && (this._loops.splice(t, 1), e.getFace() === this && e.setFace(void 0), !0);}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getVertices = function () {return Array.from(this.collectVertices());}, a.prototype.evaluatePosition = function (e, t) {return this._surface.evaluatePosition(e, t);}, a.prototype.evaluateNormal = function (e, t) {var r = this._surface.evaluateNormal(e, t);return !0 === this.isReversed() && n.Vector3.negate(r, r), r;}, a.prototype.getBody = function () {return this._shell ? this._shell.getBody() : void 0;}, a.prototype.collectFaces = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._loops.length; ++t) {this._loops[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {var e = this._surface.getRangeU(),t = this._surface.getRangeV();return isFinite(e[0]) && isFinite(e[1]) || (s.DebugUtils.warn("Face.getBoundingBox: Surface is unbounded in u."), e = [0, 1]), isFinite(t[0]) && isFinite(t[1]) || (s.DebugUtils.warn("Face.getBoundingBox: Surface is unbounded in v."), t = [0, 1]), this._surface.getBoundingBox(e, t);}, a.prototype.closestParam = function (e) {return this._surface.closestParam(e);}, a.prototype.isPlanarFace = function () {return this.getSurfaceType() === i.GEOMETRY_TYPES.PLANE;}, a.prototype.toObject = function () {return { loops: this.refsToStrings(this._loops), reversed: this._reversed, geometry: this.refToString(this._surface), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._loops, this._surface, this._attributes]);}, t.Face = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Vertex = void 0;var n = r(9),o = r(0),i = r(2),s = r(78),a = function a(e) {n.BaseTopology.call(this), this._point = e, this._precision = 0, this._edges = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.VERTEX;}, a.prototype.getPoint = function () {return this._point;}, a.prototype.setPoint = function (e) {this._point = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {i.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.getEdges = function () {return this._edges;}, a.prototype.isAdjacentEdge = function (e) {return -1 !== this._edges.indexOf(e);}, a.prototype.getOtherEdge = function (e) {for (var t = 0; t < this._edges.length; t++) {var r = this._edges[t];if (r !== e) return r;}return null;}, a.prototype.getOtherEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r];n !== e && t.push(n);}return t;}, a.prototype.getAdjacentVertices = function () {for (var e = [], t = 0; t < this._edges.length; t++) {var r = this._edges[t].getOtherVertex(this);r !== this && e.indexOf(r) < 0 && e.push(r);}return e;}, a.prototype.getCommonEdges = function (e) {for (var t = [], r = 0; r < this._edges.length; r++) {var n = this._edges[r],o = n.getStartVertex(),i = n.getEndVertex();(o === this && i === e || i === this && o === e) && t.push(n);}return t;}, a.prototype.addEdge = function (e) {-1 === this._edges.indexOf(e) && this._edges.push(e);}, a.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t >= 0 && (this._edges.splice(t, 1), !0);}, a.prototype.getPosition = function () {return this._point.getPosition();}, a.prototype.getBody = function () {return this._edges.length > 0 ? this._edges[0].getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, a.prototype.collectVertices = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.getBoundingBox = function () {return this._point.getBoundingBox();}, a.prototype.toString = function () {return String(this._point.getPosition());}, a.prototype.getOrderedFaces = function () {var e = [],t = (0, s.getOrderedFacesOnVertex)(this);for (var _r = 0; _r < t.length; _r++) {t[_r].faces.forEach(function (t) {e.push(t);});}return e;}, a.prototype.toObject = function () {return { geometry: this.refToString(this._point), precision: this.getPrecision(), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._point, this._attributes]);}, t.Vertex = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.controlPointsFromHomogeneous = t.controlPointsToHomogeneous = t.getUniqueKnots = t.findKnotSpanAndMultiplicity = t.findKnotSpan = void 0;var n = r(0),o = r(2),i = function i(e, t) {var r = 0,n = t.length - 1;if (e <= t[r]) {for (; t[r] === t[r + 1] && r < n - 1;) {r += 1;}return r;}if (e >= t[n]) {for (; t[n] === t[n - 1] && n > r + 1;) {n -= 1;}return n - 1;}for (var o = Math.floor((r + n) / 2); e < t[o] || e >= t[o + 1];) {e < t[o] ? n = o : r = o, o = Math.floor((r + n) / 2);}return o;};t.findKnotSpan = i, t.findKnotSpanAndMultiplicity = function (e, t) {var r = n.PARAMETER_SPACE_TOLERANCE,o = i(e, t),s = 0,a = e,c = o;if (e < t[c] + r) for (a = t[c]; c >= 0 && Math.abs(t[c] - a) < r;) {--c, ++s;} else if (e > t[c + 1] - r) {for (a = t[++c]; c < t.length && Math.abs(t[c] - a) < r;) {++c, ++s;}a = c < t.length ? t[o = c - 1] : t[t.length - 1];}return { span: o, multiplicity: s, knot: a };}, t.getUniqueKnots = function (e) {for (var t = [e[0]], r = 1; r < e.length; ++r) {e[r] !== e[r - 1] && t.push(e[r]);}return t;}, t.controlPointsToHomogeneous = function (e, t) {o.ConsoleUtils.assert(e.length > 0 && e.length === 3 * t.length);for (var r = t.length, n = new Array(4 * r), i = 0; i < r; ++i) {var s = t[i];n[4 * i] = e[3 * i] * s, n[4 * i + 1] = e[3 * i + 1] * s, n[4 * i + 2] = e[3 * i + 2] * s, n[4 * i + 3] = s;}return n;}, t.controlPointsFromHomogeneous = function (e) {o.ConsoleUtils.assert(e.length > 0 && e.length % 4 == 0);for (var t = e.length / 4, r = new Array(3 * t), n = new Array(t), i = 0; i < t; ++i) {var s = e[4 * i + 3];r[3 * i] = e[4 * i] / s, r[3 * i + 1] = e[4 * i + 1] / s, r[3 * i + 2] = e[4 * i + 2] / s, n[i] = s;}return { P: r, w: n };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Plane = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(2),u = function u() {s.Surface.call(this), this._origin = n.Vector3.createFloat64(), this._normal = n.Vector3.createFloat64(), this._uAxis = n.Vector3.createFloat64(), this._vAxis = n.Vector3.createFloat64();};(u.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.PLANE;}, u.prototype.clone = function () {var e = new u();return e.copy(this), e;}, u.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), n.Vector3.copy(this._origin, e._origin), n.Vector3.copy(this._normal, e._normal), n.Vector3.copy(this._uAxis, e._uAxis), n.Vector3.copy(this._vAxis, e._vAxis);}, u.prototype._computeVAxis = function () {n.Vector3.cross(this._vAxis, this._normal, this._uAxis);}, u.prototype.set = function (e, t, r) {n.Vector3.copy(this._origin, e), c.ConsoleUtils.assert(n.Vector3.squaredLength(t) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, t), void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)) : (c.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.copy(this._uAxis, r)), this._computeVAxis();}, u.prototype.getOrigin = function () {return this._origin;}, u.prototype.setOrigin = function (e) {n.Vector3.copy(this._origin, e);}, u.prototype.getNormal = function () {return this._normal;}, u.prototype.setNormal = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._normal, e), (n.Vector3.squaredLength(this._uAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._uAxis, this._normal, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._uAxis, this._normal), n.Vector3.normalize(this._uAxis, this._uAxis)), this._computeVAxis();}, u.prototype.getUAxis = function () {return this._uAxis;}, u.prototype.setUAxis = function (e) {c.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.copy(this._uAxis, e), this._computeVAxis();}, u.prototype.evaluatePosition = function (e, t) {var r = n.Vector3.clone(this._origin);return n.Vector3.scaleAndAdd(r, r, this._uAxis, e), n.Vector3.scaleAndAdd(r, r, this._vAxis, t), r;}, u.prototype.evaluateNormal = function (e, t) {return n.Vector3.clone(this._normal);}, u.prototype.evaluateDu = function (e, t) {return n.Vector3.clone(this._uAxis);}, u.prototype.evaluateDv = function (e, t) {return n.Vector3.clone(this._vAxis);}, u.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();return n.Vector3.sub(t, e, this._origin), { u: n.Vector3.dot(t, this._uAxis) / n.Vector3.squaredLength(this._uAxis), v: n.Vector3.dot(t, this._vAxis) / n.Vector3.squaredLength(this._vAxis) };}, u.prototype.vParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(e, 0), this._vAxis), t;}, u.prototype.uParamLine = function (e) {var t = new a.Line();return t.set(this.evaluatePosition(0, e), this._uAxis), t;}, u.prototype.getBoundingBox = function (e, t) {var r = new o.BoundingBox();return e && t ? (r.includePoint(this.evaluatePosition(e[0], t[0])), r.includePoint(this.evaluatePosition(e[0], t[1])), r.includePoint(this.evaluatePosition(e[1], t[1])), r.includePoint(this.evaluatePosition(e[1], t[0]))) : (r.includePoint([-1 / 0, -1 / 0, -1 / 0]), r.includePoint([1 / 0, 1 / 0, 1 / 0])), r;}, u.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._origin, this._origin, e), n.Vector3.transformAsDirectionMatrix44(this._uAxis, this._uAxis, e), n.Vector3.transformAsDirectionMatrix44(this._vAxis, this._vAxis, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.normalize(this._normal, this._normal);}, u.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, u.prototype.getRangeUnlimitedV = function () {return [-1 / 0, 1 / 0];}, u.prototype.isPeriodicUnlimitedU = function () {return !1;}, u.prototype.isPeriodicUnlimitedV = function () {return !1;}, u.prototype.isClosedUnlimitedU = function () {return !1;}, u.prototype.isClosedUnlimitedV = function () {return !1;}, u.prototype.toObject = function () {return { origin: this.vectorToObject(this._origin), normal: this.vectorToObject(this._normal), uAxis: this.vectorToObject(this._uAxis), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Plane = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeConnectedFaces = t.mergeFaces = t.findConnectedFaces = t.findConnectedEdges = t.mergeCoincidentVertices = t.transformTopology = t.reverseFace = void 0;var n = r(1),o = r(0),i = r(13),s = r(2),a = function a(e) {e.setReversed(!e.isReversed());},c = function c(e, t) {var r = !1,n = !0,o = new Set();t && (void 0 !== t.inputFacesOnly && (r = t.inputFacesOnly), void 0 !== t.allowVertexConnections && (n = t.allowVertexConnections), void 0 !== t.barrierEdges && (o = new Set(t.barrierEdges)));var i = new Set(),s = new Set(e);function a(t) {s.delete(t), i.add(t), i.forEach(function (t) {var a = new Set();n ? t.collectVertices().forEach(function (e) {e.collectEdges(a);}) : (t.collectEdges(a), o.forEach(function (e) {a.delete(e);})), a.forEach(function (t) {for (var n = t.getCoedge(), o = n; o;) {if (o.getLoop()) {var a = o.getLoop().getFace();i.has(a) || r && !(e.indexOf(a) >= 0) || (i.add(a), s.delete(a));}(o = o.getPartner()) === n && (o = void 0);}});});}for (var c = []; s.size > 0;) {i.clear(), a(s.values().next().value), c.push(Array.from(i));}return c;},u = function u(e) {if (1 !== e.length) {var t = new Set();e.forEach(function (e) {e.collectEdges(t);});var r = new Set(),n = [];t.forEach(function (t) {var o = t.getCoedges(),i = o.map(function (t) {return e.indexOf(t.getFace()) >= 0;});if (2 === o.length && i[0] && i[1]) n.push(t);else for (var s = 0; s < o.length; s++) {i[s] && (r.add(o[s]), o[s].resetUVCurve());}});for (var o = []; r.size > 0;) {for (var a = [], c = r.values().next().value; c;) {a.push(c), r.delete(c);var u = c,l = void 0,h = 2 * c.getEndVertex().getEdges().length;do {if (u = u.getNext(), r.has(u)) {l = u;break;}u = u.getPartner();} while (u && u !== c && --h > 0);c = l;}s.ConsoleUtils.assert(a[0].getStartVertex() === a[a.length - 1].getEndVertex()), o.push(a);}n.forEach(function (e) {e.setStartVertex(null), e.setEndVertex(null);});var d = e[0];d.setLoops([]), o.forEach(function (e) {var t = new i.Loop();t.addCoedges(e), d.addLoop(t);});for (var g = 1; g < e.length; g++) {e[g].getShell() && e[g].getShell().removeFace(e[g]);}var p = d.getSurface();p.unlimitRangeU(), p.unlimitRangeV();}};t.reverseFace = function (e) {e.setReversed(!e.isReversed());for (var t = e.getLoops(), r = 0; r < t.length; ++r) {for (var n = t[r].getCoedges(), o = 0; o < n.length; ++o) {a(n[o]);}n.reverse();}}, t.transformTopology = function (e, t) {Array.isArray(e) || (e = [e]);for (var r = new Set(), n = new Set(), i = new Set(), s = 0; s < e.length; ++s) {var a = e[s],c = a.getTopologyType();a.collectVertices(r), c !== o.TOPOLOGY_TYPES.VERTEX && a.collectEdges(n), c !== o.TOPOLOGY_TYPES.VERTEX && c !== o.TOPOLOGY_TYPES.EDGE && c !== o.TOPOLOGY_TYPES.COEDGE && c !== o.TOPOLOGY_TYPES.LOOP && a.collectFaces(i);}r.forEach(function (e) {e.getPoint() && e.getPoint().transform(t);}), n.forEach(function (e) {e.getCurve() && e.getCurve().transform(t);}), i.forEach(function (e) {e.getSurface() && e.getSurface().transform(t);});}, t.mergeCoincidentVertices = function (e) {for (var t = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, r = [], i = 0; i < e.length; ++i) {var s,a = e[i],c = a.getStartVertex(),u = a.getEndVertex();for (s = 0; s < r.length && !(n.Vector3.squaredDistance(c.getPosition(), r[s].getPosition()) < t); ++s) {;}if (s === r.length ? r.push(c) : (r[s].setPrecision(Math.max(r[s].getPrecision(), c.getPrecision())), a.setStartVertex(r[s])), c !== u) for (s = 0; s < r.length && !(n.Vector3.squaredDistance(u.getPosition(), r[s].getPosition()) < t); ++s) {;}s === r.length ? r.push(u) : (r[s].setPrecision(Math.max(r[s].getPrecision(), u.getPrecision())), a.setEndVertex(r[s]));}}, t.findConnectedEdges = function (e, t) {for (var r = t || !1, n = [], o = new Set(), i = 0; i < e.length; ++i) {var s = e[i];if (!o.has(s)) {for (var a = [], c = [s], u = 0; u < c.length; ++u) {var l = c[u];o.has(l) || r && !(e.indexOf(l) >= 0) || (o.add(l), a.push(l), c = c.concat(l.getStartVertex().getEdges(), l.getEndVertex().getEdges()));}n.push(a);}}return n;}, t.findConnectedFaces = c, t.mergeFaces = u, t.mergeConnectedFaces = function (e) {var t = [];return c(e, { inputFacesOnly: !0, allowVertexConnections: !1 }).forEach(function (e) {u(e), t.push(e[0]);}), t;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Edge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = function a(e) {o.BaseTopology.call(this), this._curve = e, this._reversed = !1, this._vertices = [null, null], this._range = [0, 0], this._precision = 0, this._coedge = void 0, this._wire = void 0, this._tessellationPoints = [];};(a.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.EDGE;}, a.prototype.getCurveType = function () {return this._curve ? this._curve.getGeometryType() : void 0;}, a.prototype.clone = function () {var e = new a();return e._curve = this._curve ? this._curve.clone() : void 0, e._reversed = this._reversed, e._vertices[0] = this._vertices[0], e._vertices[1] = this._vertices[1], e._range[0] = this._range[0], e._range[1] = this._range[1], e._precision = this._precision, e._coedge = this._coedge, e._wire = this._wire, e._tessellationPoints = [], e;}, a.prototype.getCurve = function () {return this._curve;}, a.prototype.setCurve = function (e) {this._curve = e;}, a.prototype.getArcLength = function () {var e = this.getRange();return this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getArcLength(e);}, a.prototype.getVertices = function () {return this._vertices;}, a.prototype.getVertex = function (e) {return s.ConsoleUtils.assert(0 === e || 1 === e), this._vertices[e];}, a.prototype.getStartVertex = function () {return this._vertices[0];}, a.prototype.getEndVertex = function () {return this._vertices[1];}, a.prototype.setCoedge = function (e) {this._coedge = e;}, a.prototype.getCoedge = function () {return this._coedge;}, a.prototype.getCoedges = function () {for (var e = [], t = this._coedge; t;) {e.push(t), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.setWire = function (e) {this._wire = e;}, a.prototype.getWire = function () {return this._wire;}, a.prototype.getRange = function () {return this._range;}, a.prototype.setRange = function (e) {s.ConsoleUtils.assert(2 === e.length), this._range[0] = e[0], this._range[1] = e[1];}, a.prototype.t0 = function () {return this._range[0];}, a.prototype.sett0 = function (e) {this._range[0] = e;}, a.prototype.t1 = function () {return this._range[1];}, a.prototype.sett1 = function (e) {this._range[1] = e;}, a.prototype.isClosed = function () {return this._curve && this._vertices[0] && this._vertices[0] === this._vertices[1];}, a.prototype.getOtherVertex = function (e) {return s.ConsoleUtils.assert(this._vertices[0] === e || this._vertices[1] === e), this._vertices[0] === e ? this._vertices[1] : this._vertices[0];}, a.prototype.getCommonVertex = function (e) {var t = this.getStartVertex(),r = this.getEndVertex(),n = e.getStartVertex(),o = e.getEndVertex();return t === n || t === o ? t : r === n || r === o ? r : null;}, a.prototype.setVertex = function (e, t) {s.ConsoleUtils.assert(0 === e || 1 === e), t !== this._vertices[e] && (this._vertices[e] && this._vertices[0] !== this._vertices[1] && this._vertices[e].removeEdge(this), this._vertices[e] = t, t && this._vertices[e].addEdge(this));}, a.prototype.setStartVertex = function (e) {this.setVertex(0, e);}, a.prototype.setEndVertex = function (e) {this.setVertex(1, e);}, a.prototype.getCoedgeForFace = function (e) {for (var t = this._coedge; t;) {if (t.getFace() === e) return t;if ((t = t.getPartner()) === this._coedge) break;}}, a.prototype.getOtherFace = function (e) {var t = this.getCoedgeForFace(e);s.ConsoleUtils.assert(t);var r = t.getPartner();if (r && r !== t) return r.getFace();}, a.prototype.isReversed = function () {return this._reversed;}, a.prototype.setReversed = function (e) {this._reversed = e;}, a.prototype.getPrecision = function () {return this._precision;}, a.prototype.setPrecision = function (e) {s.ConsoleUtils.assert(e >= 0), this._precision = e;}, a.prototype.evaluatePosition = function (e) {return this.isReversed() && (e = -e), this._curve.evaluatePosition(e);}, a.prototype.evaluateDt = function (e) {this.isReversed() && (e = -e);var t = this._curve.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}, a.prototype.evaluateCurvature = function (e, t) {return this.isReversed() && (e = -e), this._curve.evaluateCurvature(e, t);}, a.prototype.closestToPointParam = function (e, t) {if (this._curve) {var r = t || this.getRange();this.isReversed() && (r = [-r[1], -r[0]]);var n = this._curve.closestToPointParam(e, r);return this.isReversed() ? -n : n;}}, a.prototype.includesPoint = function (e) {var t = Math.max(this.getPrecision(), i.KERNEL_TOLERANCE),r = this.closestToPointParam(e),o = this.evaluatePosition(r);return n.Vector3.squaredDistance(o, e) < t * t;}, a.prototype.distanceToPoint = function (e) {var t = this.closestToPointParam(e),r = this.evaluatePosition(t);return n.Vector3.distance(r, e);}, a.prototype.tessellate = function (e, t) {var r, o;if (!1 === this.isReversed()) r = e || [this._range[0], this._range[1]];else if (e) {r = new Array(e.length);for (var i = 0; i < e.length; ++i) {r[i] = -e[e.length - 1 - i];}} else r = [-this._range[1], -this._range[0]];var s,a = this._curve.tessellate(r, t);if (this._tessellationPoints.length !== a.positions.length) for (this._tessellationPoints = new Array(a.positions.length), i = 0; i < a.positions.length; i++) {this._tessellationPoints[i] = n.Vector3.createFloat64();}if (!1 === this.isReversed()) for (s = a.offsets, o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[o]);} else {for (o = 0; o < a.positions.length; ++o) {n.Vector3.copy(this._tessellationPoints[o], a.positions[a.positions.length - 1 - o]);}for (s = new Array(a.offsets.length), o = 0; o < a.offsets.length; ++o) {s[o] = a.positions.length - 1 - a.offsets[a.offsets.length - 1 - o];}}return { positions: this._tessellationPoints, offsets: s, tolerance: a.tolerance };}, a.prototype.getBody = function () {return s.ConsoleUtils.assert(void 0 === this._coedge || void 0 === this._wire), this._coedge ? this._coedge.getBody() : this._wire ? this._wire.getBody() : void 0;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = this._coedge; t;) {t.collectFaces(e), (t = t.getPartner()) === this._coedge && (t = void 0);}return e;}, a.prototype.collectEdges = function (e) {return (e = e || new Set()).add(this), e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._vertices.length; ++t) {this._vertices[t] && e.add(this._vertices[t]);}return e;}, a.prototype.getBoundingBox = function () {var e = this.getRange();return !0 === this.isReversed() && (e = [-e[1], -e[0]]), this._curve.getBoundingBox(e);}, a.prototype.closestToRayParam = function (e, t, r) {var n = this.getRange();!0 === this.isReversed() && (n = [-n[1], -n[0]]);var o = this._curve.closestToRayParam(e, t, n, r);return !0 === this.isReversed() ? -o : o;}, a.prototype.toString = function () {return i.GEOMETRY_TYPES.toString(this.getCurveType()) + " " + String(this.getStartVertex()) + " -> " + String(this.getEndVertex());}, a.prototype.getLoops = function () {var e = this.getCoedges(),t = new Set();for (var _r2 = 0; _r2 < e.length; _r2++) {t.add(e[_r2].getLoop());}return Array.from(t);}, a.prototype.toObject = function () {return { vertex0: this.refToString(this._vertices[0]), vertex1: this.refToString(this._vertices[1]), precision: this._precision, range: this.rangeToObject(this._range, !0), reversed: this._reversed, geometry: this.refToString(this._curve), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._vertices[0], this._vertices[1], this._curve, this._attributes]);}, t.Edge = a;}, function (e, t, r) {"use strict";e.exports = i, i.className = "ReflectionObject";var n,o = r(5);function i(e, t) {if (!o.isString(e)) throw TypeError("name must be a string");if (t && !o.isObject(t)) throw TypeError("options must be an object");this.options = t, this.name = e, this.parent = null, this.resolved = !1, this.comment = null, this.filename = null;}Object.defineProperties(i.prototype, { root: { get: function get() {for (var e = this; null !== e.parent;) {e = e.parent;}return e;} }, fullName: { get: function get() {for (var e = [this.name], t = this.parent; t;) {e.unshift(t.name), t = t.parent;}return e.join(".");} } }), i.prototype.toJSON = function () {throw Error();}, i.prototype.onAdd = function (e) {this.parent && this.parent !== e && this.parent.remove(this), this.parent = e, this.resolved = !1;var t = e.root;t instanceof n && t._handleAdd(this);}, i.prototype.onRemove = function (e) {var t = e.root;t instanceof n && t._handleRemove(this), this.parent = null, this.resolved = !1;}, i.prototype.resolve = function () {return this.resolved || this.root instanceof n && (this.resolved = !0), this;}, i.prototype.getOption = function (e) {if (this.options) return this.options[e];}, i.prototype.setOption = function (e, t, r) {return r && this.options && void 0 !== this.options[e] || ((this.options || (this.options = {}))[e] = t), this;}, i.prototype.setOptions = function (e, t) {if (e) for (var r = Object.keys(e), n = 0; n < r.length; ++n) {this.setOption(r[n], e[r[n]], t);}return this;}, i.prototype.toString = function () {var e = this.constructor.className,t = this.fullName;return t.length ? e + " " + t : e;}, i._configure = function (e) {n = e;};}, function (e, t, r) {"use strict";e.exports = u;var n = r(21);((u.prototype = Object.create(n.prototype)).constructor = u).className = "Field";var o,i = r(11),s = r(31),a = r(5),c = /^required|optional|repeated$/;function u(e, t, r, o, i, u, l) {if (a.isObject(o) ? (l = i, u = o, o = i = void 0) : a.isObject(i) && (l = u, u = i, i = void 0), n.call(this, e, u), !a.isInteger(t) || t < 0) throw TypeError("id must be a non-negative integer");if (!a.isString(r)) throw TypeError("type must be a string");if (void 0 !== o && !c.test(o = o.toString().toLowerCase())) throw TypeError("rule must be a string rule");if (void 0 !== i && !a.isString(i)) throw TypeError("extend must be a string");this.rule = o && "optional" !== o ? o : void 0, this.type = r, this.id = t, this.extend = i || void 0, this.required = "required" === o, this.optional = !this.required, this.repeated = "repeated" === o, this.map = !1, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!a.Long && void 0 !== s.long[r], this.bytes = "bytes" === r, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = l;}u.fromJSON = function (e, t) {return new u(e, t.id, t.type, t.rule, t.extend, t.options, t.comment);}, Object.defineProperty(u.prototype, "packed", { get: function get() {return null === this._packed && (this._packed = !1 !== this.getOption("packed")), this._packed;} }), u.prototype.setOption = function (e, t, r) {return "packed" === e && (this._packed = null), n.prototype.setOption.call(this, e, t, r);}, u.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return a.toObject(["rule", "optional" !== this.rule && this.rule || void 0, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);}, u.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === (this.typeDefault = s.defaults[this.type]) && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof o ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof i && "string" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (!0 !== this.options.packed && (void 0 === this.options.packed || !this.resolvedType || this.resolvedType instanceof i) || delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = a.Long.fromNumber(this.typeDefault, "u" === this.type.charAt(0)), Object.freeze && Object.freeze(this.typeDefault);else if (this.bytes && "string" == typeof this.typeDefault) {var e;a.base64.test(this.typeDefault) ? a.base64.decode(this.typeDefault, e = a.newBuffer(a.base64.length(this.typeDefault)), 0) : a.utf8.write(this.typeDefault, e = a.newBuffer(a.utf8.length(this.typeDefault)), 0), this.typeDefault = e;}return this.map ? this.defaultValue = a.emptyObject : this.repeated ? this.defaultValue = a.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof o && (this.parent.ctor.prototype[this.name] = this.defaultValue), n.prototype.resolve.call(this);}, u.d = function (e, t, r, n) {return "function" == typeof t ? t = a.decorateType(t).name : t && "object" == _typeof(t) && (t = a.decorateEnum(t).name), function (o, i) {a.decorateType(o.constructor).add(new u(i, e, t, r, { default: n }));};}, u._configure = function (e) {o = e;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Ellipse = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(3),u = r(35),l = r(2),h = r(50),d = function d() {a.Curve.call(this), this._center = n.Vector3.createFloat64FromValues(0, 0, 0), this._normal = n.Vector3.createFloat64FromValues(0, 0, 1), this._xAxis = n.Vector3.createFloat64FromValues(1, 0, 0), this._yAxis = n.Vector3.createFloat64FromValues(0, 1, 0), this._majorRadius = 0, this._minorRadius = 0, this._tessellationCache = new h.TessellationCache();};(d.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPSE;}, d.prototype.set = function (e, t, r, o) {l.ConsoleUtils.assert(n.Vector3.squaredLength(t) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(t, r, s.KERNEL_ANGULAR_TOLERANCE)), l.ConsoleUtils.assert(o > n.FLOAT64_TOLERANCE && o <= 1, "Invalid radius ratio"), n.Vector3.copy(this._center, e), n.Vector3.normalize(this._normal, t), n.Vector3.normalize(this._xAxis, r), this._majorRadius = n.Vector3.length(r), this._minorRadius = this._majorRadius * o, this._computeYAxis(), this._dirtyTessellation();}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._normal, this._xAxis);}, d.prototype.getCenter = function () {return this._center;}, d.prototype.getNormal = function () {return this._normal;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e), this._dirtyTessellation();}, d.prototype.setNormal = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), this._normal !== e && (n.Vector3.normalize(this._normal, e), n.Vector3.isOrthogonal(this._xAxis, this._normal) || (n.Vector3.computeOrthogonal(this._xAxis, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis(), this._dirtyTessellation());}, d.prototype.setMajorAxis = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), l.ConsoleUtils.assert(n.Vector3.isOrthogonal(e, this._normal, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, e), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.getMinorAxis = function () {return this._yAxis;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._normal, e._normal);}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMajorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e, this._dirtyTessellation();}, d.prototype.setMinorRadius = function (e) {l.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e, this._dirtyTessellation();}, d.prototype.getRangeUnlimited = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimited = function () {return !0;}, d.prototype.isClosedUnlimited = function () {return !0;}, d.prototype._dirtyTessellation = function () {this._tessellationCache.setDirty(!0);}, d.prototype._evaluateArcLengthIntegrand = function (e) {var t = this._majorRadius * Math.sin(e),r = this._minorRadius * Math.cos(e);return Math.sqrt(t * t + r * r);}, d.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = e[0], r = 0; t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {for (var n = t, o = [this._evaluateArcLengthIntegrand(t)]; o.length < 5 && t < e[1] + s.PARAMETER_SPACE_TOLERANCE;) {t += .01, o.push(this._evaluateArcLengthIntegrand(t));}switch (n = t - n, o.length) {case 1:break;case 2:r += (o[0] + o[1]) * n / 2;break;case 3:r += (o[0] + 4 * o[1] + o[2]) * n / 6;break;case 4:r += (o[0] + 3 * o[1] + 3 * o[2] + o[3]) * n / 8;break;default:r += (7 * o[0] + 32 * o[1] + 12 * o[2] + 32 * o[3] + 7 * o[4]) * n / 90;}(n = t - e[1]) > s.PARAMETER_SPACE_TOLERANCE && (r -= this._evaluateArcLengthIntegrand(e[1]) * n);}return r;}, d.prototype.getParameterFromArcLength = function (e, t) {return void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited()), (0, u.invertIntegral1D)(this._evaluateArcLengthIntegrand.bind(this), e, t);}, d.prototype.evaluatePosition = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.sin(e) * this._minorRadius), n.Vector3.add(t, t, this._center), t;}, d.prototype.evaluateDt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.sin(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, Math.cos(e) * this._minorRadius), t;}, d.prototype.evaluateDtt = function (e) {var t = n.Vector3.createFloat64FromValues(0, 0, 0);return n.Vector3.scaleAndAdd(t, t, this._xAxis, -Math.cos(e) * this._majorRadius), n.Vector3.scaleAndAdd(t, t, this._yAxis, -Math.sin(e) * this._minorRadius), t;}, d.prototype._getFullTessellation = function (e) {var t = [-Math.PI, -Math.PI / 2, 0, Math.PI / 2, Math.PI],r = h.CurveTessellator.getAdaptiveRenderPoints(this, e, [-Math.PI, Math.PI], t);return r.didRetessellate = !0, r;}, d.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, d.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = (0, c.minMaxCosSinFunc)(this._xAxis[0] * this._majorRadius, this._yAxis[0] * this._minorRadius, this._center[0], e),r = (0, c.minMaxCosSinFunc)(this._xAxis[1] * this._majorRadius, this._yAxis[1] * this._minorRadius, this._center[1], e),n = (0, c.minMaxCosSinFunc)(this._xAxis[2] * this._majorRadius, this._yAxis[2] * this._minorRadius, this._center[2], e),i = new o.BoundingBox();return i.min[0] = t[0], i.max[0] = t[1], i.min[1] = r[0], i.max[1] = r[1], i.min[2] = n[0], i.max[2] = n[1], i;}, d.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluateDt(e[0]);n.Vector3.normalize(t, t);var r = this.evaluateDt(e[1]);n.Vector3.normalize(r, r);var o = n.Vector3.createFloat64(),a = n.Vector3.dot(t, r),u = n.Vector3.dot(n.Vector3.cross(o, t, r), this._normal),l = Math.atan2(u, a);l < 0 ? l += c.PI2 : e[1] - e[0] > c.PI2 - s.PARAMETER_SPACE_TOLERANCE && (l = c.PI2), l *= .5, a = Math.cos(l), u = Math.sin(l);var h = n.Vector3.clone(t);return n.Vector3.scale(h, h, a), n.Vector3.cross(o, this._normal, t), n.Vector3.scaleAndAdd(h, h, o, u), new i.TangentCone(h, l);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._normal, this._normal, e), n.Vector3.scale(this._xAxis, this._xAxis, this._majorRadius), n.Vector3.scale(this._yAxis, this._yAxis, this._minorRadius), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), this._majorRadius = n.Vector3.length(this._xAxis), this._minorRadius = n.Vector3.length(this._yAxis), n.Vector3.normalize(this._normal, this._normal), n.Vector3.normalize(this._xAxis, this._xAxis), this._computeYAxis(), this._dirtyTessellation();}, d.prototype.closestToRayParam = function (e, t, r) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, this._center, e);var i = n.Vector3.dot(o, this._normal) / n.Vector3.dot(t, this._normal);if (isFinite(i)) {var s = n.Vector3.createFloat64();return n.Vector3.scaleAndAdd(s, e, t, i), this.closestToPointParam(s, r);}}, d.prototype.isCircular = function () {return Math.abs(this._majorRadius - this._minorRadius) < s.KERNEL_TOLERANCE;}, d.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = n.Vector3.createFloat64();n.Vector3.sub(r, e, this._center);var o = n.Vector3.dot(r, this._xAxis),i = n.Vector3.dot(r, this._yAxis);if (o * o + i * i < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) {var a = .5 * Math.PI;if (((a = (0, c.adjustParameterToPeriodicRange)(a, t, c.PI2)) < t[0] || a > t[1]) && (a = (0, c.adjustParameterToPeriodicRange)(.5 * -Math.PI, t, c.PI2)), a < t[0] || a > t[1]) {var l = this.evaluatePosition(t[0]),h = this.evaluatePosition(t[1]);a = n.Vector3.squaredDistance(this._center, l) < n.Vector3.squaredDistance(this._center, h) ? t[0] : t[1];}return a;}var d = this._majorRadius,g = this._minorRadius,p = Math.atan2(d * i, g * o),f = this.evaluatePosition(p);n.Vector3.sub(f, f, this._center), o * o + i * i < n.Vector3.squaredLength(f) && (p = (i < s.KERNEL_TOLERANCE ? -1 : 1) * Math.acos(o / d));var v,_ = n.FLOAT64_TOLERANCE,y = function y(t) {var r = this.evaluatePosition(t),n = this.evaluateDt(t),o = this.evaluateDtt(t),i = [r[0] - e[0], r[1] - e[1], r[2] - e[2]];return { val: 2 * (i[0] * n[0] + i[1] * n[1] + i[2] * n[2]), deriv: 2 * (i[0] * o[0] + i[1] * o[1] + i[2] * o[2] + (n[0] * n[0] + n[1] * n[1] + n[2] * n[2])) };},m = (0, u.newtonRaphson1D)(y.bind(this), void 0, p, _, 32);(m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? (m = (0, u.newtonRaphson1D)(y.bind(this), void 0, -m, _, 32), v = (m = (0, c.adjustParameterToPeriodicRange)(m, t, c.PI2)) < t[0] || m > t[1] ? 1 / 0 : n.Vector3.squaredDistance(e, this.evaluatePosition(m))) : v = n.Vector3.squaredDistance(e, this.evaluatePosition(m));var E = n.Vector3.squaredDistance(e, this.evaluatePosition(t[0])),x = n.Vector3.squaredDistance(e, this.evaluatePosition(t[1]));return E < v && (v = E, m = t[0]), x < v && (m = t[1]), m;}, d.prototype.suggestSplittingParam = function (e) {}, d.prototype.toObject = function () {var e = this.evaluatePosition(0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), normal: this.vectorToObject(this._normal), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.Ellipse = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Body = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._lumps = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.BODY;}, a.prototype.getLumps = function () {return this._lumps;}, a.prototype.setLumps = function (e) {this._lumps = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._lumps[t] = e[t];}}, a.prototype.addLump = function (e) {this._lumps ? this._lumps.push(e) : this._lumps = [e], e.setBody(this);}, a.prototype.addLumps = function (e) {this._lumps || (this._lumps = []);for (var t = 0; t < e.length; ++t) {e[t].setBody(this);}this._lumps = this._lumps.concat(e);}, a.prototype.removeLump = function (e) {var t = this._lumps.indexOf(e);return t > -1 && (this._lumps.splice(t, 1), e.getBody() === this && e.setBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectFaces(e);}return e;}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._lumps.length; ++t) {this._lumps[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._lumps.length; ++t) {e.include(this._lumps[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toObject = function () {return { lumps: this.refsToStrings(this._lumps), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._lumps, this._attributes]);}, t.Body = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Lump = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._shells = [], this._body = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.LUMP;}, s.prototype.getBody = function () {return this._body;}, s.prototype.setBody = function (e) {this._body = e;}, s.prototype.getShells = function () {return this._shells;}, s.prototype.setShells = function (e) {this._shells = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._shells[t] = e[t];}}, s.prototype.addShell = function (e) {this._shells ? this._shells.push(e) : this._shells = [e], e.setLump(this);}, s.prototype.addShells = function (e) {this._shells || (this._shells = []);for (var t = 0; t < e.length; ++t) {e[t].setLump(this);}this._shells = this._shells.concat(e);}, s.prototype.removeShell = function (e) {var t = this._shells.indexOf(e);return t > -1 && (this._shells.splice(t, 1), e.getLump() === this && e.setLump(void 0), !0);}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectFaces(e);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._shells.length; ++t) {this._shells[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._shells.length; ++t) {e.include(this._shells[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Lump";}, s.prototype.toObject = function () {return { shells: this.refsToStrings(this._shells), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._shells, this._attributes]);}, t.Lump = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Shell = void 0;var n = r(9),o = r(0),i = r(4),s = function s() {n.BaseTopology.call(this), this._faces = [], this._lump = void 0;};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.SHELL;}, s.prototype.getLump = function () {return this._lump;}, s.prototype.setLump = function (e) {this._lump = e;}, s.prototype.getFaces = function () {return this._faces;}, s.prototype.setFaces = function (e) {this._faces = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._faces[t] = e[t];}}, s.prototype.addFace = function (e) {this._faces ? this._faces.push(e) : this._faces = [e], e.setShell(this);}, s.prototype.addFaces = function (e) {this._faces || (this._faces = []);for (var t = 0; t < e.length; ++t) {e[t].setShell(this);}this._faces = this._faces.concat(e);}, s.prototype.removeFace = function (e) {var t = this._faces.indexOf(e);return t > -1 && (this._faces.splice(t, 1), e.getShell() === this && e.setShell(void 0), !0);}, s.prototype.getBody = function () {return this._lump ? this._lump.getBody() : void 0;}, s.prototype.collectFaces = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {e.add(this._faces[t]);}return e;}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectEdges(e);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._faces.length; ++t) {this._faces[t].collectVertices(e);}return e;}, s.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._faces.length; ++t) {e.include(this._faces[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Shell";}, s.prototype.toObject = function () {return { faces: this.refsToStrings(this._faces), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._faces, this._attributes]);}, t.Shell = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Coedge = void 0;var n = r(1),o = r(9),i = r(0),s = r(2),a = r(3),c = r(36),u = function u(e) {o.BaseTopology.call(this), this._reversed = !1, this._edge = e, this._loop = void 0, this._partner = void 0, this._uvCurve = void 0;};(u.prototype = Object.create(o.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.COEDGE;}, u.prototype.getEdge = function () {return this._edge;}, u.prototype.getLoop = function () {return this._loop;}, u.prototype.getPartner = function () {return this._partner;}, u.prototype.setEdge = function (e) {this._edge = e;}, u.prototype.setLoop = function (e) {this._loop = e;}, u.prototype.setPartner = function (e) {this._partner = e;}, u.prototype.getStartVertex = function () {return this._reversed ? this._edge.getEndVertex() : this._edge.getStartVertex();}, u.prototype.getEndVertex = function () {return this._reversed ? this._edge.getStartVertex() : this._edge.getEndVertex();}, u.prototype.getFace = function () {return this._loop ? this._loop.getFace() : void 0;}, u.prototype.getNext = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(t + 1) % e.length];}}, u.prototype.getPrevious = function () {if (this._loop) {var e = this._loop.getCoedges(),t = e.indexOf(this);return s.ConsoleUtils.assert(t >= 0), e[(0, a.modulus)(t - 1, e.length)];}}, u.prototype.isReversed = function () {return this._reversed;}, u.prototype.setReversed = function (e) {this._reversed = e;}, u.prototype.getRange = function () {if (this._edge) return this._reversed ? [-this._edge.t1(), -this._edge.t0()] : [this._edge.t0(), this._edge.t1()];}, u.prototype.t0 = function () {if (this._edge) return this._reversed ? -this._edge.t1() : this._edge.t0();}, u.prototype.t1 = function () {if (this._edge) return this._reversed ? -this._edge.t0() : this._edge.t1();}, u.prototype.evaluatePosition = function (e) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluatePosition(e);}, u.prototype.evaluateDt = function (e) {if (this._edge) {this.isReversed() && (e = -e);var t = this._edge.evaluateDt(e);return this.isReversed() && n.Vector3.negate(t, t), t;}}, u.prototype.evaluateCurvature = function (e, t) {if (this._edge) return this.isReversed() && (e = -e), this._edge.evaluateCurvature(e, t);}, u.prototype.evaluateFaceUV = function (e) {var t = this.getFace();if (t) {var r = this.evaluatePosition(e);return t.closestParam(r);}}, u.prototype.evaluateInwardDirection = function (e) {var t = this.getFace();if (t) {var r = this.evaluateDt(e),o = this.evaluateFaceUV(e),i = t.evaluateNormal(o.u, o.v),s = [0, 0, 0];return n.Vector3.cross(s, i, r), n.Vector3.normalize(s, s), s;}}, u.prototype.getBoundingBox = function () {if (this._edge) return this._edge.getBoundingBox();}, u.prototype.generateUVCurve = function (e) {if (!this._uvCurve && this._edge) {var t = this._edge.getCurve();if (t && this._loop && this._loop.getFace()) {var r = this._loop.getFace().getSurface();r && r.getGeometryType() === i.GEOMETRY_TYPES.PLANE && (e || (e = (0, a.getPlaneTransforms)(r).threeSpaceToUV), e ? (this._uvCurve = t.clone(), this._uvCurve.transform(e)) : this._uvCurve = t);}}}, u.prototype.resetUVCurve = function () {this._uvCurve = void 0;}, u.prototype.uvAngleSubtended = function (e) {var t = this._loop.getFace().getSurface().closestParam(e),r = [t.u, t.v, 0];this.generateUVCurve(), s.ConsoleUtils.assert(this._uvCurve);var o = this.getRange(),u = 1;this.isReversed() !== this._edge.isReversed() && (o = [-o[1], -o[0]], u = -1), this._loop && this._loop.getFace() && this._loop.getFace().isReversed() && (u *= -1);var l = !1,h = this._uvCurve.getRange();this._uvCurve.isClosed() && o[1] - o[0] >= h[1] - h[0] - 2 * i.PARAMETER_SPACE_TOLERANCE && (l = !0);var d = this._uvCurve.evaluatePosition(o[0]),g = this._uvCurve.evaluatePosition(o[1]),p = n.Vector3.createFloat64();n.Vector3.sub(p, d, r), n.Vector3.normalize(p, p);var f = n.Vector3.createFloat64();n.Vector3.sub(f, g, r), n.Vector3.normalize(f, f);var v = (0, a.getSignedAngle)(p, f),_ = v < 0,y = !1,m = !1;switch (this._edge.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:m = this._uvCurve.getNormal()[2] > 0, y = n.Vector3.distance(r, this._uvCurve.getCenter()) < this._uvCurve.getRadius(), l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.ELLIPSE:m = this._uvCurve.getNormal()[2] > 0;var E = n.Vector3.sub([0, 0, 0], r, this._uvCurve.getCenter()),x = n.Vector3.dot(E, this._uvCurve.getMajorAxis()) / this._uvCurve.getMajorRadius(),R = n.Vector3.dot(E, this._uvCurve.getMinorAxis()) / this._uvCurve.getMinorRadius();y = x * x + R * R <= 1, l || (y = y && _ !== m);break;case i.GEOMETRY_TYPES.BCURVE:this._uvCurve.isPlanarXY() || console.warn("Unsupported non-planar curve for uvAngleSubtended");var A = [r[0], r[1]];y = c.SplineCurveHelper.isPointInsideSplineRegionXYPlanar3D(A, this._uvCurve, o), m = !0;break;default:throw new Error("Unsupported curve type for uvAngleSubtended");}return l ? v = y ? 2 * Math.PI * (m ? -1 : 1) : 0 : y && (v < 0 ? v = 2 * Math.PI + v : v -= 2 * Math.PI), v * u;}, u.prototype.getBody = function () {return this._loop ? this._loop.getBody() : void 0;}, u.prototype.collectFaces = function (e) {return e = e || new Set(), this._loop && this._loop.collectFaces(e), e;}, u.prototype.collectEdges = function (e) {return e = e || new Set(), this._edge && e.add(this._edge), e;}, u.prototype.collectVertices = function (e) {return e = e || new Set(), this._edge && this._edge.collectVertices(e), e;}, u.prototype.toString = function () {return "Coedge";}, u.prototype.toObject = function () {return { edge: this.refToString(this._edge), partner: this.refToString(this._partner), reversed: this._reversed, attributes: this.refsToStrings(this._attributes) };}, u.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edge, this._attributes]);}, t.Coedge = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createShellsFromFaces = t.createWiresFromEdges = t.createEdgesFromCurves = t.createEdgeFromCurve = t.createLoopFromPolyline = t.createFaceFromPolyline = t.makeConeOrCylinderVParamLoop = t.createCoedgeOnEdge = t.createLineEdge = t.createLineEdgeBetweenVertices = void 0;var n = r(1),o = r(0),i = r(2),s = r(6),a = r(7),c = r(18),u = r(27),l = r(16),h = r(26),d = r(20),g = r(13),p = r(15),f = r(40),v = r(3),_ = r(19),y = function y(e, t) {var r = e.getPosition(),o = t.getPosition(),i = new a.Line();i.setFromEndpoints(r, o);var s = new d.Edge(i);return s.setRange([0, n.Vector3.distance(r, o)]), s.setStartVertex(e), s.setEndVertex(t), s;},m = function m(e) {var t = new u.Coedge();t.setEdge(e);var r = e.getCoedge();return r ? (i.ConsoleUtils.assert(!r.getPartner()), r.setPartner(t), t.setPartner(r), t.setReversed(!r.isReversed())) : e.setCoedge(t), t;},E = function E(e) {for (var t = e.length, r = new Array(t), n = 0; n < t; ++n) {r[n] = new l.Vertex(new s.Point(e[n]));}var o = new Array(t);for (n = 0; n < t; ++n) {var i = (n + 1) % t,a = y(r[n], r[i]);o[n] = m(a);}var c = new g.Loop();return c.addCoedges(o), c;},x = function x(e) {var t = new d.Edge(e),r = e.getRange();r[0] !== -1 / 0 && r[1] !== 1 / 0 ? (t.sett0(r[0]), t.sett1(r[1])) : (t.sett0(0), t.sett1(1));var n = t.evaluatePosition(t.t0());if (t.setStartVertex(new l.Vertex(new s.Point(n))), e.isClosed()) t.setEndVertex(t.getStartVertex());else {var o = t.evaluatePosition(t.t1());t.setEndVertex(new l.Vertex(new s.Point(o)));}return t;};t.createLineEdgeBetweenVertices = y, t.createLineEdge = function (e, t) {var r = new l.Vertex(new s.Point(e)),n = new l.Vertex(new s.Point(t));return y(r, n);}, t.createCoedgeOnEdge = m, t.makeConeOrCylinderVParamLoop = function (e, t) {i.ConsoleUtils.assert(e.getGeometryType() === o.GEOMETRY_TYPES.CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.CONE || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || e.getGeometryType() === o.GEOMETRY_TYPES.ELLIPTICAL_CONE), i.ConsoleUtils.assert(e.isPeriodicV());var r,n = new d.Edge(),a = e.vParamLine(t);a.getGeometryType() === o.GEOMETRY_TYPES.POINT ? r = a : (r = new s.Point(a.evaluatePosition(a.getRange()[0])), n.setCurve(a), n.setRange(a.getRange()));var c = new l.Vertex(r);n.setStartVertex(c), n.setEndVertex(c);var u = new g.Loop();return u.addCoedge(m(n)), u;}, t.createFaceFromPolyline = function (e) {var t = E(e),r = (0, v.definePlaneThroughPoints)(e),n = new c.Plane();n.set(r.origin, r.normal, r.uAxis), n.limitRangeU(r.uRange), n.limitRangeV(r.vRange);var o = new p.Face(n);return o.addLoop(t), o;}, t.createLoopFromPolyline = E, t.createEdgeFromCurve = x, t.createEdgesFromCurves = function (e) {for (var t = [], r = 0; r < e.length; ++r) {t.push(x(e[r]));}return (0, _.mergeCoincidentVertices)(t), t;}, t.createWiresFromEdges = function (e) {for (var t = (0, _.findConnectedEdges)(e), r = [], n = 0; n < t.length; ++n) {var o = new f.Wire();o.addEdges(t[n]), r.push(o);}return r;}, t.createShellsFromFaces = function (e) {for (var t = (0, _.findConnectedFaces)(e), r = new Array(t.length), n = 0; n < t.length; ++n) {var o = new h.Shell();o.addFaces(t[n]), r[n] = o;}return r;};}, function (e, t, r) {"use strict";r.r(t), function (e) {r.d(t, "default", function () {return _;}), r.d(t, "VERSION", function () {return y;}), r.d(t, "iteratee", function () {return x;}), r.d(t, "restArguments", function () {return A;}), r.d(t, "each", function () {return S;}), r.d(t, "forEach", function () {return S;}), r.d(t, "map", function () {return M;}), r.d(t, "collect", function () {return M;}), r.d(t, "reduce", function () {return N;}), r.d(t, "foldl", function () {return N;}), r.d(t, "inject", function () {return N;}), r.d(t, "reduceRight", function () {return F;}), r.d(t, "foldr", function () {return F;}), r.d(t, "find", function () {return I;}), r.d(t, "detect", function () {return I;}), r.d(t, "filter", function () {return D;}), r.d(t, "select", function () {return D;}), r.d(t, "reject", function () {return j;}), r.d(t, "every", function () {return B;}), r.d(t, "all", function () {return B;}), r.d(t, "some", function () {return U;}), r.d(t, "any", function () {return U;}), r.d(t, "contains", function () {return k;}), r.d(t, "includes", function () {return k;}), r.d(t, "include", function () {return k;}), r.d(t, "invoke", function () {return G;}), r.d(t, "pluck", function () {return z;}), r.d(t, "where", function () {return Y;}), r.d(t, "findWhere", function () {return K;}), r.d(t, "max", function () {return q;}), r.d(t, "min", function () {return W;}), r.d(t, "shuffle", function () {return H;}), r.d(t, "sample", function () {return X;}), r.d(t, "sortBy", function () {return J;}), r.d(t, "groupBy", function () {return Z;}), r.d(t, "indexBy", function () {return Q;}), r.d(t, "countBy", function () {return ee;}), r.d(t, "toArray", function () {return re;}), r.d(t, "size", function () {return ne;}), r.d(t, "partition", function () {return oe;}), r.d(t, "first", function () {return ie;}), r.d(t, "head", function () {return ie;}), r.d(t, "take", function () {return ie;}), r.d(t, "initial", function () {return se;}), r.d(t, "last", function () {return ae;}), r.d(t, "rest", function () {return ce;}), r.d(t, "tail", function () {return ce;}), r.d(t, "drop", function () {return ce;}), r.d(t, "compact", function () {return ue;}), r.d(t, "flatten", function () {return he;}), r.d(t, "without", function () {return de;}), r.d(t, "uniq", function () {return ge;}), r.d(t, "unique", function () {return ge;}), r.d(t, "union", function () {return pe;}), r.d(t, "intersection", function () {return fe;}), r.d(t, "difference", function () {return ve;}), r.d(t, "unzip", function () {return _e;}), r.d(t, "zip", function () {return ye;}), r.d(t, "object", function () {return me;}), r.d(t, "findIndex", function () {return xe;}), r.d(t, "findLastIndex", function () {return Re;}), r.d(t, "sortedIndex", function () {return Ae;}), r.d(t, "indexOf", function () {return Ve;}), r.d(t, "lastIndexOf", function () {return Te;}), r.d(t, "range", function () {return Ce;}), r.d(t, "chunk", function () {return be;}), r.d(t, "bind", function () {return Oe;}), r.d(t, "partial", function () {return Se;}), r.d(t, "bindAll", function () {return Me;}), r.d(t, "memoize", function () {return we;}), r.d(t, "delay", function () {return Ne;}), r.d(t, "defer", function () {return Fe;}), r.d(t, "throttle", function () {return Ie;}), r.d(t, "debounce", function () {return De;}), r.d(t, "wrap", function () {return je;}), r.d(t, "negate", function () {return Be;}), r.d(t, "compose", function () {return Ue;}), r.d(t, "after", function () {return ke;}), r.d(t, "before", function () {return Ge;}), r.d(t, "once", function () {return ze;}), r.d(t, "keys", function () {return We;}), r.d(t, "allKeys", function () {return He;}), r.d(t, "values", function () {return Xe;}), r.d(t, "mapObject", function () {return Je;}), r.d(t, "pairs", function () {return $e;}), r.d(t, "invert", function () {return Ze;}), r.d(t, "functions", function () {return Qe;}), r.d(t, "methods", function () {return Qe;}), r.d(t, "extend", function () {return tt;}), r.d(t, "extendOwn", function () {return rt;}), r.d(t, "assign", function () {return rt;}), r.d(t, "findKey", function () {return nt;}), r.d(t, "pick", function () {return it;}), r.d(t, "omit", function () {return st;}), r.d(t, "defaults", function () {return at;}), r.d(t, "create", function () {return ct;}), r.d(t, "clone", function () {return ut;}), r.d(t, "tap", function () {return lt;}), r.d(t, "isMatch", function () {return ht;}), r.d(t, "isEqual", function () {return dt;}), r.d(t, "isEmpty", function () {return gt;}), r.d(t, "isElement", function () {return pt;}), r.d(t, "isArray", function () {return vt;}), r.d(t, "isObject", function () {return _t;}), r.d(t, "isArguments", function () {return yt;}), r.d(t, "isFunction", function () {return mt;}), r.d(t, "isString", function () {return Et;}), r.d(t, "isNumber", function () {return xt;}), r.d(t, "isDate", function () {return Rt;}), r.d(t, "isRegExp", function () {return At;}), r.d(t, "isError", function () {return Pt;}), r.d(t, "isSymbol", function () {return Vt;}), r.d(t, "isMap", function () {return Tt;}), r.d(t, "isWeakMap", function () {return Ct;}), r.d(t, "isSet", function () {return bt;}), r.d(t, "isWeakSet", function () {return Lt;}), r.d(t, "isFinite", function () {return St;}), r.d(t, "isNaN", function () {return Mt;}), r.d(t, "isBoolean", function () {return wt;}), r.d(t, "isNull", function () {return Nt;}), r.d(t, "isUndefined", function () {return Ft;}), r.d(t, "has", function () {return It;}), r.d(t, "identity", function () {return Dt;}), r.d(t, "constant", function () {return jt;}), r.d(t, "noop", function () {return Bt;}), r.d(t, "property", function () {return Ut;}), r.d(t, "propertyOf", function () {return kt;}), r.d(t, "matcher", function () {return Gt;}), r.d(t, "matches", function () {return Gt;}), r.d(t, "times", function () {return zt;}), r.d(t, "random", function () {return Yt;}), r.d(t, "now", function () {return Kt;}), r.d(t, "escape", function () {return Xt;}), r.d(t, "unescape", function () {return Jt;}), r.d(t, "result", function () {return $t;}), r.d(t, "uniqueId", function () {return Qt;}), r.d(t, "templateSettings", function () {return er;}), r.d(t, "template", function () {return ir;}), r.d(t, "chain", function () {return sr;}), r.d(t, "mixin", function () {return cr;});var n = "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self.self === self && self || "object" == _typeof(e) && e.global === e && e || Function("return this")() || {},o = Array.prototype,i = Object.prototype,s = "undefined" != typeof Symbol ? Symbol.prototype : null,a = o.push,c = o.slice,u = i.toString,l = i.hasOwnProperty,h = Array.isArray,d = Object.keys,g = Object.create,p = n.isNaN,f = n.isFinite,v = function v() {};function _(e) {return e instanceof _ ? e : this instanceof _ ? void (this._wrapped = e) : new _(e);}var y = _.VERSION = "1.10.2";function m(e, t, r) {if (void 0 === t) return e;switch (null == r ? 3 : r) {case 1:return function (r) {return e.call(t, r);};case 3:return function (r, n, o) {return e.call(t, r, n, o);};case 4:return function (r, n, o, i) {return e.call(t, r, n, o, i);};}return function () {return e.apply(t, arguments);};}function E(e, t, r) {return null == e ? Dt : mt(e) ? m(e, t, r) : _t(e) && !vt(e) ? Gt(e) : Ut(e);}function x(e, t) {return E(e, t, 1 / 0);}function R(e, t, r) {return _.iteratee !== x ? _.iteratee(e, t) : E(e, t, r);}function A(e, t) {return t = null == t ? e.length - 1 : +t, function () {for (var r = Math.max(arguments.length - t, 0), n = Array(r), o = 0; o < r; o++) {n[o] = arguments[o + t];}switch (t) {case 0:return e.call(this, n);case 1:return e.call(this, arguments[0], n);case 2:return e.call(this, arguments[0], arguments[1], n);}var i = Array(t + 1);for (o = 0; o < t; o++) {i[o] = arguments[o];}return i[t] = n, e.apply(this, i);};}function P(e) {if (!_t(e)) return {};if (g) return g(e);v.prototype = e;var t = new v();return v.prototype = null, t;}function V(e) {return function (t) {return null == t ? void 0 : t[e];};}function T(e, t) {return null != e && l.call(e, t);}function C(e, t) {for (var r = t.length, n = 0; n < r; n++) {if (null == e) return;e = e[t[n]];}return r ? e : void 0;}_.iteratee = x;var b = Math.pow(2, 53) - 1,L = V("length");function O(e) {var t = L(e);return "number" == typeof t && t >= 0 && t <= b;}function S(e, t, r) {var n, o;if (t = m(t, r), O(e)) for (n = 0, o = e.length; n < o; n++) {t(e[n], n, e);} else {var i = We(e);for (n = 0, o = i.length; n < o; n++) {t(e[i[n]], i[n], e);}}return e;}function M(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = Array(o), s = 0; s < o; s++) {var a = n ? n[s] : s;i[s] = t(e[a], a, e);}return i;}function w(e) {return function (t, r, n, o) {var i = arguments.length >= 3;return function (t, r, n, o) {var i = !O(t) && We(t),s = (i || t).length,a = e > 0 ? 0 : s - 1;for (o || (n = t[i ? i[a] : a], a += e); a >= 0 && a < s; a += e) {var c = i ? i[a] : a;n = r(n, t[c], c, t);}return n;}(t, m(r, o, 4), n, i);};}var N = w(1),F = w(-1);function I(e, t, r) {var n = (O(e) ? xe : nt)(e, t, r);if (void 0 !== n && -1 !== n) return e[n];}function D(e, t, r) {var n = [];return t = R(t, r), S(e, function (e, r, o) {t(e, r, o) && n.push(e);}), n;}function j(e, t, r) {return D(e, Be(R(t)), r);}function B(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (!t(e[s], s, e)) return !1;}return !0;}function U(e, t, r) {t = R(t, r);for (var n = !O(e) && We(e), o = (n || e).length, i = 0; i < o; i++) {var s = n ? n[i] : i;if (t(e[s], s, e)) return !0;}return !1;}function k(e, t, r, n) {return O(e) || (e = Xe(e)), ("number" != typeof r || n) && (r = 0), Ve(e, t, r) >= 0;}var G = A(function (e, t, r) {var n, o;return mt(t) ? o = t : vt(t) && (n = t.slice(0, -1), t = t[t.length - 1]), M(e, function (e) {var i = o;if (!i) {if (n && n.length && (e = C(e, n)), null == e) return;i = e[t];}return null == i ? i : i.apply(e, r);});});function z(e, t) {return M(e, Ut(t));}function Y(e, t) {return D(e, Gt(t));}function K(e, t) {return I(e, Gt(t));}function q(e, t, r) {var n,o,i = -1 / 0,s = -1 / 0;if (null == t || "number" == typeof t && "object" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n > i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) > s || o === -1 / 0 && i === -1 / 0) && (i = e, s = o);});return i;}function W(e, t, r) {var n,o,i = 1 / 0,s = 1 / 0;if (null == t || "number" == typeof t && "object" != _typeof(e[0]) && null != e) for (var a = 0, c = (e = O(e) ? e : Xe(e)).length; a < c; a++) {null != (n = e[a]) && n < i && (i = n);} else t = R(t, r), S(e, function (e, r, n) {((o = t(e, r, n)) < s || o === 1 / 0 && i === 1 / 0) && (i = e, s = o);});return i;}function H(e) {return X(e, 1 / 0);}function X(e, t, r) {if (null == t || r) return O(e) || (e = Xe(e)), e[Yt(e.length - 1)];var n = O(e) ? ut(e) : Xe(e),o = L(n);t = Math.max(Math.min(t, o), 0);for (var i = o - 1, s = 0; s < t; s++) {var a = Yt(s, i),c = n[s];n[s] = n[a], n[a] = c;}return n.slice(0, t);}function J(e, t, r) {var n = 0;return t = R(t, r), z(M(e, function (e, r, o) {return { value: e, index: n++, criteria: t(e, r, o) };}).sort(function (e, t) {var r = e.criteria,n = t.criteria;if (r !== n) {if (r > n || void 0 === r) return 1;if (r < n || void 0 === n) return -1;}return e.index - t.index;}), "value");}function $(e, t) {return function (r, n, o) {var i = t ? [[], []] : {};return n = R(n, o), S(r, function (t, o) {var s = n(t, o, r);e(i, t, s);}), i;};}var Z = $(function (e, t, r) {T(e, r) ? e[r].push(t) : e[r] = [t];}),Q = $(function (e, t, r) {e[r] = t;}),ee = $(function (e, t, r) {T(e, r) ? e[r]++ : e[r] = 1;}),te = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;function re(e) {return e ? vt(e) ? c.call(e) : Et(e) ? e.match(te) : O(e) ? M(e, Dt) : Xe(e) : [];}function ne(e) {return null == e ? 0 : O(e) ? e.length : We(e).length;}var oe = $(function (e, t, r) {e[r ? 0 : 1].push(t);}, !0);function ie(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[0] : se(e, e.length - t);}function se(e, t, r) {return c.call(e, 0, Math.max(0, e.length - (null == t || r ? 1 : t)));}function ae(e, t, r) {return null == e || e.length < 1 ? null == t ? void 0 : [] : null == t || r ? e[e.length - 1] : ce(e, Math.max(0, e.length - t));}function ce(e, t, r) {return c.call(e, null == t || r ? 1 : t);}function ue(e) {return D(e, Boolean);}function le(e, t, r, n) {for (var o = (n = n || []).length, i = 0, s = L(e); i < s; i++) {var a = e[i];if (O(a) && (vt(a) || yt(a))) {if (t) for (var c = 0, u = a.length; c < u;) {n[o++] = a[c++];} else le(a, t, r, n), o = n.length;} else r || (n[o++] = a);}return n;}function he(e, t) {return le(e, t, !1);}var de = A(function (e, t) {return ve(e, t);});function ge(e, t, r, n) {wt(t) || (n = r, r = t, t = !1), null != r && (r = R(r, n));for (var o = [], i = [], s = 0, a = L(e); s < a; s++) {var c = e[s],u = r ? r(c, s, e) : c;t && !r ? (s && i === u || o.push(c), i = u) : r ? k(i, u) || (i.push(u), o.push(c)) : k(o, c) || o.push(c);}return o;}var pe = A(function (e) {return ge(le(e, !0, !0));});function fe(e) {for (var t = [], r = arguments.length, n = 0, o = L(e); n < o; n++) {var i = e[n];if (!k(t, i)) {var s;for (s = 1; s < r && k(arguments[s], i); s++) {;}s === r && t.push(i);}}return t;}var ve = A(function (e, t) {return t = le(t, !0, !0), D(e, function (e) {return !k(t, e);});});function _e(e) {for (var t = e && q(e, L).length || 0, r = Array(t), n = 0; n < t; n++) {r[n] = z(e, n);}return r;}var ye = A(_e);function me(e, t) {for (var r = {}, n = 0, o = L(e); n < o; n++) {t ? r[e[n]] = t[n] : r[e[n][0]] = e[n][1];}return r;}function Ee(e) {return function (t, r, n) {r = R(r, n);for (var o = L(t), i = e > 0 ? 0 : o - 1; i >= 0 && i < o; i += e) {if (r(t[i], i, t)) return i;}return -1;};}var xe = Ee(1),Re = Ee(-1);function Ae(e, t, r, n) {for (var o = (r = R(r, n, 1))(t), i = 0, s = L(e); i < s;) {var a = Math.floor((i + s) / 2);r(e[a]) < o ? i = a + 1 : s = a;}return i;}function Pe(e, t, r) {return function (n, o, i) {var s = 0,a = L(n);if ("number" == typeof i) e > 0 ? s = i >= 0 ? i : Math.max(i + a, s) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;else if (r && i && a) return n[i = r(n, o)] === o ? i : -1;if (o != o) return (i = t(c.call(n, s, a), Mt)) >= 0 ? i + s : -1;for (i = e > 0 ? s : a - 1; i >= 0 && i < a; i += e) {if (n[i] === o) return i;}return -1;};}var Ve = Pe(1, xe, Ae),Te = Pe(-1, Re);function Ce(e, t, r) {null == t && (t = e || 0, e = 0), r || (r = t < e ? -1 : 1);for (var n = Math.max(Math.ceil((t - e) / r), 0), o = Array(n), i = 0; i < n; i++, e += r) {o[i] = e;}return o;}function be(e, t) {if (null == t || t < 1) return [];for (var r = [], n = 0, o = e.length; n < o;) {r.push(c.call(e, n, n += t));}return r;}function Le(e, t, r, n, o) {if (!(n instanceof t)) return e.apply(r, o);var i = P(e.prototype),s = e.apply(i, o);return _t(s) ? s : i;}var Oe = A(function (e, t, r) {if (!mt(e)) throw new TypeError("Bind must be called on a function");var n = A(function (o) {return Le(e, n, t, this, r.concat(o));});return n;}),Se = A(function (e, t) {var r = Se.placeholder,n = function n() {for (var o = 0, i = t.length, s = Array(i), a = 0; a < i; a++) {s[a] = t[a] === r ? arguments[o++] : t[a];}for (; o < arguments.length;) {s.push(arguments[o++]);}return Le(e, n, this, this, s);};return n;});Se.placeholder = _;var Me = A(function (e, t) {var r = (t = le(t, !1, !1)).length;if (r < 1) throw new Error("bindAll must be passed function names");for (; r--;) {var n = t[r];e[n] = Oe(e[n], e);}});function we(e, t) {var r = function r(n) {var o = r.cache,i = "" + (t ? t.apply(this, arguments) : n);return T(o, i) || (o[i] = e.apply(this, arguments)), o[i];};return r.cache = {}, r;}var Ne = A(function (e, t, r) {return setTimeout(function () {return e.apply(null, r);}, t);}),Fe = Se(Ne, _, 1);function Ie(e, t, r) {var n,o,i,s,a = 0;r || (r = {});var c = function c() {a = !1 === r.leading ? 0 : Kt(), n = null, s = e.apply(o, i), n || (o = i = null);},u = function u() {var u = Kt();a || !1 !== r.leading || (a = u);var l = t - (u - a);return o = this, i = arguments, l <= 0 || l > t ? (n && (clearTimeout(n), n = null), a = u, s = e.apply(o, i), n || (o = i = null)) : n || !1 === r.trailing || (n = setTimeout(c, l)), s;};return u.cancel = function () {clearTimeout(n), a = 0, n = o = i = null;}, u;}function De(e, t, r) {var n,o,i = function i(t, r) {n = null, r && (o = e.apply(t, r));},s = A(function (s) {if (n && clearTimeout(n), r) {var a = !n;n = setTimeout(i, t), a && (o = e.apply(this, s));} else n = Ne(i, t, this, s);return o;});return s.cancel = function () {clearTimeout(n), n = null;}, s;}function je(e, t) {return Se(t, e);}function Be(e) {return function () {return !e.apply(this, arguments);};}function Ue() {var e = arguments,t = e.length - 1;return function () {for (var r = t, n = e[t].apply(this, arguments); r--;) {n = e[r].call(this, n);}return n;};}function ke(e, t) {return function () {if (--e < 1) return t.apply(this, arguments);};}function Ge(e, t) {var r;return function () {return --e > 0 && (r = t.apply(this, arguments)), e <= 1 && (t = null), r;};}var ze = Se(Ge, 2),Ye = !{ toString: null }.propertyIsEnumerable("toString"),Ke = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];function qe(e, t) {var r = Ke.length,n = e.constructor,o = mt(n) && n.prototype || i,s = "constructor";for (T(e, s) && !k(t, s) && t.push(s); r--;) {(s = Ke[r]) in e && e[s] !== o[s] && !k(t, s) && t.push(s);}}function We(e) {if (!_t(e)) return [];if (d) return d(e);var t = [];for (var r in e) {T(e, r) && t.push(r);}return Ye && qe(e, t), t;}function He(e) {if (!_t(e)) return [];var t = [];for (var r in e) {t.push(r);}return Ye && qe(e, t), t;}function Xe(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = e[t[o]];}return n;}function Je(e, t, r) {t = R(t, r);for (var n = We(e), o = n.length, i = {}, s = 0; s < o; s++) {var a = n[s];i[a] = t(e[a], a, e);}return i;}function $e(e) {for (var t = We(e), r = t.length, n = Array(r), o = 0; o < r; o++) {n[o] = [t[o], e[t[o]]];}return n;}function Ze(e) {for (var t = {}, r = We(e), n = 0, o = r.length; n < o; n++) {t[e[r[n]]] = r[n];}return t;}function Qe(e) {var t = [];for (var r in e) {mt(e[r]) && t.push(r);}return t.sort();}function et(e, t) {return function (r) {var n = arguments.length;if (t && (r = Object(r)), n < 2 || null == r) return r;for (var o = 1; o < n; o++) {for (var i = arguments[o], s = e(i), a = s.length, c = 0; c < a; c++) {var u = s[c];t && void 0 !== r[u] || (r[u] = i[u]);}}return r;};}var tt = et(He),rt = et(We);function nt(e, t, r) {t = R(t, r);for (var n, o = We(e), i = 0, s = o.length; i < s; i++) {if (t(e[n = o[i]], n, e)) return n;}}function ot(e, t, r) {return t in r;}var it = A(function (e, t) {var r = {},n = t[0];if (null == e) return r;mt(n) ? (t.length > 1 && (n = m(n, t[1])), t = He(e)) : (n = ot, t = le(t, !1, !1), e = Object(e));for (var o = 0, i = t.length; o < i; o++) {var s = t[o],a = e[s];n(a, s, e) && (r[s] = a);}return r;}),st = A(function (e, t) {var r,n = t[0];return mt(n) ? (n = Be(n), t.length > 1 && (r = t[1])) : (t = M(le(t, !1, !1), String), n = function n(e, r) {return !k(t, r);}), it(e, n, r);}),at = et(He, !0);function ct(e, t) {var r = P(e);return t && rt(r, t), r;}function ut(e) {return _t(e) ? vt(e) ? e.slice() : tt({}, e) : e;}function lt(e, t) {return t(e), e;}function ht(e, t) {var r = We(t),n = r.length;if (null == e) return !n;for (var o = Object(e), i = 0; i < n; i++) {var s = r[i];if (t[s] !== o[s] || !(s in o)) return !1;}return !0;}function dt(e, t) {return function e(t, r, n, o) {if (t === r) return 0 !== t || 1 / t == 1 / r;if (null == t || null == r) return !1;if (t != t) return r != r;var i = _typeof(t);return ("function" === i || "object" === i || "object" == _typeof(r)) && function (t, r, n, o) {t instanceof _ && (t = t._wrapped), r instanceof _ && (r = r._wrapped);var i = u.call(t);if (i !== u.call(r)) return !1;switch (i) {case "[object RegExp]":case "[object String]":return "" + t == "" + r;case "[object Number]":return +t != +t ? +r != +r : 0 == +t ? 1 / +t == 1 / r : +t == +r;case "[object Date]":case "[object Boolean]":return +t == +r;case "[object Symbol]":return s.valueOf.call(t) === s.valueOf.call(r);}var a = "[object Array]" === i;if (!a) {if ("object" != _typeof(t) || "object" != _typeof(r)) return !1;var c = t.constructor,l = r.constructor;if (c !== l && !(mt(c) && c instanceof c && mt(l) && l instanceof l) && "constructor" in t && "constructor" in r) return !1;}o = o || [];for (var h = (n = n || []).length; h--;) {if (n[h] === t) return o[h] === r;}if (n.push(t), o.push(r), a) {if ((h = t.length) !== r.length) return !1;for (; h--;) {if (!e(t[h], r[h], n, o)) return !1;}} else {var d,g = We(t);if (h = g.length, We(r).length !== h) return !1;for (; h--;) {if (!T(r, d = g[h]) || !e(t[d], r[d], n, o)) return !1;}}return n.pop(), o.pop(), !0;}(t, r, n, o);}(e, t);}function gt(e) {return null == e || (O(e) && (vt(e) || Et(e) || yt(e)) ? 0 === e.length : 0 === We(e).length);}function pt(e) {return !(!e || 1 !== e.nodeType);}function ft(e) {return function (t) {return u.call(t) === "[object " + e + "]";};}var vt = h || ft("Array");function _t(e) {var t = _typeof(e);return "function" === t || "object" === t && !!e;}var yt = ft("Arguments"),mt = ft("Function"),Et = ft("String"),xt = ft("Number"),Rt = ft("Date"),At = ft("RegExp"),Pt = ft("Error"),Vt = ft("Symbol"),Tt = ft("Map"),Ct = ft("WeakMap"),bt = ft("Set"),Lt = ft("WeakSet");!function () {yt(arguments) || (yt = function yt(e) {return T(e, "callee");});}();var Ot = n.document && n.document.childNodes;function St(e) {return !Vt(e) && f(e) && !p(parseFloat(e));}function Mt(e) {return xt(e) && p(e);}function wt(e) {return !0 === e || !1 === e || "[object Boolean]" === u.call(e);}function Nt(e) {return null === e;}function Ft(e) {return void 0 === e;}function It(e, t) {if (!vt(t)) return T(e, t);for (var r = t.length, n = 0; n < r; n++) {var o = t[n];if (null == e || !l.call(e, o)) return !1;e = e[o];}return !!r;}function Dt(e) {return e;}function jt(e) {return function () {return e;};}function Bt() {}function Ut(e) {return vt(e) ? function (t) {return C(t, e);} : V(e);}function kt(e) {return null == e ? function () {} : function (t) {return vt(t) ? C(e, t) : e[t];};}function Gt(e) {return e = rt({}, e), function (t) {return ht(t, e);};}function zt(e, t, r) {var n = Array(Math.max(0, e));t = m(t, r, 1);for (var o = 0; o < e; o++) {n[o] = t(o);}return n;}function Yt(e, t) {return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1));}"object" != (typeof Int8Array === "undefined" ? "undefined" : _typeof(Int8Array)) && "function" != typeof Ot && (mt = function mt(e) {return "function" == typeof e || !1;});var Kt = Date.now || function () {return new Date().getTime();},qt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" },Wt = Ze(qt);function Ht(e) {var t = function t(_t3) {return e[_t3];},r = "(?:" + We(e).join("|") + ")",n = RegExp(r),o = RegExp(r, "g");return function (e) {return e = null == e ? "" : "" + e, n.test(e) ? e.replace(o, t) : e;};}var Xt = Ht(qt),Jt = Ht(Wt);function $t(e, t, r) {vt(t) || (t = [t]);var n = t.length;if (!n) return mt(r) ? r.call(e) : r;for (var o = 0; o < n; o++) {var i = null == e ? void 0 : e[t[o]];void 0 === i && (i = r, o = n), e = mt(i) ? i.call(e) : i;}return e;}var Zt = 0;function Qt(e) {var t = ++Zt + "";return e ? e + t : t;}var er = _.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g },tr = /(.)^/,rr = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" },nr = /\\|'|\r|\n|\u2028|\u2029/g,or = function or(e) {return "\\" + rr[e];};function ir(e, t, r) {!t && r && (t = r), t = at({}, t, _.templateSettings);var n,o = RegExp([(t.escape || tr).source, (t.interpolate || tr).source, (t.evaluate || tr).source].join("|") + "|$", "g"),i = 0,s = "__p+='";e.replace(o, function (t, r, n, o, a) {return s += e.slice(i, a).replace(nr, or), i = a + t.length, r ? s += "'+\n((__t=(" + r + "))==null?'':_.escape(__t))+\n'" : n ? s += "'+\n((__t=(" + n + "))==null?'':__t)+\n'" : o && (s += "';\n" + o + "\n__p+='"), t;}), s += "';\n", t.variable || (s = "with(obj||{}){\n" + s + "}\n"), s = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + s + "return __p;\n";try {n = new Function(t.variable || "obj", "_", s);} catch (e) {throw e.source = s, e;}var a = function a(e) {return n.call(this, e, _);},c = t.variable || "obj";return a.source = "function(" + c + "){\n" + s + "}", a;}function sr(e) {var t = _(e);return t._chain = !0, t;}function ar(e, t) {return e._chain ? _(t).chain() : t;}function cr(e) {return S(Qe(e), function (t) {var r = _[t] = e[t];_.prototype[t] = function () {var e = [this._wrapped];return a.apply(e, arguments), ar(this, r.apply(_, e));};}), _;}S(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (e) {var t = o[e];_.prototype[e] = function () {var r = this._wrapped;return t.apply(r, arguments), "shift" !== e && "splice" !== e || 0 !== r.length || delete r[0], ar(this, r);};}), S(["concat", "join", "slice"], function (e) {var t = o[e];_.prototype[e] = function () {return ar(this, t.apply(this._wrapped, arguments));};}), _.prototype.value = function () {return this._wrapped;}, _.prototype.valueOf = _.prototype.toJSON = _.prototype.value, _.prototype.toString = function () {return String(this._wrapped);};}.call(this, r(57));}, function (e, t, r) {"use strict";e.exports = l;var n = r(21);((l.prototype = Object.create(n.prototype)).constructor = l).className = "Namespace";var o,i,s,a = r(22),c = r(5);function u(e, t) {if (e && e.length) {for (var r = {}, n = 0; n < e.length; ++n) {r[e[n].name] = e[n].toJSON(t);}return r;}}function l(e, t) {n.call(this, e, t), this.nested = void 0, this._nestedArray = null;}function h(e) {return e._nestedArray = null, e;}l.fromJSON = function (e, t) {return new l(e, t.options).addJSON(t.nested);}, l.arrayToJSON = u, l.isReservedId = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if ("string" != typeof e[r] && e[r][0] <= t && e[r][1] >= t) return !0;}return !1;}, l.isReservedName = function (e, t) {if (e) for (var r = 0; r < e.length; ++r) {if (e[r] === t) return !0;}return !1;}, Object.defineProperty(l.prototype, "nestedArray", { get: function get() {return this._nestedArray || (this._nestedArray = c.toArray(this.nested));} }), l.prototype.toJSON = function (e) {return c.toObject(["options", this.options, "nested", u(this.nestedArray, e)]);}, l.prototype.addJSON = function (e) {if (e) for (var t, r = Object.keys(e), n = 0; n < r.length; ++n) {t = e[r[n]], this.add((void 0 !== t.fields ? o.fromJSON : void 0 !== t.values ? s.fromJSON : void 0 !== t.methods ? i.fromJSON : void 0 !== t.id ? a.fromJSON : l.fromJSON)(r[n], t));}return this;}, l.prototype.get = function (e) {return this.nested && this.nested[e] || null;}, l.prototype.getEnum = function (e) {if (this.nested && this.nested[e] instanceof s) return this.nested[e].values;throw Error("no such enum: " + e);}, l.prototype.add = function (e) {if (!(e instanceof a && void 0 !== e.extend || e instanceof o || e instanceof s || e instanceof i || e instanceof l)) throw TypeError("object must be a valid nested object");if (this.nested) {var t = this.get(e.name);if (t) {if (!(t instanceof l && e instanceof l) || t instanceof o || t instanceof i) throw Error("duplicate name '" + e.name + "' in " + this);for (var r = t.nestedArray, n = 0; n < r.length; ++n) {e.add(r[n]);}this.remove(t), this.nested || (this.nested = {}), e.setOptions(t.options, !0);}} else this.nested = {};return this.nested[e.name] = e, e.onAdd(this), h(this);}, l.prototype.remove = function (e) {if (!(e instanceof n)) throw TypeError("object must be a ReflectionObject");if (e.parent !== this) throw Error(e + " is not a member of " + this);return delete this.nested[e.name], Object.keys(this.nested).length || (this.nested = void 0), e.onRemove(this), h(this);}, l.prototype.define = function (e, t) {if (c.isString(e)) e = e.split(".");else if (!Array.isArray(e)) throw TypeError("illegal path");if (e && e.length && "" === e[0]) throw Error("path must be relative");for (var r = this; e.length > 0;) {var n = e.shift();if (r.nested && r.nested[n]) {if (!((r = r.nested[n]) instanceof l)) throw Error("path conflicts with non-namespace objects");} else r.add(r = new l(n));}return t && r.addJSON(t), r;}, l.prototype.resolveAll = function () {for (var e = this.nestedArray, t = 0; t < e.length;) {e[t] instanceof l ? e[t++].resolveAll() : e[t++].resolve();}return this.resolve();}, l.prototype.lookup = function (e, t, r) {if ("boolean" == typeof t ? (r = t, t = void 0) : t && !Array.isArray(t) && (t = [t]), c.isString(e) && e.length) {if ("." === e) return this.root;e = e.split(".");} else if (!e.length) return this;if ("" === e[0]) return this.root.lookup(e.slice(1), t);var n = this.get(e[0]);if (n) {if (1 === e.length) {if (!t || t.indexOf(n.constructor) > -1) return n;} else if (n instanceof l && (n = n.lookup(e.slice(1), t, !0))) return n;} else for (var o = 0; o < this.nestedArray.length; ++o) {if (this._nestedArray[o] instanceof l && (n = this._nestedArray[o].lookup(e, t, !0))) return n;}return null === this.parent || r ? null : this.parent.lookup(e, t);}, l.prototype.lookupType = function (e) {var t = this.lookup(e, [o]);if (!t) throw Error("no such type: " + e);return t;}, l.prototype.lookupEnum = function (e) {var t = this.lookup(e, [s]);if (!t) throw Error("no such Enum '" + e + "' in " + this);return t;}, l.prototype.lookupTypeOrEnum = function (e) {var t = this.lookup(e, [o, s]);if (!t) throw Error("no such Type or Enum '" + e + "' in " + this);return t;}, l.prototype.lookupService = function (e) {var t = this.lookup(e, [i]);if (!t) throw Error("no such Service '" + e + "' in " + this);return t;}, l._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {"use strict";var n = t,o = r(5),i = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];function s(e, t) {var r = 0,n = {};for (t |= 0; r < e.length;) {n[i[r + t]] = e[r++];}return n;}n.basic = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), n.defaults = s([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, !1, "", o.emptyArray, null]), n.long = s([0, 0, 0, 1, 1], 7), n.mapKey = s([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), n.packed = s([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Curve = void 0;var n = r(1),o = r(43),i = r(0),s = r(3),a = r(2),c = function c() {o.BaseGeometry.call(this), this._subrange = [];};(c.prototype = Object.create(o.BaseGeometry.prototype)).copy = function (e) {o.BaseGeometry.prototype.copy.call(this, e), this._subrange = e.isLimited() ? [e._subrange[0], e._subrange[1]] : [];}, c.prototype.isLimited = function () {return this._subrange.length > 0;}, c.prototype.getRange = function () {return this.isLimited() ? this._subrange : this.getRangeUnlimited();}, c.prototype.getRangeUnlimited = function () {console.warn("Curve.getRangeUnlimited : abstract method invoked!");}, c.prototype.limitRange = function (e) {this._subrange = (0, s.limitRange)(this.getRange(), e, this.isPeriodic(), this.getPeriod());}, c.prototype.unlimitRange = function () {this._subrange = [];}, c.prototype.isPeriodic = function () {return this.isPeriodicUnlimited() && !this.isLimited();}, c.prototype.isPeriodicUnlimited = function () {console.warn("Curve.isPeriodicUnlimited : abstract method invoked!");}, c.prototype.getPeriod = function () {return this.isLimited() ? void 0 : this.getPeriodUnlimited();}, c.prototype.getPeriodUnlimited = function () {if (this.isPeriodicUnlimited()) {var e = this.getRangeUnlimited();return e[1] - e[0];}}, c.prototype.isClosed = function () {if (this.isClosedUnlimited()) {if (this.isLimited()) {var e = this.getRangeUnlimited(),t = e[1] - e[0];return this._subrange[1] - this._subrange[0] > t - i.PARAMETER_SPACE_TOLERANCE;}return !0;}return !1;}, c.prototype.isClosedUnlimited = function () {console.warn("Curve.isClosedUnlimited : abstract method invoked!");}, c.prototype._restrictRangeToUnlimited = function (e) {a.ConsoleUtils.assert(2 === e.length), a.ConsoleUtils.assert(e[0] <= e[1]);var t = this.getRangeUnlimited(),r = [];if (this.isPeriodicUnlimited()) {var o = t[1] - t[0];if (e[1] - e[0] > o - i.PARAMETER_SPACE_TOLERANCE) r.push([t[0], t[1]]);else {var c = (0, s.foldAbove)(e[0], t[0], o) - e[0];r.push([e[0] + c, e[1] + c]), r[0][1] > t[1] + i.PARAMETER_SPACE_TOLERANCE && (r.push([t[0], r[0][1] - o]), r[0][1] = t[1]);}} else {var u = Math.max(e[0], t[0]),l = Math.min(e[1], t[1]);u > t[1] ? u < t[1] + n.FLOAT64_TOLERANCE && r.push([t[1], t[1]]) : l < t[0] ? l > t[0] - n.FLOAT64_TOLERANCE && r.push([t[0], t[0]]) : r.push([u, l]);}return r;}, c.prototype.transform = function (e) {console.warn("Curve.transform : abstract method invoked! Doing nothing.");}, c.prototype.evaluatePosition = function (e) {console.warn("Curve.evaluatePosition : abstract method invoked! Returning undefined.");}, c.prototype.evaluateDt = function (e) {console.warn("Curve.evaluateDt : abstract method invoked! Returning undefined.");}, c.prototype.evaluateCurvature = function (e, t) {var r = this.evaluateDt(e),o = this.evaluateDt(e + i.KERNEL_TOLERANCE);n.Vector3.sub(o, o, r);var s = n.Vector3.createFloat64();n.Vector3.scale(s, o, 1 / i.KERNEL_TOLERANCE), t && (n.Vector3.copy(t, s), n.Vector3.normalize(t, t));var a = n.Vector3.squaredLength(r);return n.Vector3.cross(s, r, s), n.Vector3.length(s) / Math.pow(a, 1.5);}, c.prototype.tangentLength = function (e) {return n.Vector3.length(this.evaluateDt(e));}, c.prototype.suggestSplittingParam = function (e) {console.warn("Curve.suggestSplittingParam : abstract method invoked! Returning undefined.");}, c.prototype.getTangentCone = function (e) {console.warn("Curve.getTangentCone : abstract method invoked! Returning undefined.");}, c.prototype.closestToRayParam = function (e, t, r) {console.warn("Curve.closestToRayParam : abstract method invoked! Returning undefined.");}, c.prototype.closestToPointParam = function (e, t) {console.warn("Curve.closestToPointParam : abstract method invoked! Returning undefined.");}, c.prototype.getArcLength = function (e) {console.warn("Curve.getArcLength : abstract method invoked!");}, c.prototype.getParameterFromArcLength = function (e, t) {console.warn("Curve.getParameterFromArcLength : abstract method invoked!");}, c.prototype.getBoundingBox = function (e) {console.warn("Curve.getBoundingBox : abstract method invoked! Returning undefined.");}, c.prototype.tessellate = function (e, t) {console.warn("Curve.tessellate : abstract method invoked! Returning undefined.");}, t.Curve = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BCurve = void 0;var n = r(1),o = r(4),i = r(34),s = r(0),a = r(32),c = r(7),u = r(3),l = r(35),h = r(2),d = r(8),g = r(50),p = r(36),f = r(17),v = r(37),_ = r(102),y = r(73),m = function m() {a.Curve.call(this), this._controlPoints = [], this._weights = [], this._degree = 0, this._knots = [], this._isRational = void 0, this._isPeriodic = void 0, this._isClosed = void 0, this._isPlanarXY = void 0, this._discretizationCache = void 0, this._segments = void 0, this._hasDirtySegments = !0, this._isDirtyControlPoint = [], this._tessellationCache = new g.TessellationCache();};(m.prototype = Object.create(a.Curve.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.BCURVE;}, m.prototype.clone = function () {var e = new m();return e.copy(this), e;}, m.prototype.getControlPointsVector3 = function () {for (var e = new Array(this._controlPoints.length / 3), t = 0; t < this._controlPoints.length / 3; t++) {e[t] = n.Vector3.createFloat64FromValues(this._controlPoints[3 * t], this._controlPoints[3 * t + 1], this._controlPoints[3 * t + 2]);}return e;}, m.prototype.copy = function (e) {a.Curve.prototype.copy.call(this, e), this._isRational = e._isRational, this._weights = e._weights.slice(0), this._degree = e._degree, this._knots = e._knots.slice(0), this._isPeriodic = e._isPeriodic, this._isClosed = e._isClosed, this._weights = e._weights.slice(0), this._controlPoints = e._controlPoints.slice(0), this._isPlanarXY = e._isPlanarXY, this._hasDirtySegments = !0, this._tessellationCache.reset();}, m.prototype.set = function (e, t, r, o) {this.dirtyCurveRepresentation(), this._weights = Array.prototype.slice.call(t), this._degree = r;var i = 0;if (this._isRational = !1, this._weights.length !== t.length) {this._weights = Array.prototype.slice.call(t);var s = this._weights[0];for (i = 1; i < this._weights.length; ++i) {if (Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE) {this._isRational = !0;break;}}} else for (s = this._weights[0], i = 1; i < this._weights.length; ++i) {this._weights[i] = t[i], Math.abs(this._weights[i] - s) > n.FLOAT64_TOLERANCE && (this._isRational = !0);}if (this._knots.length !== o.length) this._knots = Array.prototype.slice.call(o);else for (i = 0; i < this._knots.length; ++i) {this._knots[i] = o[i];}var a = e.length / 3;if (0 === this._weights.length) for (this._weights = new Array(a), i = 0; i < a; ++i) {this._weights[i] = 1;}if (this._controlPoints.length !== e.length) this._controlPoints = Array.prototype.slice.call(e);else for (i = 0; i < e.length; ++i) {this._controlPoints[i] = e[i];}this._isDirtyControlPoint.length !== a && (this._isDirtyControlPoint = new Array(a)), this._isDirtyControlPoint.fill(!1);}, m.prototype.dirtyCurveRepresentation = function () {this._isPlanarXY = void 0, this._isRational = void 0, this._isClosed = void 0, this._isPeriodic = void 0, this._discretizationCache = void 0, this._hasDirtySegments = !0, this._tessellationCache.setDirty(!0);}, m.prototype.hasDirtyTessellation = function () {return this._tessellationCache.isDirty();}, m.prototype.getTessellationCacheTolerance = function () {return this._tessellationCache.getTolerance();}, m.prototype.weightedControlPoints = function () {for (var e = [], t = 0; t < this._controlPoints.length / 3; ++t) {var r = this._weights[t];e.push(this._controlPoints[3 * t] * r, this._controlPoints[3 * t + 1] * r, this._controlPoints[3 * t + 2] * r, r);}return e;}, m.prototype.getControlPoints = function () {return this._controlPoints;}, m.prototype._findChangedControlPoints = function (e) {var t = e.length === this._controlPoints.length;t || (this._isDirtyControlPoint = new Array(e.length / 3), this._isDirtyControlPoint.fill(!0));for (var r = 0; r < e.length / 3; ++r) {if (t) {var n = e[3 * r] - this._controlPoints[3 * r],o = e[3 * r + 1] - this._controlPoints[3 * r + 1],i = e[3 * r + 2] - this._controlPoints[3 * r + 2];n * n + o * o + i * i > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (this._isDirtyControlPoint[r] = !0);} else this._isDirtyControlPoint[r] = !0;}}, m.prototype.setControlPoints = function (e) {this._findChangedControlPoints(e), this._controlPoints = e, this.dirtyCurveRepresentation();}, m.prototype.copyControlPoints = function (e) {if (this._findChangedControlPoints(e), e !== this._controlPoints) {this._controlPoints.length = e.length;for (var t = 0; t < e.length; ++t) {this._controlPoints[t] = e[t];}}this.dirtyCurveRepresentation();}, m.prototype.transform = function (e) {for (var t = [], r = n.Vector3.createFloat64(), o = 0; o < this._controlPoints.length; o += 3) {n.Vector3.set(r, this._controlPoints[o], this._controlPoints[o + 1], this._controlPoints[o + 2]), n.Vector3.transformMatrix44(r, r, e), t.push(r[0], r[1], r[2]);}this.setControlPoints(t);}, m.prototype.getControlPointPosition = function (e) {return n.Vector3.createFloat64FromValues(this._controlPoints[3 * e], this._controlPoints[3 * e + 1], this._controlPoints[3 * e + 2]);}, m.prototype.extendBBoxFromControlPoints = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), e.includePoint(t);}}, m.prototype.setControlPointPosition = function (e, t, r, n) {this._controlPoints[3 * e] = t, this._controlPoints[3 * e + 1] = r, this._controlPoints[3 * e + 2] = n, this._isDirtyControlPoint[e] = !0, this.dirtyCurveRepresentation();}, m.prototype.getWeights = function () {return this._weights;}, m.prototype.setWeights = function (e) {this._weights = e, this.dirtyCurveRepresentation();}, m.prototype.getKnotVector = function () {return this._knots;}, m.prototype.setKnotVector = function (e) {this._knots = e, this.dirtyCurveRepresentation();}, m.prototype.getDegree = function () {return this._degree;}, m.prototype.isRational = function () {if (void 0 === this._isRational && (this._isRational = !1, this._weights)) for (var e = this._weights[0], t = 0; t < this._weights.length; ++t) {if (Math.abs(this._weights[t] - e) > n.FLOAT64_TOLERANCE) return this._isRational = !0, !0;}return this._isRational;}, m.prototype.isSimpleBezier = function () {return this._knots.length === 2 * this._degree + 2;}, m.prototype.getNumControlPoints = function () {return this._controlPoints.length / 3;}, m.prototype.getTessellationCache = function () {return this._tessellationCache.getCache();}, m.prototype.getEvaluationCache = function () {return void 0 === this._discretizationCache && this.evaluate(), this._discretizationCache;}, m.prototype.getRangeUnlimited = function () {return [this._knots[0], this._knots[this._knots.length - 1]];}, m.prototype.isPeriodicUnlimited = function () {return this._checkClosure(), this._isPeriodic;}, m.prototype.isClosedUnlimited = function () {return this._checkClosure(), this._isClosed;}, m.prototype._checkClosure = function () {if (void 0 === this._isClosed || void 0 === this._isPeriodic) {this._isClosed = this._isPeriodic = !1;var e = this.getRangeUnlimited(),t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);if (n.Vector3.equals(t, r, s.KERNEL_TOLERANCE)) {this._isClosed = !0;var o = this.evaluateDt(e[0]),i = this.evaluateDt(e[1]);n.Vector3.isParallel(o, i, 1, s.KERNEL_ANGULAR_TOLERANCE) && (this._isPeriodic = !0);}}}, m.prototype.getBezierSegments = function () {return this._decomposeCurve(), this.isSimpleBezier() ? [this] : this._segments;}, m.prototype.isPlanarXY = function () {if (void 0 === this._isPlanarXY) {var e = s.SPLINE_DISTANCE_TOLERANCE;this._isPlanarXY = !0;for (var t = 1 / 0, r = -1 / 0, n = 2; n < this._controlPoints.length; n += 3) {t = Math.min(t, this._controlPoints[n]), r = Math.max(r, this._controlPoints[n]);}Math.abs(r - t) > 2 * e && (this._isPlanarXY = !1);}return this._isPlanarXY;}, m.prototype.getBezierSegmentsInRange = function (e, t) {for (var r = this.getBezierSegments(), n = e || this._knots[0], o = t || this._knots[this._knots.length - 1], i = [], s = 0; s < r.length; ++s) {var a = r[s].getKnotVector();n <= a[a.length - 1] && a[0] >= o && i.push(r[s]);}return i;}, m.prototype.getApproxParameterSpaceTolerance = function () {if (12 === this.getControlPoints().length) return p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this.getBoundingBox(), s.KERNEL_TOLERANCE);this._decomposeCurve();for (var e = 0, t = 0; t < this._segments.size(); ++t) {e += p.SplineCurveHelper.getApproxBezierParameterSpaceTolerance(this._segments[t].getBoundingBox(), s.KERNEL_TOLERANCE);}return e;}, m.prototype.getArcLength = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());for (var t = this._restrictRangeToUnlimited(e), r = 0, o = this.getBezierSegments(), i = 0; i < o.length; ++i) {for (var a = o[i], c = a.getRangeUnlimited(), u = 0; u < t.length; ++u) {var h = [Math.max(c[0], t[u][0]), Math.min(c[1], t[u][1])];h[1] - h[0] > s.PARAMETER_SPACE_TOLERANCE && (r += (0, l.integrateFunction1D)(function (e) {return n.Vector3.length(a.evaluateDt(e));}, h));}}return r;}, m.prototype.getParameterFromArcLength = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());var r = this;return (0, l.invertIntegral1D)(function (e) {return n.Vector3.length(r.evaluateDt(e));}, e, t);}, m.prototype._decomposeCurve = function () {if (this._hasDirtySegments) if (this._hasDirtySegments = !1, this.isSimpleBezier()) this._segments = void 0;else {var e;this._isDirtyControlPoint.length === this.getNumControlPoints() ? e = (0, _.decomposeBCurveFlags)(this.getKnotVector(), this._isDirtyControlPoint) : (this._isDirtyControlPoint = new Array(this.getNumControlPoints()), (e = new Array(this.getNumControlPoints())).fill(!0)), this._isDirtyControlPoint.fill(!1);var t = (0, _.decomposeBCurveToBezier)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0);this._segments && this._segments.length === t.P.length || (this._segments = []);for (var r = 0; r < t.P.length; ++r) {void 0 === this._segments[r] && (this._segments[r] = new m(), e[r] = !0), e[r] && this._segments[r].set(t.P[r], t.w ? t.w[r] : new Array(2 * this._degree + 2).fill(1), this._degree, t.U[r]);}}}, m.prototype.evaluatePosition = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurvePoint)(e, this._degree, this._knots, this._controlPoints, t);}, m.prototype.evaluateDt = function (e) {this.isPeriodicUnlimited() && (e = (0, u.normalizeParameterToShiftedRange)(e, [this._knots[0], this._knots[this._knots.length - 1]]));var t = this.isRational() ? this._weights : void 0;return (0, v.evaluateBCurveDerivs)(e, 1, this._degree, this._knots, this._controlPoints, t)[1];}, m.prototype.closestToRayParam = function (e, t, r, o) {if (!(this._controlPoints.length < 9)) {if (this.isPlanarXY()) {var i = t[2],a = n.Vector3.createFloat64();if (Math.abs(i) < s.KERNEL_ANGULAR_TOLERANCE) n.Vector3.copy(a, e);else {var c = (this._controlPoints[2] - e[2]) / i;n.Vector3.add(a, n.Vector3.scale(a, t, c), e);}return this.closestToPointParam(a);}d.DebugUtils.warn("BCurve.closestToRayParam() only defined for planar curves");}}, m.prototype.closestToPointParam = function (e, t) {void 0 === t ? t = this.getRange() : 0 === t.length && (t = this.getRangeUnlimited());for (var r = this._restrictRangeToUnlimited(t), o = n.FLOAT64_TOLERANCE, i = this.getBezierSegments(), s = (0, y.closestBCurveSegments)(e, i, void 0, r), a = Number.POSITIVE_INFINITY, c = void 0, l = 0; l < s.length; ++l) {if (!(s[l].minDistSqr > a)) for (var h = i[s[l].index], d = h.getRangeUnlimited(), g = 0; g < r.length; ++g) {var p = [Math.max(d[0], r[g][0]), Math.min(d[1], r[g][1])];if (!(p[1] - p[0] <= n.FLOAT64_TOLERANCE)) {var f = h.getEvaluationCache(),v = (0, u.closestPointToPolyline)(e, f.points, f.offset, p),_ = (0, y.relaxBCurveToPerpendicular)(this._knots, this._controlPoints, this.isRational() ? this._weights : void 0, e, v, p, o, 32),m = h.evaluatePosition(_),E = n.Vector3.squaredDistance(m, e);E < a && (a = E, c = _);var x = h.evaluatePosition(p[0]),R = n.Vector3.squaredDistance(x, e);R < a && (a = R, c = p[0]);var A = h.evaluatePosition(p[1]),P = n.Vector3.squaredDistance(A, e);P < a && (a = P, c = p[1]);}}}return this.isPeriodicUnlimited() && (c = (0, u.foldNearTo)(c, .5 * (t[0] + t[1]), this.getPeriodUnlimited())), c;}, m.prototype.evaluate = function () {var e = this.getBezierSegments();if (e[0] === this) void 0 === this._discretizationCache && (this._discretizationCache = p.SplineCurveHelper.evaluateCurve(this.getDegree(), this.getKnotVector(), this.getControlPoints(), this.getWeights(), !0));else for (var t = 0; t < e.length; ++t) {var r = e[t];void 0 === r._discretizationCache && (r._discretizationCache = p.SplineCurveHelper.evaluateCurve(r.getDegree(), r.getKnotVector(), r.getControlPoints(), r.getWeights(), !0));}}, m.prototype._getFullTessellation = function (e) {var t,r,o = this.getBezierSegments(),i = 0,s = !1;if (o[0] === this) {s = !0;var a = g.CurveTessellator.getAdaptiveRenderPoints(this, e, this.getRangeUnlimited());t = a.positions, r = a.params, i = Math.max(i, a.tolerance);} else {t = [], r = [];for (var c = 0; c < o.length; ++c) {var u = o[c];if (u.hasDirtyTessellation() || u.getTessellationCacheTolerance() > e + n.FLOAT64_TOLERANCE) {s = !0;var l = g.CurveTessellator.getAdaptiveRenderPoints(u, e, u.getRangeUnlimited());u._tessellationCache.setCache(l), i = Math.max(i, l.tolerance);}u._tessellationCache && (0 === c ? (t.push.apply(t, u._tessellationCache.getCache().positions), r.push.apply(r, u._tessellationCache.getCache().params)) : (t.push.apply(t, u._tessellationCache.getCache().positions.slice(1)), r.push.apply(r, u._tessellationCache.getCache().params.slice(1))));}}return { positions: t, params: r, didRetessellate: s, tolerance: i };}, m.prototype.tessellate = function (e, t) {return t = t || s.TESSELLATION.LINEAR_PRECISION, this._tessellationCache.getTessellation(e, this, t, this._getFullTessellation.bind(this));}, m.prototype.getBoundingBox = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this._restrictRangeToUnlimited(e),r = new o.BoundingBox(),n = this.getRangeUnlimited();if (t[0][0] < n[0] + s.PARAMETER_SPACE_TOLERANCE && t[0][1] > n[1] - s.PARAMETER_SPACE_TOLERANCE) this.extendBBoxFromControlPoints(r);else for (var i = this.getBezierSegments(), a = 0; a < t.length; a++) {for (var c = 0; c < i.length; c++) {var u = i[c];(u = u._getSubset(t[a][0], t[a][1])) && u.extendBBoxFromControlPoints(r);}}return r;}, m.prototype.getTangentCone = function (e) {void 0 === e ? e = this.getRange() : 0 === e.length && (e = this.getRangeUnlimited());var t = this.evaluatePosition(e[0]),r = this.evaluatePosition(e[1]);n.Vector3.sub(r, r, t), n.Vector3.squaredLength(r) < .01 * s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE && (r = this.evaluateDt(.5 * (e[0] + e[1]))), n.Vector3.normalize(r, r);for (var o = new i.TangentCone(r, 0), a = this._restrictRangeToUnlimited(e), c = n.Vector3.createFloat64FromValues(0, 0, 0), u = this.getBezierSegments(), l = 0; l < a.length; l++) {for (var h = 0; h < u.length; h++) {var d = u[h];if (d = d._getSubset(a[l][0], a[l][1])) for (var g = d._controlPoints, p = 0; p < g.length - 3; p += 3) {c[0] = g[p + 3] - g[p], c[1] = g[p + 4] - g[p + 1], c[2] = g[p + 5] - g[p + 2], n.Vector3.dot(c, r) >= 0 ? o.includeVector(c) : o.angle = Math.PI;}}}return o;}, m.prototype._getSubset = function (e, t) {var r;if (this.isPeriodicUnlimited()) return t - e > this.getPeriodUnlimited() - s.PARAMETER_SPACE_TOLERANCE ? this : ((r = this.clone())._periodicTrimToParams(e, t), r);var n = this.getRangeUnlimited();return e > n[1] - s.PARAMETER_SPACE_TOLERANCE || t < n[0] + s.PARAMETER_SPACE_TOLERANCE ? void 0 : e < n[0] + s.PARAMETER_SPACE_TOLERANCE && t > n[1] - s.PARAMETER_SPACE_TOLERANCE ? this : (r = this.clone(), e > n[0] + s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!0, e), t < n[1] - s.PARAMETER_SPACE_TOLERANCE && r.trimToParam(!1, t), r);}, m.prototype._periodicTrimToParams = function (e, t) {h.ConsoleUtils.assert(this._isPeriodic);var r = this.getRangeUnlimited(),n = (0, u.normalizeParametricRangeToShiftedRange)([e, t], r);if (n[1] > r[1]) this._isClosed = this._isPeriodic = !1, this.trimToParam(!0, n[1] - (r[1] - r[0]), void 0), this.trimToParam(!1, n[0], void 0);else {var o,i,s = this.getControlPoints(),a = this.getKnotVector(),c = this.getWeights(),l = this.getDegree(),d = this.getPeriodUnlimited(),g = [],f = a.slice(),v = a.slice(),_ = [];for (i = 0; i < s.length / 3; ++i) {g[4 * i + 0] = s[3 * i + 0] * c[i], g[4 * i + 1] = s[3 * i + 1] * c[i], g[4 * i + 2] = s[3 * i + 2] * c[i], g[4 * i + 3] = c[i];}for (o = g.slice(), p.SplineCurveHelper.extractCurveSegment(l, n[1], r[1], f, g), p.SplineCurveHelper.extractCurveSegment(l, r[0], n[0], v, o), i = 0; i < v.length; ++i) {v[i] = v[i] + d;}p.SplineCurveHelper.joinCurves(l, f, g, v, o);var y = g.length / 4,m = [];for (_.length = y, m.length = 3 * y, i = 0; i < y; ++i) {var E = g[4 * i + 3];m[3 * i] = g[4 * i] / E, m[3 * i + 1] = g[4 * i + 1] / E, m[3 * i + 2] = g[4 * i + 2] / E, _[i] = E;}this.set(m, _, l, f), this._isClosed = this._isPeriodic = !1;}}, m.prototype.trimToParam = function (e, t, r) {if (this.isPeriodicUnlimited()) return h.ConsoleUtils.assert(void 0 !== r), void this._periodicTrimToParams(t, r);var n,o,i = this.getControlPoints(),s = this.getKnotVector(),a = this.getWeights(),c = this.getDegree(),u = [];for (n = 0; n < i.length / 3; ++n) {u[4 * n + 0] = i[3 * n + 0] * a[n], u[4 * n + 1] = i[3 * n + 1] * a[n], u[4 * n + 2] = i[3 * n + 2] * a[n], u[4 * n + 3] = a[n];}var l = [],d = 0,g = p.SplineCurveHelper.insertKnot(c, s, u, t, c),v = (0, f.findKnotSpan)(t, g.U);for (e ? (g.U.splice(0, v - c + 1, t), o = g.U.length - c - 1, d = 4 * (g.Pw.length / 4 - o)) : (g.U.splice(v + 1, g.U.length, t), o = g.U.length - c - 1), u.length = 3 * o, l.length = o, n = 0; n < o; ++n) {var _ = g.Pw[4 * n + 3 + d];u[3 * n] = g.Pw[4 * n + 0 + d] / _, u[3 * n + 1] = g.Pw[4 * n + 1 + d] / _, u[3 * n + 2] = g.Pw[4 * n + 2 + d] / _, l[n] = _;}this.set(u, l, c, g.U);}, m.prototype.addControlPoint = function (e, t) {var r = this.getControlPoints(),o = this.getNumControlPoints(),i = this.getKnotVector(),a = this.getWeights(),u = this.getDegree(),l = this.getControlPointPosition(e),h = this.getControlPointPosition(e + 1),d = new c.Line();d.setFromEndpoints(l, h);var g = d.closestToPointParam(t),f = d.evaluatePosition(g),v = n.Vector3.distance(f, l),_ = n.Vector3.distance(f, h),y = a[e] * v + a[e + 1] * _;if (Math.abs(y) < s.KERNEL_TOLERANCE) console.warn("numerical error in addControlPoints -- coincident control points / negative weights?");else {for (var m = a[e] * v / y, E = i[e + 1] + m * (i[e + u + 1] - i[e + 1]), x = [], R = 0; R < r.length / 3; ++R) {x[4 * R] = r[3 * R] * a[R], x[4 * R + 1] = r[3 * R + 1] * a[R], x[4 * R + 2] = r[3 * R + 2] * a[R], x[4 * R + 3] = a[R];}var A = p.SplineCurveHelper.findKnotMultiplicity(E, i),P = p.SplineCurveHelper.insertKnot(u, i, x, E, A + 1),V = [];for (x.length = 3 * (o + 1), V.length = o + 1, R = 0; R <= o; ++R) {var T = P.Pw[4 * R + 3];x[3 * R] = P.Pw[4 * R] / T, x[3 * R + 1] = P.Pw[4 * R + 1] / T, x[3 * R + 2] = P.Pw[4 * R + 2] / T, V[R] = T;}this.set(x, V, u, P.U);}}, m.prototype.addControlPointOnCurve = function (e) {for (var t = this.getNumControlPoints(), r = Number.MAX_VALUE, o = -1, i = n.Vector3.createFloat64FromValues(0, 0, 0), s = n.Vector3.createFloat64FromValues(0, 0, 0), a = 0; a < t - 1; ++a) {i[0] = this._controlPoints[3 * a + 0], i[1] = this._controlPoints[3 * a + 1], s[0] = this._controlPoints[3 * a + 3], s[1] = this._controlPoints[3 * a + 4];var c = (0, u.distancePointToLineSegment)(i, s, e);c < r && (r = c, o = a);}-1 !== o && this.addControlPoint(o, e);}, m.prototype.makePeriodic = function () {if (!this.isPeriodicUnlimited()) {for (var e = this.getControlPoints(), t = this.getKnotVector(), r = this.getWeights(), n = this.getDegree(), o = [], i = 0; i < e.length / 3; ++i) {o[4 * i] = e[3 * i] * r[i], o[4 * i + 1] = e[3 * i + 1] * r[i], o[4 * i + 2] = e[3 * i + 2] * r[i], o[4 * i + 3] = r[i];}var s = t.slice();p.SplineCurveHelper.makePeriodic(n, s, o);var a = [],c = [],u = o.length / 4;for (a.length = u, c.length = 3 * u, i = 0; i < u; ++i) {var l = o[4 * i + 3];c[3 * i] = o[4 * i] / l, c[3 * i + 1] = o[4 * i + 1] / l, c[3 * i + 2] = o[4 * i + 2] / l, a[i] = l;}this.set(c, a, n, s), this._isClosed = this._isPeriodic = !0;}}, m.prototype.suggestSplittingParam = function (e) {var t,r = this.getKnotVector(),n = .5 * (e[0] + e[1]),o = (0, u.sortedIndex)(r, n);if (0 === o) t = r[o];else if (o === r.length) t = r[o - 1];else {var i = r[o - 1],s = r[o];t = n - i < s - n ? i : s;}return t >= e[0] && t <= e[1] ? t : void 0;}, m.prototype.toObject = function () {return { degree: this._degree, knots: this._knots, controlPoints: this._controlPoints, weights: this._weights, range: this.rangeToObject(this.getRange(), this.isLimited()) };}, t.BCurve = m;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TangentCone = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this.set(e, t);};s.prototype.set = function (e, t) {void 0 === e || void 0 === t ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e), this.angle = t);}, s.prototype.toString = function () {return this.isDegenerate() ? "degenerate" : "(x:" + this.axis[0] + ", y:" + this.axis[1] + ", z:" + this.axis[2] + ", radians:" + this.angle + ")";}, s.prototype.copy = function (e) {return e.isDegenerate() ? (this.axis = void 0, this.angle = void 0) : (this.axis = n.Vector3.clone(e.axis), this.angle = e.angle), this;}, s.prototype.clone = function () {return new s(this.axis, this.angle);}, s.prototype.isDegenerate = function () {return void 0 === this.axis || void 0 === this.angle;}, s.prototype.includeVector = function (e) {if (n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return this;if (this.isDegenerate()) return this.axis || (this.axis = n.Vector3.createFloat64()), n.Vector3.normalize(this.axis, e), this.angle = 0, this;var t = n.Vector3.dot(this.axis, e) / n.Vector3.length(e);t = (0, i.clamp)(t, -1, 1);var r = Math.acos(t);return this.angle = Math.max(this.angle, r), this;}, s.prototype.includeCone = function (e) {if (e.isDegenerate()) return this;if (this.isDegenerate()) return this.copy(e);var t = n.Vector3.dot(this.axis, e.axis),r = Math.acos((0, i.clamp)(t, -1, 1));if (this.angle >= e.angle + r) return this;if (e.angle >= this.angle + r) return this.copy(e);if (r > Math.PI - o.KERNEL_ANGULAR_TOLERANCE) return this.angle = Math.PI, this;var s = (this.angle + e.angle + r) / 2;if (s >= Math.PI) return this.angle = Math.PI, this;var a = Math.sin(s - e.angle),c = Math.sin(s - this.angle);return n.Vector3.scale(this.axis, this.axis, a), n.Vector3.scaleAndAdd(this.axis, this.axis, e.axis, c), n.Vector3.normalize(this.axis, this.axis), this.angle = s, this;}, s.prototype.contains = function (e, t) {if (t = "number" == typeof t ? t : o.KERNEL_ANGULAR_TOLERANCE, !this.isDegenerate()) return n.Vector3.squaredLength(e) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE || n.Vector3.angle(this.axis, e) < this.angle + t;}, t.TangentCone = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.invertIntegral1D = t.integrateFunction1D = t.newtonRaphson1D = void 0;var n = r(0),o = r(3),i = r(8),s = function () {var e = [.9914553711208126, .9491079123427585, .8648644233597691, .7415311855993945, .5860872354676911, .4058451513773972, .20778495500789848, 0],t = [.022935322010529224, .06309209262997856, .10479001032225019, .14065325971552592, .1690047266392679, .19035057806478542, .20443294007529889, .20948214108472782],r = [.1294849661688697, .27970539148927664, .3818300505051189, .4179591836734694];return function (o, a, c) {var u = function (n, o, i) {for (var s = .5 * (o + i), a = .5 * (i - o), c = n(s), u = c * t[7], l = c * r[3], h = 0; h < 7; ++h) {var d = a * e[h],g = n(s - d) + n(s + d);u += g * t[h], h % 2 == 1 && (l += g * r[Math.floor(h / 2)]);}var p = 200 * Math.abs(u - l) * a;return { length: u * a, error: p *= Math.sqrt(p) };}(o, a[0], a[1]);if (void 0 === c) c = 0;else if (c > 8) return i.DebugUtils.warn("Max depth reached in integrateFunction1D!"), u.length;if (u.error > n.KERNEL_TOLERANCE) {var l = .5 * (a[0] + a[1]);return s(o, [a[0], l], c + 1) + s(o, [l, a[1]], c + 1);}return u.length;};}();t.newtonRaphson1D = function (e, t, r, n, s) {var a,c = r;t && (c = (0, o.clamp)(c, t[0], t[1]));var u = 0;do {++u;var l = e(c),h = c - l.val / l.deriv;t && (h = (0, o.clamp)(h, t[0], t[1])), a = Math.abs(h - c), c = h;} while (a > n && u < s);return u >= s && i.DebugUtils.warn("Maximum number of iterations reached. Something wrong is going on here !!!"), c;}, t.integrateFunction1D = s, t.invertIntegral1D = function (e, t, r) {var i = n.KERNEL_TOLERANCE,a = s(e, r);if (t < i) return r[0];if (t > a - i) return r[1];for (var c = r[0], u = r[1], l = t; u - c > n.PARAMETER_SPACE_TOLERANCE;) {var h = l / a,d = c + (h = (0, o.clamp)(h, .01, .99)) * (u - c),g = s(e, [c, d]),p = a - (g = (0, o.clamp)(g, 0, a));if (Math.abs(l - g) < i) return d;g > l ? (u = d, a = g) : (c = d, l -= g, a = p);}return .5 * (c + u);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SplineCurveHelper = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = r(17),c = r(37),u = r(72),l = function l() {};l.getApproxBezierParameterSpaceTolerance = function (e, t) {var r = e.getDiagonal(),i = 2 * t / n.Vector3.length(r);return i < .01 * o.PARAMETER_SPACE_TOLERANCE ? .01 * o.PARAMETER_SPACE_TOLERANCE : i;}, l.solve_cubic_uniqueRoots = function (e, t) {var r = e[2] * e[2] - 3 * e[1],n = e[2] * (2 * e[2] * e[2] - 9 * e[1]) + 27 * e[0];if (0 === n && 0 === r) return t[0] = -e[2] / 3, 1;if (n * n / 4 < r * r * r) {var o = -2 * Math.sqrt(r),i = Math.acos(-n / (r * o));return t[0] = (o * Math.cos(i / 3) - e[2]) / 3, t[1] = (o * Math.cos((i + 2 * Math.PI) / 3) - e[2]) / 3, t[2] = (o * Math.cos((i - 2 * Math.PI) / 3) - e[2]) / 3, 3;}var s = Math.pow(Math.abs(n) / 2 + Math.sqrt(n * n / 4 - r * r * r), 1 / 3) / 3;return n > 0 && (s = -s), t[0] = s + r / (9 * s) - e[2] / 3, 1;};var h = function h(e, t, r) {return 6 * ((1 - r) * (e[6 + t] - 2 * e[3 + t] + e[t]) + r * (e[9 + t] - 2 * e[6 + t] + e[3 + t]));},d = function d(e, t) {return 6 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));},g = function g(e, t) {var r = new Array(3);!function (e, t, r) {r[0] = 3 * (e[3 + t] - e[t]), r[1] = 6 * (e[t] + e[6 + t] - 2 * e[3 + t]), r[2] = 3 * (e[9 + t] - e[t] + 3 * (e[3 + t] - e[6 + t]));}(e, t, r);var n,o = new Array(2),i = function (e, t) {var r = e[1] * e[1] - 4 * e[2] * e[0];if (r < 0) return 0;if (0 === r) return t[0] = -.5 * e[1] / e[2], 1;var n = e[1] > 0 ? -.5 * (e[1] + Math.sqrt(r)) : -.5 * (e[1] - Math.sqrt(r));return t[0] = n / e[2], t[1] = e[0] / n, 2;}(r, o);2 === i && o[0] > o[1] && (n = o[0], o[0] = o[1], o[1] = n);for (var s = [], a = 0; a < i; a++) {o[a] > 0 && o[a] < 1 && ((n = Math.abs(h(e, t, o[a])) < 1e-12) ? (n = Math.abs(d(e, t)) < 1e-12) && s.push(o[a]) : s.push(o[a]));}return s;},p = function p(e, t, r) {return e + t[0] + t[1] * r + t[2] * r * r + t[3] * r * r * r;};l.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D = function (e, t, r, n) {var i = new Float64Array(4),s = new Float64Array(4);i[0] = t[0] - e[0], i[1] = 3 * (t[3] - t[0]), i[2] = 3 * (t[0] + t[6] - 2 * t[3]), i[3] = t[9] - t[0] + 3 * (t[3] - t[6]), s[0] = t[1] - e[1], s[1] = 3 * (t[4] - t[1]), s[2] = 3 * (t[1] + t[7] - 2 * t[4]), s[3] = t[10] - t[1] + 3 * (t[4] - t[7]);var a,c = s;if (Math.abs(c[3]) > 1e-4) c[0] /= c[3], c[1] /= c[3], c[2] /= c[3], c[3] = 1, a = this.solve_cubic_uniqueRoots(c, r);else {var l = [].slice.call(c).reverse();0 === l[0] && (l = l.slice(1));var h = (0, u.getRealPolynomialRoots)(l);a = h.length;for (var d = 0; d < a; d++) {r[d] = h[d];}}if (1 === a) return (f = r[0]) < 0 || f > 1 ? 0 : (r[0] = p(e[0], i, f), 1);d = 0;for (var g = 0; g < a; ++g) {(f = r[g]) >= 0 && f <= 1 && (r[d] = p(e[0], i, f), ++d);}if (void 0 !== n) {var f, v;if (Math.abs(s[3]) < 1e-12) Math.abs(s[2]) < 1e-12 ? v = -1 : (f = -s[1] / (2 * s[2]), v = 0);else {var _ = 2 / 3 * s[2] / s[3];v = _ * _ / 4 - 1 / 3 * s[1] / s[3], f = -_ / 2;}if (0 === v) {if (f < 0 || f > 1) {var y = p(e[0], s, 0),m = p(e[0], s, 1);Math.abs(y) > Math.abs(m) ? n.push([p(e[0], i, 0), y]) : n.push([p(e[0], i, 1), m]);} else n.push([p(e[0], i, f), p(e[0], s, f)]);} else if (v > 0) {for (g = 0; g < 2; g++) {(f = -_ / 2 + (0 === g ? -1 : 1) * Math.sqrt(v)) < -o.PARAMETER_SPACE_TOLERANCE || f > 1 + o.PARAMETER_SPACE_TOLERANCE || (f = Math.max(Math.min(1, f), 0), n.push([p(e[0], i, f), p(e[0], s, f)]));}if (n.length > 1 && n[0][0] > n[1][0]) {var E = n[0];n[0] = n[1], n[1] = E;}}}return d;}, l.isPointInsideSplineRegionXYPlanar3D = function (e, t, r) {var o,s,a = new Float64Array(3),c = t.getBezierSegments();if (t.isRational() || !c || 3 !== t.getDegree()) {for (var u = t.tessellate().positions, l = new Float64Array(2 * u.length), h = 0; h < u.length; ++h) {l[2 * h] = u[h].x, l[2 * h + 1] = u[h].y;}return (0, i.isPointInsidePolygon2D)(e, l);}var d,g = 0,p = n.Vector3.createFloat64();for (h = 0; h < c.length; ++h) {s = c[h].getControlPoints(), o = this.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D(e, s, a);for (var f = 0; f < o; ++f) {n.Vector3.set(p, a[f], e[1], 0), (d = t.closestToPointParam(p)) >= r[0] && d <= r[1] && a[f] > e[0] && ++g;}}var v = t.evaluatePosition(r[0]),_ = t.evaluatePosition(r[1]),y = n.Vector3.createFloat64();n.Vector3.normalize(y, n.Vector3.sub(y, _, v)), y[1] < 0 && n.Vector3.negate(y, y);var m = n.Vector2.createFloat64FromValues(e[0], e[1]);return (0, i.signedDistanceTo2DLine)(v, y, m) <= 0 && e[1] >= Math.min(v[1], _[1]) && e[1] <= Math.max(v[1], _[1]) && ++g, 1 & g;}, l.insertKnot = function (e, t, r, n, o) {var i,s,c,u = [],l = [],h = [],d = r.length / 4,g = d + e + 1,p = (0, a.findKnotSpanAndMultiplicity)(n, t),f = o - p.multiplicity;if (f < 1) return { U: u = t.slice(), Pw: l = r.slice() };for (i = 0; i <= p.span; ++i) {u[i] = t[i];}for (i = 1; i <= f; ++i) {u[p.span + i] = n;}for (i = p.span + 1; i < g; ++i) {u[i + f] = t[i];}for (i = 0; i <= p.span - e; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = r[4 * i + s];}}for (i = p.span - p.multiplicity; i < d; ++i) {for (s = 0; s < 4; ++s) {l[4 * (i + f) + s] = r[4 * i + s];}}for (i = 0; i <= e - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {h[4 * i + s] = r[4 * (p.span - e + i) + s];}}for (var v = 1; v <= f; ++v) {for (c = p.span - e + v, i = 0; i <= e - v - p.multiplicity; ++i) {var _ = (n - t[c + i]) / (t[i + p.span + 1] - t[c + i]);for (s = 0; s < 4; ++s) {h[4 * i + s] = h[4 * (i + 1) + s] * _ + h[4 * i + s] * (1 - _);}}for (s = 0; s < 4; ++s) {l[4 * c + s] = h[s], l[4 * (p.span + f - v - p.multiplicity) + s] = h[4 * (e - v - p.multiplicity) + s];}}for (i = c + 1; i < p.span - p.multiplicity; ++i) {for (s = 0; s < 4; ++s) {l[4 * i + s] = h[4 * (i - c) + s];}}return { U: u, Pw: l };}, l.refineKnotVector = function (e, t, r, n) {var i,s,c = [],u = [],l = r.length / 4 - 1,h = n.length - 1,d = l + e + 1,g = (0, a.findKnotSpan)(n[0], t),p = (0, a.findKnotSpan)(n[h], t) + 1;for (i = 0; i <= g - e; ++i) {for (s = 0; s < 4; ++s) {u[4 * i + s] = r[4 * i + s];}}for (i = p - 1; i <= l; ++i) {for (s = 0; s < 4; ++s) {u[4 * (i + h + 1) + s] = r[4 * i + s];}}for (i = 0; i <= g; ++i) {c[i] = t[i];}for (i = p + e; i <= d; ++i) {c[i + h + 1] = t[i];}var f = p + e - 1,v = p + e + h;for (i = h; i >= 0; --i) {for (; n[i] <= t[f] && f > g;) {for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + s] = r[4 * (f - e - 1) + s];}c[v] = t[f], --v, --f;}for (s = 0; s < 4; ++s) {u[4 * (v - e - 1) + 1] = u[4 * (v - e) + s];}for (var _ = 1; _ <= e; ++_) {var y = v - e + _,m = c[v + _] - n[i];if (Math.abs(m) < o.KERNEL_TOLERANCE) for (s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * y + s];} else for (m /= c[v + _] - t[f - e + _], s = 0; s < 4; ++s) {u[4 * (y - 1) + s] = u[4 * (y - 1) + s] * m + u[4 * y + s] * (1 - m);}}c[v] = n[i], --v;}return { U: c, Pw: u };};var f = function f(e, t, r, o) {var s = (0, i.projectPointToLineSegment)(t, r, e);return o && (s = (0, i.clamp)(s, 0, 1)), n.Vector3.lerp(n.Vector3.createFloat64(), t, r, s);};l.validControlPolygon = function (e) {for (var t = e.length / 3, r = e.length, o = n.Vector3.createFloat64(), i = n.Vector3.createFloat64(), s = n.Vector3.createFloat64(), a = 3, c = 1; c < t - 1; ++c) {n.Vector3.set(o, e[a], e[a + 1], e[a + 2]), n.Vector3.set(i, e[a - 3], e[a - 2], e[a - 1]), n.Vector3.set(s, e[a + 3], e[a + 4], e[a + 5]);var u = f(o, i, s, !1);if (n.Vector3.sub(o, o, u), c < t / 2 ? n.Vector3.sub(i, [e[r - 3], e[r - 2], e[r - 1]], u) : n.Vector3.sub(i, [e[0], e[1], e[2]], u), n.Vector3.dot(o, i) > 0) return !1;a += 3;}return !0;};var v = function v(e) {if (e) for (var t = 0; t < e.length; ++t) {if (Math.abs(e[t] - 1) > n.FLOAT64_TOLERANCE) return !0;}return !1;},_ = function () {var e = new Float64Array(4),t = new Float64Array(4),r = new Float64Array(4),n = new Float64Array(16);return function (o, i, s, a, c) {var u,l,h,d,g,p,f = 1 - s;if (e[0] = f * f * f, e[1] = 3 * s * f * f, e[2] = 3 * s * s * f, e[3] = s * s * s, t[0] = -3 * f * f, t[1] = 3 * (s - 1) * (3 * s - 1), t[2] = 3 * s * (2 - 3 * s), t[3] = 3 * s * s, r[0] = 6 * f, r[1] = 6 * (3 * s - 2), r[2] = 6 * (1 - 3 * s), r[3] = 6 * s, void 0 === c ? v(i) : c) {for (var _ = 0; _ < 4; ++_) {n[4 * _ + a] = o[3 * _ + a] * i[_], n[4 * _ + 3] = i[_];}for (u = n[a] * e[0], l = n[a] * t[0], h = n[a] * r[0], _ = 1; _ < 4; ++_) {u += n[4 * _ + a] * e[_], l += n[4 * _ + a] * t[_], h += n[4 * _ + a] * r[_];}for (d = n[3] * e[0], g = n[3] * t[0], p = n[3] * r[0], _ = 1; _ < 4; ++_) {d += n[4 * _ + 3] * e[_], g += n[4 * _ + 3] * t[_], p += n[4 * _ + 3] * r[_];}u /= d, l /= g, h /= p;} else for (u = o[a] * e[0], l = o[a] * t[0], h = o[a] * r[0], _ = 1; _ < 4; ++_) {u += o[3 * _ + a] * e[_], l += o[3 * _ + a] * t[_], h += o[3 * _ + a] * r[_];}return [u, l, h];};}(),y = function y(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1];var i = o[0] * o[0] + o[1] * o[1],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[1] = n[0] * n[0] + n[1] * n[1], n[0] = a;}},m = function m(e, t, r, n) {var o = n;o[0] = r[0] - t[0], o[1] = r[1] - t[1], o[2] = r[2] - t[2];var i = o[0] * o[0] + o[1] * o[1] + o[2] * o[2],s = (e[0] - t[0]) * o[0] + (e[1] - t[1]) * o[1] + (e[2] - t[2]) * o[2];if (0 === i || s <= 0) n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 0;else if (s > i) n[0] = e[0] - r[0], n[1] = e[1] - r[1], n[2] = e[2] - r[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[1] * n[1], n[0] = 1;else {var a = s / i;n[0] = t[0] + a * o[0] - e[0], n[1] = t[1] + a * o[1] - e[1], n[2] = t[2] + a * o[2] - e[2], n[1] = n[0] * n[0] + n[1] * n[1] + n[2] * n[2], n[0] = a;}};l.closestStartPoint = function () {var e,t,r,n,o = new Float64Array(3),i = new Float64Array(3),s = new Float64Array(3),a = new Float64Array(2);return function (c, u, l, h) {if (l) for (a[0] = 0, a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], i[0] = u.points[n + 3], i[1] = u.points[n + 4], y(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));} else for (a[1] = 1 / 0, r = u.points.length, n = 0; n < r - 3; n += 3) {o[0] = u.points[n], o[1] = u.points[n + 1], o[2] = u.points[n + 2], i[0] = u.points[n + 3], i[1] = u.points[n + 4], i[2] = u.points[n + 5], m(c, o, i, s), s[1] < a[1] && (e = n / 3, t = (1 - s[0]) * u.offset[e] + s[0] * u.offset[e + 1], (!h || t >= h[0] && t <= h[1]) && (a[0] = t, a[1] = s[1]));}return a[0];};}(), l.extremalParams = function (e, t) {if (3 !== e.getDegree()) return s.DebugUtils.warn("SplineCurveHelper.extremalParams called with non-degree 3 curve"), [];var r,i,a = e.getBezierSegments(),c = [];for (r = 0; r < a.length; ++r) {var u = a[r].getControlPoints(),h = a[r].getWeights(),d = a[r].getKnotVector(),g = l.extremalParamsXYPlanarBezierCurve(u, h, t),p = [];for (i = 0; i < g.length; i++) {p.push(d[0] * (1 - g[i]) + d[d.length - 1] * g[i]);}c.push(p);}var f = [];for (r = 0; r < a.length; ++r) {if (f = f.concat(c[r]), r < a.length - 1 || e.isPeriodicUnlimited()) {var v = a[r],_ = a[(r + 1) % a.length],y = c[r],m = c[(r + 1) % a.length],E = v.getRangeUnlimited()[1],x = _.getRangeUnlimited()[0],R = 0 === y.length || E - y[y.length - 1] > o.PARAMETER_SPACE_TOLERANCE,A = 0 === m.length || m[0] - x > o.PARAMETER_SPACE_TOLERANCE;if (R && A) {var P = v.evaluateDt(E)[t],V = _.evaluateDt(x)[t];(Math.abs(P) < n.FLOAT64_TOLERANCE || Math.abs(V) < n.FLOAT64_TOLERANCE || Math.sign(P) !== Math.sign(V)) && f.push(E);}}}return f;}, l.extremalParamsXYPlanarBezierCurve = function (e, t, r, n, o) {var i = v(t);if (!i) return g(e, r);for (var s, a, c = n || 16, u = o || 1e-12, l = [], h = void 0, d = 0; d < 8; d++) {if (a = _(e, t, d / 7, r, i), void 0 !== h && Math.sign(a[1]) !== h) {var p = (d - 1 + Math.abs(s) / (Math.abs(a[1]) + Math.abs(s))) / 7;l.push(p);}h = Math.sign(a[1]), s = a[1];}0 === l.length && (l[0] = 0 + u, l[1] = 1 - u), l.length > 2 && console.error("More than two roots in the second derivative of a cubic polynomial. This should not happen.");var f,y,m,E = [],x = [];for (d = 0; d < l.length; d++) {var R = 0;do {++R, m = 0 !== (a = _(e, t, l[d], r, i))[2] ? l[d] - a[1] / a[2] : l[d], f = Math.abs(a[1]), y = Math.abs(l[d] - m), l[d] = m;} while ((f > u || y > 1e-6) && R < c);E[d] = f, x[d] = a[2];}for (d = 0; d < l.length; d++) {if (l[d] < 0 || l[d] > 1 || E[d] > u) l.splice(d, 1), d--;else if (Math.abs(x[d]) < 1e-6) {var A = (_(e, t, l[d] + 5e-7, r, i)[2] - _(e, t, l[d] - 5e-7, r, i)[2]) / 1e-6;Math.abs(A) > 1e-6 && (l.splice(d, 1), d--);}}if (2 === l.length) {if (Math.abs(l[0] - l[1]) < 1e-6) {var P = E[0] / (E[0] + E[1]);return [l[0] * (1 - P) + l[1] * P];}return l;}return l;}, l.evaluateNURBSCurvePointWithFactors = function (e, t, r, n, o, i) {var s,u,l,h = (0, a.findKnotSpan)(o, t),d = (0, c.evaluateBasisFunctions)(h, o, e, t),g = new Float64Array(3),p = 0,f = 3 * (h - e);for (i.rangeMin = h - e, i.rangeMax = h, u = 0; u <= e; ++u) {for (s = n[h - e + u] * d[u], i.factors[u] = s, l = 0; l < 3; ++l) {g[l] += r[f + l] * s;}p += s, f += 3;}for (u = 0; u < 3; ++u) {g[u] /= p;}for (u = 0; u <= e; ++u) {i.factors[u] /= p;}return g;};var E = function E(e, t, r, o, i, s, a, u, h, d, g, p, v) {var _ = .5 * (r + i),y = (0, c.evaluateBCurvePoint)(_, e, t, a, h ? u : void 0);if (p > v) g.push({ offset: _, point: y });else {var m = f(y, o, s, !1),x = n.Vector3.squaredDistance(s, o),R = n.Vector3.squaredDistance(m, y);l.validControlPolygon(a) && R < d * x ? g.push({ offset: _, point: y }) : (E(e, t, r, o, _, y, a, u, h, d, g, p + 1, v), E(e, t, _, y, i, s, a, u, h, d, g, p + 1, v));}};l.renderNURBSCurve = function (e, t, r, i, s, a, u, l) {var h = a || o.DEFAULT_CURVE_RESOLUTION,d = u || [t[0], t[t.length - 1]];l = void 0 === l || l;var g,p = v(i);if (s) {var f,_,y = [];f = (0, c.evaluateBCurvePoint)(d[0], e, t, r, p ? i : void 0), _ = (0, c.evaluateBCurvePoint)(d[1], e, t, r, p ? i : void 0), y.push({ offset: d[0], point: f }), E(e, t, d[0], f, d[1], _, r, i, p, o.SPLINE_DISTANCE_TOLERANCE, y, 0, 4), y.push({ offset: d[1], point: _ }), g = new Array(4 * y.length);for (var m = l ? 0 : 1, x = l ? 0 : 1; x < y.length; x++) {g[m] = y[x].point[0], g[m + 1] = y[x].point[1], g[m + 2] = y[x].point[2], g[m + 3] = y[x].offset, m += 4;}} else {for (var R = 0, A = 3; A < r.length; A += 3) {R += n.Vector3.distance([r[A - 3], r[A - 2], r[A - 1]], [r[A], r[A + 1], r[A + 2]]);}for (h = 10 * Math.round(R), l ? (A = 0, g = new Float32Array(3 * h)) : (A = 1, g = new Float32Array(3 * (h - 1))); A < h; ++A) {var P,V = d[0] + (d[1] - d[0]) * A / (h - 1);P = (0, c.evaluateBCurvePoint)(V, e, t, r, p ? i : void 0);for (var T = 3 * A, C = 0; C < 3; ++C) {g[T + C] = P[C];}}}return g;}, l.evaluateCurve = function (e, t, r, n, i, s) {if (i) {var a = (0, c.evaluateBCurvePoint)(t[0], e, t, r, n),u = (0, c.evaluateBCurvePoint)(t[t.length - 1], e, t, r, n),l = [];l.push({ offset: t[0], point: a }), E(e, t, t[0], a, t[t.length - 1], u, r, n, !0, o.SPLINE_DISTANCE_TOLERANCE, l, 0, 3), l.push({ offset: t[t.length - 1], point: u });for (var h = [], d = [], g = 0; g < l.length; ++g) {h.push(l[g].offset), d.push(l[g].point[0], l[g].point[1], l[g].point[2]);}} else {var p = s || .01,f = t[0],v = 0;h = [], d = [];do {var _ = (0, c.evaluateBCurvePoint)(f, e, t, r, n);for (h[v] = f, g = 0; g < 3; ++g) {d[3 * v + g] = _[g];}++v, f += p;} while (f <= t[t.length - 1]);}return { offset: h, points: d };};var x = function x(e, t, r) {var n = new Float64Array(2);n[0] = r[0] - t[0], n[1] = r[1] - t[1];var o = n[0] * n[0] + n[1] * n[1];if (0 === o) return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[0] * n[0] + n[1] * n[1];var i = (e[0] - t[0]) * n[0] + (e[1] - t[1]) * n[1];return i < 0 ? (n[0] = e[0] - t[0], n[1] = e[1] - t[1]) : i > o ? (n[0] = e[0] - r[0], n[1] = e[1] - r[1]) : (i /= o, n[0] = t[0] + i * n[0] - e[0], n[1] = t[1] + i * n[1] - e[1]), n[0] * n[0] + n[1] * n[1];},R = function R(e, t) {var r,n = !1,o = t.length;r = 0;for (var i = o - 3; r < o; r += 3) {t[r + 1] > e[1] != t[i + 1] > e[1] && e[0] < (t[i] - t[r]) * (e[1] - t[r + 1]) / (t[i + 1] - t[r + 1]) + t[r] && (n = !n), i = r;}return n;},A = function A(e, t) {for (var r, n = new Float64Array(2), o = Number.NEGATIVE_INFINITY, i = 0; i < t.length; i += 3) {n[0] = t[i] - e[0], n[1] = t[i + 1] - e[1], (r = n[0] * n[0] + n[1] * n[1]) > o && (o = r);}return o;},P = function P(e, t, r) {for (var n, o = t.length, i = new Float64Array(2), s = new Float64Array(2), a = Number.POSITIVE_INFINITY, c = 0; c < o - 3; c += 3) {i[0] = t[c], i[1] = t[c + 1], s[0] = t[c + 3], s[1] = t[c + 4], (n = x(e, i, s)) < a && (a = n);}return void 0 !== r && r && (i[0] = t[o - 3], i[1] = t[o - 2], s[0] = t[0], s[1] = t[1], (n = x(e, i, s)) < a && (a = n)), a;};l.closestSegmentsXYPlanar = function (e, t, r, n) {for (var o = Number.POSITIVE_INFINITY, i = [], s = 0; s < t.length; ++s) {var a,c = t[s],u = c.getRangeUnlimited();if (n) {a = !1;for (var l = 0; l < n.length; ++l) {if (u[1] >= n[l][0] && u[0] <= n[l][1]) {a = !0;break;}}} else a = !0;if (a) {var h,d,g = r ? r[s] : 0,p = c.getControlPoints();R(e, p) ? h = 0 : (h = P(e, p, !0), h = Math.max(0, h - g)), h <= o && (d = A(e, p) + g, i.push({ index: s, minDistSqr: h, maxDistSqr: d }), d < o && (o = d));}}var f = [];for (s = 0; s < i.length; ++s) {i[s].minDistSqr <= o && f.push(i[s]);}return f.sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), f;}, l.findKnotMultiplicity = function (e, t) {for (var r = 0, n = 0; n < t.length; ++n) {if (t[n] > e + 1e-8) return r;Math.abs(t[n] - e) < 1e-8 && r++;}return r;}, l.unclampCurve = function (e, t, r, n) {var o,i,s,a,c,u = r.length / 4 - 1,l = n || 1;for (o = 0; o < e - 1; ++o) {for (t[e - o - 1] = t[e - o] - (t[u - o + 1] - t[u - o]) * l, s = e - 1, i = o; i >= 0; --i) {for (a = (t[e] - t[s]) / (t[e + i + 1] - t[s]), c = 0; c < 4; ++c) {r[4 * i + c] = (r[4 * i + c] - a * r[4 * (i + 1) + c]) / (1 - a);}s -= 1;}}for (t[0] = t[1] - (t[u - e + 2] - t[u - e + 1]) * l, o = 0; o < e - 1; ++o) {for (t[u + o + 2] = t[u + o + 1] + (t[e + o + 1] - t[e + o]) * l, i = o; i >= 0; --i) {for (a = (t[u + 1] - t[u - i]) / (t[u - i + o + 2] - t[u - i]), c = 0; c < 4; ++c) {r[4 * (u - i) + c] = (r[4 * (u - i) + c] - (1 - a) * r[4 * (u - i - 1) + c]) / a;}}}t[u + e + 1] = t[u + e] + (t[2 * e] - t[2 * e - 1]) * l;}, l.extractCurveSegment = function (e, t, r, n, o) {var i = this.insertKnot(e, n, o, t, e);i = this.insertKnot(e, i.U, i.Pw, r, e);var s,c = (0, a.findKnotSpan)(t, i.U);for (n.length = i.U.length - (c - e), n[0] = t, s = 1; s < n.length; ++s) {n[s] = i.U[s + c - e];}var u = n.length - e - 1,l = 4 * (i.Pw.length / 4 - u);for (o.length = i.Pw.length - l, s = 0; s < o.length; ++s) {o[s] = i.Pw[s + l];}c = (0, a.findKnotSpan)(r, n), n.length = c + 1, n.push(r), o.length = 4 * (n.length - e - 1);};var V = function V(e, t, r, n) {for (var o = 0, i = 0; i < 4; ++i) {o += (e[t + i] - r[n + i]) * (e[t + i] - r[n + i]);}return Math.sqrt(o);};l.removeKnot = function (e, t, r, n, i) {if (t <= n[0] || t >= n[n.length - 1]) return 0;var s,c,u,l,h,d = [],g = e + 1,p = (0, a.findKnotSpanAndMultiplicity)(t, n);if (p.multiplicity < 1) return 0;for (var f, v, _, y, m = (2 * p.span - p.multiplicity - e) / 2, E = o.KERNEL_TOLERANCE, x = p.span - p.multiplicity, R = p.span - e, A = !1, P = [0, 0, 0, 0], T = 0; T < r; ++T) {for (f = R - 1, h = 0; h < 4; ++h) {d[0 + h] = i[4 * f + h], d[4 * (x + 1 - f) + h] = i[4 * (x + 1) + h];}for (s = R, c = x, u = 1, l = x - f, A = !1; c - s > T;) {for (v = (t - n[s]) / (n[s + g + T] - n[s]), _ = (t - n[c - T]) / (n[c + g] - n[c - T]), h = 0; h < 4; ++h) {d[4 * u + h] = (i[4 * s + h] - (1 - v) * d[4 * (u - 1) + h]) / v, d[4 * l + h] = (i[4 * c + h] - _ * d[4 * (l + 1) + h]) / (1 - _);}++s, ++u, --c, --l;}if (c - s < T) V(d, 4 * (u - 1), d, 4 * (l + 1)) <= E && (A = !0);else {for (v = (t - n[s]) / (n[s + g + T] - n[s]), h = 0; h < 4; ++h) {P[h] = v * d[4 * (u + T + 1) + h] + (1 - v) * d[4 * (u - 1) + h];}V(i, 4 * s, P, 0) <= E && (A = !0);}if (!A) break;for (s = R, c = x; c - s > T;) {for (h = 0; h < 4; ++h) {i[4 * s + h] = d[4 * (s - f) + h], i[4 * c + h] = d[4 * (c - f) + h];}++s, --c;}--R, ++x;}if (0 === T) return 0;for (y = p.span + 1; y < n.length; ++y) {n[y - T] = n[y];}for (n.length = n.length - T, s = c = m, y = 1; y < T; ++y) {y % 2 == 1 ? s += 1 : c -= 1;}for (y = s + 1; y < i.length / 4; ++y) {for (h = 0; h < 4; ++h) {i[4 * c + h] = i[4 * y + h];}c += 1;}return i.length = i.length - 4 * T, T;}, l.joinCurves = function (e, t, r, n, o) {var i,s = t[t.length - 1];for (t.length = t.length - 1, i = e + 1; i < n.length; ++i) {t.push(n[i]);}for (i = 4; i < o.length; ++i) {r.push(o[i]);}var a = this.removeKnot(e, s, e - 1, t, r);a !== e - 1 && console.warn("Failed knot removal, only removed seam knot " + a + " times.");}, l.clampCurve = function (e, t, r) {var n = t[e],o = t[t.length - e - 1];this.extractCurveSegment(e, n, o, t, r);}, l.makePeriodic = function (e, t, r) {var n,o,i = function (e, t, r) {var n,o,i,s = 0;for (n = 1; n < r.length / 4; ++n) {for (i = 0, o = 0; o < 3; ++o) {i += (r[4 * n + o] - r[4 * (n - 1) + o]) * (r[4 * n + o] - r[4 * (n - 1) + o]);}s += Math.sqrt(i);}for (i = 0, o = 0; o < 3; ++o) {i += (r[o] - r[r.length - 4 + o]) * (r[o] - r[r.length - 4 + o]);}var a = Math.sqrt(i),c = (t[t.length - 1] - t[0]) / s,u = r.length / 4 - 1,l = t.slice();for (n = 0; n < e - 1; ++n) {l[e - n - 1] = l[e - n] - (l[u - n + 1] - l[u - n]), l[u + n + 2] = l[u + n + 1] + (l[e + n + 1] - l[e + n]);}var h = l[1] - (l[u - e + 2] - l[u - e + 1]),d = l[u + e] + (l[2 * e] - l[2 * e - 1]);return c / ((t[0] - h + d - t[t.length - 1]) / a);}(e, t, r);this.unclampCurve(e, t, r, i);var s = t.length;for (n = e - 1; n >= 0; --n) {t[s - n] = t[s - n - 1] + (t[e - (n - 1)] - t[e - n]);}var a = r.length / 4;for (r.length = 4 * a + 4 * e, t.length = s + e, n = 0; n < e; ++n) {for (o = 0; o < 4; ++o) {r[4 * (a + n) + o] = r[4 * n + o];}t[s + n] = t[s + n - 1] + (t[e + n + 1] - t[e + n]);}this.clampCurve(e, t, r);}, t.SplineCurveHelper = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.evaluateBCurveDerivs = t.evaluateBCurvePoint = t.evaluateBasisDerivatives = t.evaluateBasisFunctions = void 0;var n = r(1),o = r(3),i = r(17),s = function () {var e = null,t = null;return function (r, n, o, i) {(null === e || e.length < o + 1) && (e = new Float64Array(o + 1), t = new Float64Array(o + 1));var s = new Float64Array(o + 1);s[0] = 1;for (var a = 1; a <= o; ++a) {e[a] = n - i[r + 1 - a], t[a] = i[r + a] - n;for (var c = 0, u = 0; u < a; ++u) {var l = s[u] / (t[u + 1] + e[a - u]);s[u] = c + t[u + 1] * l, c = e[a - u] * l;}s[a] = c;}return s;};}(),a = function () {var e = null,t = null,r = null,n = null;return function (o, i, s, a, c, u) {var l, h, d;if (null === t || t.length < s + 1) {for (e = [new Float64Array(s + 1), new Float64Array(s + 1)], t = new Array(s + 1), l = 0; l < s + 1; ++l) {t[l] = new Float64Array(s + 1);}r = new Float64Array(s + 1), n = new Float64Array(s + 1);}if (!u) for (u = new Array(a + 1), l = 0; l <= a; ++l) {u[l] = new Float64Array(s + 1);}for (t[0][0] = 1, l = 1; l <= s; ++l) {r[l] = i - c[o + 1 - l], n[l] = c[o + l] - i;var g = 0;for (d = 0; d < l; ++d) {t[l][d] = n[d + 1] + r[l - d];var p = t[d][l - 1] / t[l][d];t[d][l] = g + n[d + 1] * p, g = r[l - d] * p;}t[l][l] = g;}for (l = 0; l <= s; ++l) {u[0][l] = t[l][s];}for (d = 0; d <= s; ++d) {var f = 0,v = 1;for (e[0][0] = 1, h = 1; h <= a; ++h) {var _,y = 0,m = d - h,E = s - h;for (d >= h && (e[v][0] = e[f][0] / t[E + 1][m], y = e[v][0] * t[m][E]), _ = d - 1 <= E ? h - 1 : s - d, l = m >= -1 ? 1 : -m; l <= _; ++l) {e[v][l] = (e[f][l] - e[f][l - 1]) / t[E + 1][m + l], y += e[v][l] * t[m + l][E];}d <= E && (e[v][h] = -e[f][h - 1] / t[E + 1][d], y += e[v][h] * t[d][E]), u[h][d] = y, l = f, f = v, v = l;}}for (d = s, h = 1; h <= a; ++h) {for (l = 0; l <= s; ++l) {u[h][l] *= d;}d *= s - h;}return u;};}(),c = function () {var e = null,t = null;return function (r, s, c, u, l, h) {var d, g, p;if (null === e || e.length < c + 1) {for (e = new Array(c + 1), d = 0; d <= c; ++d) {e[d] = new Float64Array(c + 1);}t = new Float64Array(c + 1);}var f = Math.min(s, c),v = h && h.length > 0,_ = (0, i.findKnotSpan)(r, u);a(_, r, c, f, u, e);var y = new Array(s + 1);for (d = 0; d <= s; ++d) {y[d] = n.Vector3.createFloat64();}for (g = 0; g <= f; ++g) {var m = 3 * (_ - c);if (v) for (t[g] = 0, d = 0; d <= c; ++d) {p = h[_ - c + d] * e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, t[g] += p, m += 3;} else for (d = 0; d <= c; ++d) {p = e[g][d], y[g][0] += l[m] * p, y[g][1] += l[m + 1] * p, y[g][2] += l[m + 2] * p, m += 3;}}if (v) for (g = 0; g <= f; ++g) {var E = y[g];for (d = 1; d <= g; ++d) {p = -o.binomialCoefficients[g][d] * t[d], n.Vector3.scaleAndAdd(E, E, y[g - d], p);}n.Vector3.scale(E, E, 1 / t[0]);}return y;};}();t.evaluateBasisFunctions = s, t.evaluateBasisDerivatives = a, t.evaluateBCurvePoint = function (e, t, r, o, a) {var c,u,l = (0, i.findKnotSpan)(e, r),h = s(l, e, t, r),d = a && a.length > 0,g = n.Vector3.createFloat64(),p = 0,f = 3 * (l - t);if (d) {for (c = 0; c <= t; ++c) {u = a[l - t + c] * h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, p += u, f += 3;}n.Vector3.scale(g, g, 1 / p);} else for (c = 0; c <= t; ++c) {u = h[c], g[0] += o[f] * u, g[1] += o[f + 1] * u, g[2] += o[f + 2] * u, f += 3;}return g;}, t.evaluateBCurveDerivs = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Cylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, u.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), void 0 !== o && n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._radius * Math.cos(t),o = this._radius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.cos(t),o = Math.sin(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._radius * Math.sin(t),o = this._radius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis) / this._uScale,a = 0;return r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE && (a = Math.atan2(o, r)), { u: s, v: a };}, l.prototype.vParamLine = function (e) {var t = new c.Circle(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._radius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cylinder = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.EllipticalCylinder = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(7),c = r(23),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), u.ConsoleUtils.assert(this._majorRadius > i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), u.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, u.ConsoleUtils.assert(this._minorRadius > i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), this._uScale = s || 1, u.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getMajorAxis = function () {return this._xAxis;}, l.prototype.setMajorAxis = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, l.prototype.getUScale = function () {return this._uScale;}, l.prototype.setUScale = function (e) {u.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, l.prototype.evaluatePosition = function (e, t) {var r = this._majorRadius * Math.cos(t),o = this._minorRadius * Math.sin(t),i = this._uScale * e,s = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(s, s, this._xAxis, r), n.Vector3.scaleAndAdd(s, s, this._yAxis, o), n.Vector3.scaleAndAdd(s, s, this._zAxis, i), s;}, l.prototype.evaluateNormal = function (e, t) {var r = this._minorRadius * Math.cos(t),o = this._majorRadius * Math.sin(t),i = Math.sqrt(r * r + o * o),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, r / i), n.Vector3.scaleAndAdd(s, s, this._yAxis, o / i), s;}, l.prototype.evaluateDu = function (e, t) {var r = n.Vector3.createFloat64();return n.Vector3.scale(r, this._zAxis, this._uScale), r;}, l.prototype.evaluateDv = function (e, t) {var r = -this._majorRadius * Math.sin(t),o = this._minorRadius * Math.cos(t),i = n.Vector3.createFloat64();return n.Vector3.scale(i, this._xAxis, r), n.Vector3.scaleAndAdd(i, i, this._yAxis, o), i;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._zAxis) / this._uScale;return { u: r, v: this.vParamLine(r).closestToPointParam(e) };}, l.prototype.vParamLine = function (e) {var t = new c.Ellipse(),r = n.Vector3.clone(this._center),o = e * this._uScale;n.Vector3.scaleAndAdd(r, r, this._zAxis, o);var i = n.Vector3.clone(this._xAxis);n.Vector3.scale(i, i, this._majorRadius);var s = n.Vector3.clone(this._zAxis);return n.Vector3.negate(s, s), t.set(r, s, i, this._minorRadius / this._majorRadius), t;}, l.prototype.uParamLine = function (e) {var t = new a.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, l.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCylinder = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Wire = void 0;var n = r(9),o = r(4),i = r(0),s = function s() {n.BaseTopology.call(this), this._wireBody = void 0, this._edges = [];};(s.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return i.TOPOLOGY_TYPES.WIRE;}, s.prototype.getWireBody = function () {return this._wireBody;}, s.prototype.setWireBody = function (e) {this._wireBody = e;}, s.prototype.getEdges = function () {return this._edges;}, s.prototype.setEdges = function (e) {this._edges = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._edges[t] = e[t];}}, s.prototype.addEdge = function (e) {this._edges ? this._edges.push(e) : this._edges = [e], e.setWire(this), e.setCoedge(void 0);}, s.prototype.addEdges = function (e) {this._edges || (this._edges = []);for (var t = 0; t < e.length; ++t) {e[t].setWire(this), e[t].setCoedge(void 0);}this._edges = this._edges.concat(e);}, s.prototype.removeEdge = function (e) {var t = this._edges.indexOf(e);return t > -1 && (this._edges.splice(t, 1), e.getWire() === this && e.setWire(void 0), !0);}, s.prototype.getBody = function () {return this._wireBody;}, s.prototype.collectFaces = function (e) {return e || new Set();}, s.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {e.add(this._edges[t]);}return e;}, s.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._edges.length; ++t) {this._edges[t].collectVertices(e);}return e;}, s.prototype.isBranched = function () {for (var e = 0; e < this._edges.length; ++e) {var t = this._edges[e],r = t.getStartVertex(),n = t.getEndVertex();if (r === n && r.getOtherEdge(t)) return !0;if (r.getEdges().length > 2 || n.getEdges().length > 2) return !0;}return !1;}, s.prototype.getOrderedEdges = function () {if (0 === this._edges.length) return { edges: [], start: void 0, end: void 0 };var e = [];e.push(this._edges[0]);for (var t = new Set(this._edges.slice(1)), r = e[0].getStartVertex(), n = e[0].getEndVertex(); t.size > 0;) {var o = t.size;if (t.forEach(function (o) {o.getEndVertex() === r ? (e.unshift(o), r = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === r ? (e.unshift(o), r = o.getEndVertex(), t.delete(o)) : o.getEndVertex() === n ? (e.push(o), n = o.getStartVertex(), t.delete(o)) : o.getStartVertex() === n && (e.push(o), n = o.getEndVertex(), t.delete(o));}), o === t.size) {console.warn("Wire is disconnected or branching.");break;}}return { edges: e, start: r, end: n };}, s.prototype.isClosed = function () {if (1 === this._edges.length) return this._edges[0].getStartVertex() === this._edges[0].getEndVertex();for (var e = this._edges[0], t = void 0, r = 0; r < this._edges.length; ++r) {var n,o = e.getStartVertex(),i = e.getEndVertex();if (o === i || 2 !== o.getEdges().length || 2 !== i.getEdges().length) return !1;if (t && o.getOtherEdge(e) !== t) {if (i.getOtherEdge(e) !== t) return !1;n = o.getOtherEdge(e);} else n = i.getOtherEdge(e);t = e, e = n;}return e === this._edges[0];}, s.prototype.getBoundingBox = function () {for (var e = new o.BoundingBox(), t = 0; t < this._edges.length; ++t) {e.include(this._edges[t].getBoundingBox());}return e;}, s.prototype.toString = function () {return "Wire";}, s.prototype.toObject = function () {return { edges: this.refsToStrings(this._edges), attributes: this.refsToStrings(this._attributes) };}, s.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._edges, this._attributes]);}, t.Wire = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.ProgenitorMap = void 0;var n = r(0),o = r(2),i = function i() {this._newToOldMap = new Map(), this._oldToNewMap = new Map(), this._labelMap = new Map();};i.prototype.addEntry = function (e, t, r) {t = Array.from(new Set(t)), o.ConsoleUtils.assert(!this._newToOldMap.has(e)), this._newToOldMap.set(e, t), r && this._labelMap.set(e, r);for (var n = 0; n < t.length; n++) {var i = t[n],s = this._oldToNewMap.get(i);s ? s.indexOf(e) < 0 && s.push(e) : this._oldToNewMap.set(i, [e]);}}, i.prototype.hasEntry = function (e) {return this._newToOldMap.has(e);}, i.prototype.removeEntry = function (e) {var t = this._newToOldMap.get(e);if (t) {this._newToOldMap.delete(e), this._labelMap.delete(e);for (var r = 0; r < t.length; r++) {var n = this._oldToNewMap.get(t[r]),i = n.indexOf(e);o.ConsoleUtils.assert(i >= 0), n.splice(i, 1), 0 === n.length && this._oldToNewMap.delete(t[r]);}}}, i.prototype.size = function () {return this._newToOldMap.size;}, i.prototype.getProgenitors = function (e) {return this._newToOldMap.get(e);}, i.prototype.getDescendants = function (e) {return this._oldToNewMap.get(e) || [];}, i.prototype.getLabel = function (e) {return this._labelMap.get(e) || "";}, i.prototype.getAllNewTopology = function () {return Array.from(this._newToOldMap.keys());}, i.prototype.getAllOldTopology = function () {return Array.from(this._oldToNewMap.keys());}, i.prototype.clear = function () {this._newToOldMap.clear(), this._oldToNewMap.clear(), this._labelMap.clear();}, i.prototype.mergeMaps = function (e) {var t = new i(),r = new Set(this._newToOldMap.keys());return e._newToOldMap.keys().forEach(function (e) {r.add(e);}), r.forEach(function (r) {var n = this.getProgenitors(r) || [],o = e.getProgenitors(r) || [],i = this.getLabel(r) || e.getLabel(r);t.addEntry(r, n.concat(o), i);}), t;}, i.prototype.collapseMaps = function (e, t) {var r = !1,n = !1;t && (void 0 !== t.keepIntermediates && (r = t.keepIntermediates), void 0 !== t.keepAllDescendants && (n = t.keepAllDescendants));var o = new i(),s = void 0;return n && (s = new Set(e._newToOldMap.keys())), this._newToOldMap.forEach(function (t, i) {for (var a = new Set(), c = 0; c < t.length; c++) {var u = t[c],l = e.getProgenitors(u);l && l.length > 0 ? (l.forEach(function (e) {a.add(e);}), r && a.add(u)) : a.add(u), n && s.delete(u);}o.addEntry(i, Array.from(a));}), n && s.forEach(function (t) {var r = e.getProgenitors(t);o.hasEntry(t) && (r = r.concat(o.getProgenitors(t)), o.removeEntry(t)), o.addEntry(t, r);}), o;}, i.prototype.toString = function () {for (var e = "ProgenitorMap:\n", t = this.getAllNewTopology(), r = 0; r < t.length; r++) {var o = t[r];e += n.TOPOLOGY_TYPES.toString(o.getTopologyType()) + ":" + o.getGuid();var i = this.getLabel(o);i && (e += " '" + i + "'"), e += " -> [ ";for (var s = this.getProgenitors(o), a = 0; a < s.length; a++) {a > 0 && (e += ", "), e += n.TOPOLOGY_TYPES.toString(s[a].getTopologyType()) + ":" + s[a].getGuid();}e += " ]\n";}return e;}, t.ProgenitorMap = i;}, function (e, t, r) {"use strict";r.r(t), r.d(t, "default", function () {return i;}), r.d(t, "VERSION", function () {return n.VERSION;}), r.d(t, "iteratee", function () {return n.iteratee;}), r.d(t, "restArguments", function () {return n.restArguments;}), r.d(t, "each", function () {return n.each;}), r.d(t, "forEach", function () {return n.forEach;}), r.d(t, "map", function () {return n.map;}), r.d(t, "collect", function () {return n.collect;}), r.d(t, "reduce", function () {return n.reduce;}), r.d(t, "foldl", function () {return n.foldl;}), r.d(t, "inject", function () {return n.inject;}), r.d(t, "reduceRight", function () {return n.reduceRight;}), r.d(t, "foldr", function () {return n.foldr;}), r.d(t, "find", function () {return n.find;}), r.d(t, "detect", function () {return n.detect;}), r.d(t, "filter", function () {return n.filter;}), r.d(t, "select", function () {return n.select;}), r.d(t, "reject", function () {return n.reject;}), r.d(t, "every", function () {return n.every;}), r.d(t, "all", function () {return n.all;}), r.d(t, "some", function () {return n.some;}), r.d(t, "any", function () {return n.any;}), r.d(t, "contains", function () {return n.contains;}), r.d(t, "includes", function () {return n.includes;}), r.d(t, "include", function () {return n.include;}), r.d(t, "invoke", function () {return n.invoke;}), r.d(t, "pluck", function () {return n.pluck;}), r.d(t, "where", function () {return n.where;}), r.d(t, "findWhere", function () {return n.findWhere;}), r.d(t, "max", function () {return n.max;}), r.d(t, "min", function () {return n.min;}), r.d(t, "shuffle", function () {return n.shuffle;}), r.d(t, "sample", function () {return n.sample;}), r.d(t, "sortBy", function () {return n.sortBy;}), r.d(t, "groupBy", function () {return n.groupBy;}), r.d(t, "indexBy", function () {return n.indexBy;}), r.d(t, "countBy", function () {return n.countBy;}), r.d(t, "toArray", function () {return n.toArray;}), r.d(t, "size", function () {return n.size;}), r.d(t, "partition", function () {return n.partition;}), r.d(t, "first", function () {return n.first;}), r.d(t, "head", function () {return n.head;}), r.d(t, "take", function () {return n.take;}), r.d(t, "initial", function () {return n.initial;}), r.d(t, "last", function () {return n.last;}), r.d(t, "rest", function () {return n.rest;}), r.d(t, "tail", function () {return n.tail;}), r.d(t, "drop", function () {return n.drop;}), r.d(t, "compact", function () {return n.compact;}), r.d(t, "flatten", function () {return n.flatten;}), r.d(t, "without", function () {return n.without;}), r.d(t, "uniq", function () {return n.uniq;}), r.d(t, "unique", function () {return n.unique;}), r.d(t, "union", function () {return n.union;}), r.d(t, "intersection", function () {return n.intersection;}), r.d(t, "difference", function () {return n.difference;}), r.d(t, "unzip", function () {return n.unzip;}), r.d(t, "zip", function () {return n.zip;}), r.d(t, "object", function () {return n.object;}), r.d(t, "findIndex", function () {return n.findIndex;}), r.d(t, "findLastIndex", function () {return n.findLastIndex;}), r.d(t, "sortedIndex", function () {return n.sortedIndex;}), r.d(t, "indexOf", function () {return n.indexOf;}), r.d(t, "lastIndexOf", function () {return n.lastIndexOf;}), r.d(t, "range", function () {return n.range;}), r.d(t, "chunk", function () {return n.chunk;}), r.d(t, "bind", function () {return n.bind;}), r.d(t, "partial", function () {return n.partial;}), r.d(t, "bindAll", function () {return n.bindAll;}), r.d(t, "memoize", function () {return n.memoize;}), r.d(t, "delay", function () {return n.delay;}), r.d(t, "defer", function () {return n.defer;}), r.d(t, "throttle", function () {return n.throttle;}), r.d(t, "debounce", function () {return n.debounce;}), r.d(t, "wrap", function () {return n.wrap;}), r.d(t, "negate", function () {return n.negate;}), r.d(t, "compose", function () {return n.compose;}), r.d(t, "after", function () {return n.after;}), r.d(t, "before", function () {return n.before;}), r.d(t, "once", function () {return n.once;}), r.d(t, "keys", function () {return n.keys;}), r.d(t, "allKeys", function () {return n.allKeys;}), r.d(t, "values", function () {return n.values;}), r.d(t, "mapObject", function () {return n.mapObject;}), r.d(t, "pairs", function () {return n.pairs;}), r.d(t, "invert", function () {return n.invert;}), r.d(t, "functions", function () {return n.functions;}), r.d(t, "methods", function () {return n.methods;}), r.d(t, "extend", function () {return n.extend;}), r.d(t, "extendOwn", function () {return n.extendOwn;}), r.d(t, "assign", function () {return n.assign;}), r.d(t, "findKey", function () {return n.findKey;}), r.d(t, "pick", function () {return n.pick;}), r.d(t, "omit", function () {return n.omit;}), r.d(t, "defaults", function () {return n.defaults;}), r.d(t, "create", function () {return n.create;}), r.d(t, "clone", function () {return n.clone;}), r.d(t, "tap", function () {return n.tap;}), r.d(t, "isMatch", function () {return n.isMatch;}), r.d(t, "isEqual", function () {return n.isEqual;}), r.d(t, "isEmpty", function () {return n.isEmpty;}), r.d(t, "isElement", function () {return n.isElement;}), r.d(t, "isArray", function () {return n.isArray;}), r.d(t, "isObject", function () {return n.isObject;}), r.d(t, "isArguments", function () {return n.isArguments;}), r.d(t, "isFunction", function () {return n.isFunction;}), r.d(t, "isString", function () {return n.isString;}), r.d(t, "isNumber", function () {return n.isNumber;}), r.d(t, "isDate", function () {return n.isDate;}), r.d(t, "isRegExp", function () {return n.isRegExp;}), r.d(t, "isError", function () {return n.isError;}), r.d(t, "isSymbol", function () {return n.isSymbol;}), r.d(t, "isMap", function () {return n.isMap;}), r.d(t, "isWeakMap", function () {return n.isWeakMap;}), r.d(t, "isSet", function () {return n.isSet;}), r.d(t, "isWeakSet", function () {return n.isWeakSet;}), r.d(t, "isFinite", function () {return n.isFinite;}), r.d(t, "isNaN", function () {return n.isNaN;}), r.d(t, "isBoolean", function () {return n.isBoolean;}), r.d(t, "isNull", function () {return n.isNull;}), r.d(t, "isUndefined", function () {return n.isUndefined;}), r.d(t, "has", function () {return n.has;}), r.d(t, "identity", function () {return n.identity;}), r.d(t, "constant", function () {return n.constant;}), r.d(t, "noop", function () {return n.noop;}), r.d(t, "property", function () {return n.property;}), r.d(t, "propertyOf", function () {return n.propertyOf;}), r.d(t, "matcher", function () {return n.matcher;}), r.d(t, "matches", function () {return n.matches;}), r.d(t, "times", function () {return n.times;}), r.d(t, "random", function () {return n.random;}), r.d(t, "now", function () {return n.now;}), r.d(t, "escape", function () {return n.escape;}), r.d(t, "unescape", function () {return n.unescape;}), r.d(t, "result", function () {return n.result;}), r.d(t, "uniqueId", function () {return n.uniqueId;}), r.d(t, "templateSettings", function () {return n.templateSettings;}), r.d(t, "template", function () {return n.template;}), r.d(t, "chain", function () {return n.chain;}), r.d(t, "mixin", function () {return n.mixin;});var n = r(29),o = Object(n.mixin)(n);o._ = o;var i = o;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseGeometry = void 0;var n = r(44),o = r(0),i = function i() {n.Base.call(this);};(i.prototype = Object.create(n.Base.prototype)).getGeometryType = function () {console.warn("BaseGeometry.getGeometryType : abstract method invoked!");}, i.prototype.clone = function () {console.warn("BaseGeometry.clone : abstract method invoked");}, i.prototype.copy = function (e) {this._guid = "";}, i.prototype.addToModelObject = function (e) {if (!e.geometries[this.getGuid()]) {var _t4 = {};_t4[o.GEOMETRY_TYPES.toString(this.getGeometryType()).toLowerCase()] = this.toObject(), e.geometries[this.getGuid()] = _t4;}}, t.BaseGeometry = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Base = void 0;var n = r(56);var o = r(45).Autodesk.lookup("SolidDef.paramrange_1_0_0.typeEnum");var i = function i() {this._guid = "";};i.prototype.setGuid = function (e) {this._guid = e;}, i.prototype.getGuid = function () {return this._guid || (this._guid = (0, n.generateGUID)()), this._guid;}, i.prototype.refsToStrings = function (e) {if (e) {var _t5 = new Array(e.length);for (var _r3 = 0; _r3 < e.length; ++_r3) {_t5[_r3] = e[_r3].getGuid();}return _t5;}return [];}, i.prototype.refToString = function (e) {return e ? e.getGuid() : "";}, i.prototype.toObject = function () {return console.warn("Base.toObject : abstract method invoked!"), {};}, i.prototype.vectorToObject = function (e) {return { x: e[0], y: e[1], z: e[2] };}, i.prototype.rangeToObject = function (e, t) {var r = 1,n = 0;t && void 0 !== e && 2 === e.length && isFinite(e[0]) && isFinite(e[1]) && (r = e[0], n = e[1]);var i = r <= n ? "finite" : "infinite";return { low: r, high: n, type: o.values[i] };}, i.prototype.addToModelObject = function (e) {console.warn("Base.addToModelObject : abstract method invoked!");}, t.Base = i;}, function (e, t, r) {"use strict";var n = r(87),o = (n.roots.default || (n.roots.default = new n.Root())).addJSON({ Autodesk: { nested: { SolidDef: { nested: { SolidDef_grpc: { methods: {} }, point3d_1_0_0: { fields: { x: { type: "double", id: 1 }, y: { type: "double", id: 2 }, z: { type: "double", id: 3 } } }, vector3d_1_0_0: { fields: { x: { type: "double", id: 1 }, y: { type: "double", id: 2 }, z: { type: "double", id: 3 } } }, geometry_1_0_0: { fields: {} }, geometry_1_0_0_Type: { oneofs: { geometry: { oneof: ["point", "bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "surface", "torus", "bcurve", "circle", "curve", "ellipse", "line"] } }, fields: { point: { type: "point_1_0_0", id: 1 }, bsurface: { type: "bsurface_1_0_0", id: 2 }, cone: { type: "cone_1_0_0", id: 3 }, cylinder: { type: "cylinder_1_0_0", id: 4 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 5 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 6 }, plane: { type: "plane_1_0_0", id: 7 }, sphere: { type: "sphere_1_0_0", id: 8 }, surface: { type: "surface_1_0_0", id: 9 }, torus: { type: "torus_1_0_0", id: 10 }, bcurve: { type: "bcurve_1_0_0", id: 11 }, circle: { type: "circle_1_0_0", id: 12 }, curve: { type: "curve_1_0_0", id: 13 }, ellipse: { type: "ellipse_1_0_0", id: 14 }, line: { type: "line_1_0_0", id: 15 } } }, paramrange_1_0_0: { fields: { low: { type: "double", id: 1 }, high: { type: "double", id: 2 }, type: { type: "typeEnum", id: 3 } }, nested: { typeEnum: { values: { infinite: 0, finite: 1, boundBelow: 2, boundAbove: 3 } } } }, point_1_0_0: { fields: { position: { type: "point3d_1_0_0", id: 1 } } }, bsurface_1_0_0: { fields: { uDegree: { type: "uint32", id: 1 }, vDegree: { type: "uint32", id: 2 }, uKnots: { rule: "repeated", type: "double", id: 3 }, vKnots: { rule: "repeated", type: "double", id: 4 }, controlPoints: { rule: "repeated", type: "double", id: 5 }, weights: { rule: "repeated", type: "double", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, cone_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, angle: { type: "double", id: 4 }, uCoordScale: { type: "double", id: 5 }, uRange: { type: "paramrange_1_0_0", id: 6 }, vRange: { type: "paramrange_1_0_0", id: 7 } } }, cylinder_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, uCoordScale: { type: "double", id: 4 }, uRange: { type: "paramrange_1_0_0", id: 5 }, vRange: { type: "paramrange_1_0_0", id: 6 } } }, ellipticalcone_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, angle: { type: "double", id: 5 }, uCoordScale: { type: "double", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, ellipticalcylinder_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, uCoordScale: { type: "double", id: 5 }, uRange: { type: "paramrange_1_0_0", id: 6 }, vRange: { type: "paramrange_1_0_0", id: 7 } } }, plane_1_0_0: { fields: { origin: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, uAxis: { type: "vector3d_1_0_0", id: 3 }, uRange: { type: "paramrange_1_0_0", id: 4 }, vRange: { type: "paramrange_1_0_0", id: 5 } } }, sphere_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, radius: { type: "vector3d_1_0_0", id: 2 }, axis: { type: "vector3d_1_0_0", id: 3 }, uRange: { type: "paramrange_1_0_0", id: 4 }, vRange: { type: "paramrange_1_0_0", id: 5 } } }, surface_1_0_0: { fields: { uRange: { type: "paramrange_1_0_0", id: 1 }, vRange: { type: "paramrange_1_0_0", id: 2 } } }, surface_1_0_0_Type: { oneofs: { surface: { oneof: ["bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "torus"] } }, fields: { bsurface: { type: "bsurface_1_0_0", id: 1 }, cone: { type: "cone_1_0_0", id: 2 }, cylinder: { type: "cylinder_1_0_0", id: 3 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 4 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 5 }, plane: { type: "plane_1_0_0", id: 6 }, sphere: { type: "sphere_1_0_0", id: 7 }, torus: { type: "torus_1_0_0", id: 8 } } }, torus_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, axis: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "double", id: 3 }, minorRadius: { type: "double", id: 4 }, coordAxis: { type: "vector3d_1_0_0", id: 5 }, lemon: { type: "bool", id: 6 }, uRange: { type: "paramrange_1_0_0", id: 7 }, vRange: { type: "paramrange_1_0_0", id: 8 } } }, bcurve_1_0_0: { fields: { degree: { type: "uint32", id: 1 }, knots: { rule: "repeated", type: "double", id: 2 }, controlPoints: { rule: "repeated", type: "double", id: 3 }, weights: { rule: "repeated", type: "double", id: 4 }, range: { type: "paramrange_1_0_0", id: 5 } } }, circle_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, radius: { type: "vector3d_1_0_0", id: 3 }, range: { type: "paramrange_1_0_0", id: 4 } } }, curve_1_0_0: { fields: { range: { type: "paramrange_1_0_0", id: 1 } } }, curve_1_0_0_Type: { oneofs: { curve: { oneof: ["bcurve", "circle", "ellipse", "line"] } }, fields: { bcurve: { type: "bcurve_1_0_0", id: 1 }, circle: { type: "circle_1_0_0", id: 2 }, ellipse: { type: "ellipse_1_0_0", id: 3 }, line: { type: "line_1_0_0", id: 4 } } }, ellipse_1_0_0: { fields: { center: { type: "point3d_1_0_0", id: 1 }, normal: { type: "vector3d_1_0_0", id: 2 }, majorRadius: { type: "vector3d_1_0_0", id: 3 }, radiusRatio: { type: "double", id: 4 }, range: { type: "paramrange_1_0_0", id: 5 } } }, line_1_0_0: { fields: { position: { type: "point3d_1_0_0", id: 1 }, direction: { type: "vector3d_1_0_0", id: 2 }, range: { type: "paramrange_1_0_0", id: 3 } } }, attribute_1_0_0: { fields: {} }, attribute_1_0_0_Type: { oneofs: { attribute: { oneof: ["nmiattribute", "nmiattributearr", "nmiattributestr", "textattribute"] } }, fields: { nmiattribute: { type: "nmiattribute_1_0_0", id: 1 }, nmiattributearr: { type: "nmiattributearr_1_0_0", id: 4 }, nmiattributestr: { type: "nmiattributestr_1_0_0", id: 2 }, textattribute: { type: "textattribute_1_0_0", id: 3 } } }, body_1_0_0: { fields: { lumps: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, coedge_1_0_0: { fields: { edge: { type: "string", id: 1 }, partner: { type: "string", id: 2 }, reversed: { type: "bool", id: 3 }, attributes: { rule: "repeated", type: "string", id: 4 } } }, edge_1_0_0: { fields: { vertex0: { type: "string", id: 1 }, vertex1: { type: "string", id: 2 }, precision: { type: "double", id: 3 }, range: { type: "paramrange_1_0_0", id: 4 }, reversed: { type: "bool", id: 5 }, geometry: { type: "string", id: 6 }, attributes: { rule: "repeated", type: "string", id: 7 } } }, face_1_0_0: { fields: { loops: { rule: "repeated", type: "string", id: 1 }, reversed: { type: "bool", id: 2 }, geometry: { type: "string", id: 3 }, attributes: { rule: "repeated", type: "string", id: 4 } } }, loop_1_0_0: { fields: { coedges: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, lump_1_0_0: { fields: { shells: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, model_1_0_0: { fields: { geometries: { keyType: "string", type: "geometry_1_0_0_Type", id: 1 }, topologies: { keyType: "string", type: "topology_1_0_0_Type", id: 2 }, attributes: { keyType: "string", type: "attribute_1_0_0_Type", id: 3 } } }, shell_1_0_0: { fields: { faces: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, topology_1_0_0: { fields: { attributes: { rule: "repeated", type: "string", id: 1 } } }, topology_1_0_0_Type: { oneofs: { topology: { oneof: ["body", "coedge", "edge", "face", "loop", "lump", "shell", "vertex", "wire", "wirebody"] } }, fields: { body: { type: "body_1_0_0", id: 1 }, coedge: { type: "coedge_1_0_0", id: 2 }, edge: { type: "edge_1_0_0", id: 3 }, face: { type: "face_1_0_0", id: 4 }, loop: { type: "loop_1_0_0", id: 5 }, lump: { type: "lump_1_0_0", id: 6 }, shell: { type: "shell_1_0_0", id: 7 }, vertex: { type: "vertex_1_0_0", id: 8 }, wire: { type: "wire_1_0_0", id: 9 }, wirebody: { type: "wirebody_1_0_0", id: 10 } } }, vertex_1_0_0: { fields: { precision: { type: "double", id: 1 }, geometry: { type: "string", id: 2 }, attributes: { rule: "repeated", type: "string", id: 3 } } }, wire_1_0_0: { fields: { edges: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, wirebody_1_0_0: { fields: { wires: { rule: "repeated", type: "string", id: 1 }, attributes: { rule: "repeated", type: "string", id: 2 } } }, nmiattribute_1_0_0: { fields: { primaryId: { type: "uint64", id: 1 }, secondaryId: { type: "int64", id: 2 }, approachId: { type: "int64", id: 3 }, operationIds: { rule: "repeated", type: "int64", id: 4 } } }, nmiattributearr_1_0_0: { fields: { tagInfo: { rule: "repeated", type: "nmiattributestr_1_0_0", id: 1 } } }, nmiattributestr_1_0_0: { fields: { primaryId: { type: "string", id: 1 }, secondaryId: { type: "string", id: 2 }, approachId: { type: "string", id: 3 }, operationIds: { rule: "repeated", type: "string", id: 4 } } }, textattribute_1_0_0: { fields: { text: { type: "string", id: 1 } } }, entity: { oneofs: { entity: { oneof: ["point3d", "vector3d", "geometry", "paramrange", "point", "bsurface", "cone", "cylinder", "ellipticalcone", "ellipticalcylinder", "plane", "sphere", "surface", "torus", "bcurve", "circle", "curve", "ellipse", "line", "attribute", "body", "coedge", "edge", "face", "loop", "lump", "model", "shell", "topology", "vertex", "wire", "wirebody", "nmiattribute", "nmiattributearr", "nmiattributestr", "textattribute"] } }, fields: { id: { type: "string", id: 1 }, point3d: { type: "point3d_1_0_0", id: 2 }, vector3d: { type: "vector3d_1_0_0", id: 3 }, geometry: { type: "geometry_1_0_0", id: 4 }, paramrange: { type: "paramrange_1_0_0", id: 5 }, point: { type: "point_1_0_0", id: 6 }, bsurface: { type: "bsurface_1_0_0", id: 7 }, cone: { type: "cone_1_0_0", id: 8 }, cylinder: { type: "cylinder_1_0_0", id: 9 }, ellipticalcone: { type: "ellipticalcone_1_0_0", id: 10 }, ellipticalcylinder: { type: "ellipticalcylinder_1_0_0", id: 11 }, plane: { type: "plane_1_0_0", id: 12 }, sphere: { type: "sphere_1_0_0", id: 13 }, surface: { type: "surface_1_0_0", id: 14 }, torus: { type: "torus_1_0_0", id: 15 }, bcurve: { type: "bcurve_1_0_0", id: 16 }, circle: { type: "circle_1_0_0", id: 17 }, curve: { type: "curve_1_0_0", id: 18 }, ellipse: { type: "ellipse_1_0_0", id: 19 }, line: { type: "line_1_0_0", id: 20 }, attribute: { type: "attribute_1_0_0", id: 21 }, body: { type: "body_1_0_0", id: 22 }, coedge: { type: "coedge_1_0_0", id: 23 }, edge: { type: "edge_1_0_0", id: 24 }, face: { type: "face_1_0_0", id: 25 }, loop: { type: "loop_1_0_0", id: 26 }, lump: { type: "lump_1_0_0", id: 27 }, model: { type: "model_1_0_0", id: 28 }, shell: { type: "shell_1_0_0", id: 29 }, topology: { type: "topology_1_0_0", id: 30 }, vertex: { type: "vertex_1_0_0", id: 31 }, wire: { type: "wire_1_0_0", id: 32 }, wirebody: { type: "wirebody_1_0_0", id: 33 }, nmiattribute: { type: "nmiattribute_1_0_0", id: 34 }, nmiattributearr: { type: "nmiattributearr_1_0_0", id: 37 }, nmiattributestr: { type: "nmiattributestr_1_0_0", id: 35 }, textattribute: { type: "textattribute_1_0_0", id: 36 } } } } } } } });e.exports = o;}, function (e, t, r) {"use strict";e.exports = l;var n,o = r(10),i = o.LongBits,s = o.base64,a = o.utf8;function c(e, t, r) {this.fn = e, this.len = t, this.next = void 0, this.val = r;}function u() {}function l() {this.len = 0, this.head = new c(u, 0, 0), this.tail = this.head, this.states = null;}function h(e, t, r) {t[r] = 255 & e;}function d(e, t) {this.len = e, this.next = void 0, this.val = t;}function g(e, t, r) {for (; e.hi;) {t[r++] = 127 & e.lo | 128, e.lo = (e.lo >>> 7 | e.hi << 25) >>> 0, e.hi >>>= 7;}for (; e.lo > 127;) {t[r++] = 127 & e.lo | 128, e.lo = e.lo >>> 7;}t[r++] = e.lo;}function p(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}l.create = o.Buffer ? function () {return (l.create = function () {return new n();})();} : function () {return new l();}, l.alloc = function (e) {return new o.Array(e);}, o.Array !== Array && (l.alloc = o.pool(l.alloc, o.Array.prototype.subarray)), l.prototype._push = function (e, t, r) {return this.tail = this.tail.next = new c(e, t, r), this.len += t, this;}, d.prototype = Object.create(c.prototype), d.prototype.fn = function (e, t, r) {for (; e > 127;) {t[r++] = 127 & e | 128, e >>>= 7;}t[r] = e;}, l.prototype.uint32 = function (e) {return this.len += (this.tail = this.tail.next = new d((e >>>= 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;}, l.prototype.int32 = function (e) {return e < 0 ? this._push(g, 10, i.fromNumber(e)) : this.uint32(e);}, l.prototype.sint32 = function (e) {return this.uint32((e << 1 ^ e >> 31) >>> 0);}, l.prototype.uint64 = function (e) {var t = i.from(e);return this._push(g, t.length(), t);}, l.prototype.int64 = l.prototype.uint64, l.prototype.sint64 = function (e) {var t = i.from(e).zzEncode();return this._push(g, t.length(), t);}, l.prototype.bool = function (e) {return this._push(h, 1, e ? 1 : 0);}, l.prototype.fixed32 = function (e) {return this._push(p, 4, e >>> 0);}, l.prototype.sfixed32 = l.prototype.fixed32, l.prototype.fixed64 = function (e) {var t = i.from(e);return this._push(p, 4, t.lo)._push(p, 4, t.hi);}, l.prototype.sfixed64 = l.prototype.fixed64, l.prototype.float = function (e) {return this._push(o.float.writeFloatLE, 4, e);}, l.prototype.double = function (e) {return this._push(o.float.writeDoubleLE, 8, e);};var f = o.Array.prototype.set ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {for (var n = 0; n < e.length; ++n) {t[r + n] = e[n];}};l.prototype.bytes = function (e) {var t = e.length >>> 0;if (!t) return this._push(h, 1, 0);if (o.isString(e)) {var r = l.alloc(t = s.length(e));s.decode(e, r, 0), e = r;}return this.uint32(t)._push(f, t, e);}, l.prototype.string = function (e) {var t = a.length(e);return t ? this.uint32(t)._push(a.write, t, e) : this._push(h, 1, 0);}, l.prototype.fork = function () {return this.states = new function (e) {this.head = e.head, this.tail = e.tail, this.len = e.len, this.next = e.states;}(this), this.head = this.tail = new c(u, 0, 0), this.len = 0, this;}, l.prototype.reset = function () {return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new c(u, 0, 0), this.len = 0), this;}, l.prototype.ldelim = function () {var e = this.head,t = this.tail,r = this.len;return this.reset().uint32(r), r && (this.tail.next = e.next, this.tail = t, this.len += r), this;}, l.prototype.finish = function () {for (var e = this.head.next, t = this.constructor.alloc(this.len), r = 0; e;) {e.fn(e.val, t, r), r += e.len, e = e.next;}return t;}, l._configure = function (e) {n = e;};}, function (e, t, r) {"use strict";e.exports = c;var n,o = r(10),i = o.LongBits,s = o.utf8;function a(e, t) {return RangeError("index out of range: " + e.pos + " + " + (t || 1) + " > " + e.len);}function c(e) {this.buf = e, this.pos = 0, this.len = e.length;}var u = "undefined" != typeof Uint8Array ? function (e) {if (e instanceof Uint8Array || Array.isArray(e)) return new c(e);throw Error("illegal buffer");} : function (e) {if (Array.isArray(e)) return new c(e);throw Error("illegal buffer");};function l() {var e = new i(0, 0),t = 0;if (!(this.len - this.pos > 4)) {for (; t < 3; ++t) {if (this.pos >= this.len) throw a(this);if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}return e.lo = (e.lo | (127 & this.buf[this.pos++]) << 7 * t) >>> 0, e;}for (; t < 4; ++t) {if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 7 * t) >>> 0, this.buf[this.pos++] < 128) return e;}if (e.lo = (e.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e.hi = (e.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e;if (t = 0, this.len - this.pos > 4) {for (; t < 5; ++t) {if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}} else for (; t < 5; ++t) {if (this.pos >= this.len) throw a(this);if (e.hi = (e.hi | (127 & this.buf[this.pos]) << 7 * t + 3) >>> 0, this.buf[this.pos++] < 128) return e;}throw Error("invalid varint encoding");}function h(e, t) {return (e[t - 4] | e[t - 3] << 8 | e[t - 2] << 16 | e[t - 1] << 24) >>> 0;}function d() {if (this.pos + 8 > this.len) throw a(this, 8);return new i(h(this.buf, this.pos += 4), h(this.buf, this.pos += 4));}c.create = o.Buffer ? function (e) {return (c.create = function (e) {return o.Buffer.isBuffer(e) ? new n(e) : u(e);})(e);} : u, c.prototype._slice = o.Array.prototype.subarray || o.Array.prototype.slice, c.prototype.uint32 = function () {var e = 4294967295;return function () {if (e = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return e;if (e = (e | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return e;if ((this.pos += 5) > this.len) throw this.pos = this.len, a(this, 10);return e;};}(), c.prototype.int32 = function () {return 0 | this.uint32();}, c.prototype.sint32 = function () {var e = this.uint32();return e >>> 1 ^ -(1 & e) | 0;}, c.prototype.bool = function () {return 0 !== this.uint32();}, c.prototype.fixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return h(this.buf, this.pos += 4);}, c.prototype.sfixed32 = function () {if (this.pos + 4 > this.len) throw a(this, 4);return 0 | h(this.buf, this.pos += 4);}, c.prototype.float = function () {if (this.pos + 4 > this.len) throw a(this, 4);var e = o.float.readFloatLE(this.buf, this.pos);return this.pos += 4, e;}, c.prototype.double = function () {if (this.pos + 8 > this.len) throw a(this, 4);var e = o.float.readDoubleLE(this.buf, this.pos);return this.pos += 8, e;}, c.prototype.bytes = function () {var e = this.uint32(),t = this.pos,r = this.pos + e;if (r > this.len) throw a(this, e);return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(t, r) : t === r ? new this.buf.constructor(0) : this._slice.call(this.buf, t, r);}, c.prototype.string = function () {var e = this.bytes();return s.read(e, 0, e.length);}, c.prototype.skip = function (e) {if ("number" == typeof e) {if (this.pos + e > this.len) throw a(this, e);this.pos += e;} else do {if (this.pos >= this.len) throw a(this);} while (128 & this.buf[this.pos++]);return this;}, c.prototype.skipType = function (e) {switch (e) {case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for (; 4 != (e = 7 & this.uint32());) {this.skipType(e);}break;case 5:this.skip(4);break;default:throw Error("invalid wire type " + e + " at offset " + this.pos);}return this;}, c._configure = function (e) {n = e;var t = o.Long ? "toLong" : "toNumber";o.merge(c.prototype, { int64: function int64() {return l.call(this)[t](!1);}, uint64: function uint64() {return l.call(this)[t](!0);}, sint64: function sint64() {return l.call(this).zzDecode()[t](!1);}, fixed64: function fixed64() {return d.call(this)[t](!0);}, sfixed64: function sfixed64() {return d.call(this)[t](!1);} });};}, function (e, t, r) {"use strict";e.exports = s;var n = r(21);((s.prototype = Object.create(n.prototype)).constructor = s).className = "OneOf";var o = r(22),i = r(5);function s(e, t, r, o) {if (Array.isArray(t) || (r = t, t = void 0), n.call(this, e, r), void 0 !== t && !Array.isArray(t)) throw TypeError("fieldNames must be an Array");this.oneof = t || [], this.fieldsArray = [], this.comment = o;}function a(e) {if (e.parent) for (var t = 0; t < e.fieldsArray.length; ++t) {e.fieldsArray[t].parent || e.parent.add(e.fieldsArray[t]);}}s.fromJSON = function (e, t) {return new s(e, t.oneof, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["options", this.options, "oneof", this.oneof, "comment", t ? this.comment : void 0]);}, s.prototype.add = function (e) {if (!(e instanceof o)) throw TypeError("field must be a Field");return e.parent && e.parent !== this.parent && e.parent.remove(e), this.oneof.push(e.name), this.fieldsArray.push(e), e.partOf = this, a(this), this;}, s.prototype.remove = function (e) {if (!(e instanceof o)) throw TypeError("field must be a Field");var t = this.fieldsArray.indexOf(e);if (t < 0) throw Error(e + " is not a member of " + this);return this.fieldsArray.splice(t, 1), (t = this.oneof.indexOf(e.name)) > -1 && this.oneof.splice(t, 1), e.partOf = null, this;}, s.prototype.onAdd = function (e) {n.prototype.onAdd.call(this, e);for (var t = 0; t < this.oneof.length; ++t) {var r = e.get(this.oneof[t]);r && !r.partOf && (r.partOf = this, this.fieldsArray.push(r));}a(this);}, s.prototype.onRemove = function (e) {for (var t, r = 0; r < this.fieldsArray.length; ++r) {(t = this.fieldsArray[r]).parent && t.parent.remove(t);}n.prototype.onRemove.call(this, e);}, s.d = function () {for (var e = new Array(arguments.length), t = 0; t < arguments.length;) {e[t] = arguments[t++];}return function (t, r) {i.decorateType(t.constructor).add(new s(r, e)), Object.defineProperty(t, r, { get: i.oneOfGetter(e), set: i.oneOfSetter(e) });};};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e) {if (e) for (var t = Object.keys(e), r = 0; r < t.length; ++r) {this[t[r]] = e[t[r]];}}o.create = function (e) {return this.$type.create(e);}, o.encode = function (e, t) {return this.$type.encode(e, t);}, o.encodeDelimited = function (e, t) {return this.$type.encodeDelimited(e, t);}, o.decode = function (e) {return this.$type.decode(e);}, o.decodeDelimited = function (e) {return this.$type.decodeDelimited(e);}, o.verify = function (e) {return this.$type.verify(e);}, o.fromObject = function (e) {return this.$type.fromObject(e);}, o.toObject = function (e, t) {return this.$type.toObject(e, t);}, o.prototype.toJSON = function () {return this.$type.toObject(this, n.toJSONOptions);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TessellationCache = t.CurveTessellator = void 0;var n = r(1),o = r(0),i = r(3),s = r(8),a = { getCircularArcRenderPoints: function getCircularArcRenderPoints(e, t, r, n, o) {var i = e.getRadius(),s = 2 * Math.acos((i - r) / i),a = t[1] - t[0],c = Math.ceil(a / s),u = 0;for (!1 === n && u++; u <= c; ++u) {var l = u / c,h = t[0] * (1 - l) + t[1] * l;o.push(e.evaluatePosition(h));}return i * (1 - Math.cos(a / c * .5));}, getAdaptiveRenderPoints: function getAdaptiveRenderPoints(e, t, r, i) {for (var a = t || .001, c = a * a, u = [], l = [], h = n.Vector3.createFloat64(), d = 0, g = function g(t, r, i, a, p) {var f = i - t,v = .5 * (t + i),_ = e.evaluatePosition(v);n.Vector3.scaleAndAdd(h, [0, 0, 0], r, .5), n.Vector3.scaleAndAdd(h, h, a, .5);var y = n.Vector3.squaredDistance(h, _);if (p > 64) s.DebugUtils.warn("Max recursion depth reach in getAdaptiveRenderPoints");else if (f > 10 * o.PARAMETER_SPACE_TOLERANCE && y > c) return g(t, r, v, _, p + 1), void g(v, _, i, a, p + 1);d = Math.max(d, y), u.push(r), l.push(t);}, p = i || function (e, t, r) {for (var n = new Array(7), o = t, i = (r - t) / 6, s = 0; s < 7; s++) {var a = o;s > 0 && s < 6 && (a += Math.sin(s) * i * .1), n[s] = a, o += i;}return n;}(0, r[0], r[1]), f = 0; f < p.length - 1; ++f) {var v = p[f],_ = p[f + 1],y = e.evaluatePosition(v),m = e.evaluatePosition(_);g(v, y, _, m, 0), f === p.length - 2 && (u.push(m), l.push(_));}return { positions: u, params: l, tolerance: Math.sqrt(d) };} },c = function c() {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };};c.prototype.setDirty = function (e) {this._hasDirtyTessellation = e;}, c.prototype.isDirty = function () {return this._hasDirtyTessellation;}, c.prototype.reset = function () {this._hasDirtyTessellation = !0, this._tessellationCache = void 0, this._trimmedTessellationCache = { positions: void 0, offsets: void 0, transitions: [1, -1] };}, c.prototype.setCache = function (e) {this._tessellationCache = e, this._hasDirtyTessellation = !1;}, c.prototype.getCache = function () {return this._tessellationCache;}, c.prototype.getTolerance = function () {if (this._tessellationCache) return this._tessellationCache.tolerance;}, c.prototype.getTessellation = function (e, t, r, s) {var a = !1;if (!1 === this._hasDirtyTessellation && this._tessellationCache.tolerance > r + n.FLOAT64_TOLERANCE && (this._hasDirtyTessellation = !0), this._hasDirtyTessellation) {this._hasDirtyTessellation = !1;var c = s(r);this._tessellationCache = { positions: c.positions, params: c.params, tolerance: c.tolerance }, a = c.didRetessellate;}var u = [e[0], e[e.length - 1]],l = 0,h = t.getRangeUnlimited();t.isPeriodicUnlimited() && (l = (u = (0, i.normalizeParametricRangeToShiftedRange)(u, h))[0] - e[0]);var d = this._trimmedTessellationCache,g = d.transitions[0] - u[0],p = d.transitions[d.transitions.length - 1] - u[1],f = g * g + p * p < n.FLOAT64_TOLERANCE;if (f && e.length > 2) {f = d.transitions.length === e.length;for (var v = 1; f && v < e.length - 1; ++v) {f = d.transitions[v - 1] === e[v - 1] + l;}}if (!f || a) {var _;for (d.transitions.length = e.length, _ = 0; _ < e.length; ++_) {d.transitions[_] = e[_] + l;}d.positions = [t.evaluatePosition(e[0])], d.offsets = [0];var y,m,E = 1,x = u[0];for (_ = 1; _ < e.length; _++) {var R = e[_] + l;for (m = 0; m < this._tessellationCache.positions.length; m++) {if ((y = this._tessellationCache.params[m]) > x + o.PARAMETER_SPACE_TOLERANCE) {if (y >= R - o.PARAMETER_SPACE_TOLERANCE) break;n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}}if (t.isPeriodicUnlimited() && R > h[1]) for (m = 1; m < this._tessellationCache.positions.length && (y = this._tessellationCache.params[m]) < R - (h[1] - h[0]) - o.PARAMETER_SPACE_TOLERANCE; m++) {n.Vector3.sqrDist(d.positions[E - 1], this._tessellationCache.positions[m]) > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (d.positions[E++] = n.Vector3.clone(this._tessellationCache.positions[m]));}var A = t.evaluatePosition(R);n.Vector3.sqrDist(d.positions[E - 1], A) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && E > d.offsets[d.offsets.length - 1] + 1 && E--, d.positions[E++] = A, d.offsets.push(d.positions.length - 1), x = R;}}return { positions: d.positions, offsets: d.offsets, tolerance: this._tessellationCache.tolerance };}, t.CurveTessellator = a, t.TessellationCache = c;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Cone = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(6),c = r(7),u = r(14),l = r(2),h = function h() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(h.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.CONE;}, h.prototype.clone = function () {var e = new h();return e.copy(this), e;}, h.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, h.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, h.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), l.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t, l.ConsoleUtils.assert(n.Vector3.squaredLength(r) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, r), l.ConsoleUtils.assert(Math.abs(o) < Math.PI / 2), this._angle = o, void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (l.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._uScale = a || 1, l.ConsoleUtils.assert(this._uScale > i.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, h.prototype.getRadius = function () {return this._radius;}, h.prototype.setRadius = function (e) {l.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, h.prototype.getCenter = function () {return this._center;}, h.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, h.prototype.getAxisDir = function () {return this._zAxis;}, h.prototype.setAxisDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, h.prototype.getUvOriginDir = function () {return this._xAxis;}, h.prototype.setUvOriginDir = function (e) {l.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, h.prototype.getUScale = function () {return this._uScale;}, h.prototype.setUScale = function (e) {l.ConsoleUtils.assert(e > i.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, h.prototype.getAngle = function () {return this._angle;}, h.prototype.setAngle = function (e) {l.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - i.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, h.prototype.isCylinder = function () {return Math.abs(this._angle) < i.KERNEL_ANGULAR_TOLERANCE;}, h.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._radius / (this._uScale * Math.sin(this._angle));}, h.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._radius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, h.prototype.evaluatePosition = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateNormal = function (e, t) {var r = Math.sin(this._angle),o = Math.cos(this._angle),i = o * Math.cos(t),s = o * Math.sin(t),a = -r,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, i), n.Vector3.scaleAndAdd(c, c, this._yAxis, s), n.Vector3.scaleAndAdd(c, c, this._zAxis, a), c;}, h.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle),o = r * Math.cos(t),i = r * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, h.prototype.evaluateDv = function (e, t) {var r = this._radius + e * this._uScale * Math.sin(this._angle),o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, h.prototype.closestParam = function (e) {var t = Math.sin(this._angle),r = Math.cos(this._angle),o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center);var s = n.Vector3.dot(o, this._xAxis),a = n.Vector3.dot(o, this._yAxis),c = n.Vector3.dot(o, this._zAxis),u = Math.sqrt(s * s + a * a),l = this.getApexParam();if (void 0 !== l) {var h = l * this._uScale * r;(h > 0 && c > h || h < 0 && c < h) && (s = -s, a = -a, u = -u);}return { u: ((u - this._radius) * t + c * r) / this._uScale, v: Math.abs(u) > i.KERNEL_TOLERANCE ? Math.atan2(a, s) : 0 };}, h.prototype.vParamLine = function (e) {var t = this._radius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var r = new u.Circle(),o = n.Vector3.clone(this._center),s = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, s);var c = n.Vector3.clone(this._xAxis);n.Vector3.scale(c, c, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), r.set(o, l, c), r;}return new a.Point(this.getApexPosition());}, h.prototype.uParamLine = function (e) {var t = new c.Line(),r = n.Vector3.clone(this._center),o = this._radius * Math.cos(e),i = this._radius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, h.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, h.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, h.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, h.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, h.prototype.isPeriodicUnlimitedU = function () {return !1;}, h.prototype.isPeriodicUnlimitedV = function () {return !0;}, h.prototype.isClosedUnlimitedU = function () {return !1;}, h.prototype.isClosedUnlimitedV = function () {return !0;}, h.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Cone = h;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.EllipticalCone = void 0;var n = r(1),o = r(4),i = r(35),s = r(0),a = r(12),c = r(6),u = r(7),l = r(23),h = r(2),d = function d() {a.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._angle = 0, this._uScale = 1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(d.prototype = Object.create(a.Surface.prototype)).getGeometryType = function () {return s.GEOMETRY_TYPES.ELLIPTICAL_CONE;}, d.prototype.clone = function () {var e = new d();return e.copy(this), e;}, d.prototype.copy = function (e) {a.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._angle = e._angle, this._uScale = e._uScale, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, d.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, d.prototype.set = function (e, t, r, o, i, a) {n.Vector3.copy(this._center, e), this._majorRadius = n.Vector3.length(t), h.ConsoleUtils.assert(this._majorRadius > s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, t), h.ConsoleUtils.assert(r <= 1), this._minorRadius = r * this._majorRadius, h.ConsoleUtils.assert(this._minorRadius > s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.squaredLength(o) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), h.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, t, s.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._zAxis, o), h.ConsoleUtils.assert(Math.abs(i) < Math.PI / 2), this._angle = i, this._uScale = a || 1, h.ConsoleUtils.assert(this._uScale > s.PARAMETER_SPACE_TOLERANCE), this._computeYAxis();}, d.prototype.getMajorRadius = function () {return this._majorRadius;}, d.prototype.setMajorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._majorRadius = e;}, d.prototype.getMinorRadius = function () {return this._minorRadius;}, d.prototype.setMinorRadius = function (e) {h.ConsoleUtils.assert(e > s.KERNEL_TOLERANCE), this._minorRadius = e;}, d.prototype.getMajorAxis = function () {return this._xAxis;}, d.prototype.setMajorAxis = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, d.prototype.getCenter = function () {return this._center;}, d.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, d.prototype.getAxisDir = function () {return this._zAxis;}, d.prototype.setAxisDir = function (e) {h.ConsoleUtils.assert(n.Vector3.squaredLength(e) > s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), this._computeYAxis();}, d.prototype.getUScale = function () {return this._uScale;}, d.prototype.setUScale = function (e) {h.ConsoleUtils.assert(e > s.PARAMETER_SPACE_TOLERANCE), this._uScale = e;}, d.prototype.getAngle = function () {return this._angle;}, d.prototype.setAngle = function (e) {h.ConsoleUtils.assert(Math.abs(e) < Math.PI / 2 - s.KERNEL_ANGULAR_TOLERANCE), this._angle = e;}, d.prototype.isCylinder = function () {return Math.abs(this._angle) < s.KERNEL_ANGULAR_TOLERANCE;}, d.prototype.getApexParam = function () {return this.isCylinder() ? void 0 : -this._majorRadius / (this._uScale * Math.sin(this._angle));}, d.prototype.getApexPosition = function () {if (!this.isCylinder()) {var e = -this._majorRadius / Math.tan(this._angle),t = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(t, t, this._zAxis, e), t;}}, d.prototype.evaluatePosition = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = e * this._uScale * Math.cos(this._angle),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateNormal = function (e, t) {var r = Math.cos(this._angle),o = r * this._minorRadius * Math.cos(t),i = r * this._majorRadius * Math.sin(t),s = -Math.sin(this._angle) * this._minorRadius,a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), n.Vector3.normalize(a, a), a;}, d.prototype.evaluateDu = function (e, t) {var r = this._uScale * Math.sin(this._angle) / this._majorRadius,o = r * this._majorRadius * Math.cos(t),i = r * this._minorRadius * Math.sin(t),s = this._uScale * Math.cos(this._angle),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, d.prototype.evaluateDv = function (e, t) {var r = 1 + e * this._uScale * Math.sin(this._angle) / this._majorRadius,o = -r * this._majorRadius * Math.sin(t),i = r * this._minorRadius * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, d.prototype.closestParam = function (e) {var t, r;if (this.isCylinder()) {var o = n.Vector3.createFloat64();n.Vector3.sub(o, e, this._center), t = n.Vector3.dot(o, this._zAxis) / this._uScale, r = this.vParamLine(t).closestToPointParam(e);} else {var a = n.Vector3.createFloat64();n.Vector3.sub(a, e, this.getApexPosition());var c = n.Vector3.dot(a, this._xAxis),u = n.Vector3.dot(a, this._yAxis),l = n.Vector3.dot(a, this._zAxis),h = this._uScale * Math.sin(this._angle),d = h * this._minorRadius / this._majorRadius,g = this._uScale * Math.cos(this._angle),p = this._majorRadius / h,f = function (e, t, r, o, a, c) {if (o * o + a * a + c * c < s.KERNEL_TOLERANCE * s.KERNEL_TOLERANCE) return { u: 0, v: 0 };var u = n.FLOAT64_TOLERANCE,l = c * e >= 0 ? 1 : -1,h = (o * l >= 0 ? .25 : .75) * (a * l >= 0 ? 1 : -1),d = h * Math.PI,g = [(h - .25) * Math.PI, (h + .25) * Math.PI],p = (0, i.newtonRaphson1D)(function (n) {var i = Math.sin(n),s = Math.cos(n),u = e * (t * t + r * r) * o,l = t * (e * e + r * r) * a,h = r * (e * e - t * t) * c;return { val: u * i - l * s - h * i * s, deriv: u * s + l * i - h * (s * s - i * i) };}, g, d, u, 32),f = e * Math.cos(p),v = t * Math.sin(p);return { u: (f * o + v * a + r * c) / (f * f + v * v + r * r), v: p };}(h, d, g, c, u, l);t = f.u - p, r = f.v;}return { u: t, v: r };}, d.prototype.vParamLine = function (e) {var t = this._majorRadius + e * this._uScale * Math.sin(this._angle);if (Math.abs(t) > s.KERNEL_TOLERANCE) {var r = new l.Ellipse(),o = n.Vector3.clone(this._center),i = e * this._uScale * Math.cos(this._angle);n.Vector3.scaleAndAdd(o, o, this._zAxis, i);var a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, t);var u = n.Vector3.clone(this._zAxis);return n.Vector3.negate(u, u), r.set(o, u, a, this._minorRadius / this._majorRadius), r;}return new c.Point(this.getApexPosition());}, d.prototype.uParamLine = function (e) {var t = new u.Line(),r = n.Vector3.clone(this._center),o = this._majorRadius * Math.cos(e),i = this._minorRadius * Math.sin(e);return n.Vector3.scaleAndAdd(r, r, this._xAxis, o), n.Vector3.scaleAndAdd(r, r, this._yAxis, i), t.set(r, this.evaluateDu(0, e)), t;}, d.prototype.getBoundingBox = function (e, t) {if (e) {var r = e[0],n = e[1],i = this.vParamLine(r).getBoundingBox(t);return i.include(this.vParamLine(n).getBoundingBox(t)), i;}return new o.BoundingBox([-1 / 0, -1 / 0, -1 / 0], [1 / 0, 1 / 0, 1 / 0]);}, d.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, this._uScale *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, d.prototype.getRangeUnlimitedU = function () {return [-1 / 0, 1 / 0];}, d.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, d.prototype.isPeriodicUnlimitedU = function () {return !1;}, d.prototype.isPeriodicUnlimitedV = function () {return !0;}, d.prototype.isClosedUnlimitedU = function () {return !1;}, d.prototype.isClosedUnlimitedV = function () {return !0;}, d.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this._center), majorRadius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uCoordScale: this.getUScale(), radiusRatio: this.getMinorRadius() / this.getMajorRadius(), angle: this.getAngle(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.EllipticalCone = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.BSurface = void 0;var n = r(1),o = r(4),i = r(0),s = r(12),a = r(33),c = r(3),u = r(76),l = r(103),h = r(104),d = r(105),g = r(77),p = r(2),f = function f() {s.Surface.call(this), this._uDegree = 0, this._vDegree = 0, this._uKnots = [], this._vKnots = [], this._controlPoints = [], this._weights = [], this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;};(f.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.BSURFACE;}, f.prototype.clone = function () {var e = new f();return e.copy(this), e;}, f.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._uDegree = e._uDegree, this._vDegree = e._vDegree, this._uKnots = e._uKnots.slice(0), this._vKnots = e._vKnots.slice(0), this._controlPoints = e._controlPoints.slice(0), this._weights = e._weights.slice(0), this._clearCaches();}, f.prototype.set = function (e, t, r, n, o, i) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, p.ConsoleUtils.assert(t >= 1), this._vDegree = t, p.ConsoleUtils.assert(r.length >= 2 * (e + 1)), this._uKnots = Array.prototype.slice.call(r), p.ConsoleUtils.assert(n.length >= 2 * (t + 1)), this._vKnots = Array.prototype.slice.call(n);var s = r.length - e - 1,a = n.length - t - 1;p.ConsoleUtils.assert(o.length === 3 * s * a), this._controlPoints = Array.prototype.slice.call(o), i && i.length > 0 ? (p.ConsoleUtils.assert(i.length === s * a), this._weights = Array.prototype.slice.call(i)) : this._weights = [], this._clearCaches();}, f.prototype.getDegreeU = function () {return this._uDegree;}, f.prototype.getDegreeV = function () {return this._vDegree;}, f.prototype.setDegreeU = function (e) {p.ConsoleUtils.assert(e >= 1), this._uDegree = e, this._clearCaches();}, f.prototype.setDegreeV = function (e) {p.ConsoleUtils.assert(e >= 1), this._vDegree = e, this._clearCaches();}, f.prototype.getNumKnotsU = function () {return this._uKnots.length;}, f.prototype.getNumKnotsV = function () {return this._vKnots.length;}, f.prototype.getKnotsU = function () {return this._uKnots;}, f.prototype.getKnotsV = function () {return this._vKnots;}, f.prototype.setKnotsU = function (e) {this._uKnots = e, this._clearCaches();}, f.prototype.setKnotsV = function (e) {this._vKnots = e, this._clearCaches();}, f.prototype.getNumControlPointsU = function () {return this._uKnots.length - this._uDegree - 1;}, f.prototype.getNumControlPointsV = function () {return this._vKnots.length - this._vDegree - 1;}, f.prototype.getControlPoints = function () {return this._controlPoints;}, f.prototype.setControlPoints = function (e) {this._controlPoints = e, this._clearCaches();}, f.prototype.getWeights = function () {return this._weights;}, f.prototype.setWeights = function (e) {e && e.length > 0 ? this._weights = e : this._weights = [], this._clearCaches();}, f.prototype.isRational = function () {return this._weights.length > 0;}, f.prototype.evaluate = function (e, t, r, n, o) {p.ConsoleUtils.assert(r >= 0), this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV()));var i = (0, u.evaluateBSurfaceDerivs)(e, t, Math.min(r, 3), this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),s = { pos: i[0][0] };return r >= 1 && (s.du = i[1][0], s.dv = i[0][1]), r >= 2 && (s.duu = i[2][0], s.duv = i[1][1], s.dvv = i[0][2]), r >= 3 && (s.duuu = i[3][0], s.duuv = i[2][1], s.duvv = i[1][2], s.dvvv = i[0][3]), s;}, f.prototype.evaluatePosition = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfacePoint)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);}, f.prototype.evaluateNormal = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), s.Surface.prototype.evaluateNormal.call(this, e, t);}, f.prototype.evaluateDu = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[1][0];}, f.prototype.evaluateDv = function (e, t) {return this.isPeriodicUnlimitedU() && (e = (0, c.normalizeParameterToShiftedRange)(e, this.getRangeUnlimitedU())), this.isPeriodicUnlimitedV() && (t = (0, c.normalizeParameterToShiftedRange)(t, this.getRangeUnlimitedV())), (0, u.evaluateBSurfaceDerivs)(e, t, 1, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights)[0][1];}, f.prototype.insertKnotU = function (e, t) {var r = (0, l.insertBSurfaceKnotU)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._uKnots = r.uknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.insertKnotV = function (e, t) {var r = (0, l.insertBSurfaceKnotV)(e, t, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._vKnots = r.vknots, this._controlPoints = r.P, this._weights = r.weights || [], this._clearCaches();}, f.prototype.relaxToPerpendicular = function (e, t, r, o, i, s, a) {var c = this;o && 0 !== o.length || (o = this.getRangeU()), i && 0 !== i.length || (i = this.getRangeV());var u = (0, g.newtonRaphson2D)(function (t) {var r = c.evaluate(t[0], t[1], 2);n.Vector3.sub(r.pos, r.pos, e);var o = n.Vector3.dot(r.du, r.pos),i = n.Vector3.dot(r.dv, r.pos),s = n.Vector3.dot(r.duu, r.pos) + n.Vector3.dot(r.du, r.du),a = n.Vector3.dot(r.duv, r.pos) + n.Vector3.dot(r.du, r.dv);return { val: [o, i], deriv1: [s, a], deriv2: [a, n.Vector3.dot(r.dvv, r.pos) + n.Vector3.dot(r.dv, r.dv)] };}, [t, r], [o, i]);return { u: u.param[0], v: u.param[1], status: u.status };}, f.prototype.closestParam = function (e) {for (var t = n.FLOAT64_TOLERANCE, r = [[this.getRangeU(), this.getRangeV()]], o = this.getBezierPatches(), i = (0, d.closestBSurfacePatches)(e, o, r), s = Number.POSITIVE_INFINITY, a = { u: void 0, v: void 0 }, u = 0; u < i.length; ++u) {if (!(i[u].minDistSqr > s)) for (var l = i[u].index, h = o[l[0]][l[1]], g = h.getRangeUnlimitedU(), p = h.getRangeUnlimitedV(), f = 0; f < r.length; ++f) {var v = [Math.max(g[0], r[f][0][0]), Math.min(g[1], r[f][0][1])],_ = [Math.max(p[0], r[f][1][0]), Math.min(p[1], r[f][1][1])];if (!(v[1] - v[0] <= n.FLOAT64_TOLERANCE || _[1] - _[0] <= n.FLOAT64_TOLERANCE)) {var y = (0, d.closestBSurfacePointApprox)(e, h.getDegreeU(), h.getDegreeV(), h.getKnotsU(), h.getKnotsV(), h.getControlPoints(), h.isRational() ? h.getWeights() : void 0, v, _),m = this.relaxToPerpendicular(e, y.u, y.v, v, _, t, 64),E = h.evaluatePosition(m.u, m.v),x = n.Vector3.squaredDistance(E, e);x < s && (s = x, a.u = m.u, a.v = m.v);}}}return this.isPeriodicUnlimitedU() && (a.u = (0, c.foldNearTo)(a.u, .5 * (this.getRangeU()[0] + this.getRangeU()[1]), this.getPeriodUnlimitedU())), this.isPeriodicUnlimitedV() && (a.v = (0, c.foldNearTo)(a.v, .5 * (this.getRangeV()[0] + this.getRangeV()[1]), this.getPeriodUnlimitedV())), a;}, f.prototype.vParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineV)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._vDegree, this._vKnots), n;}, f.prototype.uParamLine = function (e) {var t = (0, l.extractBSurfaceParamLineU)(e, this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights),r = t.ctrlPts.length / 3;t.weights && 0 !== t.weights.length || (t.weights = new Array(r), t.weights.fill(1));var n = new a.BCurve();return n.set(t.ctrlPts, t.weights, this._uDegree, this._uKnots), n;}, f.prototype.getBoundingBox = function (e, t) {for (var r = new o.BoundingBox(), i = n.Vector3.createFloat64(), s = 0; s < this._controlPoints.length; s += 3) {n.Vector3.set(i, this._controlPoints[s], this._controlPoints[s + 1], this._controlPoints[s + 2]), r.includePoint(i);}return r;}, f.prototype.transform = function (e) {for (var t = n.Vector3.createFloat64(), r = 0; r < this._controlPoints.length; r += 3) {n.Vector3.set(t, this._controlPoints[r], this._controlPoints[r + 1], this._controlPoints[r + 2]), n.Vector3.transformMatrix44(t, t, e), this._controlPoints[r] = t[0], this._controlPoints[r + 1] = t[1], this._controlPoints[r + 2] = t[2];}this._clearCaches();}, f.prototype.getRangeUnlimitedU = function () {return [this._uKnots[0], this._uKnots[this._uKnots.length - 1]];}, f.prototype.getRangeUnlimitedV = function () {return [this._vKnots[0], this._vKnots[this._vKnots.length - 1]];}, f.prototype.isPeriodicUnlimitedU = function () {return this._checkClosure(), this._isPeriodicU;}, f.prototype.isPeriodicUnlimitedV = function () {return this._checkClosure(), this._isPeriodicV;}, f.prototype.isClosedUnlimitedU = function () {return this._checkClosure(), this._isClosedU;}, f.prototype.isClosedUnlimitedV = function () {return this._checkClosure(), this._isClosedV;}, f.prototype._checkClosure = function () {void 0 !== this._isClosedU && void 0 !== this._isPeriodicU || (this._isClosedU = this._isPeriodicU = !1), void 0 !== this._isClosedV && void 0 !== this._isPeriodicV || (this._isClosedV = this._isPeriodicV = !1);}, f.prototype.isSimpleBezier = function () {return this._uKnots.length === 2 * this._uDegree + 2 && this._vKnots.length === 2 * this._vDegree + 2;}, f.prototype.getBezierPatches = function () {if (this.isSimpleBezier()) return this._patches = void 0, [[this]];if (!this._patches) {var e = (0, h.decomposeBSurfaceToBezier)(this._uDegree, this._vDegree, this._uKnots, this._vKnots, this._controlPoints, this._weights);this._patches = [];for (var t = 0; t < e.U.length; ++t) {this._patches[t] = [];for (var r = 0; r < e.V.length; ++r) {var n = new f();n.set(this._uDegree, this._vDegree, e.U[t], e.V[r], e.P[t][r], e.w ? e.w[t][r] : void 0), this._patches[t][r] = n;}}}return this._patches;}, f.prototype._clearCaches = function () {this._isClosedU = void 0, this._isClosedV = void 0, this._isPeriodicU = void 0, this._isPeriodicV = void 0, this._patches = void 0;}, f.prototype.toObject = function () {return { uDegree: this._uDegree, vDegree: this._vDegree, uKnots: this._uKnots, vKnots: this._vKnots, controlPoints: this._controlPoints, weights: this._weights, uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.BSurface = f;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.WireBody = void 0;var n = r(9),o = r(0),i = r(4),s = r(19),a = function a() {n.BaseTopology.call(this), this._wires = [];};(a.prototype = Object.create(n.BaseTopology.prototype)).getTopologyType = function () {return o.TOPOLOGY_TYPES.WIREBODY;}, a.prototype.getWires = function () {return this._wires;}, a.prototype.setWires = function (e) {this._wires = new Array(e.length);for (var t = 0; t < e.length; ++t) {this._wires[t] = e[t];}}, a.prototype.addWire = function (e) {this._wires ? this._wires.push(e) : this._wires = [e], e.setWireBody(this);}, a.prototype.addWires = function (e) {this._wires || (this._wires = []);for (var t = 0; t < e.length; ++t) {e[t].setWireBody(this);}this._wires = this._wires.concat(e);}, a.prototype.removeWire = function (e) {var t = this._wires.indexOf(e);return t > -1 && (this._wires.splice(t, 1), e.getWireBody() === this && e.setWireBody(void 0), !0);}, a.prototype.getBody = function () {return this;}, a.prototype.collectFaces = function (e) {return e || new Set();}, a.prototype.collectEdges = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectEdges(e);}return e;}, a.prototype.collectVertices = function (e) {e = e || new Set();for (var t = 0; t < this._wires.length; ++t) {this._wires[t].collectVertices(e);}return e;}, a.prototype.getBoundingBox = function () {for (var e = new i.BoundingBox(), t = 0; t < this._wires.length; ++t) {e.include(this._wires[t].getBoundingBox());}return e;}, a.prototype.transform = function (e) {(0, s.transformTopology)(this, e);}, a.prototype.toString = function () {return "WireBody";}, a.prototype.toObject = function () {return { wires: this.refsToStrings(this._wires), attributes: this.refsToStrings(this._attributes) };}, a.prototype.addToModelObject = function (e) {this.addAllToModelObject(e, [this._wires, this._attributes]);}, t.WireBody = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologyCloner = void 0;var n = r(16),o = r(20),i = r(27),s = r(13),a = r(15),c = r(26),u = r(25),l = r(24),h = r(41),d = function d() {this._edgeMap = {}, this._vertexMap = {}, this._coedgeMap = {}, this._progenitorMap = new h.ProgenitorMap();};d.prototype.cloneVertex = function (e) {var t = this._vertexMap[e.getGuid()];return t || (t = new n.Vertex(e.getPoint().clone()), this._vertexMap[e.getGuid()] = t, t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneEdge = function (e) {var t = this._edgeMap[e.getGuid()];return t || (t = new o.Edge(e.getCurve().clone()), this._edgeMap[e.getGuid()] = t, t.setReversed(e.isReversed()), t.setRange(e.getRange()), t.setStartVertex(this.cloneVertex(e.getStartVertex())), t.setEndVertex(this.cloneVertex(e.getEndVertex())), t.setPrecision(e.getPrecision()), this._progenitorMap.addEntry(t, [e])), t;}, d.prototype.cloneCoedge = function (e) {var t,r,n = new i.Coedge();this._coedgeMap[e.getGuid()] = n, n.setReversed(e.isReversed()), n.setEdge(this.cloneEdge(e.getEdge())), n.getEdge().setCoedge(n);for (var o = e.getPartner(); o;) {var s = this._coedgeMap[o.getGuid()];s && (t || (t = s), r = s, e.getEdge().getCoedge() === o && n.getEdge().setCoedge(s)), (o = o.getPartner()) === e && (o = void 0);}return t && r && (n.setPartner(t), r.setPartner(n)), this._progenitorMap.addEntry(n, [e]), n;}, d.prototype.cloneLoop = function (e) {for (var t = new s.Loop(), r = e.getCoedges(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneCoedge(r[o]);}return t.addCoedges(n), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFace = function (e) {for (var t = new a.Face(), r = e.getLoops(), n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = this.cloneLoop(r[o]);}return t.addLoops(n), t.setSurface(e.getSurface().clone()), t.setReversed(e.isReversed()), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneFaces = function (e) {for (var t = new Array(e.length), r = 0; r < e.length; ++r) {t[r] = this.cloneFace(e[r]);}return t;}, d.prototype.cloneShell = function (e) {var t = new c.Shell();return t.addFaces(this.cloneFaces(e.getFaces())), this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneLump = function (e) {for (var t = new u.Lump(), r = e.getShells(), n = 0; n < r.length; ++n) {t.addShell(this.cloneShell(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.cloneBody = function (e) {for (var t = new l.Body(), r = e.getLumps(), n = 0; n < r.length; ++n) {t.addLump(this.cloneLump(r[n]));}return this._progenitorMap.addEntry(t, [e]), t;}, d.prototype.getProgenitorMap = function () {return this._progenitorMap;}, t.TopologyCloner = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = function n(e, t) {if (t < 1) return "";for (var r = ""; t > 1;) {1 & t && (r += e), t >>= 1, e += e;}return r + e;},o = { isInitialized: !1, rngA: 4027999010, rngB: 3993266363, rngC: 3605298456, rotl32: function rotl32(e, t) {return (e << t >>> 0 | e >>> 32 - t) >>> 0;}, initialize: function initialize(e, t) {return o.isInitialized && !t ? 0 : (o.isInitialized && (o.rngA = 4027999010, o.rngB = 3993266363, o.rngC = 3605298456), o.isInitialized = !0, void 0 !== e ? r = e : (r = new Date().getTime(), r ^= Math.floor(2147483647 * Math.random() + 1)), o.rngA += 2097151 & r, o.rngB += r >> 7 & 524287, o.rngC += r >> 13, r);var r;}, genRandUInt32: function genRandUInt32() {return o.rngA = ~(2911329625 * o.rngA), o.rngA = o.rotl32(o.rngA, 17), o.rngB = 4031235431 * o.rngB, o.rngB = o.rotl32(o.rngB, 15), o.rngC = 3286325185 - o.rotl32(o.rngC, 19), o.rngA + o.rngB ^ o.rngC;} },i = function i(e) {for (var t = "", r = 0; r < 4; r++) {var o = e[r].toString(16);t += n("0", 8 - o.length) + o;}return t.substr(0, 8) + "-" + t.substr(8, 4) + "-" + t.substr(12, 4) + "-" + t.substr(16, 4) + "-" + t.substr(20, 12);},s = function s(e, t) {var r = t;return void 0 === r && (r = new Uint32Array(4)), r[0] = parseInt("0x" + e.substr(0, 8), 16), r[1] = parseInt("0x" + e.substr(9, 4) + e.substr(14, 4), 16), r[2] = parseInt("0x" + e.substr(19, 4) + e.substr(24, 4), 16), r[3] = parseInt("0x" + e.substr(28, 8), 16), r;},a = function a(e, t) {var r = new Uint32Array(t);return r[0] += 2654435769, r[1] += 104395303, r[2] += 452930477, r[3] += 982451653, r[0] += e[3] << 6, r[1] += e[0] << 6, r[2] += e[1] << 6, r[3] += e[2] << 6, r[0] += e[2] >> 2, r[1] += e[3] >> 2, r[2] += e[0] >> 2, r[3] += e[1] >> 2, r[0] = 16777619 * (r[0] ^ e[1]) >>> 0, r[1] = 16777619 * (r[1] ^ e[2]) >>> 0, r[2] = 16777619 * (r[2] ^ e[3]) >>> 0, r[3] = 16777619 * (r[3] ^ e[0]) >>> 0, r;};o.initialize(), t.uint32x4ToGUID = i, t.guidToUint32x4 = s, t.generateGUID = function () {var e = new Uint32Array(4);return e[0] = o.genRandUInt32(), e[1] = o.genRandUInt32(), e[2] = o.genRandUInt32(), e[3] = o.genRandUInt32(), i(e);}, t.isGUID = function (e) {return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(e);}, t.combineGuids = function (e, t) {var r = s(e),n = s(t),o = a(r, n);return i(o);}, t.hashCombine4xUint32 = a;}, function (e, t) {var r;r = function () {return this;}();try {r = r || new Function("return this")();} catch (e) {"object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && (r = window);}e.exports = r;}, function (e, t, r) {"use strict";e.exports = function (e, t) {for (var r = new Array(arguments.length - 1), n = 0, o = 2, i = !0; o < arguments.length;) {r[n++] = arguments[o++];}return new Promise(function (o, s) {r[n] = function (e) {if (i) if (i = !1, e) s(e);else {for (var t = new Array(arguments.length - 1), r = 0; r < t.length;) {t[r++] = arguments[r];}o.apply(null, t);}};try {e.apply(t || null, r);} catch (e) {i && (i = !1, s(e));}});};}, function (module, exports, __webpack_require__) {"use strict";function inquire(moduleName) {try {var mod = eval("quire".replace(/^/, "re"))(moduleName);if (mod && (mod.length || Object.keys(mod).length)) return mod;} catch (e) {}return null;}module.exports = inquire;}, function (e, t, r) {"use strict";t.Service = r(98);}, function (e, t, r) {"use strict";e.exports = {};}, function (e, t, r) {"use strict";e.exports = function (e) {for (var t, r = i.codegen(["m", "w"], e.name + "$encode")("if(!w)")("w=Writer.create()"), a = e.fieldsArray.slice().sort(i.compareFieldsById), c = 0; c < a.length; ++c) {var u = a[c].resolve(),l = e._fieldsArray.indexOf(u),h = u.resolvedType instanceof n ? "int32" : u.type,d = o.basic[h];t = "m" + i.safeProp(u.name), u.map ? (r("if(%s!=null&&m.hasOwnProperty(%j)){", t, u.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", t)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (u.id << 3 | 2) >>> 0, 8 | o.mapKey[u.keyType], u.keyType), void 0 === d ? r("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", l, t) : r(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | d, h, t), r("}")("}")) : u.repeated ? (r("if(%s!=null&&%s.length){", t, t), u.packed && void 0 !== o.packed[h] ? r("w.uint32(%i).fork()", (u.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", t)("w.%s(%s[i])", h, t)("w.ldelim()") : (r("for(var i=0;i<%s.length;++i)", t), void 0 === d ? s(r, u, l, t + "[i]") : r("w.uint32(%i).%s(%s[i])", (u.id << 3 | d) >>> 0, h, t)), r("}")) : (u.optional && r("if(%s!=null&&m.hasOwnProperty(%j))", t, u.name), void 0 === d ? s(r, u, l, t) : r("w.uint32(%i).%s(%s)", (u.id << 3 | d) >>> 0, h, t));}return r("return w");};var n = r(11),o = r(31),i = r(5);function s(e, t, r, n) {return t.resolvedType.group ? e("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", r, n, (t.id << 3 | 3) >>> 0, (t.id << 3 | 4) >>> 0) : e("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", r, n, (t.id << 3 | 2) >>> 0);}}, function (e, t, r) {"use strict";e.exports = y;var n = r(30);((y.prototype = Object.create(n.prototype)).constructor = y).className = "Type";var o = r(11),i = r(48),s = r(22),a = r(64),c = r(65),u = r(49),l = r(47),h = r(46),d = r(5),g = r(62),p = r(67),f = r(68),v = r(69),_ = r(70);function y(e, t) {n.call(this, e, t), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;}function m(e) {return e._fieldsById = e._fieldsArray = e._oneofsArray = null, delete e.encode, delete e.decode, delete e.verify, e;}Object.defineProperties(y.prototype, { fieldsById: { get: function get() {if (this._fieldsById) return this._fieldsById;this._fieldsById = {};for (var e = Object.keys(this.fields), t = 0; t < e.length; ++t) {var r = this.fields[e[t]],n = r.id;if (this._fieldsById[n]) throw Error("duplicate id " + n + " in " + this);this._fieldsById[n] = r;}return this._fieldsById;} }, fieldsArray: { get: function get() {return this._fieldsArray || (this._fieldsArray = d.toArray(this.fields));} }, oneofsArray: { get: function get() {return this._oneofsArray || (this._oneofsArray = d.toArray(this.oneofs));} }, ctor: { get: function get() {return this._ctor || (this.ctor = y.generateConstructor(this)());}, set: function set(e) {var t = e.prototype;t instanceof u || ((e.prototype = new u()).constructor = e, d.merge(e.prototype, t)), e.$type = e.prototype.$type = this, d.merge(e, u, !0), this._ctor = e;for (var r = 0; r < this.fieldsArray.length; ++r) {this._fieldsArray[r].resolve();}var n = {};for (r = 0; r < this.oneofsArray.length; ++r) {n[this._oneofsArray[r].resolve().name] = { get: d.oneOfGetter(this._oneofsArray[r].oneof), set: d.oneOfSetter(this._oneofsArray[r].oneof) };}r && Object.defineProperties(e.prototype, n);} } }), y.generateConstructor = function (e) {for (var t, r = d.codegen(["p"], e.name), n = 0; n < e.fieldsArray.length; ++n) {(t = e._fieldsArray[n]).map ? r("this%s={}", d.safeProp(t.name)) : t.repeated && r("this%s=[]", d.safeProp(t.name));}return r("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");}, y.fromJSON = function (e, t) {var r = new y(e, t.options);r.extensions = t.extensions, r.reserved = t.reserved;for (var u = Object.keys(t.fields), l = 0; l < u.length; ++l) {r.add((void 0 !== t.fields[u[l]].keyType ? a.fromJSON : s.fromJSON)(u[l], t.fields[u[l]]));}if (t.oneofs) for (u = Object.keys(t.oneofs), l = 0; l < u.length; ++l) {r.add(i.fromJSON(u[l], t.oneofs[u[l]]));}if (t.nested) for (u = Object.keys(t.nested), l = 0; l < u.length; ++l) {var h = t.nested[u[l]];r.add((void 0 !== h.id ? s.fromJSON : void 0 !== h.fields ? y.fromJSON : void 0 !== h.values ? o.fromJSON : void 0 !== h.methods ? c.fromJSON : n.fromJSON)(u[l], h));}return t.extensions && t.extensions.length && (r.extensions = t.extensions), t.reserved && t.reserved.length && (r.reserved = t.reserved), t.group && (r.group = !0), t.comment && (r.comment = t.comment), r;}, y.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return d.toObject(["options", t && t.options || void 0, "oneofs", n.arrayToJSON(this.oneofsArray, e), "fields", n.arrayToJSON(this.fieldsArray.filter(function (e) {return !e.declaringField;}), e) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group", this.group || void 0, "nested", t && t.nested || void 0, "comment", r ? this.comment : void 0]);}, y.prototype.resolveAll = function () {for (var e = this.fieldsArray, t = 0; t < e.length;) {e[t++].resolve();}var r = this.oneofsArray;for (t = 0; t < r.length;) {r[t++].resolve();}return n.prototype.resolveAll.call(this);}, y.prototype.get = function (e) {return this.fields[e] || this.oneofs && this.oneofs[e] || this.nested && this.nested[e] || null;}, y.prototype.add = function (e) {if (this.get(e.name)) throw Error("duplicate name '" + e.name + "' in " + this);if (e instanceof s && void 0 === e.extend) {if (this._fieldsById ? this._fieldsById[e.id] : this.fieldsById[e.id]) throw Error("duplicate id " + e.id + " in " + this);if (this.isReservedId(e.id)) throw Error("id " + e.id + " is reserved in " + this);if (this.isReservedName(e.name)) throw Error("name '" + e.name + "' is reserved in " + this);return e.parent && e.parent.remove(e), this.fields[e.name] = e, e.message = this, e.onAdd(this), m(this);}return e instanceof i ? (this.oneofs || (this.oneofs = {}), this.oneofs[e.name] = e, e.onAdd(this), m(this)) : n.prototype.add.call(this, e);}, y.prototype.remove = function (e) {if (e instanceof s && void 0 === e.extend) {if (!this.fields || this.fields[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.fields[e.name], e.parent = null, e.onRemove(this), m(this);}if (e instanceof i) {if (!this.oneofs || this.oneofs[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.oneofs[e.name], e.parent = null, e.onRemove(this), m(this);}return n.prototype.remove.call(this, e);}, y.prototype.isReservedId = function (e) {return n.isReservedId(this.reserved, e);}, y.prototype.isReservedName = function (e) {return n.isReservedName(this.reserved, e);}, y.prototype.create = function (e) {return new this.ctor(e);}, y.prototype.setup = function () {for (var e = this.fullName, t = [], r = 0; r < this.fieldsArray.length; ++r) {t.push(this._fieldsArray[r].resolve().resolvedType);}this.encode = g(this)({ Writer: h, types: t, util: d }), this.decode = p(this)({ Reader: l, types: t, util: d }), this.verify = f(this)({ types: t, util: d }), this.fromObject = v.fromObject(this)({ types: t, util: d }), this.toObject = v.toObject(this)({ types: t, util: d });var n = _[e];if (n) {var o = Object.create(this);o.fromObject = this.fromObject, this.fromObject = n.fromObject.bind(o), o.toObject = this.toObject, this.toObject = n.toObject.bind(o);}return this;}, y.prototype.encode = function (e, t) {return this.setup().encode(e, t);}, y.prototype.encodeDelimited = function (e, t) {return this.encode(e, t && t.len ? t.fork() : t).ldelim();}, y.prototype.decode = function (e, t) {return this.setup().decode(e, t);}, y.prototype.decodeDelimited = function (e) {return e instanceof l || (e = l.create(e)), this.decode(e, e.uint32());}, y.prototype.verify = function (e) {return this.setup().verify(e);}, y.prototype.fromObject = function (e) {return this.setup().fromObject(e);}, y.prototype.toObject = function (e, t) {return this.setup().toObject(e, t);}, y.d = function (e) {return function (t) {d.decorateType(t, e);};};}, function (e, t, r) {"use strict";e.exports = s;var n = r(22);((s.prototype = Object.create(n.prototype)).constructor = s).className = "MapField";var o = r(31),i = r(5);function s(e, t, r, o, s, a) {if (n.call(this, e, t, o, void 0, void 0, s, a), !i.isString(r)) throw TypeError("keyType must be a string");this.keyType = r, this.resolvedKeyType = null, this.map = !0;}s.fromJSON = function (e, t) {return new s(e, t.id, t.keyType, t.type, t.options, t.comment);}, s.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return i.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t ? this.comment : void 0]);}, s.prototype.resolve = function () {if (this.resolved) return this;if (void 0 === o.mapKey[this.keyType]) throw Error("invalid key type: " + this.keyType);return n.prototype.resolve.call(this);}, s.d = function (e, t, r) {return "function" == typeof r ? r = i.decorateType(r).name : r && "object" == _typeof(r) && (r = i.decorateEnum(r).name), function (n, o) {i.decorateType(n.constructor).add(new s(o, e, t, r));};};}, function (e, t, r) {"use strict";e.exports = a;var n = r(30);((a.prototype = Object.create(n.prototype)).constructor = a).className = "Service";var o = r(66),i = r(5),s = r(60);function a(e, t) {n.call(this, e, t), this.methods = {}, this._methodsArray = null;}function c(e) {return e._methodsArray = null, e;}a.fromJSON = function (e, t) {var r = new a(e, t.options);if (t.methods) for (var n = Object.keys(t.methods), i = 0; i < n.length; ++i) {r.add(o.fromJSON(n[i], t.methods[n[i]]));}return t.nested && r.addJSON(t.nested), r.comment = t.comment, r;}, a.prototype.toJSON = function (e) {var t = n.prototype.toJSON.call(this, e),r = !!e && Boolean(e.keepComments);return i.toObject(["options", t && t.options || void 0, "methods", n.arrayToJSON(this.methodsArray, e) || {}, "nested", t && t.nested || void 0, "comment", r ? this.comment : void 0]);}, Object.defineProperty(a.prototype, "methodsArray", { get: function get() {return this._methodsArray || (this._methodsArray = i.toArray(this.methods));} }), a.prototype.get = function (e) {return this.methods[e] || n.prototype.get.call(this, e);}, a.prototype.resolveAll = function () {for (var e = this.methodsArray, t = 0; t < e.length; ++t) {e[t].resolve();}return n.prototype.resolve.call(this);}, a.prototype.add = function (e) {if (this.get(e.name)) throw Error("duplicate name '" + e.name + "' in " + this);return e instanceof o ? (this.methods[e.name] = e, e.parent = this, c(this)) : n.prototype.add.call(this, e);}, a.prototype.remove = function (e) {if (e instanceof o) {if (this.methods[e.name] !== e) throw Error(e + " is not a member of " + this);return delete this.methods[e.name], e.parent = null, c(this);}return n.prototype.remove.call(this, e);}, a.prototype.create = function (e, t, r) {for (var n, o = new s.Service(e, t, r), a = 0; a < this.methodsArray.length; ++a) {var c = i.lcFirst((n = this._methodsArray[a]).resolve().name).replace(/[^$\w_]/g, "");o[c] = i.codegen(["r", "c"], i.isReserved(c) ? c + "_" : c)("return this.rpcCall(m,q,s,r,c)")({ m: n, q: n.resolvedRequestType.ctor, s: n.resolvedResponseType.ctor });}return o;};}, function (e, t, r) {"use strict";e.exports = i;var n = r(21);((i.prototype = Object.create(n.prototype)).constructor = i).className = "Method";var o = r(5);function i(e, t, r, i, s, a, c, u) {if (o.isObject(s) ? (c = s, s = a = void 0) : o.isObject(a) && (c = a, a = void 0), void 0 !== t && !o.isString(t)) throw TypeError("type must be a string");if (!o.isString(r)) throw TypeError("requestType must be a string");if (!o.isString(i)) throw TypeError("responseType must be a string");n.call(this, e, c), this.type = t || "rpc", this.requestType = r, this.requestStream = !!s || void 0, this.responseType = i, this.responseStream = !!a || void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = u;}i.fromJSON = function (e, t) {return new i(e, t.type, t.requestType, t.responseType, t.requestStream, t.responseStream, t.options, t.comment);}, i.prototype.toJSON = function (e) {var t = !!e && Boolean(e.keepComments);return o.toObject(["type", "rpc" !== this.type && this.type || void 0, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options, "comment", t ? this.comment : void 0]);}, i.prototype.resolve = function () {return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), n.prototype.resolve.call(this));};}, function (e, t, r) {"use strict";e.exports = function (e) {var t = i.codegen(["r", "l"], e.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (e.fieldsArray.filter(function (e) {return e.map;}).length ? ",k" : ""))("while(r.pos<c){")("var t=r.uint32()");e.group && t("if((t&7)===4)")("break"), t("switch(t>>>3){");for (var r = 0; r < e.fieldsArray.length; ++r) {var a = e._fieldsArray[r].resolve(),c = a.resolvedType instanceof n ? "int32" : a.type,u = "m" + i.safeProp(a.name);t("case %i:", a.id), a.map ? (t("r.skip().pos++")("if(%s===util.emptyObject)", u)("%s={}", u)("k=r.%s()", a.keyType)("r.pos++"), void 0 !== o.long[a.keyType] ? void 0 === o.basic[c] ? t('%s[typeof k==="object"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())', u, r) : t('%s[typeof k==="object"?util.longToHash(k):k]=r.%s()', u, c) : void 0 === o.basic[c] ? t("%s[k]=types[%i].decode(r,r.uint32())", u, r) : t("%s[k]=r.%s()", u, c)) : a.repeated ? (t("if(!(%s&&%s.length))", u, u)("%s=[]", u), void 0 !== o.packed[c] && t("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", u, c)("}else"), void 0 === o.basic[c] ? t(a.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", u, r) : t("%s.push(r.%s())", u, c)) : void 0 === o.basic[c] ? t(a.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", u, r) : t("%s=r.%s()", u, c), t("break");}for (t("default:")("r.skipType(t&7)")("break")("}")("}"), r = 0; r < e._fieldsArray.length; ++r) {var l = e._fieldsArray[r];l.required && t("if(!m.hasOwnProperty(%j))", l.name)("throw util.ProtocolError(%j,{instance:m})", s(l));}return t("return m");};var n = r(11),o = r(31),i = r(5);function s(e) {return "missing required '" + e.name + "'";}}, function (e, t, r) {"use strict";e.exports = function (e) {var t = o.codegen(["m"], e.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"),r = {};e.oneofsArray.length && t("var p={}");for (var n = 0; n < e.fieldsArray.length; ++n) {var c = e._fieldsArray[n].resolve(),u = "m" + o.safeProp(c.name);if (c.optional && t("if(%s!=null&&m.hasOwnProperty(%j)){", u, c.name), c.map) t("if(!util.isObject(%s))", u)("return%j", i(c, "object"))("var k=Object.keys(%s)", u)("for(var i=0;i<k.length;++i){"), a(t, c, "k[i]"), s(t, c, n, u + "[k[i]]")("}");else if (c.repeated) t("if(!Array.isArray(%s))", u)("return%j", i(c, "array"))("for(var i=0;i<%s.length;++i){", u), s(t, c, n, u + "[i]")("}");else {if (c.partOf) {var l = o.safeProp(c.partOf.name);1 === r[c.partOf.name] && t("if(p%s===1)", l)("return%j", c.partOf.name + ": multiple values"), r[c.partOf.name] = 1, t("p%s=1", l);}s(t, c, n, u);}c.optional && t("}");}return t("return null");};var n = r(11),o = r(5);function i(e, t) {return e.name + ": " + t + (e.repeated && "array" !== t ? "[]" : e.map && "object" !== t ? "{k:" + e.keyType + "}" : "") + " expected";}function s(e, t, r, o) {if (t.resolvedType) {if (t.resolvedType instanceof n) {e("switch(%s){", o)("default:")("return%j", i(t, "enum value"));for (var s = Object.keys(t.resolvedType.values), a = 0; a < s.length; ++a) {e("case %i:", t.resolvedType.values[s[a]]);}e("break")("}");} else e("{")("var e=types[%i].verify(%s);", r, o)("if(e)")("return%j+e", t.name + ".")("}");} else switch (t.type) {case "int32":case "uint32":case "sint32":case "fixed32":case "sfixed32":e("if(!util.isInteger(%s))", o)("return%j", i(t, "integer"));break;case "int64":case "uint64":case "sint64":case "fixed64":case "sfixed64":e("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", o, o, o, o)("return%j", i(t, "integer|Long"));break;case "float":case "double":e('if(typeof %s!=="number")', o)("return%j", i(t, "number"));break;case "bool":e('if(typeof %s!=="boolean")', o)("return%j", i(t, "boolean"));break;case "string":e("if(!util.isString(%s))", o)("return%j", i(t, "string"));break;case "bytes":e('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', o, o, o)("return%j", i(t, "buffer"));}return e;}function a(e, t, r) {switch (t.keyType) {case "int32":case "uint32":case "sint32":case "fixed32":case "sfixed32":e("if(!util.key32Re.test(%s))", r)("return%j", i(t, "integer key"));break;case "int64":case "uint64":case "sint64":case "fixed64":case "sfixed64":e("if(!util.key64Re.test(%s))", r)("return%j", i(t, "integer|Long key"));break;case "bool":e("if(!util.key2Re.test(%s))", r)("return%j", i(t, "boolean key"));}return e;}}, function (e, t, r) {"use strict";var n = t,o = r(11),i = r(5);function s(e, t, r, n) {if (t.resolvedType) {if (t.resolvedType instanceof o) {e("switch(d%s){", n);for (var i = t.resolvedType.values, s = Object.keys(i), a = 0; a < s.length; ++a) {t.repeated && i[s[a]] === t.typeDefault && e("default:"), e("case%j:", s[a])("case %i:", i[s[a]])("m%s=%j", n, i[s[a]])("break");}e("}");} else e('if(typeof d%s!=="object")', n)("throw TypeError(%j)", t.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", n, r, n);} else {var c = !1;switch (t.type) {case "double":case "float":e("m%s=Number(d%s)", n, n);break;case "uint32":case "fixed32":e("m%s=d%s>>>0", n, n);break;case "int32":case "sint32":case "sfixed32":e("m%s=d%s|0", n, n);break;case "uint64":c = !0;case "int64":case "sint64":case "fixed64":case "sfixed64":e("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", n, n, c)('else if(typeof d%s==="string")', n)("m%s=parseInt(d%s,10)", n, n)('else if(typeof d%s==="number")', n)("m%s=d%s", n, n)('else if(typeof d%s==="object")', n)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", n, n, n, c ? "true" : "");break;case "bytes":e('if(typeof d%s==="string")', n)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", n, n, n)("else if(d%s.length)", n)("m%s=d%s", n, n);break;case "string":e("m%s=String(d%s)", n, n);break;case "bool":e("m%s=Boolean(d%s)", n, n);}}return e;}function a(e, t, r, n) {if (t.resolvedType) t.resolvedType instanceof o ? e("d%s=o.enums===String?types[%i].values[m%s]:m%s", n, r, n, n) : e("d%s=types[%i].toObject(m%s,o)", n, r, n);else {var i = !1;switch (t.type) {case "double":case "float":e("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", n, n, n, n);break;case "uint64":i = !0;case "int64":case "sint64":case "fixed64":case "sfixed64":e('if(typeof m%s==="number")', n)("d%s=o.longs===String?String(m%s):m%s", n, n, n)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", n, n, n, n, i ? "true" : "", n);break;case "bytes":e("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", n, n, n, n, n);break;default:e("d%s=m%s", n, n);}}return e;}n.fromObject = function (e) {var t = e.fieldsArray,r = i.codegen(["d"], e.name + "$fromObject")("if(d instanceof this.ctor)")("return d");if (!t.length) return r("return new this.ctor");r("var m=new this.ctor");for (var n = 0; n < t.length; ++n) {var a = t[n].resolve(),c = i.safeProp(a.name);a.map ? (r("if(d%s){", c)('if(typeof d%s!=="object")', c)("throw TypeError(%j)", a.fullName + ": object expected")("m%s={}", c)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", c), s(r, a, n, c + "[ks[i]]")("}")("}")) : a.repeated ? (r("if(d%s){", c)("if(!Array.isArray(d%s))", c)("throw TypeError(%j)", a.fullName + ": array expected")("m%s=[]", c)("for(var i=0;i<d%s.length;++i){", c), s(r, a, n, c + "[i]")("}")("}")) : (a.resolvedType instanceof o || r("if(d%s!=null){", c), s(r, a, n, c), a.resolvedType instanceof o || r("}"));}return r("return m");}, n.toObject = function (e) {var t = e.fieldsArray.slice().sort(i.compareFieldsById);if (!t.length) return i.codegen()("return {}");for (var r = i.codegen(["m", "o"], e.name + "$toObject")("if(!o)")("o={}")("var d={}"), n = [], s = [], c = [], u = 0; u < t.length; ++u) {t[u].partOf || (t[u].resolve().repeated ? n : t[u].map ? s : c).push(t[u]);}if (n.length) {for (r("if(o.arrays||o.defaults){"), u = 0; u < n.length; ++u) {r("d%s=[]", i.safeProp(n[u].name));}r("}");}if (s.length) {for (r("if(o.objects||o.defaults){"), u = 0; u < s.length; ++u) {r("d%s={}", i.safeProp(s[u].name));}r("}");}if (c.length) {for (r("if(o.defaults){"), u = 0; u < c.length; ++u) {var l = c[u],h = i.safeProp(l.name);if (l.resolvedType instanceof o) r("d%s=o.enums===String?%j:%j", h, l.resolvedType.valuesById[l.typeDefault], l.typeDefault);else if (l.long) r("if(util.Long){")("var n=new util.Long(%i,%i,%j)", l.typeDefault.low, l.typeDefault.high, l.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", h)("}else")("d%s=o.longs===String?%j:%i", h, l.typeDefault.toString(), l.typeDefault.toNumber());else if (l.bytes) {var d = "[" + Array.prototype.slice.call(l.typeDefault).join(",") + "]";r("if(o.bytes===String)d%s=%j", h, String.fromCharCode.apply(String, l.typeDefault))("else{")("d%s=%s", h, d)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", h, h)("}");} else r("d%s=%j", h, l.typeDefault);}r("}");}var g = !1;for (u = 0; u < t.length; ++u) {l = t[u];var p = e._fieldsArray.indexOf(l);h = i.safeProp(l.name), l.map ? (g || (g = !0, r("var ks2")), r("if(m%s&&(ks2=Object.keys(m%s)).length){", h, h)("d%s={}", h)("for(var j=0;j<ks2.length;++j){"), a(r, l, p, h + "[ks2[j]]")("}")) : l.repeated ? (r("if(m%s&&m%s.length){", h, h)("d%s=[]", h)("for(var j=0;j<m%s.length;++j){", h), a(r, l, p, h + "[j]")("}")) : (r("if(m%s!=null&&m.hasOwnProperty(%j)){", h, l.name), a(r, l, p, h), l.partOf && r("if(o.oneofs)")("d%s=%j", i.safeProp(l.partOf.name), l.name)), r("}");}return r("return d");};}, function (e, t, r) {"use strict";var n = t,o = r(49);n[".google.protobuf.Any"] = { fromObject: function fromObject(e) {if (e && e["@type"]) {var t = this.lookup(e["@type"]);if (t) {var r = "." === e["@type"].charAt(0) ? e["@type"].substr(1) : e["@type"];return this.create({ type_url: "/" + r, value: t.encode(t.fromObject(e)).finish() });}}return this.fromObject(e);}, toObject: function toObject(e, t) {if (t && t.json && e.type_url && e.value) {var r = e.type_url.substring(e.type_url.lastIndexOf("/") + 1),n = this.lookup(r);n && (e = n.decode(e.value));}if (!(e instanceof this.ctor) && e instanceof o) {var i = e.$type.toObject(e, t);return i["@type"] = e.$type.fullName, i;}return this.toObject(e, t);} };}, function (e, t, r) {"use strict";e.exports = h;var n = r(30);((h.prototype = Object.create(n.prototype)).constructor = h).className = "Root";var o,i,s,a = r(22),c = r(11),u = r(48),l = r(5);function h(e) {n.call(this, "", e), this.deferred = [], this.files = [];}function d() {}h.fromJSON = function (e, t) {return t || (t = new h()), e.options && t.setOptions(e.options), t.addJSON(e.nested);}, h.prototype.resolvePath = l.path.resolve, h.prototype.load = function e(t, r, n) {"function" == typeof r && (n = r, r = void 0);var o = this;if (!n) return l.asPromise(e, o, t, r);var a = n === d;function c(e, t) {if (n) {var r = n;if (n = null, a) throw e;r(e, t);}}function u(e, t) {try {if (l.isString(t) && "{" === t.charAt(0) && (t = JSON.parse(t)), l.isString(t)) {i.filename = e;var n,s = i(t, o, r),u = 0;if (s.imports) for (; u < s.imports.length; ++u) {(n = o.resolvePath(e, s.imports[u])) && h(n);}if (s.weakImports) for (u = 0; u < s.weakImports.length; ++u) {(n = o.resolvePath(e, s.weakImports[u])) && h(n, !0);}} else o.setOptions(t.options).addJSON(t.nested);} catch (e) {c(e);}a || g || c(null, o);}function h(e, t) {var r = e.lastIndexOf("google/protobuf/");if (r > -1) {var i = e.substring(r);i in s && (e = i);}if (!(o.files.indexOf(e) > -1)) if (o.files.push(e), e in s) a ? u(e, s[e]) : (++g, setTimeout(function () {--g, u(e, s[e]);}));else if (a) {var h;try {h = l.fs.readFileSync(e).toString("utf8");} catch (e) {return void (t || c(e));}u(e, h);} else ++g, l.fetch(e, function (r, i) {--g, n && (r ? t ? g || c(null, o) : c(r) : u(e, i));});}var g = 0;l.isString(t) && (t = [t]);for (var p, f = 0; f < t.length; ++f) {(p = o.resolvePath("", t[f])) && h(p);}if (a) return o;g || c(null, o);}, h.prototype.loadSync = function (e, t) {if (!l.isNode) throw Error("not supported");return this.load(e, t, d);}, h.prototype.resolveAll = function () {if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function (e) {return "'extend " + e.extend + "' in " + e.parent.fullName;}).join(", "));return n.prototype.resolveAll.call(this);};var g = /^[A-Z]/;function p(e, t) {var r = t.parent.lookup(t.extend);if (r) {var n = new a(t.fullName, t.id, t.type, t.rule, void 0, t.options);return n.declaringField = t, t.extensionField = n, r.add(n), !0;}return !1;}h.prototype._handleAdd = function (e) {if (e instanceof a) void 0 === e.extend || e.extensionField || p(0, e) || this.deferred.push(e);else if (e instanceof c) g.test(e.name) && (e.parent[e.name] = e.values);else if (!(e instanceof u)) {if (e instanceof o) for (var t = 0; t < this.deferred.length;) {p(0, this.deferred[t]) ? this.deferred.splice(t, 1) : ++t;}for (var r = 0; r < e.nestedArray.length; ++r) {this._handleAdd(e._nestedArray[r]);}g.test(e.name) && (e.parent[e.name] = e);}}, h.prototype._handleRemove = function (e) {if (e instanceof a) {if (void 0 !== e.extend) if (e.extensionField) e.extensionField.parent.remove(e.extensionField), e.extensionField = null;else {var t = this.deferred.indexOf(e);t > -1 && this.deferred.splice(t, 1);}} else if (e instanceof c) g.test(e.name) && delete e.parent[e.name];else if (e instanceof n) {for (var r = 0; r < e.nestedArray.length; ++r) {this._handleRemove(e._nestedArray[r]);}g.test(e.name) && delete e.parent[e.name];}}, h._configure = function (e, t, r) {o = e, i = t, s = r;};}, function (e, t, r) {"use strict";function n(e, t, r, n, o, i) {o[0] = i.b = n[0], o[1] = i.a = -t * i.b + n[1];for (var s = 2; s < e; s++) {o[s] = -(t * i.a + r * i.b) + n[s], i.b = i.a, i.a = o[s];}}function o(e, t, r, o, i, s, a, c, u) {var l = new Object(),h = 3;return l.b = l.a = 0, n(t, a, c, s, u, l), i.c = l.a, i.d = l.b, Math.abs(i.c) <= 100 * e * Math.abs(s[t - 1]) && Math.abs(i.d) <= 100 * e * Math.abs(s[t - 2]) || (i.h = c * o, Math.abs(i.d) >= Math.abs(i.c) ? (h = 2, i.e = r / i.d, i.f = i.c / i.d, i.g = a * o, i.a3 = i.e * (i.g + r) + i.h * (o / i.d), i.a1 = -r + i.f * o, i.a7 = i.h + (i.f + a) * r) : (h = 1, i.e = r / i.c, i.f = i.d / i.c, i.g = i.e * a, i.a3 = i.e * r + (i.g + i.h / i.c) * o, i.a1 = -r * (i.d / i.c) + o, i.a7 = i.g * i.d + i.h * i.f + r)), h;}function i(e, t, r, n, o, i, s, a, c) {var u;if (3 != r) {if (u = 1 == r ? o : n, Math.abs(i.a1) > 10 * e * Math.abs(u)) for (i.a7 /= i.a1, i.a3 /= i.a1, s[0] = c[0], s[1] = -c[0] * i.a7 + c[1], l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3 + c[l];} else for (s[0] = 0, s[1] = -c[0] * i.a7, l = 2; l < t; l++) {s[l] = -c[l - 1] * i.a7 + a[l - 2] * i.a3;}} else {s[1] = s[0] = 0;for (var l = 2; l < t; l++) {s[l] = a[l - 2];}}}function s(e, t, r, n, o, i, s, a, c, u, l, h, d, g, p, f, v) {var _, y, m, E, x, R, A, P;t.b = t.a = 0, 3 != e && (2 != e ? (_ = r + d * s + h * u, y = a + (d + g * u) * c) : (_ = (r + l) * u + h, y = (u + d) * a + g * c), 0 != (P = -(A = -((x = (m = -p[f - 1] / v[f]) * i) + (R = m * m * o)) + g * (E = -(p[f - 2] + m * v[f - 1]) / v[f]) * n) + y + m * _) && (t.a = -(d * (R + x) + g * (m * n + E * i)) / P + d, t.b = g * (1 + A / P)));}function a(e, t, r, n) {var o, i, s;n.sr = n.si = n.lr = n.li = 0, 0 != e ? 0 != r ? (o = t / 2, Math.abs(o) < Math.abs(r) ? (s = -(s = r >= 0 ? e : -e) + o * (o / Math.abs(r)), i = Math.sqrt(Math.abs(s)) * Math.sqrt(Math.abs(r))) : (s = -e / o * (r / o) + 1, i = Math.sqrt(Math.abs(s)) * Math.abs(o)), s >= 0 ? (i = o >= 0 ? -i : i, n.lr = (-o + i) / e, n.sr = 0 != n.lr ? r / n.lr / e : n.sr) : (n.lr = n.sr = -o / e, n.si = Math.abs(i / e), n.li = -n.si)) : n.lr = -t / e : n.sr = 0 != t ? -r / t : n.sr;}function c(e, t, r, c, u, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b = new Object(),L = 0,O = 0;r.NZ = 0, R = c, P = u;do {if (b.li = b.lr = b.si = b.sr = 0, a(1, R, P, b), r.szr = b.sr, r.szi = b.si, r.lzr = b.lr, r.lzi = b.li, Math.abs(Math.abs(r.szr) - Math.abs(r.lzr)) > .01 * Math.abs(r.lzr)) break;for (n(h, R, P, g, l, d), y = Math.abs(-r.szr * d.b + d.a) + Math.abs(r.szi * d.b), T = Math.sqrt(Math.abs(P)), _ = 2 * Math.abs(l[0]), x = -r.szr * d.b, C = 1; C < t; C++) {_ = _ * T + Math.abs(l[C]);}if (y <= 20 * (_ = (9 * (_ = _ * T + Math.abs(x + d.a)) + 2 * Math.abs(x) - 7 * (Math.abs(d.a + x) + T * Math.abs(d.b))) * e)) {r.NZ = 2;break;}if (++L > 20) break;if (L >= 2 && E <= .01 && y >= m && !O) {for (n(h, R -= R * (E = E < e ? Math.sqrt(e) : Math.sqrt(E)), P += P * E, g, l, d), C = 0; C < 5; C++) {i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l);}O = 1, L = 0;}m = y, i(e, t, o(e, t, d.a, d.b, f, v, R, P, p), d.a, d.b, f, v, p, l), s(o(e, t, d.a, d.b, f, v, R, P, p), d, d.a, f.a1, f.a3, f.a7, d.b, f.c, f.d, f.f, f.g, f.h, R, P, v, t, g), A = d.a, 0 != (V = d.b) && (E = Math.abs((-P + V) / V), R = A, P = V);} while (0 != V);}function u(e, t, r, n, o, i, s, a, c) {var u,l,h,d,g,p,f,v,_,y,m,E = n - 1;for (t.NZ = m = _ = 0, f = r.a;;) {for (s[0] = p = o[0], y = 1; y < i; y++) {s[y] = p = p * f + o[y];}for (h = Math.abs(p), d = Math.abs(f), u = .5 * Math.abs(s[0]), y = 1; y < i; y++) {u = u * d + Math.abs(s[y]);}if (h <= 20 * e * (2 * u - h)) {t.NZ = 1, t.szr = f, t.szi = 0;break;}if (++m > 10) break;if (m >= 2 && Math.abs(v) <= .001 * Math.abs(-v + f) && h > g) {_ = 1, t.a = f;break;}for (g = h, c[0] = l = a[0], y = 1; y < n; y++) {c[y] = l = l * f + a[y];}if (Math.abs(l) > 10 * Math.abs(a[E]) * e) for (v = -p / l, a[0] = s[0], y = 1; y < n; y++) {a[y] = v * c[y - 1] + s[y];} else for (a[0] = 0, y = 1; y < n; y++) {a[y] = c[y - 1];}for (l = a[0], y = 1; y < n; y++) {l = l * f + a[y];}f += v = Math.abs(l) > 10 * Math.abs(a[E]) * e ? -p / l : 0;}return _;}function l(e, t, r, a, l, h, d, g, p, f, v) {var _,y,m,E,x,R,A,P,V,T,C,b,L,O,S,M,w,N,F,I,D,j,B,U,k,G,z,Y,K = new Object(),q = new Object(),W = new Array(t),H = new Array(t);for (v.NZ = 0, E = m = .25, S = -2 * a, x = a, P = w = l, q.h = q.g = q.f = q.e = q.d = q.c = q.a7 = q.a3 = q.a1 = K.b = K.a = 0, n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W), B = 0; B < r; B++) {if (i(e, d, G, _, y, q, h, W, f), s(G = o(e, d, _, y, q, h, S, w, W), K, _, q.a1, q.a3, q.a7, y, q.c, q.d, q.f, q.g, q.h, S, w, h, d, g), M = K.a, F = N = K.b, T = 0 != h[d - 1] ? -g[d] / h[d - 1] : 0, C = L = 1, 0 != B && 3 != G && (z = (O = (L = 0 != F ? Math.abs((F - P) / F) : L) < A ? L * A : 1) < E ? 1 : 0, (U = (b = (C = 0 != T ? Math.abs((T - x) / T) : C) < R ? C * R : 1) < m ? 1 : 0) || z)) {for (D = 0; D < d; D++) {H[D] = h[D];}V = T, k = Y = 0, I = 1;do {if (j = 1, I && 0 == (I = 0) && U && (!z || b < O)) ;else {if (c(e, d, v, M, N, f, p, K, g, W, q, h), _ = K.a, y = K.b, v.NZ > 0) return;if (Y = 1, E *= .25, k || !U) j = 0;else for (D = 0; D < d; D++) {h[D] = H[D];}}if (0 != j) {if (K.a = V, j = u(e, v, K, d, g, p, f, h, W), V = K.a, v.NZ > 0) return;if (k = 1, m *= .25, 0 != j) {M = -(V + V), N = V * V;continue;}}for (D = 0; D < d; D++) {h[D] = H[D];}} while (z && !Y);n(p, S, w, g, f, K), G = o(e, d, _ = K.a, y = K.b, q, h, S, w, W);}P = F, x = T, A = L, R = C;}}Object.defineProperty(t, "__esModule", { value: !0 }), t.getRealPolynomialRoots = function (e) {var t = { Degree: e.length - 1 },r = new Array(e.length),n = new Array(e.length);!function (e, t, r, n) {var o,i,s,c,u,h,d,g,p,f,v,_,y,m,E,x,R,A,P,V,T,C,b = e.Degree,L = Math.LN2,O = e.Degree + 1,S = new Array(O),M = new Array(O),w = new Array(O),N = new Array(O),F = new Object(),I = new Object();_ = 1;do {i = _, y = 1 + (_ /= 2);} while (y > 1);var D = 117549435082229e-52 / i,j = Math.cos(1.6406094968746698),B = Math.sin(1.6406094968746698),U = Math.sqrt(.5),k = -U;for (I.NZ = R = 0, I.szr = I.szi = I.lzr = I.lzi = 0; 0 == t[b];) {r[R] = n[R] = 0, b--, R++;}for (T = b + 1; b >= 1;) {if (b <= 2) {b < 2 ? (r[e.Degree - 1] = -t[1] / t[0], n[e.Degree - 1] = 0) : (F.li = F.lr = F.si = F.sr = 0, a(t[0], t[1], t[2], F), r[e.Degree - 2] = F.sr, n[e.Degree - 2] = F.si, r[e.Degree - 1] = F.lr, n[e.Degree - 1] = F.li);break;}for (d = 0, g = 340282346638529e24, G = 0; G < T; G++) {(f = Math.abs(t[G])) > d && (d = f), 0 != f && f < g && (g = f);}if (((p = D / g) <= 1 && d >= 10 || p > 1 && 340282346638529e24 / p >= d) && (p = 0 == p ? 117549435082229e-52 : p, P = Math.floor(Math.log(p) / L + .5), 1 != (u = Math.pow(2, P)))) for (G = 0; G < T; G++) {t[G] *= u;}for (var G = 0; G < T; G++) {M[G] = Math.abs(t[G]);}M[b] = -M[b], V = b - 1, f = Math.exp((Math.log(-M[b]) - Math.log(M[0])) / b), 0 != M[V] && (f = (v = -M[b] / M[V]) < f ? v : f), v = f;do {for (v = .1 * (f = v), h = M[0], G = 1; G < T; G++) {h = h * v + M[G];}} while (h > 0);for (c = f; Math.abs(c / f) > .005;) {for (s = h = M[0], G = 1; G < b; G++) {s = f * s + (h = f * h + M[G]);}f -= c = (h = f * h + M[b]) / s;}for (o = f, G = 1; G < b; G++) {S[G] = (b - G) * t[G] / b;}for (S[0] = t[0], _ = t[b], y = t[V], C = 0 == S[V] ? 1 : 0, A = 0; A < 5; A++) {if (m = S[V], C) {for (G = 0; G < V; G++) {S[R = V - G] = S[R - 1];}S[0] = 0, C = 0 == S[V] ? 1 : 0;} else {for (E = -_ / m, G = 0; G < V; G++) {S[R = V - G] = E * S[R - 1] + t[R];}S[0] = t[0], C = Math.abs(S[V]) <= Math.abs(y) * i * 10 ? 1 : 0;}}for (G = 0; G < b; G++) {N[G] = S[G];}for (A = 1; A <= 20; A++) {if (x = -B * k + j * U, k = B * U + j * k, l(i, O, 20 * A, o * (U = x), o, S, b, t, T, w, I), 0 != I.NZ) {for (r[R = e.Degree - b] = I.szr, n[R] = I.szi, b = (T -= I.NZ) - 1, G = 0; G < T; G++) {t[G] = w[G];}1 != I.NZ && (r[R + 1] = I.lzr, n[R + 1] = I.lzi);break;}for (G = 0; G < b; G++) {S[G] = N[G];}}if (A > 20) {e.Degree -= b;break;}}}(t, e, r, n);for (var o = [], i = e.length - t.Degree - 1; i < e.length; i++) {Math.abs(n[i]) < 1e-8 && o.push(r[i]);}return o;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.relaxBCurveToPerpendicular = t.closestBCurveSegments = t.maxDistanceSqrToHull = t.minDistanceSqrToHull = void 0;var n = r(1),o = r(0),i = r(37),s = r(35),a = function a(e, t) {var r,i = t.length / 3,s = n.Vector3.asFloat64(0, 0, 0);for (r = 0; r < i; ++r) {s[0] += t[3 * r], s[1] += t[3 * r + 1], s[2] += t[3 * r + 2];}n.Vector3.scale(s, s, 1 / i), n.Vector3.sub(s, s, e);var a = n.Vector3.squaredLength(s);if (a < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) return 0;var c = Number.POSITIVE_INFINITY;for (r = 0; r < i; ++r) {var u = s[0] * (t[3 * r] - e[0]) + s[1] * (t[3 * r + 1] - e[1]) + s[2] * (t[3 * r + 2] - e[2]);u < c && (c = u);}return c <= 0 ? 0 : c * c / a;},c = function c(e, t) {for (var r = t.length / 3, n = 0, o = 0; o < r; ++o) {var i = t[3 * o] - e[0],s = t[3 * o + 1] - e[1],a = t[3 * o + 2] - e[2],c = i * i + s * s + a * a;c > n && (n = c);}return n;};t.minDistanceSqrToHull = a, t.maxDistanceSqrToHull = c, t.closestBCurveSegments = function (e, t, r, o) {for (var i = Number.POSITIVE_INFINITY, s = [], u = 0; u < t.length; ++u) {var l,h = t[u],d = h.getRangeUnlimited();if (o) {l = !1;for (var g = 0; g < o.length; ++g) {if (d[1] >= o[g][0] + n.FLOAT64_TOLERANCE && d[0] <= o[g][1] - n.FLOAT64_TOLERANCE) {l = !0;break;}}} else l = !0;if (l) {var p = r ? r[u] : 0,f = h.getControlPoints(),v = a(e, f);if ((v = Math.max(0, v - p)) <= i) {var _ = c(e, f) + p;s.push({ index: u, minDistSqr: v, maxDistSqr: _ }), _ < i && (i = _);}}}return (s = s.filter(function (e) {return e.minDistSqr <= i;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.relaxBCurveToPerpendicular = function (e, t, r, o, a, c, u, l) {var h = u || n.FLOAT64_TOLERANCE,d = l || 32,g = t.length / 3,p = e.length - g - 1;return (0, s.newtonRaphson1D)(function (n) {var s = (0, i.evaluateBCurveDerivs)(n, 2, p, e, t, r),a = s[0],c = s[1],u = s[2],l = [a[0] - o[0], a[1] - o[1], a[2] - o[2]];return { val: 2 * (l[0] * c[0] + l[1] * c[1] + l[2] * c[2]), deriv: 2 * (l[0] * u[0] + l[1] * u[1] + l[2] * u[2] + (c[0] * c[0] + c[1] * c[1] + c[2] * c[2])) };}, c, a, h, d);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Sphere = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._radius = 0, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.SPHERE;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._radius = e._radius, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._radius = t;var s = void 0 === r || n.Vector3.squaredLength(r) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE,a = void 0 === o || n.Vector3.squaredLength(o) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE;s && a ? (n.Vector3.set(this._xAxis, 1, 0, 0), n.Vector3.set(this._zAxis, 0, 0, 1)) : s ? (n.Vector3.normalize(this._xAxis, o), n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)) : a ? (n.Vector3.normalize(this._zAxis, r), n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)) : (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(r, o, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, o), n.Vector3.normalize(this._zAxis, r)), this._computeYAxis();}, l.prototype.getRadius = function () {return this._radius;}, l.prototype.setRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._radius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), (n.Vector3.squaredLength(this._zAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._zAxis, this._xAxis), n.Vector3.normalize(this._zAxis, this._zAxis)), this._computeYAxis();}, l.prototype.evaluatePosition = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = this._radius * o * s,c = this._radius * o * i,u = this._radius * r,l = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(l, l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = Math.cos(t),a = -this._radius * r * s,c = -this._radius * r * i,u = this._radius * o,l = n.Vector3.createFloat64();return n.Vector3.scale(l, this._xAxis, a), n.Vector3.scaleAndAdd(l, l, this._yAxis, c), n.Vector3.scaleAndAdd(l, l, this._zAxis, u), l;}, l.prototype.evaluateDv = function (e, t) {var r = Math.cos(e),o = Math.sin(t),i = Math.cos(t),s = -this._radius * r * o,a = this._radius * r * i,c = n.Vector3.createFloat64();return n.Vector3.scale(c, this._xAxis, s), n.Vector3.scaleAndAdd(c, c, this._yAxis, a), c;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.length(t);if (r < i.KERNEL_TOLERANCE) return { u: 0, v: 0 };var s = n.Vector3.dot(t, this._xAxis),a = n.Vector3.dot(t, this._yAxis),c = n.Vector3.dot(t, this._zAxis);return { u: Math.asin((0, o.clamp)(c / r, -1, 1)), v: Math.atan2(a, s) };}, l.prototype.vParamLine = function (e) {var t = Math.cos(e),r = Math.sin(e),o = this._radius * t,s = this._radius * r;if (Math.abs(o) > i.KERNEL_TOLERANCE) {var u = new c.Circle(),l = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(l, l, this._zAxis, s);var h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, o);var d = n.Vector3.clone(this._zAxis);return n.Vector3.negate(d, d), u.set(l, d, h), u;}var g = n.Vector3.clone(this._center);return s = s < 0 ? -this._radius : this._radius, n.Vector3.scaleAndAdd(g, g, this._zAxis, s), new a.Point(g);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._radius * o,s = this._radius * r,a = n.Vector3.clone(this._xAxis);n.Vector3.scale(a, a, -s), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.normalize(a, a);var u = n.Vector3.clone(this._xAxis);return n.Vector3.scale(u, u, i), n.Vector3.scaleAndAdd(u, u, this._yAxis, s), t.set(this._center, a, u), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || [-Math.PI / 2, Math.PI / 2], t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = 0; l < 3; ++l) {for (var h = 0; h < 2; ++h) {var d = 0 === h ? 1 : -1,g = Math.atan2(d * this._yAxis[l], d * this._xAxis[l]),p = Math.asin(d * this._zAxis[l]);g = (0, o.adjustParameterToPeriodicRange)(g, t, o.PI2), p > r && p < i && g > s && g < a && (n.Vector3.set(u, 0, 0, 0), u[l] = d * this._radius, c.includePoint(n.Vector3.add(u, this._center, u)));}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._radius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return [-Math.PI / 2, Math.PI / 2];}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return !1;}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return !1;}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), radius: this.vectorToObject(e), axis: this.vectorToObject(this.getAxisDir()), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Sphere = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Torus = void 0;var n = r(1),o = r(3),i = r(0),s = r(12),a = r(6),c = r(14),u = r(2),l = function l() {s.Surface.call(this), this._center = n.Vector3.createFloat64(), this._majorRadius = 0, this._minorRadius = 0, this._lemon = !1, this._xAxis = n.Vector3.createFloat64(), this._yAxis = n.Vector3.createFloat64(), this._zAxis = n.Vector3.createFloat64();};(l.prototype = Object.create(s.Surface.prototype)).getGeometryType = function () {return i.GEOMETRY_TYPES.TORUS;}, l.prototype.clone = function () {var e = new l();return e.copy(this), e;}, l.prototype.copy = function (e) {s.Surface.prototype.copy.call(this, e), this._majorRadius = e._majorRadius, this._minorRadius = e._minorRadius, this._lemon = e._lemon, n.Vector3.copy(this._center, e._center), n.Vector3.copy(this._xAxis, e._xAxis), n.Vector3.copy(this._yAxis, e._yAxis), n.Vector3.copy(this._zAxis, e._zAxis);}, l.prototype._computeYAxis = function () {n.Vector3.cross(this._yAxis, this._xAxis, this._zAxis);}, l.prototype.set = function (e, t, r, o, s, a) {n.Vector3.copy(this._center, e), u.ConsoleUtils.assert(t > i.KERNEL_TOLERANCE), this._majorRadius = t, u.ConsoleUtils.assert(r > i.KERNEL_TOLERANCE), this._minorRadius = r, u.ConsoleUtils.assert(n.Vector3.squaredLength(o) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, o), void 0 !== s && n.Vector3.squaredLength(s) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? (u.ConsoleUtils.assert(n.Vector3.isOrthogonal(o, s, i.KERNEL_ANGULAR_TOLERANCE)), n.Vector3.normalize(this._xAxis, s)) : (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._lemon = !0 === a, this._computeYAxis();}, l.prototype.getMajorRadius = function () {return this._majorRadius;}, l.prototype.setMajorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._majorRadius = e;}, l.prototype.getMinorRadius = function () {return this._minorRadius;}, l.prototype.setMinorRadius = function (e) {u.ConsoleUtils.assert(e > i.KERNEL_TOLERANCE), this._minorRadius = e;}, l.prototype.getCenter = function () {return this._center;}, l.prototype.setCenter = function (e) {n.Vector3.copy(this._center, e);}, l.prototype.getAxisDir = function () {return this._zAxis;}, l.prototype.setAxisDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._zAxis, e), (n.Vector3.squaredLength(this._xAxis) <= i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE || !n.Vector3.isOrthogonal(this._xAxis, this._zAxis, i.KERNEL_ANGULAR_TOLERANCE)) && (n.Vector3.computeOrthogonal(this._xAxis, this._zAxis), n.Vector3.normalize(this._xAxis, this._xAxis)), this._computeYAxis();}, l.prototype.getUvOriginDir = function () {return this._xAxis;}, l.prototype.setUvOriginDir = function (e) {u.ConsoleUtils.assert(n.Vector3.squaredLength(e) > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE), n.Vector3.normalize(this._xAxis, e), this._computeYAxis();}, l.prototype.isDoughnut = function () {return this._majorRadius > this._minorRadius + i.KERNEL_TOLERANCE;}, l.prototype.isVortex = function () {return Math.abs(this._majorRadius - this._minorRadius) <= i.KERNEL_TOLERANCE;}, l.prototype.isApple = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && !this._lemon;}, l.prototype.isLemon = function () {return this._majorRadius < this._minorRadius - i.KERNEL_TOLERANCE && this._lemon;}, l.prototype.setLemon = function (e) {this._lemon = e;}, l.prototype.getSingularUParams = function () {var e, t, r;return this.isDoughnut() ? [] : this.isApple() ? (e = -this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : this.isLemon() ? (e = this._minorRadius - this._majorRadius, t = this._minorRadius, [-(r = Math.acos(e / t)), r]) : [-Math.PI, Math.PI];}, l.prototype.evaluatePosition = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.sin(e),a = n.Vector3.clone(this._center);return n.Vector3.scaleAndAdd(a, a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateNormal = function (e, t) {var r = Math.sin(e),o = Math.cos(e),i = Math.sin(t),s = o * Math.cos(t),a = o * i,c = r,u = n.Vector3.createFloat64();return n.Vector3.scale(u, this._xAxis, s), n.Vector3.scaleAndAdd(u, u, this._yAxis, a), n.Vector3.scaleAndAdd(u, u, this._zAxis, c), u;}, l.prototype.evaluateDu = function (e, t) {var r = -this._minorRadius * Math.sin(e),o = r * Math.cos(t),i = r * Math.sin(t),s = this._minorRadius * Math.cos(e),a = n.Vector3.createFloat64();return n.Vector3.scale(a, this._xAxis, o), n.Vector3.scaleAndAdd(a, a, this._yAxis, i), n.Vector3.scaleAndAdd(a, a, this._zAxis, s), a;}, l.prototype.evaluateDv = function (e, t) {var r = this._minorRadius * Math.cos(e);this.isLemon() ? r -= this._majorRadius : r += this._majorRadius;var o = -r * Math.sin(t),i = r * Math.cos(t),s = n.Vector3.createFloat64();return n.Vector3.scale(s, this._xAxis, o), n.Vector3.scaleAndAdd(s, s, this._yAxis, i), s;}, l.prototype.closestParam = function (e) {var t = n.Vector3.createFloat64();n.Vector3.sub(t, e, this._center);var r = n.Vector3.dot(t, this._xAxis),o = n.Vector3.dot(t, this._yAxis),s = n.Vector3.dot(t, this._zAxis),a = Math.sqrt(r * r + o * o);return this.isLemon() ? a += this._majorRadius : a -= this._majorRadius, { u: s * s + a * a > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(s, a) : 0, v: r * r + o * o > i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE ? Math.atan2(o, r) : 0 };}, l.prototype.vParamLine = function (e) {var t = this._minorRadius * Math.cos(e);this.isLemon() ? t -= this._majorRadius : t += this._majorRadius;var r = this._minorRadius * Math.sin(e);if (Math.abs(t) > i.KERNEL_TOLERANCE) {var o = new c.Circle(),s = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(s, s, this._zAxis, r);var u = n.Vector3.clone(this._xAxis);n.Vector3.scale(u, u, t);var l = n.Vector3.clone(this._zAxis);return n.Vector3.negate(l, l), o.set(s, l, u), o;}var h = n.Vector3.clone(this._center),d = this.getSingularUParams();return d[0] && r < 0 ? r = this._minorRadius * Math.sin(d[0]) : d[1] && r > 0 && (r = this._minorRadius * Math.sin(d[1])), n.Vector3.scaleAndAdd(h, h, this._zAxis, r), new a.Point(h);}, l.prototype.uParamLine = function (e) {var t = new c.Circle(),r = Math.sin(e),o = Math.cos(e),i = this._majorRadius * o,s = this._majorRadius * r;this.isLemon() && (i = -i, s = -s);var a = n.Vector3.clone(this._center);n.Vector3.scaleAndAdd(a, a, this._xAxis, i), n.Vector3.scaleAndAdd(a, a, this._yAxis, s);var u = this._minorRadius * o,l = this._minorRadius * r,h = n.Vector3.clone(this._xAxis);n.Vector3.scale(h, h, -l), n.Vector3.scaleAndAdd(h, h, this._yAxis, u), n.Vector3.normalize(h, h);var d = n.Vector3.clone(this._xAxis);return n.Vector3.scale(d, d, u), n.Vector3.scaleAndAdd(d, d, this._yAxis, l), t.set(a, h, d), t;}, l.prototype.getBoundingBox = function (e, t) {e = e || (this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams()), t = t || [-Math.PI, Math.PI];var r = e[0],i = e[1],s = t[0],a = t[1],c = this.vParamLine(r).getBoundingBox(t);c.include(this.vParamLine(i).getBoundingBox(t)), c.include(this.uParamLine(s).getBoundingBox(e)), c.include(this.uParamLine(a).getBoundingBox(e));for (var u = n.Vector3.createFloat64(), l = n.Vector3.createFloat64(), h = 0; h < 3; ++h) {for (var d = 0; d < 2; ++d) {var g = 0 === d ? -1 : 1,p = Math.atan2(g * this._yAxis[h], g * this._xAxis[h]);if ((p = (0, o.adjustParameterToPeriodicRange)(p, t, o.PI2)) > s && p < a) {var f = this.uParamLine(p);u = f.evaluatePosition(0), n.Vector3.sub(u, u, f.getCenter()), l = f.evaluatePosition(Math.PI / 2), n.Vector3.sub(l, l, f.getCenter());var v = (0, o.minMaxCosSinFunc)(u[h], l[h], f.getCenter()[h], e);0 === h ? c.includeX(v[d]) : 1 === h ? c.includeY(v[d]) : c.includeZ(v[d]);}}}return c;}, l.prototype.transform = function (e) {n.Vector3.transformMatrix44(this._center, this._center, e), n.Vector3.transformAsDirectionMatrix44(this._xAxis, this._xAxis, e), n.Vector3.transformAsDirectionMatrix44(this._yAxis, this._yAxis, e), n.Vector3.transformAsDirectionMatrix44(this._zAxis, this._zAxis, e);var t = n.Vector3.length(this._xAxis);this._majorRadius *= t, this._minorRadius *= t, n.Vector3.normalize(this._xAxis, this._xAxis), n.Vector3.normalize(this._yAxis, this._yAxis), n.Vector3.normalize(this._zAxis, this._zAxis);}, l.prototype.getRangeUnlimitedU = function () {return this.isDoughnut() ? [-Math.PI, Math.PI] : this.getSingularUParams();}, l.prototype.getRangeUnlimitedV = function () {return [-Math.PI, Math.PI];}, l.prototype.isPeriodicUnlimitedU = function () {return this.isDoughnut();}, l.prototype.isPeriodicUnlimitedV = function () {return !0;}, l.prototype.isClosedUnlimitedU = function () {return this.isDoughnut() || this.isVortex();}, l.prototype.isClosedUnlimitedV = function () {return !0;}, l.prototype.toObject = function () {var e = this.evaluatePosition(0, 0);return n.Vector3.sub(e, e, this.getCenter()), { center: this.vectorToObject(this.getCenter()), coordAxis: this.vectorToObject(this.getUvOriginDir()), axis: this.vectorToObject(this.getAxisDir()), majorRadius: this.getMajorRadius(), minorRadius: this.getMinorRadius(), lemon: this.isLemon(), uRange: this.rangeToObject(this.getRangeU(), this.isLimitedU()), vRange: this.rangeToObject(this.getRangeV(), this.isLimitedV()) };}, t.Torus = l;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.evaluateBSurfaceDerivs = t.evaluateBSurfacePoint = void 0;var n = r(1),o = r(3),i = r(17),s = r(37);t.evaluateBSurfacePoint = function (e, t, r, o, a, c, u, l) {return l && l.length > 0 ? function (e, t, r, o, a, c, u, l) {for (var h, d = c.length - o - 1, g = (0, i.findKnotSpan)(e, a), p = (0, s.evaluateBasisFunctions)(g, e, r, a), f = (0, i.findKnotSpan)(t, c), v = (0, s.evaluateBasisFunctions)(f, t, o, c), _ = g - r, y = n.Vector4.createFloat64(), m = n.Vector4.createFloat64(), E = 0; E <= o; E++) {n.Vector4.set(m, 0, 0, 0, 0), h = f - o + E;for (var x = 0; x <= r; x++) {var R = (_ + x) * d + h,A = p[x] * l[R];m[0] += A * u[3 * R], m[1] += A * u[3 * R + 1], m[2] += A * u[3 * R + 2], m[3] += A;}y[0] += v[E] * m[0], y[1] += v[E] * m[1], y[2] += v[E] * m[2], y[3] += v[E] * m[3];}return n.Vector3.createFloat64FromValues(y[0] / y[3], y[1] / y[3], y[2] / y[3]);}(e, t, r, o, a, c, u, l) : function (e, t, r, o, a, c, u) {for (var l, h = c.length - o - 1, d = (0, i.findKnotSpan)(e, a), g = (0, s.evaluateBasisFunctions)(d, e, r, a), p = (0, i.findKnotSpan)(t, c), f = (0, s.evaluateBasisFunctions)(p, t, o, c), v = d - r, _ = n.Vector3.createFloat64(), y = n.Vector3.createFloat64(), m = 0; m <= o; m++) {n.Vector3.set(y, 0, 0, 0), l = p - o + m;for (var E = 0; E <= r; E++) {var x = (v + E) * h + l;y[0] += g[E] * u[3 * x], y[1] += g[E] * u[3 * x + 1], y[2] += g[E] * u[3 * x + 2];}_[0] += f[m] * y[0], _[1] += f[m] * y[1], _[2] += f[m] * y[2];}return _;}(e, t, r, o, a, c, u);}, t.evaluateBSurfaceDerivs = function (e, t, r, a, c, u, l, h, d) {return function (e, t, r, a, c, u, l, h, d) {var g,p,f,v,_,y,m = new Array(r + 1),E = new Array(r + 1),x = new Array(r + 1),R = new Array(r + 1);for (g = 0; g <= r; g++) {for (m[g] = new Array(r + 1 - g), E[g] = new Array(r + 1 - g), p = 0; p <= r - g; p++) {m[g][p] = n.Vector3.createFloat64(), E[g][p] = 0;}x[g] = new Array(a + 1), R[g] = new Array(c + 1);}var A = Math.min(r, a),P = (0, i.findKnotSpan)(e, u);(0, s.evaluateBasisDerivatives)(P, e, a, A, u, x);var V = Math.min(r, c),T = (0, i.findKnotSpan)(t, l);(0, s.evaluateBasisDerivatives)(T, t, c, V, l, R);var C = d && d.length > 0,b = l.length - c - 1,L = new Array(c + 1);for (g = 0; g <= A; g++) {for (f = 0; f <= c; f++) {for (L[f] = [0, 0, 0, 0], v = 0; v <= a; v++) {var O = (P - a + v) * b + (T - c + f),S = x[g][v];C && (S *= d[O], L[f][3] += S), L[f][0] += S * h[3 * O], L[f][1] += S * h[3 * O + 1], L[f][2] += S * h[3 * O + 2];}}var M = Math.min(r - g, V);for (p = 0; p <= M; p++) {for (f = 0; f <= c; f++) {m[g][p][0] += R[p][f] * L[f][0], m[g][p][1] += R[p][f] * L[f][1], m[g][p][2] += R[p][f] * L[f][2], C && (E[g][p] += R[p][f] * L[f][3]);}}}if (C) {var w = o.binomialCoefficients,N = n.Vector3.createFloat64();for (g = 0; g <= r; g++) {for (p = 0; p <= r - g; p++) {var F = m[g][p];for (y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(F, F, m[g][p - y], -w[p][y] * E[0][y]);}for (_ = 1; _ <= g; _++) {for (n.Vector3.scaleAndAdd(F, F, m[g - _][p], -w[g][_] * E[_][0]), n.Vector3.set(N, 0, 0, 0), y = 1; y <= p; y++) {n.Vector3.scaleAndAdd(N, N, m[g - _][p - y], w[p][y] * E[_][y]);}n.Vector3.scaleAndAdd(F, F, N, -w[g][_]);}n.Vector3.scale(F, F, 1 / E[0][0]);}}}return m;}(e, t, r, a, c, u, l, h, d);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.newtonRaphson2D = t.RelaxResult = void 0;var n = r(1),o = {};o[o.Success = 0] = "Success", o[o.OutOfRange = 1] = "OutOfRange", o[o.DegenerateStep = 2] = "DegenerateStep", o[o.TooManySteps = 3] = "TooManySteps", o[o.RootNotFound = 4] = "RootNotFound", t.RelaxResult = o, t.newtonRaphson2D = function (e, t, r, i, s) {i = i || 1e-12, s = s || 100;var a = [void 0, void 0];r && 2 === r.length && (r[0] && 2 === r[0].length && (a[0] = r[0]), r[1] && 2 === r[1].length && (a[1] = r[1])), a[0] && (a[0][0], a[0][1]), a[1] && (a[1][0], a[1][1]);for (var c = [0, 0], u = 1 / 0, l = 1 / 0, h = !1, d = n.Matrix22.createFloat64(), g = n.Matrix22.createFloat64(), p = n.Vector2.clone(t), f = o.Success, v = 0; v <= s; v++) {var _ = e(p);if (u = n.Vector2.squaredLength(_.val), p[0], p[1], u < n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {f = o.Success;break;}if (v > 0) {var y = Math.max(Math.abs(c[0]), Math.abs(c[1]));if (y < i) {u >= l && (n.Vector2.sub(p, p, c), u = l, _ = e(p));var m = 10 * i * (n.Vector2.len(_.deriv1) + n.Vector2.len(_.deriv2)),E = m * m;f = u > E ? h ? o.OutOfRange : o.RootNotFound : o.Success;break;}}if (v === s) {u >= l && (n.Vector2.sub(p, p, c), u = l), f = o.TooManySteps;break;}if (v > 0 && u >= l) {var x = l / (l + u);x = Math.max(x, .1), n.Vector2.sub(p, p, c), n.Vector2.scale(c, c, x), n.Vector2.add(p, p, c), u = l;} else {if (l = u, n.Matrix22.set(d, -_.deriv1[0], -_.deriv1[1], -_.deriv2[0], -_.deriv2[1]), Math.abs(n.Matrix22.determinant(d)) < n.FLOAT64_TOLERANCE) {f = o.DegenerateStep;break;}n.Matrix22.invert(g, d), n.Vector2.transformMatrix22(c, _.val, g), c[0], c[1], n.Vector2.add(p, p, c), h = !1;for (var R = 0; R < 3; R++) {var A = R >= 2,P = R % 2;if (a[P]) {var V = 0;if (p[P] < a[P][0] ? (V = p[P] - a[P][0], p[P] = a[P][0]) : p[P] > a[P][1] && (V = p[P] - a[P][1], p[P] = a[P][1]), 0 !== V) {p[P];var T = c[P];if (c[P] -= V, A) ;else {var C = 1 - P;if (p[C] -= c[C], Math.abs(c[P]) > i) {var b = c[P] / T;c[C] *= b;} else {h = !0;var L = 0 === C ? _.deriv1 : _.deriv2;c[C] = -n.Vector2.dot(_.val, L) / Math.max(n.Vector2.dot(L, L), n.FLOAT64_TOLERANCE);}p[C] += c[C], c[0], c[1];}}}}}}return o[f], p[0], p[1], { param: p, status: f };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getOrderedFacesOnVertex = function (e) {var t = e.getEdges(),r = new n(e),o = [];return t.forEach(function (t) {var n = t.getCoedges();for (var _t6 = 0; _t6 < n.length; ++_t6) {if (n[_t6].getStartVertex() === e) {var _e3 = r.marchFan(n[_t6]);_e3.faces.length > 0 && o.push(_e3);break;}}}), o;};var n = /*#__PURE__*/function () {function n(e) {_classCallCheck(this, n);this._vertex = e, this._visitedCoeds = new Set(), this._unvisitedCoeds = new Set(), this._faces = [], this._type = "unset";}_createClass(n, [{ key: "addVisitedCoedge", value: function addVisitedCoedge(e) {this._visitedCoeds.add(e), this._unvisitedCoeds.delete(e);} }, { key: "getNextFace", value: function getNextFace(e) {var t = e.getFace();t && this._faces.push(t), this.addVisitedCoedge(e);} }, { key: "getPrevFace", value: function getPrevFace(e) {var t = e.getFace();t && this._faces.unshift(t), this.addVisitedCoedge(e);} }, { key: "collectUnvisitedCoeds", value: function collectUnvisitedCoeds(e) {var _this = this;e.getEdge().getCoedges().forEach(function (e) {_this._visitedCoeds.has(e) || e.getStartVertex() !== _this._vertex || _this._unvisitedCoeds.add(e);});} }, { key: "nextFace", value: function nextFace(e) {var t = e.getPartner();if (!t) return void ("unset" === this._type && (this._type = "chain"));if (this._visitedCoeds.has(t)) return;if (t.getPartner() !== e && (this._type = "unordered", this.collectUnvisitedCoeds(e)), t.getEndVertex() !== this._vertex) return this._type = "unordered", void this.collectUnvisitedCoeds(t);this.addVisitedCoedge(t);var r = t.getNext();if (!this._visitedCoeds.has(r)) return this.getNextFace(r), r;"unset" === this._type && (this._type = "cycle");} }, { key: "prevFace", value: function prevFace(e) {var t = e.getPrevious();if (this._visitedCoeds.has(t)) return;var r = t.getPartner();return r && !this._visitedCoeds.has(r) ? (r.getPartner() !== t && (this._type = "unordered", this.collectUnvisitedCoeds(t)), r.getStartVertex() !== this._vertex ? (this._type = "unordered", void this.collectUnvisitedCoeds(r.getNext())) : (this.addVisitedCoedge(t), this.getPrevFace(r), r)) : void 0;} }, { key: "collectFanFaces", value: function collectFanFaces(e) {if (this._visitedCoeds.has(e)) return;var t = e;this.getNextFace(t);var r = t;for (; r;) {r = this.nextFace(r);}for (r = t; r;) {r = this.prevFace(r);}} }, { key: "marchFan", value: function marchFan(e) {for (this._faces = [], this._type = "unset", this.collectFanFaces(e); this._unvisitedCoeds.size > 0;) {var _e4 = this._unvisitedCoeds.values();this.collectFanFaces(_e4.next().value);}return { faces: this._faces, type: this._type };} }]);return n;}();}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Attribute = void 0;var n = r(44);var o = { "autodesk.brep:nmiattributestr-1.0.0": "nmiattributestr", "autodesk.brep:nmiattributearr-1.0.0": "nmiattributearr", "autodesk.brep:textattribute-1.0.0": "textattribute" };var i = function i(e, t) {n.Base.call(this), this._topologies = [], this.typeid = e, this.values = t || {};};(i.prototype = Object.create(n.Base.prototype)).getValues = function () {return this.values;}, i.prototype.getTypeid = function () {return this.typeid;}, i.prototype.getTopologies = function () {return this._topologies;}, i.prototype.addTopology = function (e) {this._topologies ? this._topologies.push(e) : this._topologies = [e];}, i.prototype.removeTopology = function (e) {var t = this._topologies.indexOf(e);return t > -1 && (this._topologies.splice(t, 1), !0);}, i.prototype.toObject = function () {return this.values;}, i.prototype.addToModelObject = function (e) {if (!e.attributes[this.getGuid()]) {var _t7 = o[this.typeid];if (_t7) {var _r4 = {};_r4[_t7] = this.toObject(), e.attributes[this.getGuid()] = _r4;} else console.warn("Attribute.addToModelObject : Unknown attribute type for proto object!");}}, t.Attribute = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SketchRegionSolver = void 0;var n = r(1),o = r(3),i = r(0),s = r(18),a = r(7),c = r(14),u = r(33),l = r(23),h = r(6),d = r(13),g = r(27),p = r(81),f = r(82),v = r(56),_ = r(36),y = r(55),m = r(41),E = r(112),x = r(113),R = r(2),A = r(8),P = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),V = function V() {this.SIDE = { LEFT: 0, RIGHT: 1 }, this._sketch = void 0, this._intersectionVertices = [], this._edgeSegments = [], this._cells = [], this._faces = [], this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, edgesPerCell: void 0 }, this._sketchRegionTopologies = {}, this._planeGeometry = new s.Plane(), this._planeGeometry.set([0, 0, 0], [0, 0, 1], [1, 0, 0]), this._sketchSummary = {}, this._internalToFinalMap = null, this._finalFaces = [], this._progenitorMap = null;};V.prototype.compute = function (e) {this._sketchEdges = e, this._initializeWorkspace(), this._findIntersections(), this._addGraphEdges(), this._mergeCoincidentSegments(), this._sortEdgesAroundVertex(), this._assignAdjacentEdges(), this._sweepRegions(), this._assignleftmostEdges(), this._removeGrazingIntersectionVertices(), this._updateVertexGuidLists(), this._removeTemporaryVertices(), this._assignLoops(), this._updateSketchRegionTopology(), this._clearWorkspace(), this._prepareResult();}, V.prototype._initializeWorkspace = function () {var e = this._workspace;e.edges = {};for (var t = 0; t < this._sketchEdges.length; ++t) {e.edges[this._sketchEdges[t].getGuid()] = this._sketchEdges[t];}for (e.edgeIDs = Object.getOwnPropertyNames(e.edges).sort(), e.edgeIntersections = {}, e.edgeOverlapRegions = {}, e.segmentBlackList = {}, t = 0; t < e.edgeIDs.length; t++) {e.edgeIntersections[e.edgeIDs[t]] = [], e.edgeOverlapRegions[e.edgeIDs[t]] = [], e.segmentBlackList[e.edgeIDs[t]] = [];}e.sweepLineIntersections = void 0, e.sweepLineRegions = void 0, e.edgesPerCell = [], this._faces = [];}, V.prototype._clearWorkspace = function () {this._workspace = { edgeIntersections: [], edgeOverlapRegions: [], segmentBlackList: [], edges: [], edgeIDs: [], sweepLineIntersections: void 0, sweepLineRegions: void 0, currentVertex: void 0, nextVertex: void 0, sweepLinePosition: void 0, edgesPerCell: [] };}, V.prototype._findIntersections = function () {for (var e = this._workspace, t = 0; t < e.edgeIDs.length; t++) {for (var r = e.edges[e.edgeIDs[t]], s = t; s < e.edgeIDs.length; s++) {var a = e.edges[e.edgeIDs[s]];if (s > t || r.getCurveType() === i.GEOMETRY_TYPES.BCURVE) for (var c = (0, p.computeCurveCurveIntersections)(r, a, !0, !1, i.KERNEL_TOLERANCE), u = 0; u < c.length; u++) {var l = c[u];if (l.rangeInfo) e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[t]].push(P.default.extend(l.rangeInfo[1], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[0], { temporary: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.extend(l.rangeByInfo[1], { temporary: !1 })), e.edgeOverlapRegions[e.edgeIDs[t]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[s], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE) }), e.edgeOverlapRegions[e.edgeIDs[s]].push({ overlapRange: (0, o.convertToOtherPeriodicRange)([l.rangeByInfo[0].param, l.rangeByInfo[1].param], a.getRange(), a.getCurve().getPeriod(), i.KERNEL_TOLERANCE), otherEdge: e.edgeIDs[t], otherRange: (0, o.convertToOtherPeriodicRange)([l.rangeInfo[0].param, l.rangeInfo[1].param], r.getRange(), r.getCurve().getPeriod(), i.KERNEL_TOLERANCE) });else {if (l.cutInfo.param < r.t0() || l.cutInfo.param > r.t1()) {A.DebugUtils.warn("Intersection outside the bounds of the edge, ignoring");continue;}e.edgeIntersections[e.edgeIDs[t]].push(P.default.defaults(l.cutInfo, { temporary: !1, virtualIntersection: !1 })), e.edgeIntersections[e.edgeIDs[s]].push(P.default.defaults(l.cutByInfo, { temporary: !1, virtualIntersection: !1 }));}}}var h = r.getStartVertex(),d = r.getEndVertex(),g = r.t0();h && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: g, atVertex: h }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: g, atVertex: h, temporary: !1, virtualIntersection: void 0 });var f = r.t1();d && void 0 !== P.default.findWhere(e.edgeIntersections[e.edgeIDs[t]], { param: f, atVertex: d }) || e.edgeIntersections[e.edgeIDs[t]].push({ param: f, atVertex: d, temporary: !1, virtualIntersection: void 0 }), this._makeEdgeXMonotone(r, e.edgeIntersections[e.edgeIDs[t]]);}var v = [];for (t = 0; t < e.edgeIDs.length; t++) {for (s = 0; s < e.edgeIntersections[e.edgeIDs[t]].length; s++) {v.push({ position: e.edges[e.edgeIDs[t]].evaluatePosition(e.edgeIntersections[e.edgeIDs[t]][s].param), virtualIntersection: e.edgeIntersections[e.edgeIDs[t]][s].virtualIntersection });}}for (t = 0; t < e.edgeIDs.length; t++) {var _ = e.edges[e.edgeIDs[t]];for (s = 0; s < v.length; s++) {var y = v[s];if (_.getBoundingBox().isPointInsideWithTolerance(y.position, i.KERNEL_TOLERANCE)) {var m = _.closestToPointParam(y.position);n.Vector3.distance(y.position, _.evaluatePosition(m)) < i.KERNEL_TOLERANCE && m > _.t0() + i.PARAMETER_SPACE_TOLERANCE && m < _.t1() - i.PARAMETER_SPACE_TOLERANCE && e.edgeIntersections[e.edgeIDs[t]].push({ param: m, atVertex: null, temporary: !0, virtualIntersection: y.virtualIntersection });}}}}, V.prototype._addGraphEdges = function () {var e = this._workspace;this._intersectionVertices = [], this._edgeSegments = [];for (var t = function t(_t8, r) {var n = e.segmentBlackList[_t8],s = e.edges[_t8].getCurve(),a = s.getPeriod(),c = e.edges[_t8].isReversed() ? -1 : 1,u = i.KERNEL_TOLERANCE / s.tangentLength(c * r[0]),l = i.KERNEL_TOLERANCE / s.tangentLength(c * r[1]);if (e.edges[_t8].getCurve().isPeriodic()) {for (var h = 0; h < n.length; h++) {if ((0, o.periodicDifference)(n[h].range[0], r[0], a) < u && (0, o.periodicDifference)(n[h].range[1], r[1], a) < l) return n[h].edge;}} else for (h = 0; h < n.length; h++) {if (Math.abs(n[h].range[0] - r[0]) < u && Math.abs(n[h].range[1] - r[1]) < l) return n[h].edge;}}, r = 0; r < e.edgeIDs.length; r++) {var s = e.edges[e.edgeIDs[r]],a = 1,c = this._createGUIDfromEdgeAndLocalID(s, a);e.edgeIntersections[e.edgeIDs[r]] = e.edgeIntersections[e.edgeIDs[r]].sort(function (e, t) {return e.param - t.param;});for (var u = e.edgeIntersections[e.edgeIDs[r]], l = void 0, h = 0; h < u.length; h++) {var d = s.evaluatePosition(u[h].param),g = this._findVertexIndex(d);void 0 === g ? (g = this._intersectionVertices.length, this._intersectionVertices.push({ position: d, adjacentEdges: [], vertices: [], index: g, guidList: [], mergedPositions: [], topologyVertex: void 0, temporary: u[h].temporary, virtualIntersection: u[h].virtualIntersection })) : (this._intersectionVertices[g].temporary = this._intersectionVertices[g].temporary && u[h].temporary, void 0 !== u[h].virtualIntersection && (void 0 === this._intersectionVertices[g].virtualIntersection ? this._intersectionVertices[g].virtualIntersection = u[h].virtualIntersection : this._intersectionVertices[g].virtualIntersection = this._intersectionVertices[g].virtualIntersection && u[h].virtualIntersection), this._intersectionVertices[g].mergedPositions.push(d));var p = this._intersectionVertices[g];if (u[h].atVertex && -1 === p.vertices.indexOf(u[h].atVertex) && p.vertices.push(u[h].atVertex), h > 0 && l !== g) {c = this._createGUIDfromEdgeAndLocalID(s, a), a++;var f = [u[h - 1].param, u[h].param],v = t(s.getGuid(), f);if (void 0 === v) {var _ = { originalEdge: s, parameterRange: f, startVertex: this._intersectionVertices[l], endVertex: this._intersectionVertices[g], coincidentRanges: [], adjacent: [{ prevEdge: void 0, nextEdge: void 0, face: void 0 }, { prevEdge: void 0, nextEdge: void 0, face: void 0 }], index: this._edgeSegments.length, localGuid: c, topologyEdge: void 0 };this._edgeSegments.push(_), this._intersectionVertices[l].adjacentEdges.push(_), this._intersectionVertices[g].adjacentEdges.push(_);for (var y = 0; y < e.edgeOverlapRegions[e.edgeIDs[r]].length; y++) {var m = e.edgeOverlapRegions[e.edgeIDs[r]][y],E = f,x = i.KERNEL_TOLERANCE;if (s.getCurve().isPeriodic() && (s.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && (x /= s.getCurve().getRadius()), E = (0, o.convertToOtherPeriodicRange)(E, s.getRange(), s.getCurve().getPeriod(), x)), E[0] >= m.overlapRange[0] - i.KERNEL_TOLERANCE && E[1] <= m.overlapRange[1] + i.KERNEL_TOLERANCE) {var R = m.otherEdge,A = [e.edges[R].getCurve().closestToPointParam(_.startVertex.position), e.edges[R].getCurve().closestToPointParam(_.endVertex.position)];if (e.edges[R].getCurve().isPeriodic()) {var P = _.originalEdge.getCurve().evaluateDt(_.parameterRange[0]),V = e.edges[R].getCurve().evaluateDt(A[0]);for (n.Vector3.dot(P, V) < 0 && (T = A[0], A[0] = A[1], A[1] = T); A[1] < A[0];) {A[1] += e.edges[R].getCurve().getPeriod();}} else if (A[0] > A[1]) {var T = A[0];A[0] = A[1], A[1] = T;}e.segmentBlackList[m.otherEdge].push({ range: A, edge: _ });}}} else {var C,b = n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[0])) > n.Vector3.distance(v.startVertex.position, s.evaluatePosition(f[1]));if (v.coincidentRanges.push({ originalEdge: s, parameterRange: f, localGuid: c, flipped: b }), 0 === p.adjacentEdges.length && ((C = n.Vector3.distance(d, v.startVertex.position) < n.Vector3.distance(d, v.endVertex.position) ? v.startVertex : v.endVertex).mergedPositions.push(d), d = C.position, g = C.index, u[h].atVertex && -1 === C.vertices.indexOf(u[h].atVertex) && C.vertices.push(u[h].atVertex), this._intersectionVertices.pop()), v.startVertex.index !== l && v.endVertex.index !== l) {var L = v.startVertex.index === g ? v.endVertex : v.startVertex,O = this._intersectionVertices[l];for (y = 0; y < O.adjacentEdges.length; y++) {var S = O.adjacentEdges[y];S.startVertex === O && (S.startVertex = L), S.endVertex === O && (S.endVertex = L), L.adjacentEdges.push(S);}for (L.mergedPositions.push(O.position), y = 0; y < O.mergedPositions.length; y++) {L.mergedPositions.push(O.mergedPositions[y]);}for (u[h].atVertex && -1 === L.vertices.indexOf(u[h].atVertex) && L.vertices.push(u[h].atVertex), this._intersectionVertices.splice(l, 1), y = l; y < this._intersectionVertices.length; y++) {this._intersectionVertices[y].index = y;}}}}l = g;}}}, V.prototype._mergeCoincidentSegments = function () {for (var e, t = {}, r = 0; r < this._intersectionVertices.length; r++) {for (var n = this._intersectionVertices[r], o = {}, s = 0; s < n.adjacentEdges.length; s++) {var a = (e = n.adjacentEdges[s]).startVertex === n ? e.endVertex : e.startVertex;t[String(n.index) + "_" + String(a.index)] || (o[String(a.index)] = o[String(a.index)] || [], o[String(a.index)].push(e));}var c = P.default.keys(o);for (s = 0; s < c.length; s++) {if (t[c[s] + "_" + String(n.index)] = !0, o[c[s]].length > 1) for (var u = o[c[s]], l = 0; l < u.length; l++) {for (var h = [], d = l + 1; d < u.length; d++) {(0, f.curvesAreCoincident)(u[l].originalEdge.getCurve(), u[d].originalEdge.getCurve(), u[l].parameterRange, u[d].parameterRange, i.KERNEL_TOLERANCE) && (h.push(u[d]), u.splice(d, 1), d--);}for (d = 0; d < h.length; d++) {var g = h[d];u[l].coincidentRanges.push({ originalEdge: g.originalEdge, parameterRange: g.parameterRange, localGuid: g.localGuid, flipped: g.startVertex !== u[l].startVertex }), g.startVertex.adjacentEdges.splice(g.startVertex.adjacentEdges.indexOf(g), 1), g.endVertex.adjacentEdges.splice(g.endVertex.adjacentEdges.indexOf(g), 1);var p = this._edgeSegments.indexOf(g);this._edgeSegments.splice(p, 1);for (var v = p; v < this._edgeSegments.length; v++) {this._edgeSegments[v].index = v;}}}}}}, V.prototype._sortEdgesAroundVertex = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {for (var t = this._intersectionVertices[e], r = [], s = 0; s < t.adjacentEdges.length; s++) {var a = this._computeAngleAndPositionForEdge(s, t);r.push({ index: s, originalAngle: a.angle, angle: a.angle, position: a.position, derivative: void 0 });}for (var c = 0, u = !1; !u;) {u = !0;var l = -Math.PI + c;for (s = 0; s < r.length; s++) {if ((0, o.angleDifference)(l, r[s].angle) < 1e-5) {u = !1;break;}}if (u) break;c += 2e-5;}for (s = 0; s < t.adjacentEdges.length; s++) {r[s].angle = (0, o.normalizeParameterToShiftedRange)(r[s].angle - c, [-Math.PI, Math.PI]);}var h = this;r = r.sort(function (e, r) {if ((0, o.angleDifference)(e.angle, r.angle) > 1e-5) return e.angle - r.angle;var s = t.adjacentEdges[e.index],a = t.adjacentEdges[r.index],c = s.startVertex === t ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = s.originalEdge.evaluatePosition(c),d = a.originalEdge.evaluatePosition(u),g = n.Vector3.distance(l, d),p = n.Vector3.createFloat64(),f = n.Vector3.createFloat64(),v = s.originalEdge.evaluateCurvature(c, p),_ = a.originalEdge.evaluateCurvature(u, f);if (0 === v && 0 === _) return e.angle - r.angle;if (0 === v || 0 === _) {var y = 1 / Math.max(v, _);g += 1.5 * Math.sqrt(Math.pow(y, 2) - Math.pow(y - g, 2)) + i.KERNEL_TOLERANCE;} else {var m = 1 / v,E = 1 / _;if (m < E) {var x = m;m = E, E = x;}n.Vector3.dot(p, f) < 0 ? g += -Math.sqrt(-.25 * Math.pow(g, 4) + Math.pow(g, 3) * m - g * g * m * m - (g * g - 2 * g * m) * E * E + (g * g * g - 3 * g * g * m + 2 * g * m * m) * E) / (g - m - E) * 1.5 : g += Math.sqrt(-.25 * Math.pow(g, 4) - Math.pow(g, 3) * m - g * g * m * m - (g * g + 2 * g * m) * E * E + (g * g * g + 3 * g * g * m + 2 * g * m * m) * E) / (g + m - E) * 1.5;}var R = Math.min(n.Vector3.distance(s.endVertex.position, s.startVertex.position), n.Vector3.distance(a.endVertex.position, a.startVertex.position));g = Math.max(i.KERNEL_TOLERANCE, g), g = Math.min(.9 * R, g);var A = !1;do {var P = h._computeEdgeDirectionAtVertex(e, t, g),V = h._computeEdgeDirectionAtVertex(r, t, g);A = (0, o.angleDifference)(P, V) > 1e-8, g *= 5;} while (!A && g < R);var T = P - V;return T > Math.PI ? T -= o.PI2 : T < -Math.PI && (T += o.PI2), T;}), t.adjacentEdges = P.default.map(r, function (e) {return t.adjacentEdges[e.index];});}}, V.prototype._assignAdjacentEdges = function () {for (var e = 0; e < this._edgeSegments.length; e++) {var t = this._edgeSegments[e];this._assignAdjacentEdgesToSegment(t);}}, V.prototype._assignAdjacentEdgesToSegment = function (e) {var t = e.startVertex.adjacentEdges,r = t.indexOf(e);R.ConsoleUtils.assert(-1 !== r, "Error in topology");for (var n = 0, i = e.endVertex.adjacentEdges; n < i.length && i[n] !== e;) {n++;}R.ConsoleUtils.assert(n < i.length, "Error in topology"), e.adjacent[this.SIDE.LEFT].nextEdge = i[(0, o.modulus)(n - 1, i.length)], e.adjacent[this.SIDE.LEFT].prevEdge = t[(0, o.modulus)(r + 1, t.length)], e.adjacent[this.SIDE.RIGHT].nextEdge = i[(0, o.modulus)(n + 1, i.length)], e.adjacent[this.SIDE.RIGHT].prevEdge = t[(0, o.modulus)(r - 1, t.length)];}, V.prototype._sweepRegions = function () {var e = this._workspace,t = P.default.clone(this._intersectionVertices).sort(function (e, t) {if (Math.abs(e.position[0] - t.position[0]) < 1e-9) {for (var r = 0; r < e.adjacentEdges.length; r++) {for (var o = 0; o < t.adjacentEdges.length; o++) {if (e.adjacentEdges[r].originalEdge === t.adjacentEdges[o].originalEdge) {var s = e.adjacentEdges[r],a = t.adjacentEdges[o],c = s.startVertex === e ? s.parameterRange[0] : s.parameterRange[1],u = a.startVertex === t ? a.parameterRange[0] : a.parameterRange[1],l = !0,h = n.Vector3.createFloat64();n.Vector3.normalize(h, s.originalEdge.evaluateDt(c));var d = n.Vector3.createFloat64();if (n.Vector3.normalize(d, a.originalEdge.evaluateDt(u)), Math.sign(h[0]) !== Math.sign(d[0])) continue;if (Math.abs(h[0]) > i.KERNEL_TOLERANCE && Math.abs(d[0]) > i.KERNEL_TOLERANCE) l = h[0] > 0;else {if (Math.abs(e.position[1] - t.position[1]) < i.KERNEL_TOLERANCE) continue;l = h[1] > 0;}return (c - u) * (l ? 1 : -1);}}}return e.position[1] - t.position[1];}return e.position[0] - t.position[0];});this._cells = [];var r = { index: -1, loops: [], loopOrientations: [], dangling: [], leftmostVertex: void 0 };e.sweepLineIntersections = [-1 / 0, 1 / 0], e.sweepLineRegions = e.sweepLineRegions = [r];for (var o = [], s = 0; s < t.length; s++) {e.sweepLineRegions.length !== e.sweepLineIntersections.length - 1 && console.error("Error during sweep computation");var a = t[s],c = P.default.clone(a.adjacentEdges),u = void 0;if (o[a.index]) {for (var l = o[a.index], h = [], d = 0; d < e.sweepLineIntersections.length - 1; d++) {P.default.contains(l, e.sweepLineIntersections[d]) && (void 0 === u && (u = d - 1), P.default.contains(l, e.sweepLineIntersections[d + 1]) && h.push(d));}for (d = 0; d < l.length; d++) {for (var g = l[d], p = 0; p < e.sweepLineIntersections.length; p++) {e.sweepLineIntersections[p] === g && e.sweepLineIntersections.splice(p, 1);}for (p = 0; p < c.length; p++) {c[p] === g && c.splice(p, 1);}}for (d = h.length - 1; d >= 0; d--) {e.sweepLineRegions.splice(h[d], 1);}} else u = this._findVertexOnSweepLine(a), e.sweepLineRegions.splice(u + 1, 0, e.sweepLineRegions[u]);if (c.length > 0) {var f = u + 1;for (d = 0; d < c.length; d++) {var v = c[d];e.sweepLineIntersections.splice(f, 0, v);var _ = v.startVertex === a ? v.endVertex : v.startVertex;if (void 0 === o[_.index] && (o[_.index] = []), o[_.index].push(v), d > 0) {var y = { index: this._cells.length, loops: [], loopOrientations: [], dangling: [], leftmostVertex: a };this._cells.push(y), e.sweepLineRegions.splice(f - 1, 0, y);}f++;}for (f = u, d = 0; d < c.length; d++) {var m = (v = c[d]).startVertex !== a;v.adjacent[m ? this.SIDE.RIGHT : this.SIDE.LEFT].face = e.sweepLineRegions[f + 1], v.adjacent[m ? this.SIDE.LEFT : this.SIDE.RIGHT].face = e.sweepLineRegions[f], f++;}} else if (e.sweepLineRegions[u] !== e.sweepLineRegions[u + 1]) {var E = e.sweepLineRegions[u + 1],x = e.sweepLineRegions[u];for (x === r ? (x = E, E = r, e.sweepLineRegions.splice(u, 1)) : (void 0 !== x.leftmostVertex && (void 0 === E.leftmostVertex || E.leftmostVertex.position[0] > x.leftmostVertex.position[0]) && (E.leftmostVertex = x.leftmostVertex), e.sweepLineRegions.splice(u + 1, 1)), d = 0; d < this._edgeSegments.length; d++) {this._edgeSegments[d].adjacent[this.SIDE.LEFT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.LEFT].face = E), this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face === x && (this._edgeSegments[d].adjacent[this.SIDE.RIGHT].face = E);}for (d = 0; d < e.sweepLineRegions.length; d++) {e.sweepLineRegions[d] === x && (e.sweepLineRegions[d] = E);}this._cells[x.index] = void 0;} else e.sweepLineRegions.splice(u + 1, 1);}for (s = 0; s < this._cells.length; s++) {void 0 === this._cells[s] && (this._cells.splice(s, 1), s--);}for (s = 0; s < this._cells.length; s++) {this._cells[s].index = s;}}, V.prototype._assignleftmostEdges = function () {for (var e = this, t = 0; t < this._cells.length; t++) {var r = this._cells[t],n = r.leftmostVertex,o = P.default.filter(n.adjacentEdges, function (t) {var n = t.adjacent[e.SIDE.LEFT].face,o = t.adjacent[e.SIDE.RIGHT].face;return (n === r || o === r) && n !== o;});if (R.ConsoleUtils.assert(o.length >= 2, "In each loop there should be at least two adjacent edges"), o.length > 2) for (var i = 0; i < o.length; i++) {var s = o[i].adjacent[e.SIDE.LEFT].face === r ? e.SIDE.LEFT : e.SIDE.RIGHT,a = o[i].adjacent[s],c = o[i].startVertex === n ? a.prevEdge : a.nextEdge;if (P.default.contains(o, c)) {o = [o[i], c];break;}}var u = o[0];u.loopsCurveAligned = !!(u.startVertex === n ^ o[0].adjacent[e.SIDE.RIGHT].face === r), r.leftmostEdge = u, r.leftmostVertex = void 0;}}, V.prototype._removeGrazingIntersectionVertices = function () {for (var e = {}, t = 0, r = this._intersectionVertices.slice(); r.length > 0;) {var n = r.pop();if (2 === n.adjacentEdges.length && (1 === n.adjacentEdges[0].coincidentRanges.length || 1 === n.adjacentEdges[1].coincidentRanges.length) && n.virtualIntersection) {var i,s,a = 1 === n.adjacentEdges[0].coincidentRanges.length && 1 === n.adjacentEdges[1].coincidentRanges.length,c = n.adjacentEdges.slice();if (a) {if (i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge], s = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge], !(i[0] === s[0] && i[1] === s[1] || i[0] === s[1] && i[1] === s[0])) continue;e[c[0].originalEdge.getGuid()] = !0, e[c[0].coincidentRanges[0].originalEdge.getGuid()] = !0, e[c[1].originalEdge.getGuid()] = !0, e[c[1].coincidentRanges[0].originalEdge] = !0;var u = [c[0].startVertex === n ? c[0].endVertex : c[0].startVertex, n, c[1].startVertex === n ? c[1].endVertex : c[1].startVertex];} else {var l;c[0].coincidentRanges.length > 0 ? (l = 0, i = [c[0].originalEdge, c[0].coincidentRanges[0].originalEdge]) : (l = 1, i = [c[1].originalEdge, c[1].coincidentRanges[0].originalEdge]), e[i[0].getGuid()] = !0, e[i[1].getGuid()] = !0, u = [c[l].startVertex === n ? c[l].endVertex : c[l].startVertex, n], c = [c[l]];}var h = void 0,d = void 0;if (u[0].vertices.length > 0 ? (h = u[0], d = a ? [u[1], u[2]] : [u[1]]) : a && u[2].vertices.length > 0 ? (h = u[2], d = [u[0], u[1]]) : (h = u[1], d = a ? [u[0], u[2]] : [u[0]]), d[0].vertices.length > 0 || d[1] && (d[1].vertices.length > 0 || d[0] === d[1])) continue;for (var g = !0, p = P.default.without(d, n), f = 0; f < p.length; f++) {var v = p[f].adjacentEdges;if ((v = P.default.difference(v, c)).length > 2) {g = !1;break;}for (var _ = 0; _ < v.length; _++) {if (v[_].coincidentRanges.length > 0 || v[_].originalEdge !== i[0] && v[_].originalEdge !== i[1]) {g = !1;break;}}}if (!g) continue;for (f = 0; f < p.length; f++) {var y = p[f],m = P.default.intersection(c, y.adjacentEdges)[0],E = n !== h && a ? P.default.without(c, m)[0] : m,x = P.default.without(y.adjacentEdges, m);for (y.adjacentEdges[1] === m && (x = x.reverse()), _ = 0; _ < x.length; _++) {var R = x[_],A = E.startVertex === h ? 0 : 1,V = void 0;if (E.originalEdge === R.originalEdge) V = E.parameterRange[A];else {var T = E.coincidentRanges[0].flipped ? 1 - A : A;V = E.coincidentRanges[0].parameterRange[T];}R.startVertex === y ? (R.startVertex = h, R.parameterRange[0] = V) : (R.endVertex = h, R.parameterRange[1] = V);for (var C = 0; C < R.adjacent.length; C++) {var b = R.adjacent[C].face;b.leftmostEdge !== m && b.leftmostEdge !== E || (R.loopsCurveAligned = b.leftmostEdge.loopsCurveAligned, b.leftmostEdge = R), (b.leftmostVertex === d[0] || void 0 !== d[1] && b.leftmostVertex === d[1]) && (b.leftmostVertex = h);}}var L = h.adjacentEdges.indexOf(E);Array.prototype.splice.apply(h.adjacentEdges, [L, 1].concat(x));var O = h.adjacentEdges.length,S = [(0, o.modulus)(L - 1, O), L, L + 1, (L + 2) % O];for (_ = 0; _ < S.length; _++) {var M = h.adjacentEdges[S[_]];this._assignAdjacentEdgesToSegment(M);}}this._intersectionVertices = P.default.difference(this._intersectionVertices, d), r = P.default.difference(r, d), this._edgeSegments = P.default.difference(this._edgeSegments, c), t++;}}if (t > 0) {for (var w = 0; w < this._intersectionVertices.length; w++) {this._intersectionVertices[w].index = w;}for (w = 0; w < this._edgeSegments.length; w++) {this._edgeSegments[w].index = w;}}var N = P.default.keys(e);for (w = 0; w < N.length; w++) {var F = N[w],I = [];for (f = 0; f < this._edgeSegments.length; f++) {for ((D = this._edgeSegments[f]).originalEdge.getGuid() === F && I.push([D, D.parameterRange[0]]), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && I.push([D, D.coincidentRanges[_].parameterRange[0]]);}}for (I.sort(function (e, t) {return e[1] - t[1];}), f = 0; f < I.length; f++) {var D;for ((D = I[f][0]).originalEdge.getGuid() === F && (D.localGuid = this._createGUIDfromEdgeAndLocalID(D.originalEdge, f + 1)), _ = 0; _ < D.coincidentRanges.length; _++) {D.coincidentRanges[_].originalEdge.getGuid() === F && (D.coincidentRanges[_].localGuid = this._createGUIDfromEdgeAndLocalID(D.coincidentRanges[_].originalEdge, f + 1));}}}}, V.prototype._removeTemporaryVertices = function () {for (var e = 0, t = 0; t < this._intersectionVertices.length; t++) {var r = this._intersectionVertices[t];if (r.temporary && 2 === r.adjacentEdges.length && r.adjacentEdges[0].originalEdge === r.adjacentEdges[1].originalEdge && r.adjacentEdges[0] !== r.adjacentEdges[1]) {var n, o;r.adjacentEdges[0].endVertex === r ? (n = r.adjacentEdges[0], o = r.adjacentEdges[1]) : (n = r.adjacentEdges[1], o = r.adjacentEdges[0]), R.ConsoleUtils.assert(n.adjacent[this.SIDE.LEFT].face === o.adjacent[this.SIDE.LEFT].face), R.ConsoleUtils.assert(n.adjacent[this.SIDE.RIGHT].face === o.adjacent[this.SIDE.RIGHT].face);var s = n.parameterRange[1] - o.parameterRange[0],a = (n.originalEdge.isReversed() ? -1 : 1) * n.parameterRange[0],c = i.KERNEL_TOLERANCE / n.originalEdge.getCurve().tangentLength(a);if (n.originalEdge.getCurve().isPeriodic() && Math.abs(s - n.originalEdge.getCurve().getPeriod()) < c) n.parameterRange[1] = o.parameterRange[1] + s;else {if (Math.abs(s) > c) continue;n.parameterRange[1] = o.parameterRange[1];}n.endVertex = o.endVertex, n.adjacent[this.SIDE.LEFT].nextEdge = o.adjacent[this.SIDE.LEFT].nextEdge, n.adjacent[this.SIDE.RIGHT].nextEdge = o.adjacent[this.SIDE.RIGHT].nextEdge, n.adjacent[this.SIDE.LEFT].prevEdge === o && (n.adjacent[this.SIDE.LEFT].prevEdge = n), n.adjacent[this.SIDE.RIGHT].prevEdge === o && (n.adjacent[this.SIDE.RIGHT].prevEdge = n);var u = n.adjacent[this.SIDE.LEFT].nextEdge;u.adjacent[this.SIDE.LEFT].prevEdge === o && (u.adjacent[this.SIDE.LEFT].prevEdge = n), u.adjacent[this.SIDE.LEFT].nextEdge === o && (u.adjacent[this.SIDE.LEFT].nextEdge = n), u.adjacent[this.SIDE.RIGHT].prevEdge === o && (u.adjacent[this.SIDE.RIGHT].prevEdge = n), u.adjacent[this.SIDE.RIGHT].nextEdge === o && (u.adjacent[this.SIDE.RIGHT].nextEdge = n);var l = n.adjacent[this.SIDE.RIGHT].nextEdge;l.adjacent[this.SIDE.LEFT].prevEdge === o && (l.adjacent[this.SIDE.LEFT].prevEdge = n), l.adjacent[this.SIDE.LEFT].nextEdge === o && (l.adjacent[this.SIDE.LEFT].nextEdge = n), l.adjacent[this.SIDE.RIGHT].prevEdge === o && (l.adjacent[this.SIDE.RIGHT].prevEdge = n), l.adjacent[this.SIDE.RIGHT].nextEdge === o && (l.adjacent[this.SIDE.RIGHT].nextEdge = n), o.adjacent[this.SIDE.LEFT].face.leftmostEdge === o && (o.adjacent[this.SIDE.LEFT].face.leftmostEdge = n), o.adjacent[this.SIDE.RIGHT].face.leftmostEdge === o && (o.adjacent[this.SIDE.RIGHT].face.leftmostEdge = n), void 0 === n.loopsCurveAligned && (n.loopsCurveAligned = o.loopsCurveAligned), (0, v.hashCombine4xUint32)(n.localGuid, o.localGuid, n.localGuid);var h = n.endVertex.adjacentEdges.indexOf(o);n.endVertex.adjacentEdges[h] = n, this._intersectionVertices.splice(t, 1), this._edgeSegments.splice(o.index - e, 1), t--, e++;} else this._intersectionVertices[t].index -= e;}for (t = 0; t < this._edgeSegments.length; t++) {this._edgeSegments[t].index = t;}}, V.prototype._updateVertexGuidLists = function () {for (var e = 0; e < this._intersectionVertices.length; e++) {var t = this._intersectionVertices[e];if (t.vertices.length > 0) for (var r = 0; r < t.vertices.length; r++) {t.guidList.push((0, v.guidToUint32x4)(t.vertices[r].getGuid()));} else {var n = {};for (r = 0; r < t.adjacentEdges.length; r++) {var o = t.adjacentEdges[r];if (!n[o.index]) {n[o.index] = !0, t.guidList.push(o.localGuid);for (var i = 0; i < o.coincidentRanges.length; i++) {t.guidList.push(o.coincidentRanges[i].localGuid);}}}}}}, V.prototype._assignLoops = function () {var e = this._workspace;e.edgesPerCell = [];for (var t = 0; t < this._cells.length; t++) {e.edgesPerCell[t] = [];}for (t = 0; t < this._edgeSegments.length; t++) {var r = this._edgeSegments[t],n = r.adjacent[this.SIDE.LEFT].face.index;n >= 0 && e.edgesPerCell[n].push(r);var o = r.adjacent[this.SIDE.RIGHT].face.index;o >= 0 && n !== o && e.edgesPerCell[o].push(r);}var i = [];for (t = 0; t < this._cells.length; t++) {var s = [];i[t] = s;for (var a = this._followLoopFromEdge(this._cells[t].leftmostEdge, this._cells[t], !1, !0), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}for (t = 0; t < this._cells.length; t++) {s = i[t];for (var u = 0; u < e.edgesPerCell[t].length; u++) {var l = e.edgesPerCell[t][u];if (l.adjacent[this.SIDE.LEFT].face !== l.adjacent[this.SIDE.RIGHT].face) {if (!0 !== s[l.index]) {for (a = this._followLoopFromEdge(l, this._cells[t], !0, !1), c = 0; c < a.loop.length; c++) {s[a.loop[c].index] = !0;}this._cells[t].loops.push(a.loop), this._cells[t].loopOrientations.push(a.orientations);}} else this._cells[t].dangling.push(l);}}}, V.prototype._updateSketchRegionTopology = function () {for (var e = this._workspace, t = P.default.keys(this._sketchRegionTopologies), r = 0; r < t.length; r++) {var n = t[r];this._sketchRegionTopologies[n].updated = !1, "FaceID" === this._sketchRegionTopologies[n].topology.tuid && this._sketchRegionTopologies[n].topology.removeAllEdges();}var o = {},s = {};for (r = 0; r < this._intersectionVertices.length; r++) {var a = this._addOrFindTopologySubcomponent("VertexID", i.GEOMETRY_TYPES.POINT, this._intersectionVertices[r].guidList, s);a.setPoint(new h.Point(this._intersectionVertices[r].position)), a.setAssociatedEntities(P.default.clone(this._intersectionVertices[r].vertices));for (var c = 0; c < this._intersectionVertices[r].vertices.length; ++c) {var u = this._intersectionVertices[r].vertices[c].getGuid();R.ConsoleUtils.assert(!o[u], "vertex should only map to one topology vertex"), o[u] = a;}this._intersectionVertices[r].topologyVertex = a;}for (r = 0; r < this._edgeSegments.length; r++) {var l = this._edgeSegments[r],p = [l.localGuid];for (c = 0; c < l.coincidentRanges.length; c++) {p.push(l.coincidentRanges[c].localGuid);}(V = this._addOrFindTopologySubcomponent("EdgeID", l.originalEdge.getCurveType(), p, s)).setToEdgeSegment(l.originalEdge, l.parameterRange), V.setStartVertex(l.startVertex.topologyVertex), V.setEndVertex(l.endVertex.topologyVertex);var f = [{ edge: l.originalEdge, range: P.default.clone(l.parameterRange), flipped: !1 }];for (c = 0; c < l.coincidentRanges.length; c++) {f.push({ edge: l.coincidentRanges[c].originalEdge, range: P.default.clone(l.coincidentRanges[c].parameterRange), flipped: l.coincidentRanges[c].flipped });}V.setAssociatedEdges(f), l.topologyEdge = V;}for (r = 0; r < this._cells.length; r++) {var _ = this._cells[r];for (p = [], c = 0; c < e.edgesPerCell[r].length; c++) {p.push((0, v.guidToUint32x4)(e.edgesPerCell[r][c].topologyEdge.getGuid()));}var y = this._addOrFindTopologySubcomponent("FaceID", i.GEOMETRY_TYPES.PLANE, p, s);y.setSurface(this._planeGeometry);var m = [];for (c = 0; c < _.loops.length; c++) {var E = new d.Loop();E.setFace(y), m.push(E);for (var x = [], A = 0; A < _.loops[c].length; A++) {var V = _.loops[c][A].topologyEdge,T = new g.Coedge();T.setLoop(E), x.push(T), T.setEdge(V), T.setReversed(!_.loopOrientations[c][A]), V.getCoedge() ? V.getCoedge().getPartner() || (V.getCoedge().setPartner(T), T.setPartner(V.getCoedge())) : V.setCoedge(T), _.loops[c][A].topologyEdge.setIsDangling(!1);}E.setCoedges(x);}for (y.setLoops(m), this._faces.push(y), c = 0; c < _.dangling.length; c++) {y.addDanglingEdge(_.dangling[c].topologyEdge), _.dangling[c].topologyEdge.setIsDangling(!0);}}for (r = 0; r < t.length; r++) {this._sketchRegionTopologies[t[r]].updated || delete this._sketchRegionTopologies[t[r]];}}, V.prototype._followLoopFromEdge = function (e, t, r, n) {var o = [],i = [],s = e,a = [],c = e.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT,u = !!(s.loopsCurveAligned ^ c !== this.SIDE.LEFT),l = u ? e.startVertex : e.endVertex;do {if (s.adjacent[c].face !== t) {console.error("REGION: Adjacent edge face does not match cell! FIXME!");break;}if (a[s.index]) {console.error("REGION: Malformed edges; walking edge lead us to despair");break;}a[s.index] = !0, o.push(s), i.push(u);do {u ? (l = s.endVertex, s = s.adjacent[c].nextEdge) : (l = s.startVertex, s = s.adjacent[c].prevEdge), s.startVertex === s.endVertex ? c = s.adjacent[this.SIDE.LEFT].face === t ? this.SIDE.LEFT : this.SIDE.RIGHT : (c = s.startVertex === l ? this.SIDE.LEFT : this.SIDE.RIGHT, s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face && (c = 1 - c, l = s.startVertex === l ? s.endVertex : s.startVertex)), u = c === this.SIDE.LEFT;} while (s.adjacent[this.SIDE.LEFT].face === s.adjacent[this.SIDE.RIGHT].face);n && void 0 === s.loopsCurveAligned && (s.loopsCurveAligned = !!(u ^ c !== this.SIDE.LEFT));} while (s !== e);return { loop: o, orientations: i };}, V.prototype._addNewRegionTopology = function (e) {switch (e.tuid) {case "VertexID":var t = new E.RegionTopologyVertex(new h.Point());return t.setGuid(e.guid), t;case "EdgeID":var r = void 0;switch (e.minortype) {case i.GEOMETRY_TYPES.LINE:r = new a.Line();break;case i.GEOMETRY_TYPES.CIRCLE:r = new c.Circle();break;case i.GEOMETRY_TYPES.ELLIPSE:r = new l.Ellipse();break;case i.GEOMETRY_TYPES.BCURVE:r = new u.BCurve();break;default:console.error("Unhandled curve type");}var n = new E.RegionTopologyEdge(r);return n.setGuid(e.guid), n;case "FaceID":switch (r = void 0, e.minortype) {case i.GEOMETRY_TYPES.PLANE:r = new s.Plane();break;default:console.error("Unhandled surface type");}var o = new E.RegionTopologyFace(r);return o.setGuid(e.guid), o;default:console.error("Unhandled topology type");}}, V.prototype._addOrFindTopologySubcomponent = function (e, t, r, n) {var o = this._createNameFromGuidList(e, t, r, n);if (this._sketchRegionTopologies[o]) {var i = this._sketchRegionTopologies[o];return i.updated = !0, i.topology;}var s = this._addNewRegionTopology({ tuid: e, minortype: t, guid: o });return this._sketchRegionTopologies[o] = { topology: s, updated: !0 }, s;};var T = { VertexID: [1168004130, 3764602020, 2270554856, 1368826480], EdgeID: [2942887333, 1472546498, 2159971906, 413489693], FaceID: [2166479754, 2329626594, 2838556660, 1584616933] },C = {};C[i.GEOMETRY_TYPES.POINT] = [2299429810, 2248164535, 3202574069, 2684287321], C[i.GEOMETRY_TYPES.LINE] = [910992607, 3428993096, 3010390753, 2966835859], C[i.GEOMETRY_TYPES.CIRCLE] = [2229232555, 842549819, 2526558959, 4217038233], C[i.GEOMETRY_TYPES.PLANE] = [2122299449, 3667741317, 2812958731, 939246365], C[i.GEOMETRY_TYPES.BCURVE] = [420548527, 2703575863, 2792852189, 2595995847], C[i.GEOMETRY_TYPES.ELLIPSE] = [902753991, 1129557208, 9277753211, 1913737389];var b = function b(e, t) {var r = 2166136261;return t && (r = 16777619 * (r ^ t) >>> 0), 16777619 * (((r = 16777619 * (((r = 16777619 * (((r = 16777619 * ((r ^ 255 & e) >>> 0) >>> 0) ^ e >> 8 & 255) >>> 0) >>> 0) ^ e >> 16 & 255) >>> 0) >>> 0) ^ e >> 24 & 255) >>> 0) >>> 0;},L = function () {var e = new Uint32Array(4);return function (t) {return e[0] = t, e[1] = 16777619, e[2] = t, e[3] = t, (0, v.hashCombine4xUint32)(e, e);};}(),O = function O(e, t) {for (var r = 0; r < e.length; r++) {e[r] = (e[r] ^ t[r]) >>> 0;}};V.prototype._createNameFromGuidList = function (e, t, r, n) {var o = P.default.clone(T[e]),i = C[t];R.ConsoleUtils.assert(o && i, "Unsupported tuid or minortype!"), O(o, i);for (var s = 0; s < r.length; s++) {O(o, r[s]);}var a = (0, v.uint32x4ToGUID)(o);if (n[a]) {var c = ++n[a];return (r = P.default.clone(r)).push(L(b(c))), this._createNameFromGuidList(e, t, r, n);}return n[a] = 1, a;}, V.prototype._createGUIDfromEdgeAndLocalID = function (e, t) {var r = (0, v.guidToUint32x4)(e.getGuid()),n = L(b(t));return (0, v.hashCombine4xUint32)(r, n);}, V.prototype._findVertexIndex = function (e) {for (var t = 0; t < this._intersectionVertices.length; t++) {if (n.Vector3.distance(this._intersectionVertices[t].position, e) < i.KERNEL_TOLERANCE) return t;for (var r = 0; r < this._intersectionVertices[t].mergedPositions.length; r++) {if (n.Vector3.distance(this._intersectionVertices[t].mergedPositions[r], e) < i.KERNEL_TOLERANCE) return t;}}}, V.prototype._findVertexOnSweepLine = function (e) {for (var t = this._workspace, r = 0, n = t.sweepLineIntersections.length - 1; n >= r;) {if (r + 1 >= n) return r;var o = Math.floor((r + n) / 2);this._isVertexAboveEdgeSegment(t.sweepLineIntersections[o], e) ? r = o : n = o;}console.error("Error in binary search function!");}, V.prototype._isVertexAboveEdgeSegment = function (e, t) {if (e === -1 / 0) return !0;if (e === 1 / 0) return !1;var r = e.originalEdge;switch (r.getCurveType()) {case i.GEOMETRY_TYPES.LINE:var o = r.getStartVertex().getPosition(),s = n.Vector3.createFloat64();n.Vector3.subtract(s, r.getEndVertex().getPosition(), o);var a = n.Vector3.createFloat64();return n.Vector3.subtract(a, t.position, o), (s[0] < 0 || 0 === s[0] && s[1] < 0) && n.Vector3.negate(s, s), a[1] * s[0] - a[0] * s[1] > 0;case i.GEOMETRY_TYPES.CIRCLE:var c = t.position[0] - r.getCurve().getCenter()[0],u = .5 * (e.parameterRange[0] + e.parameterRange[1]),l = r.getCurve().evaluateDtt(u)[1] > 0 ? -1 : 1;return Math.abs(c) > r.getCurve().getRadius() ? r.getCurve().getCenter()[1] < t.position[1] : r.getCurve().getCenter()[1] + l * Math.sqrt(r.getCurve().getRadius() * r.getCurve().getRadius() - c * c) < t.position[1];default:return this.getYvalueForX(e, t.position[0]) < t.position[1];}}, V.prototype._makeEdgeXMonotone = function (e, t) {var r = e.getCurve(),s = [];switch (e.getCurveType()) {case i.GEOMETRY_TYPES.LINE:break;case i.GEOMETRY_TYPES.CIRCLE:var a = r.evaluatePosition(0);n.Vector3.subtract(a, a, r.getCenter());var c = r.getNormal()[2] > 0 ? -1 : 1;s[0] = c * Math.atan2(a[1], a[0]), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.ELLIPSE:var u = r.getMajorAxis()[0] * r.getMajorRadius(),l = r.getMinorAxis()[0] * r.getMinorRadius();s[0] = Math.atan2(l, u), s[1] = s[0] - Math.PI;break;case i.GEOMETRY_TYPES.BCURVE:s = _.SplineCurveHelper.extremalParams(r, 0);break;default:console.warn("Unsupported edge type in sketch region op");}for (var h = 0; h < s.length; h++) {var d = s[h];e.isReversed() && (d = -d), r.isPeriodicUnlimited() && (d = (0, o.adjustParameterToPeriodicRange)(d, e.getRange(), r.getPeriodUnlimited())), d >= e.t0() && d <= e.t1() && (t.push({ param: d, atVertex: null, temporary: !0 }), A.DebugUtils.level("region3D") > 0 && A.DebugUtils.drawPoint3D(e.evaluatePosition(d), { color: 16711935, label: "x monotonic" }));}}, V.prototype.plotSegments = function (e, t) {var r = this._workspace;Debug.hold("on"), Debug.clearFigure(), Debug.delayUpdates(!0);for (var o = 0; o < this._intersectionVertices.length; o++) {var i = Debug.plotColorForIndex(this._intersectionVertices[o].adjacentEdges.length);if ("sweepLineState" === e && (i = "k", this._intersectionVertices[o] === r.currentVertex && (i = "g"), this._intersectionVertices[o] === r.nextVertex && (i = "b")), Debug.plot([this._intersectionVertices[o].position], i + "o"), "orderColored" === e) for (var s = this._intersectionVertices[o], a = [], c = 0; c < s.adjacentEdges.length; c++) {i = Debug.plotColorForIndex(c);var u = s.adjacentEdges[c],l = P.default.clone(u.parameterRange);u.startVertex !== s || a[u.index] ? l[0] = .5 * (l[0] + l[1]) : l[1] = .5 * (l[0] + l[1]), a[u.index] = !0;var h = u.originalEdge.tessellate(l).positions;Debug.plot(h, i + "-");}}if ("orderColored" !== e) for (o = 0; o < this._edgeSegments.length; o++) {if (u = this._edgeSegments[o], "coincidenceCount" === e) {var d = u.coincidentRanges.length + 1;i = Debug.plotColorForIndex(d);} else i = Debug.plotColorForIndex(o);if ("sweepLineState" === e && (i = r.sweepLineIntersections.indexOf(u) > -1 ? "r" : "k"), t && t.highlightLoop && (i = P.default.contains(t.highlightLoop, u) ? "R" : "k"), h = u.originalEdge.tessellate(u.parameterRange).positions, "regions" === e) {var g = [],p = [];for (c = 0; c < h.length; c++) {if (c < h.length - 1) {var f = n.Vector3.createFloat64();n.Vector3.subtract(f, h[c + 1], h[c]);} else f = n.Vector3.createFloat64(), n.Vector3.subtract(f, h[c], h[c - 1]);n.Vector3.normalize(f, f), n.Vector3.scale(f, f, .05), n.Vector3.cross(f, [0, 0, 1], f);var v = n.Vector3.clone(h[c]);g.push(n.Vector3.add(v, v, f));var _ = n.Vector3.clone(h[c]);p.push(n.Vector3.subtract(_, _, f));}var y = u.adjacent[this.SIDE.LEFT].face.index;i = Debug.plotColorForIndex(y), Debug.plot(g, i + "-");var m = u.adjacent[this.SIDE.RIGHT].face.index;i = Debug.plotColorForIndex(m), Debug.plot(p, i + "-");} else Debug.plot(h, i + "-");}if ("sweepLineState" === e && r.sweepLinePosition) {var E = r.sweepLinePosition,x = void 0;for (o = 0; o < r.sweepLineIntersections.length; o++) {var R,A = r.sweepLineIntersections[o];void 0 !== (R = A === 1 / 0 ? 5 : A === -1 / 0 ? -5 : this.getYvalueForX(A, E)) && (Debug.plot([E], [R], "y."), void 0 !== x && (i = Debug.plotColorForIndex(r.sweepLineRegions[o - 1].index), Debug.plot([E, E], [x, R], i + "-")), x = R);}}if (t && t.showOrientation) {h = [];var V = [],T = [];for (o = 0; o < this._edgeSegments.length; o++) {var C = !(void 0 === (u = this._edgeSegments[o]).loopsCurveAligned || !0 === u.loopsCurveAligned),b = C ? .05 : .95,L = u.parameterRange[0] * (1 - b) + u.parameterRange[1] * b,O = u.originalEdge.evaluatePosition(L);h.push(O);var S = t.arrowSize || .1,M = C ? -S : S;if (u.adjacent[this.SIDE.LEFT].face.index >= 0) {var w = u.originalEdge.evaluateDt(L);n.Vector3.normalize(w, w);var N = [O[0] - S * w[1], O[1] + S * w[0]];V.push(N), T.push([M * w[0], M * w[1]]);}if (u.adjacent[this.SIDE.RIGHT].face.index >= 0) {var F = u.parameterRange[0] * b + u.parameterRange[1] * (1 - b),I = u.originalEdge.evaluatePosition(F),D = u.originalEdge.evaluateDt(F);n.Vector3.normalize(D, D);var j = [I[0] + S * D[1], I[1] - S * D[0]];V.push(j), T.push([-M * D[0], -M * D[1]]);}}Debug.plot(h, "k."), Debug.quiver(V, T, "g", "c");}Debug.delayUpdates(!1), Debug.equalAxis();}, V.prototype.plotEdgeSegment = function (e, t) {Debug.plotEdgeList([e.originalEdge], !1, t + "-", { ranges: [e.parameterRange] });}, V.prototype.plotEdgesAroundVertex = function (e, t) {Debug.plot([e.position], "gx");for (var r = 0; r < e.adjacentEdges.length; r++) {var n,o = e.adjacentEdges[r];console.log(r), n = o.startVertex === e ? [o.parameterRange[0], o.parameterRange[0] + t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0])] : [o.parameterRange[1] - t / o.originalEdge.getCurve().tangentLength(o.parameterRange[0]), o.parameterRange[1]], Debug.plotEdgeList([o.originalEdge], !1, "-" + Debug.plotColorForIndex(r), { ranges: [n], showOrientation: !1, resolution: 1e4 });}}, V.prototype.getYvalueForX = function (e, t) {var r = e.parameterRange[0],n = e.parameterRange[1],o = e.originalEdge.evaluatePosition(r),s = e.originalEdge.evaluatePosition(n),a = o[0],c = s[0];if (a > c) {var u = r;r = n, n = u, u = a, a = c, c = u, u = o, o = s, s = u;}if (t <= a + i.KERNEL_TOLERANCE || t >= c - i.KERNEL_TOLERANCE) return Math.abs(t - a) <= i.KERNEL_TOLERANCE ? o[1] : Math.abs(t - c) <= i.KERNEL_TOLERANCE ? s[1] : void console.warn("Failure in getYvalueForX, in_x oustide segment range, returning undefined");for (; c >= a;) {if (a + i.KERNEL_TOLERANCE >= c) return h[1];var l = (r + n) / 2,h = e.originalEdge.evaluatePosition(l);if (Math.abs(r - n) <= i.PARAMETER_SPACE_TOLERANCE) return R.ConsoleUtils.assert(!1, "Could not converge to a solution for getYvalueForX"), h[1];h[0] < t ? (a = h[0], r = l) : (c = h[0], n = l);}console.warn("Failure in getYvalueForX, returning undefined");}, V.prototype._computeAngleAndPositionForEdge = function (e, t, r) {var o = t.adjacentEdges[e],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1];if (void 0 === r || !((s += (i ? 1 : -1) * r) < o.parameterRange[0] || s > o.parameterRange[1])) {var a = n.Vector3.createFloat64();return n.Vector3.normalize(a, o.originalEdge.evaluateDt(s)), i || n.Vector3.negate(a, a), { angle: Math.atan2(a[1], a[0]), position: o.originalEdge.evaluatePosition(s) };}}, V.prototype._computeEdgeDirectionAtVertex = function (e, t, r) {var o = t.adjacentEdges[e.index],i = o.startVertex === t,s = o.parameterRange[i ? 0 : 1],a = s + (i ? 1 : -1) * r / n.Vector3.length(o.originalEdge.evaluateDt(s)),c = o.originalEdge.evaluatePosition(a),u = n.Vector3.subtract(c, c, t.position);return Math.atan2(u[1], u[0]);}, V.prototype._prepareResult = function () {var e = new y.TopologyCloner();this._finalFaces = e.cloneFaces(this._faces), this._internalToFinalMap = e.getProgenitorMap(), this._progenitorMap = new m.ProgenitorMap();for (var t = e.getProgenitorMap().getAllNewTopology(), r = 0; r < t.length; r++) {var n = t[r],o = e.getProgenitorMap().getProgenitors(n)[0],s = void 0;n.getTopologyType() === i.TOPOLOGY_TYPES.FACE ? (s = new Set(), o.collectEdges().forEach(function (e) {e.getAssociatedEntities().forEach(function (e) {s.add(e);});}), s = Array.from(s)) : (n.getTopologyType() === i.TOPOLOGY_TYPES.EDGE || n.getTopologyType() === i.TOPOLOGY_TYPES.VERTEX) && (s = o.getAssociatedEntities()), s && this._progenitorMap.addEntry(n, s);}this._sketchSummary = { regionFaces: [], regionEdges: [], regionVertices: [], sketchEdges: {} };for (var a = P.default.keys(this._sketchRegionTopologies), c = 0; c < a.length; c++) {var u = this._sketchRegionTopologies[a[c]].topology;u instanceof E.RegionTopologyFace ? this._sketchSummary.regionFaces.push(u) : u instanceof E.RegionTopologyEdge ? this._sketchSummary.regionEdges.push(u) : u instanceof E.RegionTopologyVertex ? this._sketchSummary.regionVertices.push(u) : R.ConsoleUtils.assert(!1);}for (var l = 0; l < this._sketchEdges.length; l++) {var h = this._sketchEdges[l];this._sketchSummary.sketchEdges[h.getGuid()] = h;}}, V.prototype.getFaces = function () {return this._finalFaces;}, V.prototype.getRegionTopologyFaces = function () {return this._faces;}, V.prototype.getProgenitorMap = function () {return this._progenitorMap;}, V.prototype.createFaceRecipe = function (e) {var t = this._finalFaces.indexOf(e);if (t < 0) return "";var r = this._faces[t],n = (0, x.createRecipeFromRegionFace)(r, this._sketchSummary);return (0, x.serializeRegionFaceRecipe)(n);}, V.prototype.matchFaceRecipe = function (e) {for (var t = (0, x.deserializeRegionFaceRecipe)(e), r = (0, x.matchRegionFaceRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.regions.length; o++) {var i = this._faces.indexOf(r.regions[o]);R.ConsoleUtils.assert(i >= 0), n.push(this._finalFaces[i]);}return n;}, V.prototype.createEdgeRecipe = function (e) {var t = this._internalToFinalMap.getProgenitors(e);if (!t || 1 !== t.length) return "";var r = (0, x.createRecipeFromRegionEdge)(t[0], this._sketchSummary);return (0, x.serializeRegionEdgeRecipe)(r);}, V.prototype.matchEdgeRecipe = function (e) {for (var t = (0, x.deserializeRegionEdgeRecipe)(e), r = (0, x.matchRegionEdgeRecipe)(t, this._sketchSummary), n = [], o = 0; o < r.edges.length; o++) {var i = this._internalToFinalMap.getDescendants(r.edges[o]);R.ConsoleUtils.assert(1 === i.length), n.push(i[0]);}return n;}, t.SketchRegionSolver = V;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.computeCurveCurveIntersections = void 0;var n = r(1),o = r(0),i = r(6),s = r(7),a = r(20),c = r(16),u = r(72),l = r(36),h = r(3),d = r(110),g = o.KERNEL_TOLERANCE,p = function p(e, t, r, o) {var i = t,s = e.getRange();if (e.getCurve().isPeriodicUnlimited() && (i < s[0] - n.FLOAT64_TOLERANCE || i > s[1] + n.FLOAT64_TOLERANCE)) {var a = e.getCurve().getPeriodUnlimited();i = (0, h.foldNearTo)(i, .5 * (s[0] + s[1]), a);}var c = Math.abs(i - s[0]) < Math.abs(i - s[1]) ? 0 : 1,u = n.Vector3.length(e.evaluateDt(i));return Math.abs(i - s[c]) * u < r ? { param: s[c], atVertex: e.getVertex(c) } : i >= s[0] && i <= s[1] ? { param: i, atVertex: void 0 } : !e.isClosed() && o.distanceToPoint(e.getVertex(c).getPosition()) < r ? { param: s[c], atVertex: e.getVertex(c) } : void 0;},f = function f(e, t, r, o, i) {var s = p(e, t, i, r);if (s) {if (s.atVertex) {var a = r.getRange();e === r && (a = [o - .1 * (l = Math.abs(a[1] - a[0])), o + .1 * l]);var c = r.closestToPointParam(s.atVertex.getPosition(), a);n.Vector3.distance(r.evaluatePosition(c), s.atVertex.getPosition()) < i && (o = c);}var u = p(r, o, i, e);if (u) {var l;if (u.atVertex) a = e.getRange(), e === r && (a = [t - .1 * (l = Math.abs(a[1] - a[0])), t + .1 * l]), c = e.closestToPointParam(u.atVertex.getPosition(), a), n.Vector3.distance(e.evaluatePosition(c), u.atVertex.getPosition()) < i && (s = p(e, t = c, i, r));if (s) return { cutInfo: s, cutByInfo: u };}}},v = function v(e, t, r) {var n = [t - e.getRange()[0], t - e.getRange()[1]];if (n[0] >= r && n[1] <= -r) return { param: t, atVertex: void 0 };var o = Math.abs(n[0]) < Math.abs(n[1]) ? 0 : 1;return Math.abs(n[o]) < r ? { param: e.getRange()[o], atVertex: e.getVertex(o) } : void 0;},_ = function _(e, t, r, i, s, a, c) {var u = e.getCurve().getPeriodUnlimited(),l = t.getCurve().getPeriodUnlimited(),d = [r[0], r[2]],g = [i[0], i[2]],f = [s / n.Vector3.length(e.evaluateDt(d[0])), s / n.Vector3.length(e.evaluateDt(d[1]))],v = [s / n.Vector3.length(t.evaluateDt(g[0])), s / n.Vector3.length(t.evaluateDt(g[1]))];if (((0, h.isParameterWithinPeriodicRange)(d[0], e.getRange(), u, f[0]) || (0, h.isParameterWithinPeriodicRange)(d[1], e.getRange(), u, f[1])) && ((0, h.isParameterWithinPeriodicRange)(g[0], t.getRange(), l, v[0]) || (0, h.isParameterWithinPeriodicRange)(g[1], t.getRange(), l, v[1]))) {for (var _ = 0; _ < 2; _++) {d[_] = (0, h.adjustParameterToPeriodicRange)(d[_], e.getRange(), u, !1, !0), g[_] = (0, h.adjustParameterToPeriodicRange)(g[_], t.getRange(), l, !1, !0);var y = (0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15,m = (0, h.periodicDifference)(g[_], t.getRange()[0], l) < 3e-15 || (0, h.periodicDifference)(g[_], t.getRange()[1], l) < 3e-15;if (d[_] - e.getRange()[0] < f[_] && (d[_] = e.getRange()[0], y = !0), e.getRange()[1] - d[_] < f[_] && (d[_] = e.getRange()[1], y = !0), g[_] - t.getRange()[0] < v[_] && (g[_] = t.getRange()[0], m = !0), t.getRange()[1] - g[_] < v[_] && (g[_] = t.getRange()[1], m = !0), y) {var E = t.closestToPointParam(e.evaluatePosition(d[_]));g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0);}if (m) {var x = e.closestToPointParam(t.evaluatePosition(g[_]));d[_] = (0, h.adjustParameterToPeriodicRange)(x, e.getRange(), u, !1, !0), ((0, h.periodicDifference)(d[_], e.getRange()[0], u) < 3e-15 || (0, h.periodicDifference)(d[_], e.getRange()[1], u) < 3e-15) && (E = t.closestToPointParam(e.evaluatePosition(d[_])), g[_] = (0, h.adjustParameterToPeriodicRange)(E, t.getRange(), l, !1, !0));}}var R, A;if ((0, h.periodicDifference)(d[0], d[1], u) < Math.min(f[0], f[1]) && (0, h.periodicDifference)(g[0], g[1], l) < Math.min(v[0], v[1])) R = p(e, .5 * (d[0] + d[1]), s, e), A = p(t, .5 * (g[0] + g[1]), s, t);else for (R = p(e, r[1], s, e), A = p(t, i[1], s, t), _ = 0; _ < 2; _++) {if (!((0, h.periodicDifference)(d[_], R.param, u) < f[_] && (0, h.periodicDifference)(g[_], A.param, l) < v[_])) {var P,V,T = p(e, d[_], s, e),C = p(t, g[_], s, t);if (isFinite(u)) {var b = (0, h.getShortestParametricRange)(T.param, R.param, u);P = (0, h.periodicDifference)(R.param, b[0], u) <= o.KERNEL_ANGULAR_TOLERANCE;} else P = T.param > R.param;isFinite(l) ? (b = (0, h.getShortestParametricRange)(C.param, A.param, l), V = (0, h.periodicDifference)(A.param, b[0], l) <= o.KERNEL_ANGULAR_TOLERANCE) : V = C.param > A.param, a.push({ rangeInfo: P ? [R, T] : [T, R], rangeByInfo: V ? [A, C] : [C, A] });}}c && c.push({ firstParam: R.param, secondParam: A.param });}},y = function y(e, t, r, o) {var i = e.getRange(),s = e.evaluatePosition(0),a = e.evaluateDt(0),c = n.Vector2.length(a),u = t.getRange(),l = t.evaluatePosition(0),d = t.evaluateDt(0),g = n.Vector2.length(d),p = [a[1] / c, -a[0] / c],_ = t.evaluatePosition(u[0]);n.Vector2.subtract(_, _, s);var y = n.Vector2.dot(_, p),m = t.evaluatePosition(u[1]);n.Vector2.subtract(m, m, s);var E = n.Vector2.dot(m, p);if (Math.abs(y) <= o && Math.abs(E) <= o) {var x = n.Vector2.dot(_, a) / (c * c),R = n.Vector2.dot(m, a) / (c * c),A = [Math.min(x, R), Math.max(x, R)],P = o / c,V = o / g;if (A[1] < i[0] - P || A[0] > i[1] + P) return [];var T = [Math.max(i[0], A[0]), Math.min(i[1], A[1])];if (T[1] - T[0] < P) {var C = .5 * (T[0] + T[1]),b = Math.abs(R - x) > n.FLOAT64_TOLERANCE ? u[0] + (u[1] - u[0]) * (C - x) / (R - x) : .5 * (u[0] + u[1]);return [{ cutInfo: v(e, C, P), cutByInfo: v(t, b, V) }];}if (!r) return [];var L = u[0] + (u[1] - u[0]) * (T[0] - x) / (R - x),O = u[0] + (u[1] - u[0]) * (T[1] - x) / (R - x);return [{ rangeInfo: [v(e, T[0], P), v(e, T[1], P)], rangeByInfo: [v(t, Math.min(L, O), V), v(t, Math.max(L, O), V)] }];}if (y > o && E > o || y < -o && E < -o) return [];var S = [[a[0], -d[0], l[0] - s[0]], [a[1], -d[1], l[1] - s[1]]],M = (0, h.solveTwoEquationsTwoVariables)(S);if (M) {var w = f(e, M[0], t, M[1], o);if (w) return [w];}return [];},m = function m(e, t, r) {var o,i = t.getCenter(),s = e.closestToPointParam(i, []),a = e.evaluatePosition(s),c = n.Vector3.squaredDistance(a, i),u = [],l = t.getRadius(),h = l - Math.sqrt(c);if (h < -r) ;else if (h < r) o = t.closestToPointParam(a, []), u.push({ lineParam: s, circleParam: o });else for (var d = Math.sqrt(l * l - c) / n.Vector3.length(e.evaluateDt(0)), g = 0; g < 2; ++g) {var p = s + (0 === g ? -1 : 1) * d,f = e.evaluatePosition(p);o = t.closestToPointParam(f, []), u.push({ lineParam: p, circleParam: o });}return u;},E = function E(e, t, r, n, o, i) {var s = [r[0] + t * n[0] - e * n[1], r[1] + t * n[1] + e * n[0], 0];return { firstParam: o.closestToPointParam(s, [0, 2 * Math.PI]), secondParam: i.closestToPointParam(s, [0, 2 * Math.PI]) };},x = function x(e, t) {t || (t = o.KERNEL_TOLERANCE);for (var r = [], n = !1, i = [], s = [], a = 0; a < e.length; ++a) {e[a].hasOwnProperty("rangeInfo") ? (!1 === n ? (i = e[a].rangeInfo, s = e[a].rangeByInfo) : Math.abs(i[1].param - e[a].rangeInfo[0].param) < t && Math.abs(s[1].param - e[a].rangeByInfo[0].param) < t ? (i[1] = e[a].rangeInfo[1], s[1] = e[a].rangeByInfo[1]) : (r.push({ rangeInfo: i, rangeByInfo: s }), i = e[a].rangeInfo, s = e[a].rangeByInfo), n = !0) : e[a].hasOwnProperty("cutInfo") ? (n && r.push({ rangeInfo: i, rangeByInfo: s }), r.push(e[a]), n = !1) : console.warn("unknown segment type in intersection code");}return n && r.push({ rangeInfo: i, rangeByInfo: s }), r;},R = function R(e, t, r, o, i) {var s = r.getControlPoints(),a = r.getKnotVector(),c = e.getBoundingBox(),u = [];if (!r.getBoundingBox([a[0], a[a.length - 1]]).intersectsWithTolerance(c, i)) return u;var d = new Float64Array(s.length),g = s.length / 3 - 1,y = n.Vector2.createFloat64FromValues(e.getStartVertex().getPosition()[0], e.getStartVertex().getPosition()[1]),m = n.Vector3.createFloat64();n.Vector3.sub(m, e.getEndVertex().getPosition(), e.getStartVertex().getPosition()), n.Vector3.normalize(m, m);for (var E = n.Vector2.createFloat64FromValues(m[0], m[1]), x = n.Vector2.createFloat64(), R = !0, A = 0; A <= g; ++A) {x[0] = s[3 * A + 0], x[1] = s[3 * A + 1], d[3 * A + 0] = A / g, d[3 * A + 1] = (0, h.signedDistanceTo2DLine)(y, E, x), Math.abs(d[3 * A + 1]) > i && (R = !1), d[3 * A + 2] = 0;}if (R) return o ? u = function (e, t, r, o, i) {var s = o.length / 3 - 1,a = n.Vector3.createFloat64FromValues(o[0], o[1], o[2]),c = e.closestToPointParam(a),u = n.Vector3.createFloat64FromValues(o[3 * s + 0], o[3 * s + 1], o[3 * s + 2]),l = e.closestToPointParam(u),h = [v(e, c, r), v(e, l, r)];if (h[0].param > h[1].param) {var d = h[0];h[0] = h[1], h[1] = d;}var g = i[0],f = i[i.length - 1];if (t.isReversed()) {var _ = g;g = -f, f = -_;}var y = [p(t, g, r, e), p(t, f, r, e)];return h[0] && h[1] && y[0] && y[1] ? [{ rangeInfo: h, rangeByInfo: y }] : (console.warn("Error in intersection computation."), []);}(e, t, i, s, a) : [];var P = new Float64Array(3),V = [];return function (e, t, r, n, o, i, s, a, c) {var u,l = [],h = n.length / 3 - 1;3 === i ? (s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u), s[1] > s[2] && (u = s[1], s[1] = s[2], s[2] = u), s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u)) : 2 === i && s[0] > s[1] && (u = s[0], s[0] = s[1], s[1] = u);var d = [!1, !1, !1],g = o[o.length - 1] - o[0],v = t.getCurve().tangentLength(o[0]) * g;Math.abs(n[1]) < r && (0 === i || s[0] > r / v) && (i++, s[2] = s[1], s[1] = s[0], s[0] = 0, d[0] = !0);var y = t.getCurve().tangentLength(o[o.length - 1]) * g;Math.abs(n[3 * h + 1]) < r && (0 === i || 1 - s[i - 1] > r / y) && (s[i] = 1, d[i] = !0, i++);for (var m = e.isReversed() ? -1 : 1, E = t.isReversed() ? -1 : 1, x = 0, R = 0; R < i + 1; ++R) {var A = !1;if (R !== i) {var P = s[R];s[R] = o[0] + (o[o.length - 1] - o[0]) * s[R];var V = t.getCurve().evaluatePosition(s[R]),T = e.getCurve().closestToPointParam(V, []),C = f(e, T * m, t, s[R] * E, r);C && (C.cutInfo.virtualIntersection = d[R], C.cutByInfo.virtualIntersection = d[R], l.push(C));} else P = o[o.length - 1], A = Math.abs(n[3 * h + 1]) > r;if (0 === R && P > 0 && Math.abs(n[0]) > r && (A = !0), c) {var b = void 0;if (a.length > 0 && a[0][0] >= x && a[0][0] <= P && (b = a[0]), a.length > 1 && a[1][0] >= x && a[1][0] <= P && (b = a[1]), void 0 !== b && Math.abs(b[1]) < r && !A) {var L = [o[0] + (o[o.length - 1] - o[0]) * x, o[0] + (o[o.length - 1] - o[0]) * P],O = [e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[0]), []), e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(L[1]), [])];if (Math.abs(O[0] - O[1]) > r) {var S = [p(e, O[0] * m, r, t), p(e, O[1] * m, r, t)],M = [p(t, L[0] * E, r, e), p(t, L[1] * E, r, e)];if (S[0] && S[1] && M[0] && M[1]) {var w = o[0] + (o[o.length - 1] - o[0]) * b[0];w !== L[0] && w !== L[1] || (w = .5 * (L[0] + L[1]));var N = e.getCurve().closestToPointParam(t.getCurve().evaluatePosition(w), []);_(e, t, [O[0] * m, N * m, O[1] * m], [L[0] * E, w * E, L[1] * E], r, l);var F = { cutInfo: p(e, N * m, r, e), cutByInfo: p(t, w * E, r, e) };F.cutInfo.virtualIntersection = !0, F.cutByInfo.virtualIntersection = !0, l.push(F);}}}}x = P;}return l;}(e, t, i, d, a, l.SplineCurveHelper.intersect_xAxis_NonRationalCubicBSpline_XYPlanar3D([0, 0, 0], d, P, V), P, V, o);},A = function A(e, t, r, n) {var o = e.getBoundingBox(),i = [];if (!t.getBoundingBox().intersectsWithTolerance(o, n)) return i;for (var s = t.getCurve().getBezierSegments(), a = s.length, c = 0; c < a; c++) {for (var u = R(e, t, s[c], r, n), l = 0; l < u.length; ++l) {i.push(u[l]);}}return x(i);},P = function P(e, t, r, o, i) {var a = r.getControlPoints(),c = r.getKnotVector(),l = e.getBoundingBox(),d = [];if (!r.getBoundingBox([c[0], c[c.length - 1]]).intersectsWithTolerance(l, i)) return d;for (var v = !0, _ = n.Vector2.createFloat64(), y = n.Vector2.createFloat64(), E = n.Vector2.createFloat64(), x = 0; x < a.length / 3 - 2 && v; ++x) {_[0] = a[3 * x + 0], _[1] = a[3 * x + 1], y[0] = a[3 * x + 3], y[1] = a[3 * x + 4], E[0] = a[3 * x + 6], E[1] = a[3 * x + 7], v = Math.abs((0, h.orient2D)(_, y, E)) < g;}if (v) {var R = new s.Line(),A = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),P = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);R.setFromEndpoints(A, P);var V = n.Vector3.distance(P, A),T = m(R, e.getCurve(), i);for (x = 0; x < T.length; ++x) {if (T[x].lineParam >= 0 && T[x].lineParam <= V) {T[x].lineParam = t.getCurve().closestToPointParam(R.evaluatePosition(T[x].lineParam), []);var C = p(e, T[x].circleParam * (e.isReversed() ? -1 : 1), i, t),b = p(t, T[x].lineParam * (t.isReversed() ? -1 : 1), i, e);b && C && d.push({ cutInfo: C, cutByInfo: b });}}return d;}var L = n.Vector2.createFloat64(),O = n.Vector2.createFloat64(),S = n.Vector2.createFloat64(),M = n.Vector2.createFloat64();L[0] = -a[0] + 3 * a[3] - 3 * a[6] + a[9], L[1] = -a[1] + 3 * a[4] - 3 * a[7] + a[10], O[0] = 3 * a[0] - 6 * a[3] + 3 * a[6], O[1] = 3 * a[1] - 6 * a[4] + 3 * a[7], S[0] = -3 * a[0] + 3 * a[3], S[1] = -3 * a[1] + 3 * a[4], M[0] = a[0], M[1] = a[1];var w = e.getCurve().getCenter(),N = e.getCurve().getRadius() * e.getCurve().getRadius(),F = N,I = new Float64Array(7);I[0] = F * L[0] * L[0] + N * L[1] * L[1], I[1] = 2 * F * L[0] * O[0] + 2 * O[1] * N * L[1], I[2] = 2 * S[0] * F * L[0] + O[1] * O[1] * N + F * O[0] * O[0] + 2 * S[1] * N * L[1], I[3] = -2 * w[1] * N * L[1] + 2 * O[1] * S[1] * N + 2 * S[0] * F * O[0] - 2 * F * L[0] * w[0] + 2 * F * L[0] * M[0] + 2 * M[1] * N * L[1], I[4] = -2 * F * w[0] * O[0] + S[1] * S[1] * N - 2 * w[1] * O[1] * N + 2 * F * M[0] * O[0] + S[0] * S[0] * F + 2 * M[1] * O[1] * N, I[5] = -2 * w[1] * S[1] * N - 2 * S[0] * F * w[0] + 2 * S[0] * F * M[0] + 2 * M[1] * S[1] * N, I[6] = F * w[0] * w[0] - 2 * M[1] * w[1] * N - F * N + w[1] * w[1] * N + M[1] * M[1] * N - 2 * F * w[0] * M[0] + F * M[0] * M[0];var D = (0, u.getRealPolynomialRoots)(I);for (x = 0; x < D.length; ++x) {if (D[x] >= 0 && D[x] <= 1) {D[x] = c[0] + (c[c.length - 1] - c[0]) * D[x];var j = t.getCurve().evaluatePosition(D[x]),B = e.getCurve().closestToPointParam(j, []),U = f(e, B * (e.isReversed() ? -1 : 1), t, D[x] * (t.isReversed() ? -1 : 1), i);U && d.push(U);}}return d;},V = function V(e, t, r, n, o) {var i = e.getBoundingBox(),s = [];if (!t.getBoundingBox().intersectsWithTolerance(i, o)) return s;var a = 0;e.isClosed() && n && (a = 1);for (var c = t.getCurve().getBezierSegments(), u = c.length, l = 0; l < u; l++) {for (var h = P(e, t, c[l], 0, o), d = 0; d < h.length; ++d) {for (var g = -a; g <= a; ++g) {s.push({ cutInfo: { atVertex: h[d].cutInfo.atVertex, param: h[d].cutInfo.param + g * Math.PI * 2 }, cutByInfo: h[d].cutByInfo });}}}return x(s);},T = function T(e, t, r, l, d, v, _) {var m = r.getControlPoints(),E = r.getKnotVector(),x = l.getControlPoints(),A = l.getKnotVector(),P = r.getBoundingBox([E[0], E[E.length - 1]]),V = l.getBoundingBox([A[0], A[A.length - 1]]),T = e === t,C = !1,b = !1;T && Math.abs(m[m.length - 3] - x[0]) < v && Math.abs(m[x.length - 2] - x[1]) < v && Math.abs(m[x.length - 1] - x[2]) < v && (C = !0), T && Math.abs(m[0] - x[m.length - 3]) < v && Math.abs(m[1] - x[x.length - 2]) < v && Math.abs(m[2] - x[x.length - 1]) < v && (b = !0);var L = [];if (!P.intersectsWithTolerance(V, v)) return L;var O = !0,S = !0,M = n.Vector2.createFloat64(),w = n.Vector2.createFloat64(),N = n.Vector2.createFloat64();for (we = 0; we < m.length / 3 - 2 && O; ++we) {M[0] = m[3 * we + 0], M[1] = m[3 * we + 1], w[0] = m[3 * we + 3], w[1] = m[3 * we + 4], N[0] = m[3 * we + 6], N[1] = m[3 * we + 7], O = Math.abs((0, h.orient2D)(M, w, N)) < g;}for (we = 0; we < x.length / 3 - 2 && S; ++we) {M[0] = x[3 * we + 0], M[1] = x[3 * we + 1], w[0] = x[3 * we + 3], w[1] = x[3 * we + 4], N[0] = x[3 * we + 6], N[1] = x[3 * we + 7], S = Math.abs((0, h.orient2D)(M, w, N)) < g;}if (O || S) return function (e, t, r, u, l, h, d, g, v) {var _ = l.getControlPoints(),m = h.getControlPoints(),E = [];if (e && !t || !e && t) {var x,A,P = new s.Line();e ? (x = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]), A = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1])) : (x = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]), A = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1])), P.setFromEndpoints(x, A);var V = new a.Edge(P),T = n.Vector3.distance(A, x);V.setRange([0, T]);var C = new i.Point();C.setPosition(x[0], x[1], x[2]);var b = new i.Point();b.setPosition(A[0], A[1], A[2]);var L,O = new c.Vertex(C),S = new c.Vertex(b);V.setStartVertex(O), V.setEndVertex(S), ee = e ? R(V, u, h, d, g) : R(V, r, l, d, g);for (var M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty("cutInfo") && ee[M].hasOwnProperty("cutByInfo")) {if (ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= T && (e ? (ee[M].cutInfo.param = r.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) : (ee[M].cutInfo.param = u.closestToPointParam(P.evaluatePosition(ee[M].cutInfo.param)), L = f(r, ee[M].cutByInfo.param, u, ee[M].cutInfo.param, g)), L)) if (v) {var w = L.cutInfo.param,N = L.cutByInfo.param;(F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w))) > o.KERNEL_TOLERANCE && !ee[M].cutInfo.virtualIntersection && E.push(L);} else E.push(L);} else if (ee[M].hasOwnProperty("rangeInfo") && ee[M].hasOwnProperty("rangeByInfo") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= T && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= T) if (e ? (ee[M].rangeInfo[0].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))) : (ee[M].rangeInfo[0].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = u.closestToPointParam(P.evaluatePosition(ee[M].rangeInfo[1].param))), e ? (te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)], re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)]) : (te = [p(r, ee[M].rangeByInfo[0].param, g, u), p(r, ee[M].rangeByInfo[1].param, g, u)], re = [p(u, ee[M].rangeInfo[0].param, g, r), p(u, ee[M].rangeInfo[1].param, g, r)]), te[0] && te[1] && re[0] && re[1]) {var F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1]));(!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re });} else console.warn("Error in intersection computation.");}} else {var I = new s.Line(),D = new s.Line(),j = n.Vector3.createFloat64FromValues(_[0], _[1], _[2]),B = n.Vector3.createFloat64FromValues(_[_.length - 3], _[_.length - 2], _[_.length - 1]),U = n.Vector3.createFloat64FromValues(m[0], m[1], m[2]),k = n.Vector3.createFloat64FromValues(m[m.length - 3], m[m.length - 2], m[m.length - 1]);I.setFromEndpoints(j, B), D.setFromEndpoints(U, k);var G = new a.Edge(I),z = n.Vector3.distance(B, j),Y = new a.Edge(D),K = n.Vector3.distance(k, U);G.setRange([0, z]), Y.setRange([0, K]);var q = new i.Point();q.setPosition(j[0], j[1], j[2]);var W = new i.Point();W.setPosition(B[0], B[1], B[2]);var H = new i.Point();H.setPosition(U[0], U[1], U[2]);var X = new i.Point();X.setPosition(k[0], k[1], k[2]);var J = new c.Vertex(q),$ = new c.Vertex(W),Z = new c.Vertex(H),Q = new c.Vertex(X);G.setStartVertex(J), G.setEndVertex($), Y.setStartVertex(Z), Y.setEndVertex(Q);var ee = y(G, Y, d, g);for (M = 0; M < ee.length; ++M) {if (ee[M].hasOwnProperty("cutInfo") && ee[M].hasOwnProperty("cutByInfo")) ee[M].cutInfo.param >= 0 && ee[M].cutInfo.param <= z && ee[M].cutByInfo.param >= 0 && ee[M].cutByInfo.param <= K && (ee[M].cutInfo.param = r.closestToPointParam(I.evaluatePosition(ee[M].cutInfo.param)), ee[M].cutByInfo.param = u.closestToPointParam(D.evaluatePosition(ee[M].cutByInfo.param)), L = f(r, ee[M].cutInfo.param, u, ee[M].cutByInfo.param, g)) && (w = L.cutInfo.param, N = L.cutByInfo.param, F = Math.abs(w - N) * n.Vector3.length(r.evaluateDt(w)), (!v || v && F > o.KERNEL_TOLERANCE) && E.push(L));else if (ee[M].hasOwnProperty("rangeInfo") && ee[M].hasOwnProperty("rangeByInfo") && ee[M].rangeInfo[0].param >= 0 && ee[M].rangeInfo[0].param <= z && ee[M].rangeInfo[1].param >= 0 && ee[M].rangeInfo[1].param <= z && ee[M].rangeByInfo[0].param >= 0 && ee[M].rangeByInfo[0].param <= K && ee[M].rangeByInfo[1].param >= 0 && ee[M].rangeByInfo[1].param <= K) {ee[M].rangeInfo[0].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[0].param)), ee[M].rangeInfo[1].param = r.closestToPointParam(I.evaluatePosition(ee[M].rangeInfo[1].param)), ee[M].rangeByInfo[0].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[0].param)), ee[M].rangeByInfo[1].param = u.closestToPointParam(D.evaluatePosition(ee[M].rangeByInfo[1].param));var te = [p(r, ee[M].rangeInfo[0].param, g, u), p(r, ee[M].rangeInfo[1].param, g, u)],re = [p(u, ee[M].rangeByInfo[0].param, g, r), p(u, ee[M].rangeByInfo[1].param, g, r)];te[0] && te[1] && re[0] && re[1] ? (F = Math.abs(te[1].param - re[0].param) * n.Vector3.length(r.evaluateDt(te[1])), (!v || v && F > o.KERNEL_TOLERANCE) && E.push({ rangeInfo: te, rangeByInfo: re })) : console.warn("Error in intersection computation.");}}}return E;}(O, S, e, t, r, l, d, v, _);var F = -m[0] + 3 * m[3] - 3 * m[6] + m[9],I = 3 * m[0] - 6 * m[3] + 3 * m[6],D = -3 * m[0] + 3 * m[3],j = m[0],B = -m[1] + 3 * m[4] - 3 * m[7] + m[10],U = 3 * m[1] - 6 * m[4] + 3 * m[7],k = -3 * m[1] + 3 * m[4],G = m[1],z = j * j,Y = D * D,K = I * I,q = F * F,W = j * j * j,H = D * D * D,X = I * I * I,J = F * F * F,$ = G * G,Z = k * k,Q = U * U,ee = B * B,te = G * G * G,re = k * k * k,ne = U * U * U,oe = B * B * B,ie = -x[0] + 3 * x[3] - 3 * x[6] + x[9],se = 3 * x[0] - 6 * x[3] + 3 * x[6],ae = -3 * x[0] + 3 * x[3],ce = x[0],ue = -x[1] + 3 * x[4] - 3 * x[7] + x[10],le = 3 * x[1] - 6 * x[4] + 3 * x[7],he = -3 * x[1] + 3 * x[4],de = x[1],ge = ce * ce,pe = ce * ce * ce,fe = de * de,ve = de * de * de,_e = ae * ae,ye = ae * ae * ae,me = he * he,Ee = he * he * he,xe = se * se,Re = se * se * se,Ae = le * le,Pe = le * le * le,Ve = ie * ie,Te = ue * ue,Ce = new Float64Array(10),be = F * ue - B * ie;Ce[0] = be * be * be, Ce[1] = 3 * (F * le - B * se) * be * be, Ce[2] = 3 * (F * ue - B * ie) * (q * he * ue + q * Ae - F * B * ae * ue - 2 * F * B * se * le - F * B * ie * he + ee * ae * ie + ee * xe), Ce[3] = 3 * j * q * B * Te - 6 * j * F * ee * ie * ue + 3 * j * oe * Ve - 3 * D * I * F * B * Te + 3 * D * I * ee * ie * ue + 2 * D * q * U * Te - D * F * U * B * ie * ue - D * U * ee * Ve + X * B * Te - K * F * U * Te - 2 * K * U * B * ie * ue + I * q * k * Te + I * F * k * B * ie * ue + 2 * I * F * Q * ie * ue - 2 * I * k * ee * Ve + I * Q * B * Ve - 3 * J * G * Te + 3 * J * de * Te + 6 * J * he * le * ue + J * Pe + 6 * q * G * B * ie * ue - 3 * q * k * U * ie * ue - 3 * q * B * ce * Te - 6 * q * B * ae * le * ue - 6 * q * B * se * he * ue - 3 * q * B * se * Ae - 6 * q * B * ie * de * ue - 6 * q * B * ie * he * le - 3 * F * G * ee * Ve + 3 * F * k * U * B * Ve - F * ne * Ve + 6 * F * ee * ce * ie * ue + 6 * F * ee * ae * se * ue + 6 * F * ee * ae * ie * le + 3 * F * ee * xe * le + 6 * F * ee * se * ie * he + 3 * F * ee * Ve * de - 3 * oe * ce * Ve - 6 * oe * ae * se * ie - oe * Re, Ce[4] = 6 * j * q * B * le * ue - 6 * j * F * ee * se * ue - 6 * j * F * ee * ie * le + 6 * j * oe * se * ie - 6 * D * I * F * B * le * ue + 3 * D * I * ee * se * ue + 3 * D * I * ee * ie * le + 4 * D * q * U * le * ue - D * F * U * B * se * ue - D * F * U * B * ie * le - 2 * D * U * ee * se * ie + 2 * X * B * le * ue - 2 * K * F * U * le * ue - 2 * K * U * B * se * ue - 2 * K * U * B * ie * le + 2 * I * q * k * le * ue + I * F * k * B * se * ue + I * F * k * B * ie * le + 2 * I * F * Q * se * ue + 2 * I * F * Q * ie * le - 4 * I * k * ee * se * ie + 2 * I * Q * B * se * ie - 6 * J * G * le * ue + 6 * J * de * le * ue + 3 * J * me * ue + 3 * J * he * Ae + 6 * q * G * B * se * ue + 6 * q * G * B * ie * le - 3 * q * k * U * se * ue - 3 * q * k * U * ie * le - 6 * q * B * ce * le * ue - 6 * q * B * ae * he * ue - 3 * q * B * ae * Ae - 6 * q * B * se * de * ue - 6 * q * B * se * he * le - 6 * q * B * ie * de * le - 3 * q * B * ie * me - 6 * F * G * ee * se * ie + 6 * F * k * U * B * se * ie - 2 * F * ne * se * ie + 6 * F * ee * ce * se * ue + 6 * F * ee * ce * ie * le + 3 * F * ee * _e * ue + 6 * F * ee * ae * se * le + 6 * F * ee * ae * ie * he + 3 * F * ee * xe * he + 6 * F * ee * se * ie * de - 6 * oe * ce * se * ie - 3 * oe * _e * ie - 3 * oe * ae * xe, Ce[5] = 6 * j * q * B * he * ue + 3 * j * q * B * Ae - 6 * j * F * ee * ae * ue - 6 * j * F * ee * se * le - 6 * j * F * ee * ie * he + 6 * j * oe * ae * ie + 3 * j * oe * xe - 6 * D * I * F * B * he * ue - 3 * D * I * F * B * Ae + 3 * D * I * ee * ae * ue + 3 * D * I * ee * se * le + 3 * D * I * ee * ie * he + 4 * D * q * U * he * ue + 2 * D * q * U * Ae - D * F * U * B * ae * ue - D * F * U * B * se * le - D * F * U * B * ie * he - 2 * D * U * ee * ae * ie - D * U * ee * xe + 2 * X * B * he * ue + X * B * Ae - 2 * K * F * U * he * ue - K * F * U * Ae - 2 * K * U * B * ae * ue - 2 * K * U * B * se * le - 2 * K * U * B * ie * he + 2 * I * q * k * he * ue + I * q * k * Ae + I * F * k * B * ae * ue + I * F * k * B * se * le + I * F * k * B * ie * he + 2 * I * F * Q * ae * ue + 2 * I * F * Q * se * le + 2 * I * F * Q * ie * he - 4 * I * k * ee * ae * ie - 2 * I * k * ee * xe + 2 * I * Q * B * ae * ie + I * Q * B * xe - 6 * J * G * he * ue - 3 * J * G * Ae + 6 * J * de * he * ue + 3 * J * de * Ae + 3 * J * me * le + 6 * q * G * B * ae * ue + 6 * q * G * B * se * le + 6 * q * G * B * ie * he - 3 * q * k * U * ae * ue - 3 * q * k * U * se * le - 3 * q * k * U * ie * he - 6 * q * B * ce * he * ue - 3 * q * B * ce * Ae - 6 * q * B * ae * de * ue - 6 * q * B * ae * he * le - 6 * q * B * se * de * le - 3 * q * B * se * me - 6 * q * B * ie * de * he - 6 * F * G * ee * ae * ie - 3 * F * G * ee * xe + 6 * F * k * U * B * ae * ie + 3 * F * k * U * B * xe - 2 * F * ne * ae * ie - F * ne * xe + 6 * F * ee * ce * ae * ue + 6 * F * ee * ce * se * le + 6 * F * ee * ce * ie * he + 3 * F * ee * _e * le + 6 * F * ee * ae * se * he + 6 * F * ee * ae * ie * de + 3 * F * ee * xe * de - 6 * oe * ce * ae * ie - 3 * oe * ce * xe - 3 * oe * _e * se, Ce[6] = 3 * z * F * ee * ue - 3 * z * oe * ie - 3 * j * D * I * ee * ue + j * D * F * U * B * ue + 2 * j * D * U * ee * ie + 2 * j * K * U * B * ue - j * I * F * k * B * ue - 2 * j * I * F * Q * ue + 4 * j * I * k * ee * ie - 2 * j * I * Q * B * ie - 6 * j * q * G * B * ue + 3 * j * q * k * U * ue + 6 * j * q * B * de * ue + 6 * j * q * B * he * le + 6 * j * F * G * ee * ie - 6 * j * F * k * U * B * ie + 2 * j * F * ne * ie - 6 * j * F * ee * ce * ue - 6 * j * F * ee * ae * le - 6 * j * F * ee * se * he - 6 * j * F * ee * ie * de + 6 * j * oe * ce * ie + 6 * j * oe * ae * se + H * ee * ue - Y * I * U * B * ue - 2 * Y * F * k * B * ue + Y * F * Q * ue - Y * k * ee * ie + D * K * k * B * ue + 6 * D * I * F * G * B * ue - D * I * F * k * U * ue - 6 * D * I * F * B * de * ue - 6 * D * I * F * B * he * le - 3 * D * I * G * ee * ie + D * I * k * U * B * ie + 3 * D * I * ee * ce * ue + 3 * D * I * ee * ae * le + 3 * D * I * ee * se * he + 3 * D * I * ee * ie * de - 4 * D * q * G * U * ue + D * q * Z * ue + 4 * D * q * U * de * ue + 4 * D * q * U * he * le + D * F * G * U * B * ie + 2 * D * F * Z * B * ie - D * F * k * Q * ie - D * F * U * B * ce * ue - D * F * U * B * ae * le - D * F * U * B * se * he - D * F * U * B * ie * de - 2 * D * U * ee * ce * ie - 2 * D * U * ee * ae * se - 2 * X * G * B * ue + 2 * X * B * de * ue + 2 * X * B * he * le + 2 * K * F * G * U * ue - 2 * K * F * U * de * ue - 2 * K * F * U * he * le + 2 * K * G * U * B * ie - K * Z * B * ie - 2 * K * U * B * ce * ue - 2 * K * U * B * ae * le - 2 * K * U * B * se * he - 2 * K * U * B * ie * de - 2 * I * q * G * k * ue + 2 * I * q * k * de * ue + 2 * I * q * k * he * le - I * F * G * k * B * ie - 2 * I * F * G * Q * ie + I * F * Z * U * ie + I * F * k * B * ce * ue + I * F * k * B * ae * le + I * F * k * B * se * he + I * F * k * B * ie * de + 2 * I * F * Q * ce * ue + 2 * I * F * Q * ae * le + 2 * I * F * Q * se * he + 2 * I * F * Q * ie * de - 4 * I * k * ee * ce * ie - 4 * I * k * ee * ae * se + 2 * I * Q * B * ce * ie + 2 * I * Q * B * ae * se + 3 * J * $ * ue - 6 * J * G * de * ue - 6 * J * G * he * le + 3 * J * fe * ue + 6 * J * de * he * le + J * Ee - 3 * q * $ * B * ie + 3 * q * G * k * U * ie + 6 * q * G * B * ce * ue + 6 * q * G * B * ae * le + 6 * q * G * B * se * he + 6 * q * G * B * ie * de - q * re * ie - 3 * q * k * U * ce * ue - 3 * q * k * U * ae * le - 3 * q * k * U * se * he - 3 * q * k * U * ie * de - 6 * q * B * ce * de * ue - 6 * q * B * ce * he * le - 6 * q * B * ae * de * le - 3 * q * B * ae * me - 6 * q * B * se * de * he - 3 * q * B * ie * fe - 6 * F * G * ee * ce * ie - 6 * F * G * ee * ae * se + 6 * F * k * U * B * ce * ie + 6 * F * k * U * B * ae * se - 2 * F * ne * ce * ie - 2 * F * ne * ae * se + 3 * F * ee * ge * ue + 6 * F * ee * ce * ae * le + 6 * F * ee * ce * se * he + 6 * F * ee * ce * ie * de + 3 * F * ee * _e * he + 6 * F * ee * ae * se * de - 3 * oe * ge * ie - 6 * oe * ce * ae * se - oe * ye, Ce[7] = 3 * z * F * ee * le - 3 * z * oe * se - 3 * j * D * I * ee * le + j * D * F * U * B * le + 2 * j * D * U * ee * se + 2 * j * K * U * B * le - j * I * F * k * B * le - 2 * j * I * F * Q * le + 4 * j * I * k * ee * se - 2 * j * I * Q * B * se - 6 * j * q * G * B * le + 3 * j * q * k * U * le + 6 * j * q * B * de * le + 3 * j * q * B * me + 6 * j * F * G * ee * se - 6 * j * F * k * U * B * se + 2 * j * F * ne * se - 6 * j * F * ee * ce * le - 6 * j * F * ee * ae * he - 6 * j * F * ee * se * de + 6 * j * oe * ce * se + 3 * j * oe * _e + H * ee * le - Y * I * U * B * le - 2 * Y * F * k * B * le + Y * F * Q * le - Y * k * ee * se + D * K * k * B * le + 6 * D * I * F * G * B * le - D * I * F * k * U * le - 6 * D * I * F * B * de * le - 3 * D * I * F * B * me - 3 * D * I * G * ee * se + D * I * k * U * B * se + 3 * D * I * ee * ce * le + 3 * D * I * ee * ae * he + 3 * D * I * ee * se * de - 4 * D * q * G * U * le + D * q * Z * le + 4 * D * q * U * de * le + 2 * D * q * U * me + D * F * G * U * B * se + 2 * D * F * Z * B * se - D * F * k * Q * se - D * F * U * B * ce * le - D * F * U * B * ae * he - D * F * U * B * se * de - 2 * D * U * ee * ce * se - D * U * ee * _e - 2 * X * G * B * le + 2 * X * B * de * le + X * B * me + 2 * K * F * G * U * le - 2 * K * F * U * de * le - K * F * U * me + 2 * K * G * U * B * se - K * Z * B * se - 2 * K * U * B * ce * le - 2 * K * U * B * ae * he - 2 * K * U * B * se * de - 2 * I * q * G * k * le + 2 * I * q * k * de * le + I * q * k * me - I * F * G * k * B * se - 2 * I * F * G * Q * se + I * F * Z * U * se + I * F * k * B * ce * le + I * F * k * B * ae * he + I * F * k * B * se * de + 2 * I * F * Q * ce * le + 2 * I * F * Q * ae * he + 2 * I * F * Q * se * de - 4 * I * k * ee * ce * se - 2 * I * k * ee * _e + 2 * I * Q * B * ce * se + I * Q * B * _e + 3 * J * $ * le - 6 * J * G * de * le - 3 * J * G * me + 3 * J * fe * le + 3 * J * de * me - 3 * q * $ * B * se + 3 * q * G * k * U * se + 6 * q * G * B * ce * le + 6 * q * G * B * ae * he + 6 * q * G * B * se * de - q * re * se - 3 * q * k * U * ce * le - 3 * q * k * U * ae * he - 3 * q * k * U * se * de - 6 * q * B * ce * de * le - 3 * q * B * ce * me - 6 * q * B * ae * de * he - 3 * q * B * se * fe - 6 * F * G * ee * ce * se - 3 * F * G * ee * _e + 6 * F * k * U * B * ce * se + 3 * F * k * U * B * _e - 2 * F * ne * ce * se - F * ne * _e + 3 * F * ee * ge * le + 6 * F * ee * ce * ae * he + 6 * F * ee * ce * se * de + 3 * F * ee * _e * de - 3 * oe * ge * se - 3 * oe * ce * _e, Ce[8] = 3 * z * F * ee * he - 3 * z * oe * ae - 3 * j * D * I * ee * he + j * D * F * U * B * he + 2 * j * D * U * ee * ae + 2 * j * K * U * B * he - j * I * F * k * B * he - 2 * j * I * F * Q * he + 4 * j * I * k * ee * ae - 2 * j * I * Q * B * ae - 6 * j * q * G * B * he + 3 * j * q * k * U * he + 6 * j * q * B * de * he + 6 * j * F * G * ee * ae - 6 * j * F * k * U * B * ae + 2 * j * F * ne * ae - 6 * j * F * ee * ce * he - 6 * j * F * ee * ae * de + 6 * j * oe * ce * ae + H * ee * he - Y * I * U * B * he - 2 * Y * F * k * B * he + Y * F * Q * he - Y * k * ee * ae + D * K * k * B * he + 6 * D * I * F * G * B * he - D * I * F * k * U * he - 6 * D * I * F * B * de * he - 3 * D * I * G * ee * ae + D * I * k * U * B * ae + 3 * D * I * ee * ce * he + 3 * D * I * ee * ae * de - 4 * D * q * G * U * he + D * q * Z * he + 4 * D * q * U * de * he + D * F * G * U * B * ae + 2 * D * F * Z * B * ae - D * F * k * Q * ae - D * F * U * B * ce * he - D * F * U * B * ae * de - 2 * D * U * ee * ce * ae - 2 * X * G * B * he + 2 * X * B * de * he + 2 * K * F * G * U * he - 2 * K * F * U * de * he + 2 * K * G * U * B * ae - K * Z * B * ae - 2 * K * U * B * ce * he - 2 * K * U * B * ae * de - 2 * I * q * G * k * he + 2 * I * q * k * de * he - I * F * G * k * B * ae - 2 * I * F * G * Q * ae + I * F * Z * U * ae + I * F * k * B * ce * he + I * F * k * B * ae * de + 2 * I * F * Q * ce * he + 2 * I * F * Q * ae * de - 4 * I * k * ee * ce * ae + 2 * I * Q * B * ce * ae + 3 * J * $ * he - 6 * J * G * de * he + 3 * J * fe * he - 3 * q * $ * B * ae + 3 * q * G * k * U * ae + 6 * q * G * B * ce * he + 6 * q * G * B * ae * de - q * re * ae - 3 * q * k * U * ce * he - 3 * q * k * U * ae * de - 6 * q * B * ce * de * he - 3 * q * B * ae * fe - 6 * F * G * ee * ce * ae + 6 * F * k * U * B * ce * ae - 2 * F * ne * ce * ae + 3 * F * ee * ge * he + 6 * F * ee * ce * ae * de - 3 * oe * ge * ae, Ce[9] = W * oe - z * D * U * ee - 2 * z * I * k * ee + z * I * Q * B - 3 * z * F * G * ee + 3 * z * F * k * U * B - z * F * ne + 3 * z * F * ee * de - 3 * z * oe * ce + j * Y * k * ee + 3 * j * D * I * G * ee - j * D * I * k * U * B - 3 * j * D * I * ee * de - j * D * F * G * U * B - 2 * j * D * F * Z * B + j * D * F * k * Q + j * D * F * U * B * de + 2 * j * D * U * ee * ce - 2 * j * K * G * U * B + j * K * Z * B + 2 * j * K * U * B * de + j * I * F * G * k * B + 2 * j * I * F * G * Q - j * I * F * Z * U - j * I * F * k * B * de - 2 * j * I * F * Q * de + 4 * j * I * k * ee * ce - 2 * j * I * Q * B * ce + 3 * j * q * $ * B - 3 * j * q * G * k * U - 6 * j * q * G * B * de + j * q * re + 3 * j * q * k * U * de + 3 * j * q * B * fe + 6 * j * F * G * ee * ce - 6 * j * F * k * U * B * ce + 2 * j * F * ne * ce - 6 * j * F * ee * ce * de + 3 * j * oe * ge - H * G * ee + H * ee * de + Y * I * G * U * B - Y * I * U * B * de + 2 * Y * F * G * k * B - Y * F * G * Q - 2 * Y * F * k * B * de + Y * F * Q * de - Y * k * ee * ce - D * K * G * k * B + D * K * k * B * de - 3 * D * I * F * $ * B + D * I * F * G * k * U + 6 * D * I * F * G * B * de - D * I * F * k * U * de - 3 * D * I * F * B * fe - 3 * D * I * G * ee * ce + D * I * k * U * B * ce + 3 * D * I * ee * ce * de + 2 * D * q * $ * U - D * q * G * Z - 4 * D * q * G * U * de + D * q * Z * de + 2 * D * q * U * fe + D * F * G * U * B * ce + 2 * D * F * Z * B * ce - D * F * k * Q * ce - D * F * U * B * ce * de - D * U * ee * ge + X * $ * B - 2 * X * G * B * de + X * B * fe - K * F * $ * U + 2 * K * F * G * U * de - K * F * U * fe + 2 * K * G * U * B * ce - K * Z * B * ce - 2 * K * U * B * ce * de + I * q * $ * k - 2 * I * q * G * k * de + I * q * k * fe - I * F * G * k * B * ce - 2 * I * F * G * Q * ce + I * F * Z * U * ce + I * F * k * B * ce * de + 2 * I * F * Q * ce * de - 2 * I * k * ee * ge + I * Q * B * ge - J * te + 3 * J * $ * de - 3 * J * G * fe + J * ve - 3 * q * $ * B * ce + 3 * q * G * k * U * ce + 6 * q * G * B * ce * de - q * re * ce - 3 * q * k * U * ce * de - 3 * q * B * ce * fe - 3 * F * G * ee * ge + 3 * F * k * U * B * ge - F * ne * ge + 3 * F * ee * ge * de - oe * pe;var Le = (0, u.getRealPolynomialRoots)(Ce),Oe = l.getApproxParameterSpaceTolerance(),Se = -Oe,Me = 1 + Oe;C && (Se = Oe), b && (Me = 1 - Oe);for (var we = 0; we < Le.length; ++we) {if (Le[we] >= Se && Le[we] <= Me) {Le[we] < 0 ? Le[we] = 0 : Le[we] > 1 && (Le[we] = 1), Le[we] = A[0] + (A[A.length - 1] - A[0]) * Le[we];var Ne = t.getCurve().evaluatePosition(Le[we]);if (P.isPointInsideWithTolerance(Ne)) {var Fe = r.closestToPointParam(Ne, []);if (Fe >= E[0] && Fe <= E[E.length - 1]) {var Ie = e.getCurve().evaluatePosition(Fe);if (n.Vector3.squaredDistance(Ie, Ne) <= v * v) {var De = f(e, Fe * (e.isReversed() ? -1 : 1), t, Le[we] * (t.isReversed() ? -1 : 1), v);De && L.push(De);}}}}}return L;},C = function C(e, t, r, o) {var i = [],a = t.getControlPoints(),c = e.isReversed() ? -1 : 1,u = new s.Line(),h = n.Vector3.createFloat64FromValues(a[0], a[1], a[2]),d = n.Vector3.createFloat64FromValues(a[a.length - 3], a[a.length - 2], a[a.length - 1]);u.setFromEndpoints(h, d);var g = n.Vector3.distance(d, h),p = n.Vector3.createFloat64FromValues(a[3], a[4], a[5]),v = n.Vector3.createFloat64FromValues(a[6], a[7], a[8]);if (u.closestToPointParam(p, []) > 0 && u.closestToPointParam(p, []) < g && u.closestToPointParam(v, []) > 0 && u.closestToPointParam(v, []) < g) return i;var _,y = -a[0] + 3 * a[3] - 3 * a[6] + a[9],m = -a[1] + 3 * a[4] - 3 * a[7] + a[10],E = 3 * a[0] - 6 * a[3] + 3 * a[6],x = 3 * a[1] - 6 * a[4] + 3 * a[7],R = -3 * a[0] + 3 * a[3],A = -3 * a[1] + 3 * a[4],P = E / y,V = R / y,T = x / m,C = A / m;if (Math.abs(P - T) < o || Math.abs(C - V) < o) return i;var b = new Float64Array(4);if (Math.abs(y) < o && Math.abs(m) < o) return i;Math.abs(y) < o ? (_ = -R / E, P = T, V = C) : _ = Math.abs(m) < o ? -A / x : (C - V) / (P - T), b[0] = (-_ * _ * _ - P * _ * _ - V * _) / 2, b[1] = (3 * _ * _ + 2 * _ * P + 2 * V) / 2, b[2] = -1.5 * _, b[3] = 1;var L,O = new Float64Array(3);if (3 !== l.SplineCurveHelper.solve_cubic_uniqueRoots(b, O)) return i;if (O[1] < O[0] && (L = O[0], O[0] = O[1], O[1] = L), O[2] < O[0] && (L = O[0], O[0] = O[2], O[2] = L), O[2] < O[1] && (L = O[1], O[1] = O[2], O[2] = L), O[0] >= 0 && O[0] <= 1 && O[2] >= 0 && O[2] <= 1) {var S = t.getKnotVector();O[0] = S[0] + (S[S.length - 1] - S[0]) * O[0], O[2] = S[0] + (S[S.length - 1] - S[0]) * O[2];var M = f(e, O[0] * c, e, O[2] * c, o);M && i.push(M);}return i;};t.computeCurveCurveIntersections = function (e, t, r, i, s) {s = void 0 === s ? o.KERNEL_TOLERANCE : s;var a = e.getCurveType(),c = a === o.GEOMETRY_TYPES.CIRCLE,u = a === o.GEOMETRY_TYPES.LINE,l = a === o.GEOMETRY_TYPES.BCURVE && !e.getCurve().isRational() && 3 === e.getCurve().getDegree(),g = t.getCurveType(),v = g === o.GEOMETRY_TYPES.CIRCLE,R = g === o.GEOMETRY_TYPES.LINE,P = g === o.GEOMETRY_TYPES.BCURVE && !t.getCurve().isRational() && 3 === t.getCurve().getDegree();return u && v ? function (e, t, r) {for (var n = m(e.getCurve(), t.getCurve(), r), o = [], i = 0; i < n.length; ++i) {var s = (e.isReversed() ? -1 : 1) * n[i].lineParam,a = (t.isReversed() ? -1 : 1) * n[i].circleParam,c = f(e, s, t, a, r);c && o.push(c);}return o;}(e, t, s) : c && R ? function (e, t, r, n) {var o = m(t.getCurve(), e.getCurve(), n),i = [],s = 0;e.isClosed() && r && (s = 1);for (var a = 0; a < o.length; ++a) {var c = (e.isReversed() ? -1 : 1) * o[a].circleParam,u = (t.isReversed() ? -1 : 1) * o[a].lineParam,l = f(e, c, t, u, n);if (l) for (var h = -s; h <= s; ++h) {i.push({ cutInfo: { atVertex: l.cutInfo.atVertex, param: l.cutInfo.param + h * Math.PI * 2 }, cutByInfo: l.cutByInfo });}}return i;}(e, t, i, s) : u && R ? y(e, t, r, s) : c && v ? function (e, t, r, o, i) {var s = [],a = e.getCurve().getCenter(),c = e.getCurve().getRadius(),u = t.getCurve().getCenter(),l = t.getCurve().getRadius(),d = 2 * Math.PI,g = n.Vector3.createFloat64();n.Vector3.sub(g, u, a);var v = n.Vector3.length(g),y = Math.abs(c - l);if (v < y - i) return s;if (v + y < i) {var m = i / c;if (e.getRange()[1] - e.getRange()[0] > d - m && t.getRange()[1] - t.getRange()[0] > d - m) return s.push({ rangeInfo: [p(e, e.getRange()[0], i, t), p(e, e.getRange()[1], i, t)], rangeByInfo: [p(t, t.getRange()[0], i, e), p(t, t.getRange()[1], i, e)] }), s;var x = [],R = e.closestToPointParam(t.evaluatePosition(0), [0, d]),A = n.Vector3.dot(e.evaluateDt(R), t.evaluateDt(0)) < 0,P = e.getRange(),V = t.getRange();V = A ? [R - V[1], R - V[0]] : [R + V[0], R + V[1]];var T = (0, h.foldAbove)(V[0], P[0], d) - V[0];if ((V = [V[0] + T, V[1] + T])[0] < P[1] + m && x.push([Math.min(V[0], P[1]), Math.min(P[1], V[1])]), V[1] > P[0] + d - m && x.push([P[0], Math.max(P[0], Math.min(P[1], V[1] - d))]), P[1] - P[0] > d - m || V[1] - V[0] > d - m) for (var C = x.length - 1; C >= 0 && 1 !== x.length; --C) {x[C][1] - x[C][0] < m && x.splice(C, 1);}for (C = 0; C < x.length; ++C) {var b = x[C],L = A ? [R - b[1], R - b[0]] : [b[0] - R, b[1] - R],O = (0, h.foldAbove)(L[0], t.getRange()[0], d) - L[0];if (L = [L[0] + O, L[1] + O], b[1] - b[0] < m) {var S = .5 * (b[0] + b[1]),M = .5 * (L[0] + L[1]),w = p(e, S, i, t),N = p(t, M, i, e);w && N && s.push({ cutInfo: w, cutByInfo: N });} else {var F = [p(e, b[0], i, t), p(e, b[1], i, t)],I = [p(t, L[0], i, e), p(t, L[1], i, e)];F[0] && F[1] && I[0] && I[1] && s.push({ rangeInfo: F, rangeByInfo: I });}}return s;}var D = (c * c - l * l + v * v) / (2 * v),j = c * c - D * D,B = c - Math.abs(D),U = [],k = [];if (B < -i) ;else {var G = Math.sqrt(Math.max(0, j));if (n.Vector3.scale(g, g, 1 / v), G < 2 * i) U.push(E(0, D, a, g, e, t)), k.push(!1);else if (B < i) {if (k.push(!1), r) {k[k.length - 1] = !0;var z = E(0, D, a, g, e, t),Y = [E(G, D, a, g, e, t), E(-G, D, a, g, e, t)];_(e, t, [Y[0].firstParam, z.firstParam, Y[1].firstParam], [Y[0].secondParam, z.secondParam, Y[1].secondParam], i, s, U);} else U.push(E(0, D, a, g, e, t));} else U.push(E(G, D, a, g, e, t)), U.push(E(-G, D, a, g, e, t));}var K = 0;for (e.isClosed() && o && (K = 1), C = 0; C < U.length; ++C) {var q = f(e, U[C].firstParam, t, U[C].secondParam, i);if (q) for (var W = -K; W <= K; ++W) {s.push({ cutInfo: { atVertex: q.cutInfo.atVertex, param: q.cutInfo.param + W * Math.PI * 2 }, cutByInfo: q.cutByInfo }), k[C] && (s[s.length - 1].cutInfo.virtualIntersection = !0, s[s.length - 1].cutByInfo.virtualIntersection = !0);}}return s;}(e, t, r, i, s) : u && P ? A(e, t, r, s) : l && R ? function (e, t, r, n, o) {var i = A(t, e, r, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty("cutInfo") && i[u].hasOwnProperty("cutByInfo")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty("rangeInfo") && i[u].hasOwnProperty("rangeByInfo") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, r, i, s) : c && P ? V(e, t, 0, i, s) : l && v ? function (e, t, r, n, o) {var i = V(t, e, 0, !1, o),s = [],a = 0,c = 0;n && e.getCurve().isPeriodicUnlimited() && (a = 1, c = e.getCurve().getPeriodUnlimited());for (var u = 0; u < i.length; ++u) {if (i[u].hasOwnProperty("cutInfo") && i[u].hasOwnProperty("cutByInfo")) for (var l = -a; l <= a; ++l) {s.push({ cutInfo: { atVertex: i[u].cutByInfo.atVertex, param: i[u].cutByInfo.param + l * c }, cutByInfo: i[u].cutInfo });} else i[u].hasOwnProperty("rangeInfo") && i[u].hasOwnProperty("rangeByInfo") && s.push({ rangeInfo: i[u].rangeByInfo, rangeByInfo: i[u].rangeInfo });}return s;}(e, t, 0, i, s) : l && P ? function (e, t, r, n, o) {var i = e === t,s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, o)) return c;var u,l,h,d,g = e.getCurve().getBezierSegments(),p = g.length,f = t.getCurve().getBezierSegments(),v = f.length,_ = [],y = 0,m = 0,E = 0;for (n && e.getCurve().isPeriodic() && e.isClosed() && (m = 1, E = e.getCurve().getPeriod()), u = 0; u < p; u++) {for (i && (y = u + 1), l = y; l < v; l++) {var R = i && l === u + 1;for (_ = T(e, t, g[u], f[l], r, o, R), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}}if (i) for (u = 0; u < p; ++u) {for (_ = C(e, g[u], 0, o), h = 0; h < _.length; ++h) {for (d = -m; d <= m; ++d) {_[h].cutInfo && c.push({ cutInfo: { atVertex: _[h].cutInfo.atVertex, param: _[h].cutInfo.param + d * E }, cutByInfo: _[h].cutByInfo }), _[h].rangeInfo && c.push(_[h]);}}}return x(c);}(e, t, r, i, s) : function (e, t, r, n, i) {var s = e.getBoundingBox(),a = t.getBoundingBox(),c = [];if (!s.intersectsWithTolerance(a, i)) return c;var u = e.isReversed(),l = t.isReversed(),h = e.getRange();u && (h = [-h[1], -h[0]]);var g = t.getRange();l && (g = [-g[1], -g[0]]), c = new d.CCI(e.getCurve(), h, t.getCurve(), g, o.KERNEL_TOLERANCE).intersect();for (var p = 0; p < c.length; ++p) {u && (c[p].cutInfo ? c[p].cutInfo.param *= -1 : c[p].rangeInfo && (c[p].rangeInfo = [c[p].rangeInfo[1], c[p].rangeInfo[0]], c[p].rangeInfo[0].param *= -1, c[p].rangeInfo[1].param *= -1)), l && (c[p].cutByInfo ? c[p].cutByInfo.param *= -1 : c[p].rangeByInfo && (c[p].rangeByInfo[0].param *= -1, c[p].rangeByInfo[1].param *= -1));}return c;}(e, t, 0, 0, s);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.edgesAreCoincident = t.curvesAreCoincident = void 0;var n = r(1),o = r(0),i = r(2),s = r(8);function a(e, t, r, o, i) {var s = e.evaluatePosition(t),a = r.closestToPointParam(s, o),c = r.evaluatePosition(a);return n.Vector3.squaredDistance(s, c) < i * i;}function c(e, t, r, o, i, s) {var c = [0, 0, 0];if (n.Vector3.isParallel(e, t.getNormal())) return !0;n.Vector3.add(c, t.getCenter(), e);var u = t.closestToPointParam(c, o);if (u > o[0] && u < o[1] && !a(t, u, r, i, s)) return !1;n.Vector3.sub(c, t.getCenter(), e);var l = t.closestToPointParam(c, o);return !(l > o[0] && l < o[1] && !a(t, l, r, i, s));}function u(e, t, r, n, o) {if (!a(e, .5 * (r[0] + r[1]), t, n, o)) return !1;var i = t.closestToPointParam(e.getCenter(), n);return !(i > n[0] && i < n[1] && !a(t, i, e, r, o));}var l = function l(e, t, r, _l, h) {r ? 0 === r.length && (r = e.getRangeUnlimited()) : r = e.getRange(), _l ? 0 === _l.length && (_l = t.getRangeUnlimited()) : _l = t.getRange(), h || (h = o.KERNEL_TOLERANCE);var d = e.getGeometryType(),g = t.getGeometryType();if (!(isFinite(r[0]) && isFinite(r[1]) && isFinite(_l[0]) && isFinite(_l[1]))) {var p = r[0] === Number.NEGATIVE_INFINITY && r[1] === Number.POSITIVE_INFINITY,f = _l[0] === Number.NEGATIVE_INFINITY && _l[1] === Number.POSITIVE_INFINITY;return !(!p || !f) && (i.ConsoleUtils.assert(d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE), function (e, t, r) {if (e === t) return !0;if (!a(e, 0, t, [], r) || !a(t, 0, e, [], r)) return !1;var o = e.evaluateDt(0);n.Vector3.normalize(o, o);var i = t.evaluateDt(0);return n.Vector3.normalize(i, i), n.Vector3.dot(o, i) < 0 && n.Vector3.negate(i, i), n.Vector3.equals(o, i, n.FLOAT64_TOLERANCE);}(e, t, h));}return e === t && Math.abs(r[0] - _l[0]) < n.FLOAT64_TOLERANCE && Math.abs(r[1] - _l[1]) < n.FLOAT64_TOLERANCE || !!(a(e, r[0], t, _l, h) && a(e, r[1], t, _l, h) && a(t, _l[0], e, r, h) && a(t, _l[1], e, r, h)) && (d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.LINE || (d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.CIRCLE ? function (e, t, r, o, i) {var s = .5 * (r[0] + r[1]),u = .5 * (o[0] + o[1]);if (!a(e, s, t, o, i) || !a(t, u, e, r, i)) return !1;var l = n.Vector3.sub([0, 0, 0], t.getCenter(), e.getCenter());if (n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (n.Vector3.dot(e.getNormal(), t.getNormal()) < 0 ? n.Vector3.add(l, e.getNormal(), t.getNormal()) : n.Vector3.sub(l, e.getNormal(), t.getNormal()), n.Vector3.squaredLength(l) > n.FLOAT64_TOLERANCE * n.FLOAT64_TOLERANCE) {if (n.Vector3.normalize(l, l), !c(l, e, t, r, o, i)) return !1;if (!c(l, t, e, o, r, i)) return !1;}if (r[1] - r[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var h = e.evaluatePosition(s + Math.PI),d = t.closestToPointParam(h, o);if (d > o[0] && d < o[1] && !a(t, d, e, r, i)) return !1;}if (o[1] - o[0] < 2 * Math.PI - n.FLOAT64_TOLERANCE) {var g = t.evaluatePosition(u + Math.PI),p = e.closestToPointParam(g, r);if (p > r[0] && p < r[1] && !a(e, p, t, o, i)) return !1;}return !0;}(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.CIRCLE && g === o.GEOMETRY_TYPES.LINE ? u(e, t, r, _l, h) : d === o.GEOMETRY_TYPES.LINE && g === o.GEOMETRY_TYPES.CIRCLE ? u(t, e, _l, r, h) : function (e, t, r, o, i) {for (var a = [r[0], r[1]], c = [e.evaluatePosition(r[0]), e.evaluatePosition(r[1])], u = 0; u < 100; ++u) {var l = .5 * (a[0] + a[1]),h = e.evaluatePosition(l),d = t.closestToPointParam(h, o),g = t.evaluatePosition(d),p = n.Vector3.sub([0, 0, 0], g, h);if (n.Vector3.squaredLength(p) > i * i) return !1;if (n.Vector3.distance(c[0], h) + n.Vector3.distance(h, c[1]) < i) return !0;var f = e.evaluateDt(l);n.Vector3.dot(f, p) < 0 ? (a[0] = l, c[0] = h) : (a[1] = l, c[1] = h);}return s.DebugUtils.warn("Binary search in coincidence check exceeded maximum iterations"), !0;}(e, t, r, _l, h)));};t.curvesAreCoincident = l, t.edgesAreCoincident = function (e, t) {if (e === t) return !0;var r = Math.max(o.KERNEL_TOLERANCE, e.getPrecision(), t.getPrecision()),i = e.getCurve(),s = t.getCurve();if (!i || !s) {if (i || s) return !1;var a = e.getStartVertex(),c = t.getStartVertex();r = Math.max(r, a.getPrecision(), c.getPrecision());var u = a.getPosition(),h = c.getPosition();return n.Vector3.squaredDistance(u, h) < r * r;}var d = e.getRange();e.isReversed() && (d = [-d[1], -d[0]]);var g = t.getRange();return t.isReversed() && (g = [-g[1], -g[0]]), l(i, s, d, g, r);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.extrudeFace = void 0;var n = r(1),o = r(0),i = r(2),s = r(18),a = r(38),c = r(39),u = r(53),l = r(13),h = r(15),d = r(26),g = r(25),p = r(24),f = r(55),v = r(19),_ = r(28);function y(e, t, r) {var i = n.Vector3.length(r),s = n.Vector3.dot(e.getAxisDir(), r) > 0 ? [0, i] : [-i, 0];e.limitRangeU(s), t[1] - t[0] < 2 * Math.PI - o.PARAMETER_SPACE_TOLERANCE && e.limitRangeV(t);}var m = function m(e, t) {var r = e.getEdge().getCurve(),i = e.getRange(),l = !0;e.isReversed() !== e.getEdge().isReversed() && (i = [-i[1], -i[0]], l = !1);var h,d = l ? e.t0() : e.t1(),g = e.evaluateDt(d);if (n.Vector3.cross(g, g, t), n.Vector3.normalize(g, g), n.Vector3.negate(g, g), r.getGeometryType() === o.GEOMETRY_TYPES.LINE) h = function (e, t, r) {var o = new s.Plane(),i = e.evaluateDt(0),a = n.Vector3.createFloat64();n.Vector3.normalize(a, r);var c = n.Vector3.createFloat64();n.Vector3.cross(c, a, i), o.set(e.evaluatePosition(0), c, a);var u = n.Vector3.length(r),l = n.Vector3.dot(a, r) > 0 ? [0, u] : [-u, 0];return o.limitRangeV(t), o.limitRangeU(l), o;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.CIRCLE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new a.Cylinder();return s.set(e.getCenter(), e.getRadius(), i, o, 1), y(s, t, r), s;}(r, i, t);else if (r.getGeometryType() === o.GEOMETRY_TYPES.ELLIPSE) h = function (e, t, r) {var o = e.evaluatePosition(0);n.Vector3.subtract(o, o, e.getCenter());var i = n.Vector3.createFloat64();n.Vector3.negate(i, e.getNormal());var s = new c.EllipticalCylinder();return s.set(e.getCenter(), o, e.getMinorRadius() / e.getMajorRadius(), i, 1), y(s, t, r), s;}(r, i, t);else {if (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE) throw new Error("createSideFaceRuledSurface: Curve type not supported.");h = function (e, t, r) {for (var n = new u.BSurface(), o = e.getDegree(), i = e.getKnotVector().slice(0), s = e.getControlPoints().slice(0), a = (s = s.concat(s)).length / 2; a < s.length; a += 3) {s[a] += r[0], s[a + 1] += r[1], s[a + 2] += r[2];}var c = void 0;return e.isRational() && (c = (c = e.getWeights().slice(0)).concat(c)), n.set(1, o, [0, 0, 1, 1], i, s, c), n.limitRangeU([0, 1]), n.limitRangeV(t), n;}(r, i, t);}var p = h.evaluateNormal(0, i[0]);return { surface: h, isReversed: n.Vector3.dot(p, g) < 0 };};t.extrudeFace = function (e, t) {i.ConsoleUtils.assert(e.getSurfaceType() === o.GEOMETRY_TYPES.PLANE);var r = e.evaluateNormal(0, 0);n.Vector3.scale(r, r, t);var s = new f.TopologyCloner().cloneFace(e),a = n.Matrix44.fromTranslation(n.Matrix44.createFloat64(), r);(0, v.transformTopology)(s, a), t > 0 ? (0, v.reverseFace)(e) : (0, v.reverseFace)(s);var c = function (e, t, r) {for (var n = [], o = e.getLoops(), i = t.getLoops(), s = 0; s < o.length; ++s) {for (var a = o[s].getCoedges(), c = i[s].getCoedges(), u = new Array(a.length), d = 0; d < a.length; ++d) {var g = new Array(4),p = a[d],f = c[a.length - 1 - d],v = p.getStartVertex(),y = p.getEndVertex(),E = f.getStartVertex(),x = f.getEndVertex();g[0] = (0, _.createCoedgeOnEdge)(p.getEdge()), 0 === d && (u[d] = (0, _.createLineEdgeBetweenVertices)(v, x)), g[1] = (0, _.createCoedgeOnEdge)(u[d]), g[2] = (0, _.createCoedgeOnEdge)(f.getEdge()), d !== a.length - 1 && (u[d + 1] = (0, _.createLineEdgeBetweenVertices)(E, y)), g[3] = (0, _.createCoedgeOnEdge)(u[(d + 1) % a.length]);var R = new l.Loop();R.addCoedges(g);var A = m(p, r),P = new h.Face(A.surface);P.setReversed(A.isReversed), P.addLoop(R), n.push(P);}}return n;}(e, s, r),u = e.getShell();u || (u = new d.Shell()).addFace(e), i.ConsoleUtils.assert(1 === u.getFaces().length), u.addFaces(c), u.addFace(s);var y = u.getLump();y || (y = new g.Lump()).addShell(u);var E = y.getBody();return E || (E = new p.Body()).addLump(y), E;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeSketchRegions = void 0;var n = r(0),o = r(19),i = r(80),s = function s(e, t) {var r = e.getProgenitorMap(),o = new Set();return t.forEach(function (e) {r.getDescendants(e).forEach(function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.EDGE && o.add(e);});}), Array.from(o);},a = function a(e, t) {var r = [];return (0, o.findConnectedFaces)(e, { allowVertexConnections: !1, barrierEdges: t }).forEach(function (e) {(function (e, t) {e = new Set(e), t = new Set(t);var r = new Set();e.forEach(function (e) {e.collectEdges(r);}), r = Array.from(r);for (var n = 0; n < r.length; n++) {var o = r[n];if (!t.has(o)) {var i = o.getCoedges();if (i.length < 2) return !1;for (var s = 0; s < i.length; s++) {if (!e.has(i[s].getFace())) return !1;}}}return !0;})(e, t) && (r = r.concat(e));}), r;},c = function c(e, t) {for (var r = 0; r < e.length; r++) {if (t.indexOf(e[r]) < 0) return !1;}return !0;};t.mergeSketchRegions = function (e) {var t,r,n = [];e.forEach(function (e) {n = n.concat(e.getEdges());});var u = new i.SketchRegionSolver();u.compute(n);var l = u.getFaces(),h = [],d = [];for (t = 0; t < e.length; t++) {var g = s(u, e[t].getEdges());if (0 !== g.length) {var p = a(l, g);0 !== p.length && (d.push(g), h.push(p));}}for (var f = [], v = new Set(l), _ = !0; h.length > 0;) {var y = [];for (t = 0; t < h.length; t++) {var m = !1;for (r = 0; r < h.length; r++) {if (t !== r && c(h[t], h[r])) {m = !0;break;}}y.push(m);}var E = new Set();for (t = h.length - 1; t >= 0; t--) {y[t] ? h[t].forEach(function (e) {E.add(e), v.delete(e);}) : (h.splice(t, 1), d.splice(t, 1));}_ && (f = f.concat(Array.from(v))), v = E, _ = !_;}return (0, o.mergeConnectedFaces)(f);}, t.getRegionEdges = s, t.getBoundedRegionFaces = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.propertyToRange = t.GeometrySetters = void 0;var n = r(1),o = function o(e, t, r) {var n = t[r];e[0] = n.x, e[1] = n.y, e[2] = n.z;},i = function i(e, t) {var r = e[t];var n = r.type;return "infinite" === n || 0 === n ? [] : [r.low, r.high];},s = function s(e, t) {var r = i(e, "uRange");t.unlimitRangeU(), r.length > 0 && t.limitRangeU(r);var n = i(e, "vRange");t.unlimitRangeV(), n.length > 0 && t.limitRangeV(n);},a = function a(e, t) {var r = i(e, "range");t.unlimitRange(), r.length > 0 && t.limitRange(r);},c = { setBCurveFromProperty: function setBCurveFromProperty(e, t) {var r,n,o = t.degree,i = t.knots,s = t.controlPoints,c = t.weights,u = s.length / 3;if (0 === c.length) for (n = new Array(u), r = 0; r < u; ++r) {n[r] = 1;} else n = c;e.set(s, n, o, i), a(t, e);}, setBSurfaceFromProperty: function setBSurfaceFromProperty(e, t) {var r,n,o = t.uDegree,i = t.vDegree,a = t.uKnots,c = t.vKnots,u = t.controlPoints,l = t.weights;if (0 === l.length) {var h = u.length / 3;for (n = new Array(h), r = 0; r < h; ++r) {n[r] = 1;}} else n = l;e.set(o, i, a, c, u, n), s(t, e);}, setCircleFromProperty: function setCircleFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "normal"), o(s, t, "radius"), e.set(r, i, s), a(t, e);}, setConeFromProperty: function setConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "radius");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.angle,l = t.uCoordScale;e.set(r, c, i, u, a, l), s(t, e);}, setCylinderFromProperty: function setCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "radius");var c = n.Vector3.length(a);n.Vector3.normalize(a, a);var u = t.uCoordScale;e.set(r, c, i, a, u), s(t, e);}, setEllipseFromProperty: function setEllipseFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),s = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "normal"), o(s, t, "majorRadius");var c = t.radiusRatio;e.set(r, i, s, c), a(t, e);}, setEllipticalConeFromProperty: function setEllipticalConeFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "majorRadius");var c = t.angle,u = t.radiusRatio,l = t.uCoordScale;e.set(r, a, u, i, c, l), s(t, e);}, setEllipticalCylinderFromProperty: function setEllipticalCylinderFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "majorRadius");var c = t.radiusRatio,u = t.uCoordScale;e.set(r, a, c, i, u), s(t, e);}, setLineFromProperty: function setLineFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64();o(r, t, "position"), o(i, t, "direction"), e.set(r, i), a(t, e);}, setPlaneFromProperty: function setPlaneFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "origin"), o(i, t, "normal"), o(a, t, "uAxis"), e.set(r, i, a), s(t, e);}, setPointFromProperty: function setPointFromProperty(e, t) {e.setPosition(t.position.x, t.position.y, t.position.z);}, setSphereFromProperty: function setSphereFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "radius"), o(a, t, "axis");var c = n.Vector3.length(i);n.Vector3.normalize(i, i), e.set(r, c, a, i), s(t, e);}, setTorusFromProperty: function setTorusFromProperty(e, t) {var r = n.Vector3.createFloat64(),i = n.Vector3.createFloat64(),a = n.Vector3.createFloat64();o(r, t, "center"), o(i, t, "axis"), o(a, t, "coordAxis");var c = t.majorRadius,u = t.minorRadius,l = t.lemon;e.set(r, c, u, i, a, l), s(t, e);}, setHapCurveFromProperty: function setHapCurveFromProperty(e, t) {for (var r = t.spans, n = new Array(r.length), o = 0; o < r.length; ++o) {n[o] = {}, n[o].polyOrder = r[o].polyOrder, n[o].lowParam = r[o].lowParam, n[o].highParam = r[o].highParam, n[o].coefs = r[o].coefs.slice(0);}var i = {};i.spans = n;var s = t.periodic;void 0 === s && (s = !1), i.periodic = s, i.closed = s, e.setHapDefinition(i), a(t, e);}, setCurveRangeFromProperty: a, setSurfaceRangeFromProperty: s };t.GeometrySetters = c, t.propertyToRange = i;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.getBoundedRegionFaces = t.getRegionEdges = t.mergeConnectedFaces = t.getOrderedFacesOnVertex = t.saveToProtoMessage = t.saveToProtoBinary = t.SolidDefSaver = t.SolidDefLoader = t.Path2D = t.DebugUtils = t.svgFromWire = t.transformTopology = t.TopologyStitcher = t.TopologyCloner = t.extrudeFace = t.createEdgeFromCurve = t.createFaceFromPolyline = t.createShellsFromFaces = t.createPolyhedron = t.createLineEdgeBetweenVertices = t.createLineEdge = t.createCylinder = t.createCone = t.createBlock = t.computeCurveCurveIntersections = t.SketchRegionSolver = t.facetPlanarFace = t.checkValidity = t.BoundingBox = t.Attribute = t.Wire = t.WireBody = t.Vertex = t.Edge = t.Coedge = t.Loop = t.Face = t.Shell = t.Lump = t.Body = t.BSurface = t.Torus = t.EllipticalCone = t.Cone = t.Sphere = t.EllipticalCylinder = t.Cylinder = t.Plane = t.BCurve = t.Ellipse = t.Circle = t.Line = t.Point = t.TOPOLOGY_TYPES = t.GEOMETRY_TYPES = t.KERNEL_TOLERANCE = void 0;var n = r(0),o = r(4),i = r(6),s = r(7),a = r(14),c = r(23),u = r(33),l = r(18),h = r(38),d = r(39),g = r(74),p = r(51),f = r(52),v = r(75),_ = r(53),y = r(24),m = r(25),E = r(26),x = r(15),R = r(13),A = r(27),P = r(20),V = r(16),T = r(54),C = r(40),b = r(79),L = r(106),O = r(107),S = r(80),M = r(81),w = r(115),N = r(116),F = r(117),I = r(28),D = r(83),j = r(55),B = r(118),U = r(19),k = r(121),G = r(8),z = r(122),Y = r(123),K = r(126),q = r(84),W = r(78);t.KERNEL_TOLERANCE = n.KERNEL_TOLERANCE, t.GEOMETRY_TYPES = n.GEOMETRY_TYPES, t.TOPOLOGY_TYPES = n.TOPOLOGY_TYPES, t.Point = i.Point, t.Line = s.Line, t.Circle = a.Circle, t.Ellipse = c.Ellipse, t.BCurve = u.BCurve, t.Plane = l.Plane, t.Cylinder = h.Cylinder, t.EllipticalCylinder = d.EllipticalCylinder, t.Sphere = g.Sphere, t.Cone = p.Cone, t.EllipticalCone = f.EllipticalCone, t.Torus = v.Torus, t.BSurface = _.BSurface, t.Body = y.Body, t.Lump = m.Lump, t.Shell = E.Shell, t.Face = x.Face, t.Loop = R.Loop, t.Coedge = A.Coedge, t.Edge = P.Edge, t.Vertex = V.Vertex, t.WireBody = T.WireBody, t.Wire = C.Wire, t.Attribute = b.Attribute, t.BoundingBox = o.BoundingBox, t.checkValidity = L.checkValidity, t.facetPlanarFace = O.facetPlanarFace, t.SketchRegionSolver = S.SketchRegionSolver, t.computeCurveCurveIntersections = M.computeCurveCurveIntersections, t.createBlock = w.createBlock, t.createCone = N.createCone, t.createCylinder = N.createCylinder, t.createLineEdge = I.createLineEdge, t.createLineEdgeBetweenVertices = I.createLineEdgeBetweenVertices, t.createPolyhedron = F.createPolyhedron, t.createShellsFromFaces = I.createShellsFromFaces, t.createFaceFromPolyline = I.createFaceFromPolyline, t.createEdgeFromCurve = I.createEdgeFromCurve, t.extrudeFace = D.extrudeFace, t.TopologyCloner = j.TopologyCloner, t.TopologyStitcher = B.TopologyStitcher, t.transformTopology = U.transformTopology, t.svgFromWire = k.svgFromWire, t.DebugUtils = G.DebugUtils, t.Path2D = z.Path2D, t.SolidDefLoader = Y.SolidDefLoader, t.SolidDefSaver = K.SolidDefSaver, t.saveToProtoBinary = K.saveToProtoBinary, t.saveToProtoMessage = K.saveToProtoMessage, t.getOrderedFacesOnVertex = W.getOrderedFacesOnVertex, t.mergeConnectedFaces = U.mergeConnectedFaces, t.getRegionEdges = q.getRegionEdges, t.getBoundedRegionFaces = q.getBoundedRegionFaces;}, function (e, t, r) {"use strict";e.exports = r(88);}, function (e, t, r) {"use strict";var n = e.exports = r(89);n.build = "light", n.load = function (e, t, r) {return "function" == typeof t ? (r = t, t = new n.Root()) : t || (t = new n.Root()), t.load(e, r);}, n.loadSync = function (e, t) {return t || (t = new n.Root()), t.loadSync(e);}, n.encoder = r(62), n.decoder = r(67), n.verifier = r(68), n.converter = r(69), n.ReflectionObject = r(21), n.Namespace = r(30), n.Root = r(71), n.Enum = r(11), n.Type = r(63), n.Field = r(22), n.OneOf = r(48), n.MapField = r(64), n.Service = r(65), n.Method = r(66), n.Message = r(49), n.wrappers = r(70), n.types = r(31), n.util = r(5), n.ReflectionObject._configure(n.Root), n.Namespace._configure(n.Type, n.Service, n.Enum), n.Root._configure(n.Type), n.Field._configure(n.Type);}, function (e, t, r) {"use strict";var n = t;function o() {n.Reader._configure(n.BufferReader), n.util._configure();}n.build = "minimal", n.Writer = r(46), n.BufferWriter = r(96), n.Reader = r(47), n.BufferReader = r(97), n.util = r(10), n.rpc = r(60), n.roots = r(61), n.configure = o, n.Writer._configure(n.BufferWriter), o();}, function (e, t, r) {"use strict";var n = t;n.length = function (e) {var t = e.length;if (!t) return 0;for (var r = 0; --t % 4 > 1 && "=" === e.charAt(t);) {++r;}return Math.ceil(3 * e.length) / 4 - r;};for (var o = new Array(64), i = new Array(123), s = 0; s < 64;) {i[o[s] = s < 26 ? s + 65 : s < 52 ? s + 71 : s < 62 ? s - 4 : s - 59 | 43] = s++;}n.encode = function (e, t, r) {for (var n, i = null, s = [], a = 0, c = 0; t < r;) {var u = e[t++];switch (c) {case 0:s[a++] = o[u >> 2], n = (3 & u) << 4, c = 1;break;case 1:s[a++] = o[n | u >> 4], n = (15 & u) << 2, c = 2;break;case 2:s[a++] = o[n | u >> 6], s[a++] = o[63 & u], c = 0;}a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, s)), a = 0);}return c && (s[a++] = o[n], s[a++] = 61, 1 === c && (s[a++] = 61)), i ? (a && i.push(String.fromCharCode.apply(String, s.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, s.slice(0, a));}, n.decode = function (e, t, r) {for (var n, o = r, s = 0, a = 0; a < e.length;) {var c = e.charCodeAt(a++);if (61 === c && s > 1) break;if (void 0 === (c = i[c])) throw Error("invalid encoding");switch (s) {case 0:n = c, s = 1;break;case 1:t[r++] = n << 2 | (48 & c) >> 4, n = c, s = 2;break;case 2:t[r++] = (15 & n) << 4 | (60 & c) >> 2, n = c, s = 3;break;case 3:t[r++] = (3 & n) << 6 | c, s = 0;}}if (1 === s) throw Error("invalid encoding");return r - o;}, n.test = function (e) {return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);};}, function (e, t, r) {"use strict";function n() {this._listeners = {};}e.exports = n, n.prototype.on = function (e, t, r) {return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: t, ctx: r || this }), this;}, n.prototype.off = function (e, t) {if (void 0 === e) this._listeners = {};else if (void 0 === t) this._listeners[e] = [];else for (var r = this._listeners[e], n = 0; n < r.length;) {r[n].fn === t ? r.splice(n, 1) : ++n;}return this;}, n.prototype.emit = function (e) {var t = this._listeners[e];if (t) {for (var r = [], n = 1; n < arguments.length;) {r.push(arguments[n++]);}for (n = 0; n < t.length;) {t[n].fn.apply(t[n++].ctx, r);}}return this;};}, function (e, t, r) {"use strict";function n(e) {return "undefined" != typeof Float32Array ? function () {var t = new Float32Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[3];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3];}function i(e, n, o) {t[0] = e, n[o] = r[3], n[o + 1] = r[2], n[o + 2] = r[1], n[o + 3] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], t[0];}function a(e, n) {return r[3] = e[n], r[2] = e[n + 1], r[1] = e[n + 2], r[0] = e[n + 3], t[0];}e.writeFloatLE = n ? o : i, e.writeFloatBE = n ? i : o, e.readFloatLE = n ? s : a, e.readFloatBE = n ? a : s;}() : function () {function t(e, t, r, n) {var o = t < 0 ? 1 : 0;if (o && (t = -t), 0 === t) e(1 / t > 0 ? 0 : 2147483648, r, n);else if (isNaN(t)) e(2143289344, r, n);else if (t > 34028234663852886e22) e((o << 31 | 2139095040) >>> 0, r, n);else if (t < 11754943508222875e-54) e((o << 31 | Math.round(t / 1401298464324817e-60)) >>> 0, r, n);else {var i = Math.floor(Math.log(t) / Math.LN2);e((o << 31 | i + 127 << 23 | 8388607 & Math.round(t * Math.pow(2, -i) * 8388608)) >>> 0, r, n);}}function r(e, t, r) {var n = e(t, r),o = 2 * (n >> 31) + 1,i = n >>> 23 & 255,s = 8388607 & n;return 255 === i ? s ? NaN : o * (1 / 0) : 0 === i ? 1401298464324817e-60 * o * s : o * Math.pow(2, i - 150) * (s + 8388608);}e.writeFloatLE = t.bind(null, o), e.writeFloatBE = t.bind(null, i), e.readFloatLE = r.bind(null, s), e.readFloatBE = r.bind(null, a);}(), "undefined" != typeof Float64Array ? function () {var t = new Float64Array([-0]),r = new Uint8Array(t.buffer),n = 128 === r[7];function o(e, n, o) {t[0] = e, n[o] = r[0], n[o + 1] = r[1], n[o + 2] = r[2], n[o + 3] = r[3], n[o + 4] = r[4], n[o + 5] = r[5], n[o + 6] = r[6], n[o + 7] = r[7];}function i(e, n, o) {t[0] = e, n[o] = r[7], n[o + 1] = r[6], n[o + 2] = r[5], n[o + 3] = r[4], n[o + 4] = r[3], n[o + 5] = r[2], n[o + 6] = r[1], n[o + 7] = r[0];}function s(e, n) {return r[0] = e[n], r[1] = e[n + 1], r[2] = e[n + 2], r[3] = e[n + 3], r[4] = e[n + 4], r[5] = e[n + 5], r[6] = e[n + 6], r[7] = e[n + 7], t[0];}function a(e, n) {return r[7] = e[n], r[6] = e[n + 1], r[5] = e[n + 2], r[4] = e[n + 3], r[3] = e[n + 4], r[2] = e[n + 5], r[1] = e[n + 6], r[0] = e[n + 7], t[0];}e.writeDoubleLE = n ? o : i, e.writeDoubleBE = n ? i : o, e.readDoubleLE = n ? s : a, e.readDoubleBE = n ? a : s;}() : function () {function t(e, t, r, n, o, i) {var s = n < 0 ? 1 : 0;if (s && (n = -n), 0 === n) e(0, o, i + t), e(1 / n > 0 ? 0 : 2147483648, o, i + r);else if (isNaN(n)) e(0, o, i + t), e(2146959360, o, i + r);else if (n > 17976931348623157e292) e(0, o, i + t), e((s << 31 | 2146435072) >>> 0, o, i + r);else {var a;if (n < 22250738585072014e-324) e((a = n / 5e-324) >>> 0, o, i + t), e((s << 31 | a / 4294967296) >>> 0, o, i + r);else {var c = Math.floor(Math.log(n) / Math.LN2);1024 === c && (c = 1023), e(4503599627370496 * (a = n * Math.pow(2, -c)) >>> 0, o, i + t), e((s << 31 | c + 1023 << 20 | 1048576 * a & 1048575) >>> 0, o, i + r);}}}function r(e, t, r, n, o) {var i = e(n, o + t),s = e(n, o + r),a = 2 * (s >> 31) + 1,c = s >>> 20 & 2047,u = 4294967296 * (1048575 & s) + i;return 2047 === c ? u ? NaN : a * (1 / 0) : 0 === c ? 5e-324 * a * u : a * Math.pow(2, c - 1075) * (u + 4503599627370496);}e.writeDoubleLE = t.bind(null, o, 0, 4), e.writeDoubleBE = t.bind(null, i, 4, 0), e.readDoubleLE = r.bind(null, s, 0, 4), e.readDoubleBE = r.bind(null, a, 4, 0);}(), e;}function o(e, t, r) {t[r] = 255 & e, t[r + 1] = e >>> 8 & 255, t[r + 2] = e >>> 16 & 255, t[r + 3] = e >>> 24;}function i(e, t, r) {t[r] = e >>> 24, t[r + 1] = e >>> 16 & 255, t[r + 2] = e >>> 8 & 255, t[r + 3] = 255 & e;}function s(e, t) {return (e[t] | e[t + 1] << 8 | e[t + 2] << 16 | e[t + 3] << 24) >>> 0;}function a(e, t) {return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0;}e.exports = n(n);}, function (e, t, r) {"use strict";var n = t;n.length = function (e) {for (var t = 0, r = 0, n = 0; n < e.length; ++n) {(r = e.charCodeAt(n)) < 128 ? t += 1 : r < 2048 ? t += 2 : 55296 == (64512 & r) && 56320 == (64512 & e.charCodeAt(n + 1)) ? (++n, t += 4) : t += 3;}return t;}, n.read = function (e, t, r) {if (r - t < 1) return "";for (var n, o = null, i = [], s = 0; t < r;) {(n = e[t++]) < 128 ? i[s++] = n : n > 191 && n < 224 ? i[s++] = (31 & n) << 6 | 63 & e[t++] : n > 239 && n < 365 ? (n = ((7 & n) << 18 | (63 & e[t++]) << 12 | (63 & e[t++]) << 6 | 63 & e[t++]) - 65536, i[s++] = 55296 + (n >> 10), i[s++] = 56320 + (1023 & n)) : i[s++] = (15 & n) << 12 | (63 & e[t++]) << 6 | 63 & e[t++], s > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, i)), s = 0);}return o ? (s && o.push(String.fromCharCode.apply(String, i.slice(0, s))), o.join("")) : String.fromCharCode.apply(String, i.slice(0, s));}, n.write = function (e, t, r) {for (var n, o, i = r, s = 0; s < e.length; ++s) {(n = e.charCodeAt(s)) < 128 ? t[r++] = n : n < 2048 ? (t[r++] = n >> 6 | 192, t[r++] = 63 & n | 128) : 55296 == (64512 & n) && 56320 == (64512 & (o = e.charCodeAt(s + 1))) ? (n = 65536 + ((1023 & n) << 10) + (1023 & o), ++s, t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128) : (t[r++] = n >> 12 | 224, t[r++] = n >> 6 & 63 | 128, t[r++] = 63 & n | 128);}return r - i;};}, function (e, t, r) {"use strict";e.exports = function (e, t, r) {var n = r || 8192,o = n >>> 1,i = null,s = n;return function (r) {if (r < 1 || r > o) return e(r);s + r > n && (i = e(n), s = 0);var a = t.call(i, s, s += r);return 7 & s && (s = 1 + (7 | s)), a;};};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e, t) {this.lo = e >>> 0, this.hi = t >>> 0;}var i = o.zero = new o(0, 0);i.toNumber = function () {return 0;}, i.zzEncode = i.zzDecode = function () {return this;}, i.length = function () {return 1;};var s = o.zeroHash = "\0\0\0\0\0\0\0\0";o.fromNumber = function (e) {if (0 === e) return i;var t = e < 0;t && (e = -e);var r = e >>> 0,n = (e - r) / 4294967296 >>> 0;return t && (n = ~n >>> 0, r = ~r >>> 0, ++r > 4294967295 && (r = 0, ++n > 4294967295 && (n = 0))), new o(r, n);}, o.from = function (e) {if ("number" == typeof e) return o.fromNumber(e);if (n.isString(e)) {if (!n.Long) return o.fromNumber(parseInt(e, 10));e = n.Long.fromString(e);}return e.low || e.high ? new o(e.low >>> 0, e.high >>> 0) : i;}, o.prototype.toNumber = function (e) {if (!e && this.hi >>> 31) {var t = 1 + ~this.lo >>> 0,r = ~this.hi >>> 0;return t || (r = r + 1 >>> 0), -(t + 4294967296 * r);}return this.lo + 4294967296 * this.hi;}, o.prototype.toLong = function (e) {return n.Long ? new n.Long(0 | this.lo, 0 | this.hi, Boolean(e)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e) };};var a = String.prototype.charCodeAt;o.fromHash = function (e) {return e === s ? i : new o((a.call(e, 0) | a.call(e, 1) << 8 | a.call(e, 2) << 16 | a.call(e, 3) << 24) >>> 0, (a.call(e, 4) | a.call(e, 5) << 8 | a.call(e, 6) << 16 | a.call(e, 7) << 24) >>> 0);}, o.prototype.toHash = function () {return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);}, o.prototype.zzEncode = function () {var e = this.hi >> 31;return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;}, o.prototype.zzDecode = function () {var e = -(1 & this.lo);return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;}, o.prototype.length = function () {var e = this.lo,t = (this.lo >>> 28 | this.hi << 4) >>> 0,r = this.hi >>> 24;return 0 === r ? 0 === t ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : t < 16384 ? t < 128 ? 5 : 6 : t < 2097152 ? 7 : 8 : r < 128 ? 9 : 10;};}, function (e, t, r) {"use strict";e.exports = s;var n = r(46);(s.prototype = Object.create(n.prototype)).constructor = s;var o = r(10),i = o.Buffer;function s() {n.call(this);}s.alloc = function (e) {return (s.alloc = o._Buffer_allocUnsafe)(e);};var a = i && i.prototype instanceof Uint8Array && "set" === i.prototype.set.name ? function (e, t, r) {t.set(e, r);} : function (e, t, r) {if (e.copy) e.copy(t, r, 0, e.length);else for (var n = 0; n < e.length;) {t[r++] = e[n++];}};function c(e, t, r) {e.length < 40 ? o.utf8.write(e, t, r) : t.utf8Write(e, r);}s.prototype.bytes = function (e) {o.isString(e) && (e = o._Buffer_from(e, "base64"));var t = e.length >>> 0;return this.uint32(t), t && this._push(a, t, e), this;}, s.prototype.string = function (e) {var t = i.byteLength(e);return this.uint32(t), t && this._push(c, t, e), this;};}, function (e, t, r) {"use strict";e.exports = i;var n = r(47);(i.prototype = Object.create(n.prototype)).constructor = i;var o = r(10);function i(e) {n.call(this, e);}o.Buffer && (i.prototype._slice = o.Buffer.prototype.slice), i.prototype.string = function () {var e = this.uint32();return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len));};}, function (e, t, r) {"use strict";e.exports = o;var n = r(10);function o(e, t, r) {if ("function" != typeof e) throw TypeError("rpcImpl must be a function");n.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(t), this.responseDelimited = Boolean(r);}(o.prototype = Object.create(n.EventEmitter.prototype)).constructor = o, o.prototype.rpcCall = function e(t, r, o, i, s) {if (!i) throw TypeError("request must be specified");var a = this;if (!s) return n.asPromise(e, a, t, r, o, i);if (a.rpcImpl) try {return a.rpcImpl(t, r[a.requestDelimited ? "encodeDelimited" : "encode"](i).finish(), function (e, r) {if (e) return a.emit("error", e, t), s(e);if (null !== r) {if (!(r instanceof o)) try {r = o[a.responseDelimited ? "decodeDelimited" : "decode"](r);} catch (e) {return a.emit("error", e, t), s(e);}return a.emit("data", r, t), s(null, r);}a.end(!0);});} catch (e) {return a.emit("error", e, t), void setTimeout(function () {s(e);}, 0);} else setTimeout(function () {s(Error("already ended"));}, 0);}, o.prototype.end = function (e) {return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;};}, function (e, t, r) {"use strict";function n(e, t) {"string" == typeof e && (t = e, e = void 0);var r = [];function o(e) {if ("string" != typeof e) {var t = i();if (n.verbose && console.log("codegen: " + t), t = "return " + t, e) {for (var s = Object.keys(e), a = new Array(s.length + 1), c = new Array(s.length), u = 0; u < s.length;) {a[u] = s[u], c[u] = e[s[u++]];}return a[u] = t, Function.apply(null, a).apply(null, c);}return Function(t)();}for (var l = new Array(arguments.length - 1), h = 0; h < l.length;) {l[h] = arguments[++h];}if (h = 0, e = e.replace(/%([%dfijs])/g, function (e, t) {var r = l[h++];switch (t) {case "d":case "f":return String(Number(r));case "i":return String(Math.floor(r));case "j":return JSON.stringify(r);case "s":return String(r);}return "%";}), h !== l.length) throw Error("parameter count mismatch");return r.push(e), o;}function i(n) {return "function " + (n || t || "") + "(" + (e && e.join(",") || "") + "){\n  " + r.join("\n  ") + "\n}";}return o.toString = i, o;}e.exports = n, n.verbose = !1;}, function (e, t, r) {"use strict";e.exports = i;var n = r(58),o = r(59)("fs");function i(e, t, r) {return "function" == typeof t ? (r = t, t = {}) : t || (t = {}), r ? !t.xhr && o && o.readFile ? o.readFile(e, function (n, o) {return n && "undefined" != typeof XMLHttpRequest ? i.xhr(e, t, r) : n ? r(n) : r(null, t.binary ? o : o.toString("utf8"));}) : i.xhr(e, t, r) : n(i, this, e, t);}i.xhr = function (e, t, r) {var n = new XMLHttpRequest();n.onreadystatechange = function () {if (4 === n.readyState) {if (0 !== n.status && 200 !== n.status) return r(Error("status " + n.status));if (t.binary) {var e = n.response;if (!e) {e = [];for (var o = 0; o < n.responseText.length; ++o) {e.push(255 & n.responseText.charCodeAt(o));}}return r(null, "undefined" != typeof Uint8Array ? new Uint8Array(e) : e);}return r(null, n.responseText);}}, t.binary && ("overrideMimeType" in n && n.overrideMimeType("text/plain; charset=x-user-defined"), n.responseType = "arraybuffer"), n.open("GET", e), n.send();};}, function (e, t, r) {"use strict";var n = t,o = n.isAbsolute = function (e) {return /^(?:\/|\w+:)/.test(e);},i = n.normalize = function (e) {var t = (e = e.replace(/\\/g, "/").replace(/\/{2,}/g, "/")).split("/"),r = o(e),n = "";r && (n = t.shift() + "/");for (var i = 0; i < t.length;) {".." === t[i] ? i > 0 && ".." !== t[i - 1] ? t.splice(--i, 2) : r ? t.splice(i, 1) : ++i : "." === t[i] ? t.splice(i, 1) : ++i;}return n + t.join("/");};n.resolve = function (e, t, r) {return r || (t = i(t)), o(t) ? t : (r || (e = i(e)), (e = e.replace(/(?:\/|^)[^/]+$/, "")).length ? i(e + "/" + t) : t);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.decomposeBCurveFlags = t.decomposeBCurveToBezier = t.decomposeBCurveControlPoints = void 0;var n = r(17),o = r(2),i = function i(e, t, r) {o.ConsoleUtils.assert(t.length % r == 0);var n,i,s,a = e.length - t.length / r - 1;o.ConsoleUtils.assert(a > 0);var c = e.length - 1,u = a,l = a + 1,h = 0,d = [],g = [];for (g[h] = new Array((a + 1) * r), n = 0; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[n * r + s];}}for (; l < c;) {for (var p = 1; l < c && e[l + 1] === e[l];) {++l, ++p;}var f = l === c;if (f || (g[h + 1] = new Array((a + 1) * r)), p < a) {var v = e[l] - e[u];for (i = a; i > p; --i) {d[i - p - 1] = v / (e[u + i] - e[u]);}var _ = a - p;for (i = 1; i <= _; ++i) {for (var y = _ - i, m = p + i, E = a; E >= m; --E) {var x = d[E - m];for (s = 0; s < r; ++s) {g[h][E * r + s] = g[h][E * r + s] * x + g[h][(E - 1) * r + s] * (1 - x);}}if (!f) for (s = 0; s < r; ++s) {g[h + 1][y * r + s] = g[h][a * r + s];}}}if (f) break;for (++h, n = a - p; n <= a; ++n) {for (s = 0; s < r; ++s) {g[h][n * r + s] = t[(l - a + n) * r + s];}}u = l, ++l;}return g;};t.decomposeBCurveControlPoints = i, t.decomposeBCurveToBezier = function (e, t, r) {var s,a = r && r.length > 0;o.ConsoleUtils.assert(t.length > 0 && t.length % 3 == 0), o.ConsoleUtils.assert(!a || t.length === 3 * r.length);var c,u,l = e.length - t.length / 3 - 1;if (o.ConsoleUtils.assert(l > 0), a) {var h = (0, n.controlPointsToHomogeneous)(t, r);for (c = i(e, h, 4), u = [], s = 0; s < c.length; ++s) {var d = (0, n.controlPointsFromHomogeneous)(c[s]);c[s] = d.P, u[s] = d.w;}} else c = i(e, t, 3), u = void 0;var g = (0, n.getUniqueKnots)(e);o.ConsoleUtils.assert(g.length === c.length + 1);var p = new Array(g.length - 1);for (s = 0; s < p.length; ++s) {p[s] = new Array(2 * l + 2), p[s].fill(g[s], 0, l + 1), p[s].fill(g[s + 1], l + 1);}return { U: p, P: c, w: u };}, t.decomposeBCurveFlags = function (e, t) {var r,n = e.length - t.length - 1,o = new Array(t.length);o.fill(!1);var i = n - 1;for (r = 0; r < t.length; ++r) {if (t[r]) {var s = Math.max(r - i, 0),a = Math.min(r + i, o.length - 1);o.fill(!0, s, a + 1);}}var c = [],u = e.length - 1,l = n + 1,h = 0;for (c[h] = !1, r = 0; r <= n; ++r) {o[r] && (c[h] = !0);}for (; l < u;) {for (var d = 1; l < u && e[l + 1] === e[l];) {++l, ++d;}if (l === u) break;for (c[++h] = !1, r = n - d; r <= n; ++r) {o[l - n + r] && (c[h] = !0);}++l;}return c;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.extractBSurfaceParamLineV = t.extractBSurfaceParamLineU = t.insertBSurfaceKnotV = t.insertBSurfaceKnotU = void 0;var n = r(1),o = r(17),i = r(0),s = function s(e, t, r, o, i, _s, a) {var c,u,l = new Array(o);for (u = 0; u < o; ++u) {l[u] = new Array(i - u - r);var h = t - i + u + 1;for (c = 0; c < i - u - r; ++c) {l[u][c] = (e - _s[h + c]) / (_s[c + t + 1] - _s[h + c]);}}for (var d = a.length, g = new Array(d), p = new Array(i - r + 1), f = 0; f < d; ++f) {for (g[f] = new Array(i - r + o - 1), c = 0; c <= i - r; ++c) {p[c] = n.Vector4.clone(a[f][c]);}for (u = 0; u < o; ++u) {for (c = 0; c < i - u - r; ++c) {n.Vector4.lerp(p[c], p[c], p[c + 1], l[u][c]);}g[f][u] = n.Vector4.clone(p[0]), g[f][i + o - r - u - 2] = n.Vector4.clone(p[i - u - r - 1]);}for (c = o; c < i - r - 1; c++) {g[f][c] = n.Vector4.clone(p[c - o + 1]);}}return g;};t.insertBSurfaceKnotU = function (e, t, r, a, c, u, l, h) {t = Math.min(t, r);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, c);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < c[0] + i.PARAMETER_SPACE_TOLERANCE || e > c[c.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { uknots: c.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(E),R = p - r,A = p - f;for (y = 0; y < E; ++y) {for (x[y] = new Array(A - R + 1), _ = R; _ <= A; ++_) {var P = _ * E + y,V = d ? h[P] : 1;x[y][_ - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, r, c, x),C = c.slice(0, p + 1);for (_ = 0; _ < v; ++_) {C.push(e);}C = C.concat(c.slice(p + 1));var b,L = new Array(3 * (m + v) * E),O = new Array((m + v) * E);for (y = 0; y < E; ++y) {for (_ = 0; _ <= R; ++_) {P = b = _ * E + y, L[3 * b] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (_ = 0; _ < T[y].length; ++_) {b = (_ + R + 1) * E + y;var S = T[y][_];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (_ = A; _ < m; ++_) {P = _ * E + y, L[3 * (b = (_ + v) * E + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { uknots: C, P: L, weights: d ? O : void 0 };}, t.insertBSurfaceKnotV = function (e, t, r, a, c, u, l, h) {t = Math.min(t, a);var d = h && h.length > 0,g = (0, o.findKnotSpanAndMultiplicity)(e, u);e = g.knot;var p = g.span,f = g.multiplicity,v = t - f;if (e < u[0] + i.PARAMETER_SPACE_TOLERANCE || e > u[u.length - 1] - i.PARAMETER_SPACE_TOLERANCE || f >= t) return { vknots: u.slice(), P: l.slice(), weights: d ? h.slice() : void 0 };var _,y,m = c.length - r - 1,E = u.length - a - 1,x = new Array(m),R = p - a,A = p - f;for (_ = 0; _ < m; ++_) {for (x[_] = new Array(A - R + 1), y = R; y <= A; ++y) {var P = _ * E + y,V = d ? h[P] : 1;x[_][y - R] = n.Vector4.createFloat64FromValues(V * l[3 * P], V * l[3 * P + 1], V * l[3 * P + 2], V);}}var T = s(e, p, f, v, a, u, x),C = u.slice(0, p + 1);for (y = 0; y < v; ++y) {C.push(e);}C = C.concat(u.slice(p + 1));var b,L = new Array(3 * m * (E + v)),O = new Array(m * (E + v));for (_ = 0; _ < m; ++_) {for (y = 0; y <= R; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + y)] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}for (y = 0; y < T[_].length; ++y) {b = _ * (E + v) + (y + R + 1);var S = T[_][y];L[3 * b] = S[0] / S[3], L[3 * b + 1] = S[1] / S[3], L[3 * b + 2] = S[2] / S[3], O[b] = S[3];}for (y = A; y < E; ++y) {P = _ * E + y, L[3 * (b = _ * (E + v) + (y + v))] = l[3 * P], L[3 * b + 1] = l[3 * P + 1], L[3 * b + 2] = l[3 * P + 2], O[b] = h[P];}}return { vknots: C, P: L, weights: d ? O : void 0 };}, t.extractBSurfaceParamLineU = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, a);e = h.knot;var d,g,p,f = h.span,v = e === a[a.length - 1],_ = v ? r + 1 : h.multiplicity,y = r - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * m),R = new Array(m);if (_ >= r) for (g = v ? E - 1 : f - r, d = 0; d < m; ++d) {p = d * E + g, x[3 * d] = c[3 * p], x[3 * d + 1] = c[3 * p + 1], x[3 * d + 2] = c[3 * p + 2], R[d] = l ? u[p] : 1;} else {var A = new Array(m),P = f - r,V = f - _;for (d = 0; d < m; ++d) {for (A[d] = new Array(V - P + 1), g = P; g <= V; ++g) {p = d * E + g;var T = l ? u[p] : 1;A[d][g - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, r, a, A);for (g = y - 1, d = 0; d < m; ++d) {var b = C[d][g];x[3 * d] = b[0] / b[3], x[3 * d + 1] = b[1] / b[3], x[3 * d + 2] = b[2] / b[3], R[d] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };}, t.extractBSurfaceParamLineV = function (e, t, r, i, a, c, u) {var l = u && u.length > 0,h = (0, o.findKnotSpanAndMultiplicity)(e, i);e = h.knot;var d,g,p,f = h.span,v = e === i[i.length - 1],_ = v ? t + 1 : h.multiplicity,y = t - _,m = i.length - t - 1,E = a.length - r - 1,x = new Array(3 * E),R = new Array(E);if (_ >= t) for (d = v ? m - 1 : f - t, g = 0; g < E; ++g) {p = d * E + g, x[3 * g] = c[3 * p], x[3 * g + 1] = c[3 * p + 1], x[3 * g + 2] = c[3 * p + 2], R[g] = l ? u[p] : 1;} else {var A = new Array(E),P = f - t,V = f - _;for (g = 0; g < E; ++g) {for (A[g] = new Array(V - P + 1), d = P; d <= V; ++d) {p = d * E + g;var T = l ? u[p] : 1;A[g][d - P] = n.Vector4.createFloat64FromValues(T * c[3 * p], T * c[3 * p + 1], T * c[3 * p + 2], T);}}var C = s(e, f, _, y, t, i, A);for (d = y - 1, g = 0; g < E; ++g) {var b = C[g][d];x[3 * g] = b[0] / b[3], x[3 * g + 1] = b[1] / b[3], x[3 * g + 2] = b[2] / b[3], R[g] = b[3];}}return { ctrlPts: x, weights: l ? R : void 0 };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.decomposeBSurfaceToBezier = t.decomposeBSurfaceControlPoints = t.decomposeBSurfaceControlPointsV = t.decomposeBSurfaceControlPointsU = void 0;var n = r(17),o = r(2),i = function i(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = e + 1,d = l,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[(s * l + c) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V * d + c) * n + u] = y[v][(V * d + c) * n + u] * T + y[v][((V - 1) * d + c) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A * d + c) * n + u] = y[v][(e * d + c) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s * d + c) * n + u] = r[((f - e + s) * l + c) * n + u];}}}p = f, ++f;}return y;},s = function s(e, t, r, n) {o.ConsoleUtils.assert(r.length % n == 0);var i = t.length - e - 1;o.ConsoleUtils.assert(r.length / n % i == 0);var s,a,c,u,l = r.length / (n * i),h = l,d = e + 1,g = t.length - 1,p = e,f = e + 1,v = 0,_ = [],y = [];for (y[v] = new Array(h * d * n), s = 0; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(s + c * i) * n + u];}}}for (; f < g;) {for (var m = 1; f < g && t[f + 1] === t[f];) {++f, ++m;}var E = f === g;if (E || (y[v + 1] = new Array(h * d * n)), m < e) {var x = t[f] - t[p];for (a = e; a > m; --a) {_[a - m - 1] = x / (t[p + a] - t[p]);}var R = e - m;for (a = 1; a <= R; ++a) {for (var A = R - a, P = m + a, V = e; V >= P; --V) {var T = _[V - P];for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(V + c * d) * n + u] = y[v][(V + c * d) * n + u] * T + y[v][(V - 1 + c * d) * n + u] * (1 - T);}}}if (!E) for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v + 1][(A + c * d) * n + u] = y[v][(e + c * d) * n + u];}}}}if (E) break;for (++v, s = e - m; s <= e; ++s) {for (c = 0; c < l; ++c) {for (u = 0; u < n; ++u) {y[v][(s + c * d) * n + u] = r[(f - e + s + c * i) * n + u];}}}p = f, ++f;}return y;},a = function a(e, t, r, n, _a, c) {o.ConsoleUtils.assert(_a.length % c == 0), o.ConsoleUtils.assert(_a.length / c == (r.length - e - 1) * (n.length - t - 1));var u,l = r.length > 2 * e + 2,h = n.length > 2 * t + 2;if (!l && !h) return [[_a.slice()]];u = l ? i(e, r, _a, c) : [_a];for (var d = 0; d < u.length; ++d) {u[d] = h ? s(t, n, u[d], c) : [u[d]];}return u;};t.decomposeBSurfaceControlPointsU = i, t.decomposeBSurfaceControlPointsV = s, t.decomposeBSurfaceControlPoints = a, t.decomposeBSurfaceToBezier = function (e, t, r, i, s, c) {var u,l,h,d,g = c && c.length > 0;if (o.ConsoleUtils.assert(s.length > 0 && s.length % 3 == 0), o.ConsoleUtils.assert(!g || s.length === 3 * c.length), g) {var p = (0, n.controlPointsToHomogeneous)(s, c);for (h = a(e, t, r, i, p, 4), d = [], u = 0; u < h.length; ++u) {for (d[u] = [], l = 0; l < h[u].length; ++l) {var f = (0, n.controlPointsFromHomogeneous)(h[u][l]);h[u][l] = f.P, d[u][l] = f.w;}}} else h = a(e, t, r, i, s, 3), d = void 0;var v = (0, n.getUniqueKnots)(r);o.ConsoleUtils.assert(v.length === h.length + 1);var _ = new Array(v.length - 1);for (u = 0; u < _.length; ++u) {_[u] = new Array(2 * e + 2), _[u].fill(v[u], 0, e + 1), _[u].fill(v[u + 1], e + 1);}var y = (0, n.getUniqueKnots)(i);o.ConsoleUtils.assert(y.length === h[0].length + 1);var m = new Array(y.length - 1);for (u = 0; u < m.length; ++u) {m[u] = new Array(2 * t + 2), m[u].fill(y[u], 0, t + 1), m[u].fill(y[u + 1], t + 1);}return { U: _, V: m, P: h, w: d };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.closestBSurfacePointApprox = t.closestBSurfacePatches = void 0;var n = r(1),o = r(3),i = r(73),s = r(76);t.closestBSurfacePatches = function (e, t, r) {for (var o = Number.POSITIVE_INFINITY, s = [], a = 0; a < t.length; ++a) {for (var c = 0; c < t[a].length; ++c) {var u,l = t[a][c],h = l.getRangeUnlimitedU(),d = l.getRangeUnlimitedV();if (r) {u = !1;for (var g = 0; g < r.length; ++g) {if (h[1] >= r[g][0][0] + n.FLOAT64_TOLERANCE && h[0] <= r[g][0][1] - n.FLOAT64_TOLERANCE && d[1] >= r[g][1][0] + n.FLOAT64_TOLERANCE && d[0] <= r[g][1][1] - n.FLOAT64_TOLERANCE) {u = !0;break;}}} else u = !0;if (u) {var p = l.getControlPoints(),f = (0, i.minDistanceSqrToHull)(e, p, !0);if (f <= o) {var v = (0, i.maxDistanceSqrToHull)(e, p);s.push({ index: [a, c], minDistSqr: f, maxDistSqr: v }), v < o && (o = v);}}}}return (s = s.filter(function (e) {return e.minDistSqr <= o;})).sort(function (e, t) {var r = e.minDistSqr - t.minDistSqr;return 0 === r ? e.maxDistSqr - t.maxDistSqr : r;}), s;}, t.closestBSurfacePointApprox = function (e, t, r, i, a, c, u, l, h) {var d = t > 1 ? 2 * t : 1,g = r > 1 ? 2 * r : 1,p = (l[1] - l[0]) / (i[i.length - 1] - i[0]),f = (h[1] - h[0]) / (a[a.length - 1] - a[0]);d = Math.max(1, Math.round(d * p)), g = Math.max(1, Math.round(g * f));for (var v = (l[1] - l[0]) / d, _ = (h[1] - h[0]) / g, y = Number.POSITIVE_INFINITY, m = { u: void 0, v: void 0 }, E = void 0, x = n.Vector3.createFloat64(), R = 0; R <= g; ++R) {for (var A = h[0] + R * _, P = [], V = 0; V <= d; ++V) {var T,C,b = l[0] + V * v;P[V] = (0, s.evaluateBSurfacePoint)(b, A, t, r, i, a, c, u), V > 0 && R > 0 && (T = (0, o.closestPointToTriangle)(e, E[V - 1], E[V], P[V - 1], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b + v * (T.coordA - 1), m.v = A + _ * (T.coordB - 1)), T = (0, o.closestPointToTriangle)(e, P[V], P[V - 1], E[V], x), (C = n.Vector3.squaredDistance(e, x)) < y && (y = C, m.u = b - v * T.coordA, m.v = A - _ * T.coordB));}E = P;}return m;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.checkValidity = void 0;var n = r(1),o = r(0),i = r(32),s = r(6),a = r(12),c = r(19);function u(e) {var t = [],r = e.getGuid();return r && "string" == typeof r || t.push({ error: "BaseTopology has invalid GUID", source: [e] }), t;}function l(e) {var t = u(e),r = 0,n = 0,i = 0,s = e.getLumps();if (s.length > 0) {for (var a = new Set(), c = 0; c < s.length; ++c) {var l = s[c];a.add(l), l && l.getTopologyType() === o.TOPOLOGY_TYPES.LUMP ? l.getBody() !== e && t.push({ error: "Body is not the parent of child Lump", source: [e, l] }) : t.push({ error: "Body has invalid element in Lump array", source: [e, l] }), r += l.collectFaces().size, n += l.collectEdges().size, i += l.collectVertices().size;}a.size !== s.length && t.push({ error: "Body has non-unique Lumps", source: [e] });}return r !== e.collectFaces().size && t.push({ error: "Body has Lumps which share Faces", source: [e] }), n !== e.collectEdges().size && t.push({ error: "Body has Lumps which share Edges", source: [e] }), i !== e.collectVertices().size && t.push({ error: "Body has Lumps which share Vertices", source: [e] }), t;}function h(e) {var t = u(e),r = e.getBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.BODY && t.push({ error: "Lump has invalid parent Body", source: [e] });var n = 0,i = 0,s = 0,a = e.getShells();if (a.length > 0) {for (var c = new Set(), l = 0; l < a.length; ++l) {var h = a[l];c.add(h), h && h.getTopologyType() === o.TOPOLOGY_TYPES.SHELL ? h.getLump() !== e && t.push({ error: "Lump is not the parent of child Shell", source: [e, h] }) : t.push({ error: "Lump has invalid element in Shell array", source: [e, h] }), n += h.collectFaces().size, i += h.collectEdges().size, s += h.collectVertices().size;}c.size !== a.length && t.push({ error: "Lump has non-unique Shells", source: [e] });} else t.push({ error: "Lump has no Shells", source: [e] });return n !== e.collectFaces().size && t.push({ error: "Lump has Shells which share Faces", source: [e] }), i !== e.collectEdges().size && t.push({ error: "Lump has Shells which share Edges", source: [e] }), s !== e.collectVertices().size && t.push({ error: "Lump has Shells which share Vertices", source: [e] }), t;}function d(e) {var t = u(e),r = e.getLump();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LUMP && t.push({ error: "Shell has invalid parent Lump", source: [e] });var n = e.getFaces();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.FACE ? a.getShell() !== e && t.push({ error: "Shell is not the parent of child Face", source: [e, a] }) : t.push({ error: "Shell has invalid element in Face array", source: [e, a] });}i.size !== n.length && t.push({ error: "Shell has non-unique Faces", source: [e] });} else t.push({ error: "Shell has no Faces", source: [e] });1 !== (0, c.findConnectedFaces)(e.getFaces()).length && t.push({ error: "Shell is disconnected", source: [e] });var l = e.collectVertices(),h = e.collectEdges(),d = new Set(),g = new Set();return l.forEach(function (e) {e.collectEdges(d), e.collectFaces(g);}), d.size !== h.size && t.push({ error: "Shell has rogue edges", source: [e] }), l.size > 0 && g.size !== e.getFaces().length && t.push({ error: "Shell has rogue faces", source: [e] }), t;}function g(e) {var t = u(e),r = e.getShell();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.SHELL && t.push({ error: "Face has invalid parent Shell", source: [e] });var n = 0,i = 0,s = e.getLoops(),c = e.getSurface();if (s.length > 0) {for (var l = new Set(), h = 0; h < s.length; ++h) {var d = s[h];l.add(d), d && d.getTopologyType() === o.TOPOLOGY_TYPES.LOOP ? d.getFace() !== e && t.push({ error: "Face is not the parent of child Loop", source: [e, d] }) : t.push({ error: "Face has invalid element in Loop array", source: [e, d] }), n += d.collectEdges().size, i += d.collectVertices().size;}l.size !== s.length && t.push({ error: "Face has non-unique Loops", source: [e] });} else {var g = c.getGeometryType() === o.GEOMETRY_TYPES.SPHERE,p = c.getGeometryType() === o.GEOMETRY_TYPES.TORUS && c.isDoughnut();g || p || t.push({ error: "Face has no Loops", source: [e] });}return n !== e.collectEdges().size && t.push({ error: "Face has Loops which share Edges", source: [e] }), i !== e.collectVertices().size && t.push({ error: "Face has Loops which share Vertices", source: [e] }), c ? c instanceof a.Surface || t.push({ error: "Face has invalid Surface geometry", source: [e, c] }) : t.push({ error: "Face has no Surface geometry", source: [e] }), t;}function p(e) {var t = u(e),r = e.getFace();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.FACE && t.push({ error: "Loop has invalid parent Face", source: [e] });var n = e.getCoedges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];if (i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.COEDGE) {a.getLoop() !== e && t.push({ error: "Loop is not the parent of child Coedge", source: [e, a] });var c = n[(s + 1) % n.length];a.getEndVertex() !== c.getStartVertex() && t.push({ error: "Loop has disconnected Coedges", source: [e, a, c] });} else t.push({ error: "Loop has invalid element in Coedge array", source: [e, a] });}i.size !== n.length && t.push({ error: "Loop has non-unique Coedges", source: [e] });} else t.push({ error: "Loop has no Coedges", source: [e] });return t;}function f(e) {var t = u(e),r = e.getLoop();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.LOOP && t.push({ error: "Coedge has invalid parent Loop", source: [e] });var n = e.getBody(),i = new Set(),s = e;do {if (i.has(s)) {t.push({ error: "Coedge partner list does not form a loop", source: [e] });break;}if (i.add(s), !s.getPartner()) {s !== e && t.push({ error: "Coedge has no partner", source: [e, s] });break;}if ((s = s.getPartner()).getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE) {t.push({ error: "Coedge has invalid entry in partner list", source: [e, s] });break;}s.getEdge() !== e.getEdge() && t.push({ error: "Coedge partner refers to a different Edge", source: [e, s] }), s.getBody() !== n && t.push({ error: "Coedge partner is part of a different Body", source: [e, s] });} while (s !== e);var a = e.getEdge();return a ? a.getTopologyType() !== o.TOPOLOGY_TYPES.EDGE ? t.push({ error: "Coedge has invalid Edge", source: [e, a] }) : (s = a.getCoedge()) && i.has(s) || t.push({ error: "Coedge partner list does not include parent of Edge", source: [e, a] }) : t.push({ error: "Coedge has no Edge", source: [e] }), t;}function v(e) {var t = u(e),r = e.getCoedge(),s = e.getWire();s && r ? t.push({ error: "Edge has too many parents, both Wire and Coedge", source: [e] }) : s ? s.getTopologyType() !== o.TOPOLOGY_TYPES.WIRE && t.push({ error: "Edge has invalid parent Wire", source: [e] }) : r && r.getTopologyType() !== o.TOPOLOGY_TYPES.COEDGE && t.push({ error: "Edge has invalid parent Coedge", source: [e] });for (var a = e.getVertices(), c = 0; c < a.length; ++c) {var l = a[c];l && l.getTopologyType() === o.TOPOLOGY_TYPES.VERTEX ? l.isAdjacentEdge(e) || t.push({ error: "Edge is not adjacent to own Vertex", source: [e, l] }) : t.push({ error: "Edge has invalid Vertex", source: [e, l] });}var h = e.getCurve();return h ? h instanceof i.Curve ? t = t.concat(function (e, t) {var r = [],i = e.isReversed(),s = e.getRange();if (void 0 === s || 2 !== s.length || void 0 === s[0] || void 0 === s[1] || s[1] < s[0]) return r.push({ error: "Edge range is not defined", source: [e, s] }), r;var a = e.getStartVertex(),c = i ? -e.t0() : e.t0(),u = t.evaluatePosition(c),l = Math.max(o.KERNEL_TOLERANCE, a.getPrecision());n.Vector3.equals(a.getPosition(), u, l) || r.push({ error: "Edge start position not consistent with Vertex", source: [e, a, u] });var h = e.getEndVertex(),d = i ? -e.t1() : e.t1(),g = t.evaluatePosition(d),p = Math.max(o.KERNEL_TOLERANCE, h.getPrecision());return n.Vector3.equals(h.getPosition(), g, p) || r.push({ error: "Edge end position not consistent with Vertex", source: [e, h, g] }), e.isClosed() ? (a !== h && r.push({ error: "Edge is closed but has different start and end Vertices", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) || r.push({ error: "Edge is closed but has different start and end positions", source: [e, u, g] }), t.isClosed() || r.push({ error: "Edge is closed but its curve is not", source: [e] })) : (a === h && r.push({ error: "Edge is open but has same start and end Vertices", source: [e] }), n.Vector3.equals(u, g, o.KERNEL_TOLERANCE) && r.push({ error: "Edge is open but has same start and end positions", source: [e, u, g] })), t.isPeriodic() ? Math.abs(d - c) > t.getPeriod() + o.PARAMETER_SPACE_TOLERANCE && r.push({ error: "Edge parameter range is longer than curve period", source: [e] }) : ((c + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || c - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: "Edge start parameter is outside of curve range", source: [e] }), (d + o.PARAMETER_SPACE_TOLERANCE < t.getRange()[0] || d - o.PARAMETER_SPACE_TOLERANCE > t.getRange()[1]) && r.push({ error: "Edge end parameter is outside of curve range", source: [e] })), r;}(e, h)) : t.push({ error: "Edge has invalid Curve geometry", source: [e, h] }) : t = t.concat(function (e) {if (e.getWire()) return [{ error: "Degenerate Edge is part of a Wire", source: [e] }];if (e.getStartVertex() !== e.getEndVertex()) return [{ error: "Degenerate Edge has different start and end vertices", source: [e] }];var t = Array.from(e.collectFaces());if (0 === t.length) return [];if (1 !== t.length) return [{ error: "Degenerate Edge is part of multiple Faces", source: [e] }];var r = e.getStartVertex().getPosition(),i = t[0].getSurface(),s = i.getGeometryType();if (s === o.GEOMETRY_TYPES.PLANE || s === o.GEOMETRY_TYPES.CYLINDER || s === o.GEOMETRY_TYPES.ELLIPTICAL_CYLINDER || s === o.GEOMETRY_TYPES.SPHERE) return [{ error: "Degenerate Edge is on a surface with no singularities", source: [e, i] }];if (s === o.GEOMETRY_TYPES.CONE || s === o.GEOMETRY_TYPES.ELLIPTICAL_CONE) {if (!(l = i.getApexPosition())) return [{ error: "Degenerate Edge is on a surface with no singularities", source: [e, i] }];if (!n.Vector3.equals(r, l, o.KERNEL_TOLERANCE)) return [{ error: "Degenerate Edge is not at a surface singularity", source: [e, i] }];} else {if (s !== o.GEOMETRY_TYPES.TORUS) return [{ error: "Degenerate Edge is not on an analytic surface", source: [e] }];for (var a = !1, c = i.getSingularUParams(), u = 0; u < c.length; ++u) {var l = i.evaluatePosition(c[u], 0);n.Vector3.equals(r, l, o.KERNEL_TOLERANCE) && (a = !0);}if (!a) return [{ error: "Degenerate Edge is not at a surface singularity", source: [e, i] }];}return [];}(e)), t;}function _(e) {var t = u(e),r = e.getEdges();if (r.length > 0) for (var n = e.getBody(), i = 0; i < r.length; ++i) {var a = r[i];a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getStartVertex() !== e && a.getEndVertex() !== e ? t.push({ error: "Vertex is not an end-point of adjacent Edge", source: [e, a] }) : a.getBody() !== n && t.push({ error: "Vertex has adjacent Edge from a different body", source: [e, a] }) : t.push({ error: "Vertex has invalid entry in Edge list", source: [e, a] });} else t.push({ error: "Vertex has no adjacent Edges", source: [e] });var c = e.getPoint();return c ? c instanceof s.Point || t.push({ error: "Vertex has invalid Point geometry", source: [e, c] }) : t.push({ error: "Vertex has no Point geometry", source: [e] }), t;}function y(e) {var t = u(e),r = 0,n = 0,i = e.getWires();if (i.length > 0) {for (var s = new Set(), a = 0; a < i.length; ++a) {var c = i[a];s.add(c), c && c.getTopologyType() === o.TOPOLOGY_TYPES.WIRE ? c.getWireBody() !== e && t.push({ error: "WireBody is not the parent of child Wire", source: [e, c] }) : t.push({ error: "WireBody has invalid element in Wire array", source: [e, c] }), r += c.collectEdges().size, n += c.collectVertices().size;}s.size !== i.length && t.push({ error: "WireBody has non-unique Wires", source: [e] });} else t.push({ error: "WireBody has no Wires", source: [e] });return r !== e.collectEdges().size && t.push({ error: "WireBody has Wires which share Edges", source: [e] }), n !== e.collectVertices().size && t.push({ error: "WireBody has Wires which share Vertices", source: [e] }), t;}function m(e) {var t = u(e),r = e.getWireBody();r && r.getTopologyType() !== o.TOPOLOGY_TYPES.WIREBODY && t.push({ error: "Wire has invalid parent WireBody", source: [e] });var n = e.getEdges();if (n.length > 0) {for (var i = new Set(), s = 0; s < n.length; ++s) {var a = n[s];i.add(a), a && a.getTopologyType() === o.TOPOLOGY_TYPES.EDGE ? a.getWire() !== e && t.push({ error: "Wire is not the parent of child Edge", source: [e, a] }) : t.push({ error: "Wire has invalid element in Edge array", source: [e, a] });}i.size !== n.length && t.push({ error: "Wire has non-unique Edges", source: [e] });var l = (0, c.findConnectedEdges)(n);1 !== l.length ? t.push({ error: "Wire is not a connected set of Edges", source: [e] }) : l[0].length !== n.length && t.push({ error: "Wire is connected to other unknown Edges", source: [e] });} else t.push({ error: "Wire has no Edges", source: [e] });return t;}t.checkValidity = function (e) {for (var t, r, n, i = [], s = [e], a = new Set(), c = new Map(); s.length > 0;) {a.clear();var u = new Set();for (t = 0; t < s.length; ++t) {switch ((r = s[t]).getTopologyType()) {case o.TOPOLOGY_TYPES.BODY:i = i.concat(l(r)), r.getLumps().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.LUMP:i = i.concat(h(r)), r.getShells().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.SHELL:i = i.concat(d(r)), r.getFaces().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.FACE:i = i.concat(g(r)), r.getLoops().forEach(function (e) {a.add(e);}), r.getSurface() && u.add(r.getSurface());break;case o.TOPOLOGY_TYPES.LOOP:i = i.concat(p(r)), r.getCoedges().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.COEDGE:i = i.concat(f(r)), a.add(r.getEdge());break;case o.TOPOLOGY_TYPES.EDGE:i = i.concat(v(r)), r.getVertices().forEach(function (e) {e && a.add(e);}), r.getCurve() && u.add(r.getCurve());break;case o.TOPOLOGY_TYPES.VERTEX:i = i.concat(_(r)), r.getPoint() && u.add(r.getPoint());break;case o.TOPOLOGY_TYPES.WIREBODY:i = i.concat(y(r)), r.getWires().forEach(function (e) {a.add(e);});break;case o.TOPOLOGY_TYPES.WIRE:i = i.concat(m(r)), r.getEdges().forEach(function (e) {a.add(e);});}n = r.getGuid(), c.has(n) ? i.push({ error: "Objects have clashing GUIDs", source: [r, c.get(n)] }) : c.set(n, r);}for (u = Array.from(u), t = 0; t < u.length; ++t) {n = (r = u[t]).getGuid(), c.has(n) ? i.push({ error: "Objects have clashing GUIDs", source: [r, c.get(n)] }) : c.set(n, r);}s = Array.from(a);}return i;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.facetPlanarFace = void 0;var n = r(1),o = r(0),i = r(108),s = r(3),a = r(109),c = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),u = r(8),l = 1e-8,h = o.KERNEL_TOLERANCE,d = function d(e, t, r) {var o,i = e[(0, s.modulus)(t - 1, e.length)],a = e[(0, s.modulus)(t + 1, e.length)],c = e[t],u = c[0] - i[0],l = c[1] - i[1],d = a[0] - c[0],g = a[1] - c[1],p = Math.sqrt(u * u + l * l),f = Math.sqrt(d * d + g * g);u * d + l * g < -.95 * p * f ? (u *= -1, l *= -1) : r ? (o = u, u = -l, l = o, o = d, d = -g, g = o) : (o = u, u = l, l = -o, o = d, d = g, g = -o);var v = .5 * (u / p + d / f),_ = .5 * (l / p + g / f),y = Math.sqrt(v * v + _ * _);e[t] = n.Vector3.clone(c), e[t][0] += h * v / y, e[t][1] += h * _ / y;},g = function g(e) {return String(e[0]) + String(e[1]);},p = function p(e) {for (var t = !1, r = {}, n = 0; n < e.length; n++) {var o = g(e[n]);void 0 === r[o] ? r[o] = [] : t = !0, r[o].push(n);}return { table: r, foundSelfIntersection: t };},f = function f(e) {var t = p(e);if (t.foundSelfIntersection) {for (var r = (0, i.isLoopCCW)(e), n = [], o = 0; o < e.length - 1; o++) {n[o] = !1;}var a = [];for (o = 0; o < e.length - 1; o++) {if (!n[o]) {var c = [],u = o;n[u] = !0, c.push(e[u]);var l = g(c[0]),h = e[(0, s.modulus)(u + 1, e.length)],f = g(h),v = [];for (t.table[l].length > 1 && v.push(0); f !== l;) {if (c.push(h), c.length > e.length) throw new Error("splitHole failure");var _ = t.table[f];if (1 === _.length) u++;else {v.push(c.length - 1);for (var y = [], m = 0; m < _.length; m++) {_[m] !== u && y.push(_[m]);}var E = Math.atan2(e[u + 1][1] - e[u][1], e[u + 1][0] - e[u][0]);E = (0, s.normalizeParameterToShiftedRange)(E - Math.PI, [-Math.PI, Math.PI]);var x = -1,R = 0;for (m = 0; m < y.length; m++) {var A = Math.atan2(e[(0, s.modulus)(y[m] + 1, e.length)][1] - e[y[m]][1], e[(0, s.modulus)(y[m] + 1, e.length)][0] - e[y[m]][0]);A < E && r ? A += s.PI2 : A > E && !r && (A -= s.PI2);var P = Math.abs(A - E);P > R && (R = P, x = y[m]);}u = x;}h = e[(0, s.modulus)(u + 1, e.length)], f = g(h), n[u] = !0;}for (m = 0; m < v.length; m++) {d(c, v[m], r);}a.push(c);}}return a;}return [e];},v = function v(e, t) {for (var r = [], n = 0; n < e.length; n++) {r[n] = { index: void 0, loop: void 0 };for (var o = e[n], i = 0; i < t.length; i++) {for (var s = t[i], a = 0; a < s.length; a++) {if (s[a][0] === o[0] && s[a][1] === o[1]) {r[n].index = a, r[n].loop = s;break;}}}}return r;};function _(e, t) {var r,n = !1,o = t.length,i = o - 1;for (r = 0; r < o; r += 2) {t[r][1] > e[1] != t[i][1] > e[1] && e[0] < (t[i][0] - t[r][0]) * (e[1] - t[r][1]) / (t[i][1] - t[r][1]) + t[r][0] && (n = !n), i = r;}return n;}function y(e, t, r) {for (var o, s, a = v(e, [t].concat(r)), c = [], h = [], d = void 0, g = void 0, p = 0; p < 4; ++p) {a[p] && void 0 !== a[p].index && (d ? g || a[p].loop === d || (g = a[p].loop) : d = a[p].loop, a[p].loop === d ? (o = d, s = c) : (o = g, s = h), (P = [a[p].index - 1, a[p].index])[0] < 0 && (P[0] = o.length - 1), s.push(P), s.push([a[p].index, (a[p].index + 1) % o.length]));}g || (g = d, h = c);var f,y,m = void 0,E = d,x = c;for (p = 0; p < 3; ++p) {for (f = 0; f < c.length; ++f) {for (y = 0; y < h.length && (c === h && y >= f || !(m = (0, i.intersectSegments)(d[c[f][0]], d[c[f][1]], g[h[y][0]], g[h[y][1]], 0)) || !m.intersection); ++y) {;}if (m && m.intersection) break;}if (m && m.intersection || d === g) break;0 === p ? (d = g, c = h) : 1 === p && (d = E, c = x, g = E, h = x);}if (void 0 !== m && m.intersection) {var R = n.Vector3.subtract(n.Vector3.createFloat64(), d[c[f][1]], d[c[f][0]]);n.Vector3.scale(R, R, m.solutions[0]);var A = n.Vector3.add(R, R, d[c[f][0]]);if (c[f][0] > c[f][1]) {var P = c[f][1];c[f][1] = c[f][0], c[f][0] = P;}if (0 === c[f][0] && 1 !== c[f][1] && (c[f][0] = c[f][1], c[f][1] = 0), h[y][0] > h[y][1] && 0 !== h[y][1] && (P = h[y][1], h[y][1] = h[y][0], h[y][0] = P), 0 === h[y][0] && 1 !== h[y][1] && (h[y][0] = h[y][1], h[y][1] = 0), d === g) {if (d.length < 4) return void console.error("REGION: Failed to fix loop tessellation! [loop too short]");console.log("REGION: Fixing self-intersection");var V = new Array(4);c[f][0] < h[y][0] ? (V[0] = c[f][0], V[1] = c[f][1], V[2] = h[y][0], V[3] = h[y][1]) : (V[0] = h[y][0], V[1] = h[y][1], V[2] = c[f][0], V[3] = c[f][1]);var T = [];for (p = 0; p <= V[0]; ++p) {T.push(d[p]);}var C = n.Vector3.subtract(n.Vector3.createFloat64(), d[V[0]], d[V[1]]);n.Vector3.normalize(C, C), n.Vector3.scale(C, C, l);var b = n.Vector3.add(n.Vector3.createFloat64(), A, C);for (T.push(b), p = V[2]; p >= V[1]; --p) {T.push(d[p]);}var L = n.Vector3.subtract(n.Vector3.createFloat64(), A, C);if (T.push(L), V[3] > V[2]) for (p = V[3]; p < d.length; ++p) {T.push(d[p]);}for (d.length = T.length, p = 0; p < T.length; ++p) {d[p] = T[p];}} else {console.log("REGION: Fixing loop-loop intersection");var O = d,S = g,M = h[y][0],w = h[y][1],N = c[f][0],F = c[f][1];(t === S || S.length > O.length && t !== O) && (O = g, S = d, M = c[f][0], w = c[f][1], N = h[y][0], F = h[y][1]);var I = 1;t !== S && t !== O && (I = -1);var D = 1;_(S[w], O) && (D = -1, P = M, M = w, w = P), n.Vector3.subtract(S[w], S[M], S[w]), n.Vector3.normalize(S[w], S[w]), n.Vector3.scale(S[w], S[w], I * l), n.Vector3.add(S[w], A, S[w]);var j,B,U = w;do {(w += D) < 0 ? w = S.length - 1 : w %= S.length;} while (w !== M && !_(S[w], O));(M = w - D) < 0 && (M = S.length - 1), F = N;do {j = O[F], B = O[F = ++F % O.length], m = (0, i.intersectSegments)(j, B, S[M], S[w], 0);} while (N !== F && !m.intersection);m.intersection && (n.Vector3.scale(R, n.Vector3.subtract(R, B, j), m.solutions[0]), n.Vector3.add(A, R, j), n.Vector3.subtract(S[M], S[w], S[M]), n.Vector3.normalize(S[M], S[M]), n.Vector3.scale(S[M], S[M], I * l), n.Vector3.add(S[M], A, S[M])), Math.min(Math.abs(U - M), Math.abs(U - M - S.length)) > 1 && console.warn("REGION: Remove loop segment! FIXME!");}} else u.DebugUtils.warn("REGION: Failed to fix loop tessellation! [no intersected segments]");}var m = function m(e, t) {var r = e;for (r < 0 ? r += t.length : r %= t.length; t[r] !== r;) {r = t[r];}return r;},E = function E(e, t, r, o) {return n.Vector3.distance(r[e], r[t]) < 1e-6 ? (o[0] = e, o[1] = e, 1) : 0;},x = function x(e, t, r, o, i) {var s = new Array(2);if (s[0] = o[e], s[1] = o[r], n.Vector3.length(n.Vector3.subtract(n.Vector3.createFloat64(), s[0], s[1])) < 1e-6) return i[0] = e, i[1] = e, i[2] = e, 2;var a = (s[0][0] - s[1][0]) * (o[t][1] - s[1][1]) - (s[0][1] - s[1][1]) * (o[t][0] - s[1][0]);return a > -l * l && a < l * l ? (i[0] = e, i[1] = e, i[2] = r, 1) : 0;},R = function R(e, t, r, n, o, s) {return (0, i.intersectSegments)(o[e], o[t], o[r], o[n]).intersection ? (s[0] = e, s[1] = t, s[2] = t, s[3] = n, 1) : (s[0] = -1, 0);},A = function A(e) {if (e.length < 4) return e;for (var t, r, n, o, i = e.length, s = new Int32Array(i), a = 0; a < i; ++a) {s[a] = a;}var c,u = new Array(3),l = new Array(3);for (l[0] = 0, l[1] = 0, l[2] = 0, a = 0; a < i; ++a) {t = m(a, s), r = m(a + 1, s), (c = E(t, r, e, u)) && (++l[0], s[t] = u[0], s[r] = u[1], t = m(a += c, s), r = m(a + 1, s)), n = m(a + 2, s), (c = x(t, r, n, e, u)) && (++l[1], s[t] = u[0], s[r] = u[1], s[n] = u[2], t = m(a += c, s), r = m(a + 1, s), n = m(a + 2, s)), o = m(a + 3, s), (c = R(t, r, n, o, e, u)) && (++l[2], s[t] = u[0], s[r] = u[1], s[n] = u[2], s[o] = u[3], a += c);}var h = [];for (a = 0; a < e.length; ++a) {s[a] === a && h.push(e[a]);}return h;},P = function P(e, t, r) {for (var n = v(e, [t].concat(r)), o = 0; o < n.length; o++) {d(n[o].loop, n[o].index, (0, i.isLoopCCW)(n[o].loop));}},V = function V(e, t) {var r = !1;!function (e) {var t = p(e);if (t.foundSelfIntersection) for (var r = (0, i.isLoopCCW)(e), n = c.default.keys(t.table), o = 0; o < n.length; o++) {if (t.table[n[o]].length > 1) for (var s = t.table[n[o]], a = 0; a < s.length; a++) {d(e, s[a], r);}}}(e);for (var n = [], o = 0; o < t.length; o++) {n.push.apply(n, f(t[o]));}var s = A(e),l = [];for (o = 0; o < n.length; o++) {l.push(A(n[o]));}var h = 8;do {r = !0;var g = (0, c.default)(s).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);}),v = new a.poly2tri.SweepContext(g);for (o = 0; o < l.length; o++) {var _ = (0, c.default)(l[o]).map(function (e) {return new a.poly2tri.Point(e[0], e[1]);});v.addHole(_);}try {v.triangulate();} catch (e) {if ("poly2tri Intersecting Constraints" === e.message.substr(0, 33)) r = !1, y(e.points, s, l);else if ("poly2tri EdgeEvent: Collinear not supported" === e.message.substr(0, 43)) r = !1, P(e.points, s, l);else {if (!e.points) throw e;r = !1, y(e.points, s, l);}}} while (!r && h-- > 0);return h <= 0 && u.DebugUtils.warn("Computation of region tessellation failed, due to too many intersections."), v;};t.facetPlanarFace = function (e, t) {var r = e.getSurface(),o = (0, s.getPlaneTransforms)(r),a = new i.LoopCalculator(e, o.threeSpaceToUV).getRank0Loops();if (1 !== a.length) throw new Error("Each region should have exactly one top-loop");var c = a[0],u = (0, i.tessellateLoop)(c._loop, t);if (o.threeSpaceToUV) for (var l = 0; l < u.length; l++) {n.Vector3.transformMatrix44(u[l], u[l], o.threeSpaceToUV);}for (var h = [], d = c.getImmediatelyInsideLoops(), g = 0; g < d.length; g++) {var p = (0, i.tessellateLoop)(d[g]._loop, t);if (h.push(p), o.threeSpaceToUV) for (l = 0; l < p.length; l++) {n.Vector3.transformMatrix44(p[l], p[l], o.threeSpaceToUV);}}var f = V(u, h),v = f.getTriangles(),_ = new Uint32Array(3 * v.length),y = new Float32Array(3 * f.pointCount()),m = n.Vector3.createFloat64();for (l = 0; l < f.pointCount(); l++) {var E = f.getPoint(l);n.Vector3.set(m, E.x, E.y, 0), o.uvToThreeSpace && n.Vector3.transformMatrix44(m, m, o.uvToThreeSpace), y[3 * l] = m[0], y[3 * l + 1] = m[1], y[3 * l + 2] = m[2], E.index = l;}for (l = 0; l < v.length; l++) {var x = v[l].getPoints();for (e.isReversed() && x.reverse(), g = 0; g < x.length; g++) {var R = x[g];_[3 * l + g] = R.index;}}return { indexBuffer: _, vertexBuffer: y };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.LoopCalculator = t.intersectSegments = t.isLoopCCW = t.tessellateLoop = void 0;var n = r(1),o = r(0),i = r(3),s = function s(e, t) {this._loop = e, this._enclosureRank = 0, this._isOuterLoop = !1, this._insideLoops = [], this._isOpen = !1, this._coedges = this._loop.getCoedges();for (var r = 0; r < this._coedges.length; ++r) {this._coedges[r].generateUVCurve(t);}};s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.uvAngleSubtended = function (e) {if (!this.isClosedLoop()) throw new Error("uvAngleSubtended cannot work with open loops");for (var t = 0, r = 0; r < this._coedges.length; r++) {t += this._coedges[r].uvAngleSubtended(e);}return t;}, s.prototype.getArbitraryPointOnLoop = function () {if (1 === this._coedges.length) {var e = this._coedges[0].t0();return this._coedges[0].evaluatePosition(e);}var t = this._coedges[0].getStartVertex();if (t) return t.getPosition();}, s.prototype.isInside = function (e) {var t = this.getArbitraryPointOnLoop(),r = Math.abs(e.uvAngleSubtended(t)),n = Math.floor(r / (2 * Math.PI)),i = r - 2 * n * Math.PI;return !!(Math.abs(i) < o.KERNEL_TOLERANCE && n || Math.abs(i - 2 * Math.PI) < o.KERNEL_TOLERANCE);}, s.prototype.getEnclosureRank = function () {return this._enclosureRank;}, s.prototype.resetEnclosureRank = function () {this._enclosureRank = 0;}, s.prototype.decreaseEnclosureRank = function () {this._enclosureRank--;}, s.prototype.setIsOuterLoop = function (e) {this._isOuterLoop = e;}, s.prototype.isOuterLoop = function () {return this._isOuterLoop;}, s.prototype.isClosedLoop = function () {return !this._isOpen;}, s.prototype.addInsideLoop = function (e) {this._insideLoops.push(e);}, s.prototype.getImmediatelyInsideLoops = function () {for (var e = [], t = 0; t < this._insideLoops.length; t++) {this._insideLoops[t].getEnclosureRank() === this._enclosureRank - 1 && e.push(this._insideLoops[t]);}return e;};var a = function a(e, t) {this._face = e, this._loops = [];for (var r = 0; r < this._face.getLoops().length; ++r) {this._loops.push(new s(this._face.getLoops()[r], t));}this._calcSenses();};a.prototype._calcSenses = function () {for (var e = this._loops.length, t = 0; t < e; t++) {this._loops[t].resetEnclosureRank();}for (t = 0; t < e; t++) {if (this._loops[t].isClosedLoop()) for (var r = 0; r < e; r++) {this._loops[r].isClosedLoop() && t !== r && this._loops[t].isInside(this._loops[r]) && !this._loops[r].isInside(this._loops[t]) && (this._loops[t].decreaseEnclosureRank(), this._loops[r].addInsideLoop(this._loops[t]));}}for (t = 0; t < e; t++) {var n = 0 - this._loops[t].getEnclosureRank();this._loops[t].setIsOuterLoop(n % 2 == 0);}}, a.prototype.getRank0Loops = function () {var e = [];return this._loops.forEach(function (t) {0 === t.getEnclosureRank() && e.push(t);}), e;}, t.tessellateLoop = function (e, t) {for (var r = [], o = 0, i = e.getCoedges().length; o < i; ++o) {var s = e.getCoedges()[o],a = s.getEdge(),c = a.tessellate(void 0, t).positions;c = c.slice(1, c.length - 1), (c = [n.Vector3.clone(a.getStartVertex().getPosition())].concat(c)).push(n.Vector3.clone(a.getEndVertex().getPosition())), s.isReversed() && c.reverse(), r = r.concat(c.slice(0, c.length - 1));}return r;}, t.isLoopCCW = function (e) {for (var t = 0, r = 0; r < e.length; r++) {var n = (r + 1) % e.length;t += e[r][0] * e[n][1] - e[r][1] * e[n][0];}return t > 0;}, t.intersectSegments = function (e, t, r, o, s) {var a = [[t[0] - e[0], -(o[0] - r[0]), r[0] - e[0]], [t[1] - e[1], -(o[1] - r[1]), r[1] - e[1]]],c = (0, i.solveTwoEquationsTwoVariables)(a);if (void 0 === c) return !1;var u = n.Vector3.distance(e, t),l = n.Vector3.distance(r, o);return { intersection: -s < c[0] * u && (c[0] - 1) * u < s && -s < c[1] * l && (c[1] - 1) * l < s, solutions: c };}, t.LoopCalculator = a;}, function (e, t, r) {"use strict";var n, o;if (Object.defineProperty(t, "__esModule", { value: !0 }), void 0 === i) var i = {},s = { exports: {} };!function (a) {"object" == _typeof(i) ? s.exports = a() : void 0 === (o = "function" == typeof (n = a) ? n.call(t, r, t, e) : n) || (e.exports = o);}(function () {return function e(t, r, n) {function o(s, a) {if (!r[s]) {if (!t[s]) {if (i) return i(s, !0);throw new Error("Cannot find module '" + s + "'");}var c = r[s] = { exports: {} };t[s][0].call(c.exports, function (e) {return o(t[s][1][e] || e);}, c, c.exports, e, t, r, n);}return r[s].exports;}for (var i = !1, s = 0; s < n.length; s++) {o(n[s]);}return o;}({ 1: [function (e, t, r) {t.exports = { version: "1.3.5" };}, {}], 2: [function (e, t, r) {var n = function n(e, t) {this.head_ = e, this.tail_ = t, this.search_node_ = e;};n.prototype.head = function () {return this.head_;}, n.prototype.setHead = function (e) {this.head_ = e;}, n.prototype.tail = function () {return this.tail_;}, n.prototype.setTail = function (e) {this.tail_ = e;}, n.prototype.search = function () {return this.search_node_;}, n.prototype.setSearch = function (e) {this.search_node_ = e;}, n.prototype.findSearchNode = function () {return this.search_node_;}, n.prototype.locateNode = function (e) {var t = this.search_node_;if (e < t.value) {for (; t = t.prev;) {if (e >= t.value) return this.search_node_ = t, t;}} else for (; t = t.next;) {if (e < t.value) return this.search_node_ = t.prev, t.prev;}return null;}, n.prototype.locatePoint = function (e) {var t = e.x,r = this.findSearchNode(t),n = r.point.x;if (t === n) {if (e !== r.point) if (e === r.prev.point) r = r.prev;else {if (e !== r.next.point) throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");r = r.next;}} else if (t < n) for (; (r = r.prev) && e !== r.point;) {;} else for (; (r = r.next) && e !== r.point;) {;}return r && (this.search_node_ = r), r;}, t.exports = n, t.exports.Node = function (e, t) {this.point = e, this.triangle = t || null, this.next = null, this.prev = null, this.value = e.x;};}, {}], 3: [function (e, t, r) {t.exports = function (e, t) {if (!e) throw new Error(t || "Assert Failed");};}, {}], 4: [function (e, t, r) {var n = e("./xy"),o = function o(e, t) {this.x = +e || 0, this.y = +t || 0, this._p2t_edge_list = null;};o.prototype.toString = function () {return n.toStringBase(this);}, o.prototype.toJSON = function () {return { x: this.x, y: this.y };}, o.prototype.clone = function () {return new o(this.x, this.y);}, o.prototype.set_zero = function () {return this.x = 0, this.y = 0, this;}, o.prototype.set = function (e, t) {return this.x = +e || 0, this.y = +t || 0, this;}, o.prototype.negate = function () {return this.x = -this.x, this.y = -this.y, this;}, o.prototype.add = function (e) {return this.x += e.x, this.y += e.y, this;}, o.prototype.sub = function (e) {return this.x -= e.x, this.y -= e.y, this;}, o.prototype.mul = function (e) {return this.x *= e, this.y *= e, this;}, o.prototype.length = function () {return Math.sqrt(this.x * this.x + this.y * this.y);}, o.prototype.normalize = function () {var e = this.length();return this.x /= e, this.y /= e, e;}, o.prototype.equals = function (e) {return this.x === e.x && this.y === e.y;}, o.negate = function (e) {return new o(-e.x, -e.y);}, o.add = function (e, t) {return new o(e.x + t.x, e.y + t.y);}, o.sub = function (e, t) {return new o(e.x - t.x, e.y - t.y);}, o.mul = function (e, t) {return new o(e * t.x, e * t.y);}, o.cross = function (e, t) {return "number" == typeof e ? "number" == typeof t ? e * t : new o(-e * t.y, e * t.x) : "number" == typeof t ? new o(t * e.y, -t * e.x) : e.x * t.y - e.y * t.x;}, o.toString = n.toString, o.compare = n.compare, o.cmp = n.compare, o.equals = n.equals, o.dot = function (e, t) {return e.x * t.x + e.y * t.y;}, t.exports = o;}, { "./xy": 11 }], 5: [function (e, t, r) {var n = e("./xy"),o = function o(e, t) {this.name = "PointError", this.points = t = t || [], this.message = e || "Invalid Points!";for (var r = 0; r < t.length; r++) {this.message += " " + n.toString(t[r]);}};(o.prototype = new Error()).constructor = o, t.exports = o;}, { "./xy": 11 }], 6: [function (e, t, r) {(function (t) {var n = t.poly2tri;r.noConflict = function () {return t.poly2tri = n, r;}, r.VERSION = e("../dist/version.json").version, r.PointError = e("./pointerror"), r.Point = e("./point"), r.Triangle = e("./triangle"), r.SweepContext = e("./sweepcontext");var o = e("./sweep");r.triangulate = o.triangulate, r.sweep = { Triangulate: o.triangulate };}).call(this, "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});}, { "../dist/version.json": 1, "./point": 4, "./pointerror": 5, "./sweep": 7, "./sweepcontext": 8, "./triangle": 9 }], 7: [function (e, t, r) {var n = e("./assert"),o = e("./pointerror"),i = e("./triangle"),s = e("./advancingfront").Node,a = e("./utils"),c = a.EPSILON,u = a.Orientation,l = a.orient2d,h = a.inScanArea,d = a.isAngleObtuse;function g(e, t) {var r = e.locateNode(t),o = function (e, t, r) {var n = new i(t, r.point, r.next.point);n.markNeighbor(r.triangle), e.addToMap(n);var o = new s(t);return o.next = r.next, o.prev = r, r.next.prev = o, r.next = o, y(e, n) || e.mapTriangleToNodes(n), o;}(e, t, r);return t.x <= r.point.x + c && _(e, r), function (e, t) {for (var r = t.next; r.next && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.next;}for (r = t.prev; r.prev && !d(r.point, r.next.point, r.prev.point);) {_(e, r), r = r.prev;}t.next && t.next.next && function (e) {var t = e.point.x - e.next.next.point.x,r = e.point.y - e.next.next.point.y;return n(r >= 0, "unordered y"), t >= 0 || Math.abs(t) < r;}(t) && function (e, t) {for (l(t.point, t.next.point, t.next.next.point) === u.CCW ? e.basin.left_node = t.next.next : e.basin.left_node = t.next, e.basin.bottom_node = e.basin.left_node; e.basin.bottom_node.next && e.basin.bottom_node.point.y >= e.basin.bottom_node.next.point.y;) {e.basin.bottom_node = e.basin.bottom_node.next;}if (e.basin.bottom_node !== e.basin.left_node) {for (e.basin.right_node = e.basin.bottom_node; e.basin.right_node.next && e.basin.right_node.point.y < e.basin.right_node.next.point.y;) {e.basin.right_node = e.basin.right_node.next;}e.basin.right_node !== e.basin.bottom_node && (e.basin.width = e.basin.right_node.point.x - e.basin.left_node.point.x, e.basin.left_highest = e.basin.left_node.point.y > e.basin.right_node.point.y, function e(t, r) {if (!function (e, t) {var r;return r = e.basin.left_highest ? e.basin.left_node.point.y - t.point.y : e.basin.right_node.point.y - t.point.y, e.basin.width > r;}(t, r) && (_(t, r), r.prev !== t.basin.left_node || r.next !== t.basin.right_node)) {if (r.prev === t.basin.left_node) {if (l(r.point, r.next.point, r.next.next.point) === u.CW) return;r = r.next;} else if (r.next === t.basin.right_node) {if (l(r.point, r.prev.point, r.prev.prev.point) === u.CCW) return;r = r.prev;} else r = r.prev.point.y < r.next.point.y ? r.prev : r.next;e(t, r);}}(e, e.basin.bottom_node));}}(e, t);}(e, o), o;}function p(e, t, r) {e.edge_event.constrained_edge = t, e.edge_event.right = t.p.x > t.q.x, v(r.triangle, t.p, t.q) || (function (e, t, r) {e.edge_event.right ? function (e, t, r) {for (; r.next.point.x < t.p.x;) {l(t.q, r.next.point, t.p) === u.CCW ? x(e, t, r) : r = r.next;}}(e, t, r) : function (e, t, r) {for (; r.prev.point.x > t.p.x;) {l(t.q, r.prev.point, t.p) === u.CW ? A(e, t, r) : r = r.prev;}}(e, t, r);}(e, t, r), f(e, t.p, t.q, r.triangle, t.q));}function f(e, t, r, n, i) {if (!v(n, t, r)) {var s = n.pointCCW(i),a = l(r, s, t);if (a === u.COLLINEAR) throw new o("poly2tri EdgeEvent: Collinear not supported!", [r, s, t]);var c = n.pointCW(i),h = l(r, c, t);if (h === u.COLLINEAR) throw new o("poly2tri EdgeEvent: Collinear not supported!", [r, c, t]);a === h ? f(e, t, r, n = a === u.CW ? n.neighborCCW(i) : n.neighborCW(i), i) : V(e, t, r, n, i);}}function v(e, t, r) {var n = e.edgeIndex(t, r);if (-1 !== n) {e.markConstrainedEdgeByIndex(n);var o = e.getNeighbor(n);return o && o.markConstrainedEdgeByPoints(t, r), !0;}return !1;}function _(e, t) {var r = new i(t.prev.point, t.point, t.next.point);r.markNeighbor(t.prev.triangle), r.markNeighbor(t.triangle), e.addToMap(r), t.prev.next = t.next, t.next.prev = t.prev, y(e, r) || e.mapTriangleToNodes(r);}function y(e, t) {for (var r = 0; r < 3; ++r) {if (!t.delaunay_edge[r]) {var n = t.getNeighbor(r);if (n) {var o = t.getPoint(r),i = n.oppositePoint(t, o),s = n.index(i);if (n.constrained_edge[s] || n.delaunay_edge[s]) {t.constrained_edge[r] = n.constrained_edge[s];continue;}if (m(o, t.pointCCW(o), t.pointCW(o), i)) {t.delaunay_edge[r] = !0, n.delaunay_edge[s] = !0, E(t, o, n, i);var a = !y(e, t);return a && e.mapTriangleToNodes(t), (a = !y(e, n)) && e.mapTriangleToNodes(n), t.delaunay_edge[r] = !1, n.delaunay_edge[s] = !1, !0;}}}}return !1;}function m(e, t, r, n) {var o = e.x - n.x,i = e.y - n.y,s = t.x - n.x,a = t.y - n.y,c = o * a - s * i;if (c <= 0) return !1;var u = r.x - n.x,l = r.y - n.y,h = u * i - o * l;return !(h <= 0) && (o * o + i * i) * (s * l - u * a) + (s * s + a * a) * h + (u * u + l * l) * c > 0;}function E(e, t, r, n) {var o, i, s, a, c, u, l, h, d, g, p, f;o = e.neighborCCW(t), i = e.neighborCW(t), s = r.neighborCCW(n), a = r.neighborCW(n), c = e.getConstrainedEdgeCCW(t), u = e.getConstrainedEdgeCW(t), l = r.getConstrainedEdgeCCW(n), h = r.getConstrainedEdgeCW(n), d = e.getDelaunayEdgeCCW(t), g = e.getDelaunayEdgeCW(t), p = r.getDelaunayEdgeCCW(n), f = r.getDelaunayEdgeCW(n), e.legalize(t, n), r.legalize(n, t), r.setDelaunayEdgeCCW(t, d), e.setDelaunayEdgeCW(t, g), e.setDelaunayEdgeCCW(n, p), r.setDelaunayEdgeCW(n, f), r.setConstrainedEdgeCCW(t, c), e.setConstrainedEdgeCW(t, u), e.setConstrainedEdgeCCW(n, l), r.setConstrainedEdgeCW(n, h), e.clearNeighbors(), r.clearNeighbors(), o && r.markNeighbor(o), i && e.markNeighbor(i), s && e.markNeighbor(s), a && r.markNeighbor(a), e.markNeighbor(r);}function x(e, t, r) {r.point.x < t.p.x && (l(r.point, r.next.point, r.next.next.point) === u.CCW ? R(e, t, r) : (function e(t, r, n) {l(n.next.point, n.next.next.point, n.next.next.next.point) === u.CCW ? R(t, r, n.next) : l(r.q, n.next.next.point, r.p) === u.CCW && e(t, r, n.next);}(e, t, r), x(e, t, r)));}function R(e, t, r) {_(e, r.next), r.next.point !== t.p && l(t.q, r.next.point, t.p) === u.CCW && l(r.point, r.next.point, r.next.next.point) === u.CCW && R(e, t, r);}function A(e, t, r) {r.point.x > t.p.x && (l(r.point, r.prev.point, r.prev.prev.point) === u.CW ? P(e, t, r) : (function e(t, r, n) {l(n.prev.point, n.prev.prev.point, n.prev.prev.prev.point) === u.CW ? P(t, r, n.prev) : l(r.q, n.prev.prev.point, r.p) === u.CW && e(t, r, n.prev);}(e, t, r), A(e, t, r)));}function P(e, t, r) {_(e, r.prev), r.prev.point !== t.p && l(t.q, r.prev.point, t.p) === u.CW && l(r.point, r.prev.point, r.prev.prev.point) === u.CW && P(e, t, r);}function V(e, t, r, i, s) {var a = i.neighborAcross(s);n(a, "FLIP failed due to missing triangle!");var c = a.oppositePoint(i, s);if (i.getConstrainedEdgeAcross(s)) {var d = i.index(s);throw new o("poly2tri Intersecting Constraints", [s, c, i.getPoint((d + 1) % 3), i.getPoint((d + 2) % 3)]);}h(s, i.pointCCW(s), i.pointCW(s), c) ? (E(i, s, a, c), e.mapTriangleToNodes(i), e.mapTriangleToNodes(a), s === r && c === t ? r === e.edge_event.constrained_edge.q && t === e.edge_event.constrained_edge.p && (i.markConstrainedEdgeByPoints(t, r), a.markConstrainedEdgeByPoints(t, r), y(e, i), y(e, a)) : V(e, t, r, i = function (e, t, r, n, o, i) {var s;return t === u.CCW ? (s = n.edgeIndex(o, i), n.delaunay_edge[s] = !0, y(e, n), n.clearDelaunayEdges(), r) : (s = r.edgeIndex(o, i), r.delaunay_edge[s] = !0, y(e, r), r.clearDelaunayEdges(), n);}(e, l(r, c, t), i, a, s, c), s)) : (function e(t, r, o, i, s, a) {var c = s.neighborAcross(a);n(c, "FLIP failed due to missing triangle");var u = c.oppositePoint(s, a);h(o, i.pointCCW(o), i.pointCW(o), u) ? V(t, o, u, c, u) : e(t, r, o, i, c, T(r, o, c, u));}(e, t, r, i, a, T(t, r, a, c)), f(e, t, r, i, s));}function T(e, t, r, n) {var i = l(t, n, e);if (i === u.CW) return r.pointCCW(n);if (i === u.CCW) return r.pointCW(n);throw new o("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!", [t, n, e]);}r.triangulate = function (e) {e.initTriangulation(), e.createAdvancingFront(), function (e) {var t,r = e.pointCount();for (t = 1; t < r; ++t) {for (var n = e.getPoint(t), o = g(e, n), i = n._p2t_edge_list, s = 0; i && s < i.length; ++s) {p(e, i[s], o);}}}(e), function (e) {for (var t = e.front().head().next.triangle, r = e.front().head().next.point; !t.getConstrainedEdgeCW(r);) {t = t.neighborCCW(r);}e.meshClean(t);}(e);};}, { "./advancingfront": 2, "./assert": 3, "./pointerror": 5, "./triangle": 9, "./utils": 10 }], 8: [function (e, t, r) {var n = e("./pointerror"),o = e("./point"),i = e("./triangle"),s = e("./sweep"),a = e("./advancingfront"),c = a.Node,u = function u(e, t) {if (this.p = e, this.q = t, e.y > t.y) this.q = e, this.p = t;else if (e.y === t.y) if (e.x > t.x) this.q = e, this.p = t;else if (e.x === t.x) throw new n("poly2tri Invalid Edge constructor: repeated points!", [e]);this.q._p2t_edge_list || (this.q._p2t_edge_list = []), this.q._p2t_edge_list.push(this);},l = function l() {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};l.prototype.clear = function () {this.left_node = null, this.bottom_node = null, this.right_node = null, this.width = 0, this.left_highest = !1;};var h = function h(e, t) {t = t || {}, this.triangles_ = [], this.map_ = [], this.points_ = t.cloneArrays ? e.slice(0) : e, this.edge_list = [], this.pmin_ = this.pmax_ = null, this.front_ = null, this.head_ = null, this.tail_ = null, this.af_head_ = null, this.af_middle_ = null, this.af_tail_ = null, this.basin = new l(), this.edge_event = new function () {this.constrained_edge = null, this.right = !1;}(), this.initEdges(this.points_);};h.prototype.addHole = function (e) {this.initEdges(e);var t,r = e.length;for (t = 0; t < r; t++) {this.points_.push(e[t]);}return this;}, h.prototype.AddHole = h.prototype.addHole, h.prototype.addHoles = function (e) {var t,r = e.length;for (t = 0; t < r; t++) {this.initEdges(e[t]);}return this.points_ = this.points_.concat.apply(this.points_, e), this;}, h.prototype.addPoint = function (e) {return this.points_.push(e), this;}, h.prototype.AddPoint = h.prototype.addPoint, h.prototype.addPoints = function (e) {return this.points_ = this.points_.concat(e), this;}, h.prototype.triangulate = function () {return s.triangulate(this), this;}, h.prototype.getBoundingBox = function () {return { min: this.pmin_, max: this.pmax_ };}, h.prototype.getTriangles = function () {return this.triangles_;}, h.prototype.GetTriangles = h.prototype.getTriangles, h.prototype.front = function () {return this.front_;}, h.prototype.pointCount = function () {return this.points_.length;}, h.prototype.head = function () {return this.head_;}, h.prototype.setHead = function (e) {this.head_ = e;}, h.prototype.tail = function () {return this.tail_;}, h.prototype.setTail = function (e) {this.tail_ = e;}, h.prototype.getMap = function () {return this.map_;}, h.prototype.initTriangulation = function () {var e,t = this.points_[0].x,r = this.points_[0].x,n = this.points_[0].y,i = this.points_[0].y,s = this.points_.length;for (e = 1; e < s; e++) {var a = this.points_[e];a.x > t && (t = a.x), a.x < r && (r = a.x), a.y > n && (n = a.y), a.y < i && (i = a.y);}this.pmin_ = new o(r, i), this.pmax_ = new o(t, n);var c = .3 * (t - r),u = .3 * (n - i);this.head_ = new o(t + c, i - u), this.tail_ = new o(r - c, i - u), this.points_.sort(o.compare);}, h.prototype.initEdges = function (e, t) {var r,n = e.length,o = t ? e.length - 1 : e.length;for (r = 0; r < o; ++r) {this.edge_list.push(new u(e[r], e[(r + 1) % n]));}}, h.prototype.getPoint = function (e) {return this.points_[e];}, h.prototype.addToMap = function (e) {this.map_.push(e);}, h.prototype.locateNode = function (e) {return this.front_.locateNode(e.x);}, h.prototype.createAdvancingFront = function () {var e,t,r,n = new i(this.points_[0], this.tail_, this.head_);this.map_.push(n), e = new c(n.getPoint(1), n), t = new c(n.getPoint(0), n), r = new c(n.getPoint(2)), this.front_ = new a(e, r), e.next = t, t.next = r, t.prev = e, r.prev = t;}, h.prototype.removeNode = function (e) {}, h.prototype.mapTriangleToNodes = function (e) {for (var t = 0; t < 3; ++t) {if (!e.getNeighbor(t)) {var r = this.front_.locatePoint(e.pointCW(e.getPoint(t)));r && (r.triangle = e);}}}, h.prototype.removeFromMap = function (e) {var t,r = this.map_,n = r.length;for (t = 0; t < n; t++) {if (r[t] === e) {r.splice(t, 1);break;}}}, h.prototype.meshClean = function (e) {for (var t, r, n = [e]; t = n.pop();) {if (!t.isInterior()) for (t.setInterior(!0), this.triangles_.push(t), r = 0; r < 3; r++) {t.constrained_edge[r] || n.push(t.getNeighbor(r));}}}, t.exports = h;}, { "./advancingfront": 2, "./point": 4, "./pointerror": 5, "./sweep": 7, "./triangle": 9 }], 9: [function (e, t, r) {var n = function n(e, t, r) {this.points_ = [e, t, r], this.neighbors_ = [null, null, null], this.interior_ = !1, this.constrained_edge = [!1, !1, !1], this.delaunay_edge = [!1, !1, !1];},o = e("./xy").toString;n.prototype.toString = function () {return "[" + o(this.points_[0]) + o(this.points_[1]) + o(this.points_[2]) + "]";}, n.prototype.getPoint = function (e) {return this.points_[e];}, n.prototype.GetPoint = n.prototype.getPoint, n.prototype.getPoints = function () {return this.points_;}, n.prototype.getNeighbor = function (e) {return this.neighbors_[e];}, n.prototype.containsPoint = function (e) {var t = this.points_;return e === t[0] || e === t[1] || e === t[2];}, n.prototype.containsEdge = function (e) {return this.containsPoint(e.p) && this.containsPoint(e.q);}, n.prototype.containsPoints = function (e, t) {return this.containsPoint(e) && this.containsPoint(t);}, n.prototype.isInterior = function () {return this.interior_;}, n.prototype.setInterior = function (e) {return this.interior_ = e, this;}, n.prototype.markNeighborPointers = function (e, t, r) {var n = this.points_;if (e === n[2] && t === n[1] || e === n[1] && t === n[2]) this.neighbors_[0] = r;else if (e === n[0] && t === n[2] || e === n[2] && t === n[0]) this.neighbors_[1] = r;else {if (!(e === n[0] && t === n[1] || e === n[1] && t === n[0])) throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2] = r;}}, n.prototype.markNeighbor = function (e) {var t = this.points_;e.containsPoints(t[1], t[2]) ? (this.neighbors_[0] = e, e.markNeighborPointers(t[1], t[2], this)) : e.containsPoints(t[0], t[2]) ? (this.neighbors_[1] = e, e.markNeighborPointers(t[0], t[2], this)) : e.containsPoints(t[0], t[1]) && (this.neighbors_[2] = e, e.markNeighborPointers(t[0], t[1], this));}, n.prototype.clearNeighbors = function () {this.neighbors_[0] = null, this.neighbors_[1] = null, this.neighbors_[2] = null;}, n.prototype.clearDelaunayEdges = function () {this.delaunay_edge[0] = !1, this.delaunay_edge[1] = !1, this.delaunay_edge[2] = !1;}, n.prototype.pointCW = function (e) {var t = this.points_;return e === t[0] ? t[2] : e === t[1] ? t[0] : e === t[2] ? t[1] : null;}, n.prototype.pointCCW = function (e) {var t = this.points_;return e === t[0] ? t[1] : e === t[1] ? t[2] : e === t[2] ? t[0] : null;}, n.prototype.neighborCW = function (e) {return e === this.points_[0] ? this.neighbors_[1] : e === this.points_[1] ? this.neighbors_[2] : this.neighbors_[0];}, n.prototype.neighborCCW = function (e) {return e === this.points_[0] ? this.neighbors_[2] : e === this.points_[1] ? this.neighbors_[0] : this.neighbors_[1];}, n.prototype.getConstrainedEdgeCW = function (e) {return e === this.points_[0] ? this.constrained_edge[1] : e === this.points_[1] ? this.constrained_edge[2] : this.constrained_edge[0];}, n.prototype.getConstrainedEdgeCCW = function (e) {return e === this.points_[0] ? this.constrained_edge[2] : e === this.points_[1] ? this.constrained_edge[0] : this.constrained_edge[1];}, n.prototype.getConstrainedEdgeAcross = function (e) {return e === this.points_[0] ? this.constrained_edge[0] : e === this.points_[1] ? this.constrained_edge[1] : this.constrained_edge[2];}, n.prototype.setConstrainedEdgeCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[1] = t : e === this.points_[1] ? this.constrained_edge[2] = t : this.constrained_edge[0] = t;}, n.prototype.setConstrainedEdgeCCW = function (e, t) {e === this.points_[0] ? this.constrained_edge[2] = t : e === this.points_[1] ? this.constrained_edge[0] = t : this.constrained_edge[1] = t;}, n.prototype.getDelaunayEdgeCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[1] : e === this.points_[1] ? this.delaunay_edge[2] : this.delaunay_edge[0];}, n.prototype.getDelaunayEdgeCCW = function (e) {return e === this.points_[0] ? this.delaunay_edge[2] : e === this.points_[1] ? this.delaunay_edge[0] : this.delaunay_edge[1];}, n.prototype.setDelaunayEdgeCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[1] = t : e === this.points_[1] ? this.delaunay_edge[2] = t : this.delaunay_edge[0] = t;}, n.prototype.setDelaunayEdgeCCW = function (e, t) {e === this.points_[0] ? this.delaunay_edge[2] = t : e === this.points_[1] ? this.delaunay_edge[0] = t : this.delaunay_edge[1] = t;}, n.prototype.neighborAcross = function (e) {return e === this.points_[0] ? this.neighbors_[0] : e === this.points_[1] ? this.neighbors_[1] : this.neighbors_[2];}, n.prototype.oppositePoint = function (e, t) {var r = e.pointCW(t);return this.pointCW(r);}, n.prototype.legalize = function (e, t) {var r = this.points_;if (e === r[0]) r[1] = r[0], r[0] = r[2], r[2] = t;else if (e === r[1]) r[2] = r[1], r[1] = r[0], r[0] = t;else {if (e !== r[2]) throw new Error("poly2tri Invalid Triangle.legalize() call");r[0] = r[2], r[2] = r[1], r[1] = t;}}, n.prototype.index = function (e) {var t = this.points_;if (e === t[0]) return 0;if (e === t[1]) return 1;if (e === t[2]) return 2;throw new Error("poly2tri Invalid Triangle.index() call");}, n.prototype.edgeIndex = function (e, t) {var r = this.points_;if (e === r[0]) {if (t === r[1]) return 2;if (t === r[2]) return 1;} else if (e === r[1]) {if (t === r[2]) return 0;if (t === r[0]) return 2;} else if (e === r[2]) {if (t === r[0]) return 1;if (t === r[1]) return 0;}return -1;}, n.prototype.markConstrainedEdgeByIndex = function (e) {this.constrained_edge[e] = !0;}, n.prototype.markConstrainedEdgeByEdge = function (e) {this.markConstrainedEdgeByPoints(e.p, e.q);}, n.prototype.markConstrainedEdgeByPoints = function (e, t) {var r = this.points_;t === r[0] && e === r[1] || t === r[1] && e === r[0] ? this.constrained_edge[2] = !0 : t === r[0] && e === r[2] || t === r[2] && e === r[0] ? this.constrained_edge[1] = !0 : (t === r[1] && e === r[2] || t === r[2] && e === r[1]) && (this.constrained_edge[0] = !0);}, t.exports = n;}, { "./xy": 11 }], 10: [function (e, t, r) {var n = 1e-16;r.EPSILON = n;var o = { CW: 1, CCW: -1, COLLINEAR: 0 };r.Orientation = o, r.orient2d = function (e, t, r) {var i = (e.x - r.x) * (t.y - r.y) - (e.y - r.y) * (t.x - r.x);return i > -n && i < n ? o.COLLINEAR : i > 0 ? o.CCW : o.CW;}, r.inScanArea = function (e, t, r, o) {return !((e.x - t.x) * (o.y - t.y) - (o.x - t.x) * (e.y - t.y) >= -n || (e.x - r.x) * (o.y - r.y) - (o.x - r.x) * (e.y - r.y) <= n);}, r.isAngleObtuse = function (e, t, r) {var n = t.x - e.x,o = t.y - e.y;return n * (r.x - e.x) + o * (r.y - e.y) < 0;};}, {}], 11: [function (e, t, r) {function n(e) {return "(" + e.x + ";" + e.y + ")";}t.exports = { toString: function toString(e) {var t = e.toString();return "[object Object]" === t ? n(e) : t;}, toStringBase: n, compare: function compare(e, t) {return e.y === t.y ? e.x - t.x : e.y - t.y;}, equals: function equals(e, t) {return e.x === t.x && e.y === t.y;} };}, {}] }, {}, [6])(6);});var a = s.exports;t.poly2tri = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.CCI = void 0;var n = r(1),o = r(111),i = r(77),s = function s(e, t, r, n, i) {this._cu1 = e, this._range1 = t, this._cu2 = r, this._range2 = n, this._epsilon = i, this._tree = new o.SubCurveTree(e, t, r, n, i);};s.prototype.intersect = function () {var e = [];this._tree.build();for (var t = 0; t < this._tree._overlaps.length; ++t) {var r = this._tree._overlaps[t][0],n = this._tree._overlaps[t][1];e = e.concat(this._solve(r._range, n._range));}return this._merge(e), e;}, s.prototype._distanceSquared = function (e, t) {var r = this._cu1.evaluatePosition(e),o = this._cu2.evaluatePosition(t);return n.Vector3.squaredDistance(r, o);}, s.prototype._solve = function (e, t) {var r = [],n = [.5 * (e[0] + e[1]), .5 * (t[0] + t[1])],o = this._relaxNR(n, [e, t]),s = o === i.RelaxResult.Success;if (o === i.RelaxResult.OutOfRange) {var a = n[0] < e[0] + 1e-12 || n[0] > e[1] - 1e-12,c = n[1] < t[0] + 1e-12 || n[1] > t[1] - 1e-12;(a || c) && this._distanceSquared(n[0], n[1]) < this._epsilon * this._epsilon && (s = !0);}return s && r.push(new function (e, t) {this.cutInfo = e, this.cutByInfo = t;}({ param: n[0], atVertex: void 0 }, { param: n[1], atVertex: void 0 })), r;}, s.prototype._relaxNR = function (e, t) {var r = this,o = (0, i.newtonRaphson2D)(function (e) {var t = r._cu1.evaluatePosition(e[0]),o = r._cu2.evaluatePosition(e[1]),i = [t[0] - o[0], t[1] - o[1]],s = r._cu1.evaluateDt(e[0]),a = r._cu2.evaluateDt(e[1]);return n.Vector3.negate(a, a), { val: i, deriv1: s, deriv2: a };}, e, t);return e[0] = o.param[0], e[1] = o.param[1], o.status;}, s.prototype._merge = function (e) {e.sort(function (e, t) {return e.cutInfo.param - t.cutInfo.param;});for (var t = 0; t < e.length; t++) {if (e[t]) for (var r = e[t].cutInfo.param, n = e[t].cutByInfo.param, o = t + 1; o < e.length; o++) {if (e[o]) {var i = e[o].cutInfo.param,s = e[o].cutByInfo.param;if (i > r + 1e-11) break;if (Math.abs(s - n) <= 1e-11) {e[t] = void 0;break;}}}}for (t = 0; t < e.length; t++) {e[t] || (e.splice(t, 1), t--);}}, t.CCI = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SubCurveTree = void 0;var n = 100 * r(0).KERNEL_TOLERANCE,o = Math.PI / 180 * 10,i = function i(e, t, r) {void 0 === r && (r = 0), this._cu = e, this._range = t, this._bx = e.getBoundingBox(t).clone(), this._simple = void 0, this._split_param = void 0, this._children = [], this._depth = r;};i.prototype.isSimple = function () {if (void 0 === this._simple) {this._simple = !1;var e = [this._range[0] + 1e-8, this._range[1] - 1e-8];if (this._split_param = this._cu.suggestSplittingParam(e), void 0 === this._split_param) {this._split_param = .5 * (this._range[0] + this._range[1]);var t = this._cu.getTangentCone(this._range);(t.isDegenerate() || t.angle < o) && (this._simple = !0);}}return this._simple;}, i.prototype.canDivide = function () {return !(this._depth >= 10 || this._range[1] - this._range[0] < 2e-8 || Math.max(this._bx.getWidth(0), this._bx.getWidth(1), this._bx.getWidth(2)) < n);}, i.prototype.divide = function () {if (0 === this._children.length) {var e = [this._range[0], this._split_param],t = [this._split_param, this._range[1]];this._children = [new i(this._cu, e, this._depth + 1), new i(this._cu, t, this._depth + 1)];}}, i.prototype.fullSubdivision = function () {if (!this.isSimple() && this.canDivide()) {this.divide();for (var e = 0; e < this._children.length; ++e) {this._children[e].fullSubdivision();}}}, i.prototype.toString = function () {if (this._children.length > 0) {for (var e = "", t = 0; t < this._children.length; ++t) {e += this._children[t];}return e;}return "t=[" + this._range[0] + " " + this._range[1] + "] " + this._bx + "\n";};var s = function s(e, t, r, n, o) {this._cu1_root_node = new i(e, t), this._cu2_root_node = new i(r, n), this._epsilon = o, this._overlaps = [];};s.prototype.process = function (e, t) {if (e._bx.intersectsWithTolerance(t._bx, this._epsilon)) {var r = e.canDivide(),n = t.canDivide(),o = e.isSimple() || !r,i = t.isSimple() || !n;if (o && i) this._overlaps.push([e, t]);else if (r && n) {e.divide(), t.divide();for (var s = 0; s < e._children.length; ++s) {for (var a = 0; a < t._children.length; ++a) {this.process(e._children[s], t._children[a]);}}} else if (r) for (e.divide(), s = 0; s < e._children.length; ++s) {this.process(e._children[s], t);} else if (n) for (t.divide(), s = 0; s < t._children.length; ++s) {this.process(e, t._children[s]);}}}, s.prototype.build = function () {this.process(this._cu1_root_node, this._cu2_root_node);}, t.SubCurveTree = s;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.RegionTopologyFace = t.RegionTopologyEdge = t.RegionTopologyVertex = void 0;var n = r(1),o = r(16),i = r(20),s = r(15),a = r(0),c = r(2),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e) {o.Vertex.call(this, e), this._associatedVertices = [];};(l.prototype = Object.create(o.Vertex.prototype)).setAssociatedEntities = function (e) {this._associatedVertices = u.default.clone(e);}, l.prototype.getAssociatedEntities = function () {return this._associatedVertices;};var h = function h(e) {i.Edge.call(this, e), this._sourceEdge = void 0, this._associatedEdges = [], this._isDangling = !1;};(h.prototype = Object.create(i.Edge.prototype)).setAssociatedEdges = function (e) {this._associatedEdges = e;}, h.prototype.getAssociatedEntities = function () {return u.default.map(this._associatedEdges, function (e) {return e.edge;});}, h.prototype.getAssociatedEdgeInfo = function () {return this._associatedEdges;}, h.prototype.setToEdgeSegment = function (e, t) {this._sourceEdge = e, this._curve = e.getCurve(), this._reversed = e.isReversed(), this.setRange(t);}, h.prototype.setIsDangling = function (e) {this._isDangling = e;}, h.prototype.isDangling = function () {return this._isDangling;}, h.prototype.getSourceEdge = function () {return this._sourceEdge;};var d = function d(e) {s.Face.call(this, e), this._danglingEdges = [];};(d.prototype = Object.create(s.Face.prototype)).addDanglingEdge = function (e) {this._danglingEdges.push(e);}, d.prototype.isPointInsideFace = function (e) {for (var t = 0, r = 0; r < this.getLoops().length; ++r) {for (var n = this.getLoops()[r], o = 0; o < n.getCoedges().length; ++o) {var i = n.getCoedges()[o];i.getEdge().isDangling() || (t += i.uvAngleSubtended(e));}}t = Math.abs(t);var s = Math.floor(t / (2 * Math.PI)),c = t - 2 * s * Math.PI;return !!(Math.abs(c) < a.PARAMETER_SPACE_TOLERANCE && s || Math.abs(c - 2 * Math.PI) < a.PARAMETER_SPACE_TOLERANCE);}, d.prototype.getRepresentativePoint = function () {var e,t,r = n.Vector3.createFloat64(),o = this.getBoundingBox(),i = (o.max[0] - o.min[0]) / 33,s = (o.max[1] - o.min[1]) / 33;for (e = 1; e < 32; ++e) {for (t = 1; t < 32; ++t) {if (r[0] = o.min[0] + i * e, r[1] = o.min[1] + s * t, this.isPointInsideFace(r)) return r;}}return c.ConsoleUtils.assert(!1), o.getCenter();}, d.prototype.getDanglingEdges = function () {return this._danglingEdges;}, t.RegionTopologyVertex = l, t.RegionTopologyEdge = h, t.RegionTopologyFace = d;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.matchRegionEdgeRecipe = t.deserializeRegionEdgeRecipe = t.serializeRegionEdgeRecipe = t.createRecipeFromRegionEdge = t.matchRegionFaceRecipe = t.deserializeRegionFaceRecipe = t.serializeRegionFaceRecipe = t.createRecipeFromRegionFace = void 0;var n = r(1),o = r(3),i = r(0),s = r(114),a = r(2),c = r(8),u = function (e) {return e && e.__esModule ? e : { default: e };}(r(42)),l = function l(e, t) {var r = u.default.filter(t.regionVertices, function (t) {return u.default.contains(t.getAssociatedEntities(), e.getStartVertex());});a.ConsoleUtils.assert(1 === r.length), r = r[0];var n = [],o = [],i = new Set(),s = r,c = void 0;if (s) do {n.push(s);var l = u.default.filter(s.getEdges(), function (t) {return t !== c && u.default.contains(t.getAssociatedEntities(), e) && !i.has(t);});if (0 === l.length) {a.ConsoleUtils.assert(!e.isClosed()), a.ConsoleUtils.assert(u.default.contains(s.getAssociatedEntities(), e.getEndVertex()));break;}var h = void 0;if (l.length > 1) {l.sort(function (e, t) {return e.t0() - t.t0();});for (var d = 0; d < l.length; d++) {if (l[d].getStartVertex() === s) {h = l[d];break;}}a.ConsoleUtils.assert(h);} else h = l[0];s = h.getOtherVertex(s), a.ConsoleUtils.assert(s), c = h, i.add(c), o.push(c);} while (s !== r);return { edges: o, vertices: n };},h = function h(e, t, r) {var o = [],s = u.default.filter(t, function (t) {return t !== e;});if (0 === s.length) ;else for (var a = r.vertices, c = 0; c < a.length; c++) {for (var l = a[c], h = !1, d = l.getEdges(), g = 0; g < d.length; g++) {if (u.default.intersection(s, d[g].getAssociatedEntities()).length > 0) {h = !0;break;}}h && o.push({ vertex: l, indexInTopology: c });}if (e.isClosed() && 2 === o.length && 1 === s.length) {var p = !1;if (s[0].getCurveType() === i.GEOMETRY_TYPES.LINE) {var f = s[0],v = f.closestToPointParam(o[0].vertex.getPosition());p = f.closestToPointParam(o[1].vertex.getPosition()) < v;} else if (e.getCurveType() === i.GEOMETRY_TYPES.CIRCLE && s[0].getCurveType() === i.GEOMETRY_TYPES.CIRCLE) {var _ = e.getCurve().getCenter(),y = n.Vector3.sub([0, 0, 0], s[0].getCurve().getCenter(), _);if (n.Vector3.length(y) > 0) {n.Vector3.normalize(y, y);var m = n.Vector3.sub([0, 0, 0], o[0].vertex.getPosition(), _),E = n.Vector3.sub([0, 0, 0], o[1].vertex.getPosition(), _),x = m.x * y.y - m.y * y.x,R = E.x * y.y - E.y * y.x;x > 0 && R < 0 && (p = !0);}}if (p) {var A = o[1];o[1] = o[0], o[0] = A;}}return o;},d = function d(e, t, r, n, o) {var i,a = {};a[e.getGuid()] = { dist: 0, prev: null, prevEdge: null, vertex: e, guid: e.getGuid() };var c = new s.BinaryHeap(function (e) {return e.dist;}, function (e) {return e.guid;});for (c.push(a[e.getGuid()]); 0 !== c.size();) {var l = c.pop();if (l === t) break;i = l.vertex.getEdges();for (var h = 0; h < i.length; h++) {var d = i[h].getOtherVertex(l.vertex);if (d && !n[i[h].getGuid()] && (!r[d.getGuid()] || d === t)) {for (var g = i[h].getEndVertex() === d, p = !1, f = i[h].getAssociatedEntities(), v = 0; v < o.length; v++) {if (u.default.contains(f, o[v].edge) && o[v].orientation === g) {p = !0;break;}}var _ = a[l.guid].dist;p || (_ += 1), void 0 === a[d.getGuid()] ? (a[d.getGuid()] = { dist: _, prev: l, prevEdge: i[h], vertex: d, guid: d.getGuid() }, c.push(a[d.getGuid()])) : a[d.getGuid()].dist > _ && (a[d.getGuid()].dist = _, a[d.getGuid()].prev = l, a[d.getGuid()].prevEdge = i[h], c.updated(a[d.getGuid()]));}}}var y = a[t.getGuid()];if (y) {i = [];for (var m = [], E = y, x = t; E.prevEdge;) {var R = E.prevEdge;i.push(R), E = E.prev, m.push(R.getEndVertex() === x), x = R.getOtherVertex(x);}return { dist: y.dist, edges: i.reverse(), orientations: m.reverse(), startVertex: e, endVertex: t };}return { dist: 1 / 0, edges: [] };},g = function g(e, t, r, n, i, s, a) {for (var c = e[i], l = {}, h = 0; h < c.length; h++) {null !== c[h].endVertex && (l[c[h].endVertex.getGuid()] ? l[c[h].endVertex.getGuid()].incomingEdges.push({ edge: c[h].edge, orientation: c[h].edgeOriented }) : l[c[h].endVertex.getGuid()] = { edgeIndex: h, edgeInfo: c[h], vertex: c[h].endVertex, incomingEdges: [{ edge: c[h].edge, orientation: c[h].edgeOriented }] });}if (u.default.values(l).length > 0) {var g = s.vertices,p = s.edges,f = u.default.keys(l),v = { dist: 1 / 0 },_ = n;do {_ = (0, o.modulus)(_ - 1, e.length);for (var y = u.default.keys(a[_]), m = 0; m < y.length; m++) {var E = a[_][y[m]].vertex;if (E) for (var x = 0; x < f.length; x++) {var R = l[f[x]].vertex,A = a[_][y[m]].outgoingEdges.concat(l[f[x]].incomingEdges),P = d(E, R, g, p, A);P.dist < v.dist && ((v = P).startIndex = _);}}} while (_ !== t && v.dist === 1 / 0);if (v.dist < 1 / 0) {var V = a[v.startIndex][v.startVertex.getGuid()],T = a[i][v.endVertex.getGuid()],C = V.cost + v.dist;(!T || C < T.cost || i === t && v.endVertex.getGuid() === r.getGuid() && null === T.previousGuid) && (a[i][v.endVertex.getGuid()] = { previousGuid: v.startVertex.getGuid(), edgeSegment: null, indexRange: [], cost: V.cost + v.dist, vertex: v.endVertex, previousIndex: v.startIndex, connectionEdges: v.edges, connectionOrientation: v.orientations, outgoingEdges: [] });}}},p = function p(e, t, r, n, i) {var s = [],a = e[t][r].endVertex;s[t] = {}, s[t][a.getGuid()] = { previousGuid: null, edgeSegment: null, previousIndex: null, cost: 0, vertex: a, outgoingEdges: [] };var c = t;do {var l = (0, o.modulus)(c + 1, e.length),h = e[l];s[l] = s[l] || {};for (var d = u.default.keys(s[c]), p = 0, f = 0; f < d.length; f++) {for (var v = d[f], _ = 0; _ < h.length; _++) {if (h[_].startVertices[v]) {s[c][v].outgoingEdges.push({ edge: h[_].edge, orientation: h[_].edgeOriented });var y = h[_].endVertex;if (null !== y) {var m = s[c][v].cost;h[_].edge.isClosed() || h[_].endVertexTopologyIndex > h[_].startVertices[v].vertexIndex !== h[_].edgeOriented && (m += 1), (!s[l][y.getGuid()] || s[l][y.getGuid()].cost > m || l === t && y.getGuid() === a.getGuid() && null === s[l][y.getGuid()].previousGuid) && (s[l][y.getGuid()] = { previousGuid: v, edgeSegment: h[_], indexRange: [h[_].startVertices[v].vertexIndex, h[_].endVertexTopologyIndex], cost: m, vertex: y, previousIndex: c, outgoingEdges: [] }, p++);} else m = s[c][v].cost, (!s[l][v] || s[l][v].cost > m) && (s[l][v] = { previousGuid: v, edgeSegment: h[_], indexRange: [], cost: m, previousIndex: c, outgoingEdges: [] });}}}0 === p && g(e, t, a, c, l, n, s), c = l;} while (c !== t);null !== s[t][a.getGuid()].previousGuid && s[t][a.getGuid()].cost < i.cost && (i.cost = s[t][a.getGuid()].cost, i.state = s, i.startGuid = a.getGuid());},f = function f(e, t) {for (var r = function (e, t) {var r = {},n = {},i = {},s = t;do {var a = (0, o.modulus)(s + 1, e.length),c = e[s],u = e[a],l = i;i = {};for (var h = 0; h < u.length; h++) {var d = u[h].topologyAlongEdge.vertices,g = u[h].topologyAlongEdge.edges;u[h].startVertices = {};var p = void 0,f = void 0,v = c.length;void 0 !== l[u[h].edge.getGuid()] && v++;for (var _ = 0; _ < v; _++) {var y = void 0;if (_ === c.length) y = l[u[h].edge.getGuid()];else {if (!c[_].endVertex) continue;y = c[_].endVertex.getGuid();}for (var m = void 0, E = 0; E < d.length; E++) {if (d[E].getGuid() === y) {m = E;break;}}void 0 !== m && (u[h].startVertices[y] = { vertex: d[m], vertexIndex: m }, null !== u[h].endVertex && (u[h].edgeOriented ? (p = void 0 !== p ? Math.min(p, m) : m, f = void 0 !== f ? Math.max(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex) : (p = void 0 !== p ? Math.max(p, m) : m, f = void 0 !== f ? Math.min(f, u[h].endVertexTopologyIndex) : u[h].endVertexTopologyIndex)), void 0 === i[u[h].edge.getGuid()] && (i[u[h].edge.getGuid()] = y));}if (void 0 !== p && void 0 !== f) {if (p !== f) {var x;x = u[h].edge.isClosed() ? u[h].edgeOriented ? 1 : -1 : p < f ? 1 : -1;var R = p;do {if (r[d[R].getGuid()] = d[R], x > 0) R !== f && (n[g[R].getGuid()] = g[R]);else {var A = (0, o.modulus)(R - 1, g.length);n[g[A].getGuid()] = g[A];}R = (0, o.modulus)(R + x, d.length);} while (R !== f);}r[d[f].getGuid()] = d[f];}}s = a;} while (s !== t);return { vertices: r, edges: n };}(e, t), n = { cost: 1 / 0, state: void 0, startGuid: void 0 }, i = 0; i < e[t].length; i++) {null !== e[t][i].endVertex && p(e, t, i, r, n);}if (n.cost === 1 / 0) return { edges: void 0, edgeOrientedFlags: void 0, score: 1 / 0 };var s = function (e, t) {var r = [],n = e.startGuid,i = t;do {r.push(e.state[i][n]);var s = e.state[i][n].previousIndex;n = e.state[i][n].previousGuid, i = s;} while (i !== t);r = r.reverse();var a = [],c = [];for (i = 0; i < r.length; i++) {if (0 !== r[i].indexRange.length) {var u,l,h,d,g = r[i].edgeSegment.topologyAlongEdge;r[i].indexRange[0] < r[i].indexRange[1] ? (u = r[i].indexRange[0], l = r[i].indexRange[1], r[i].edgeSegment.edge.isClosed() && !r[i].edgeSegment.edgeOriented ? (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1) : (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0)) : r[i].edgeSegment.edge.isClosed() && r[i].edgeSegment.edgeOriented ? (h = 1, u = (0, o.modulus)(r[i].indexRange[0], g.edges.length), l = (0, o.modulus)(r[i].indexRange[1], g.edges.length), d = !0) : (h = -1, u = (0, o.modulus)(r[i].indexRange[0] - 1, g.edges.length), l = (0, o.modulus)(r[i].indexRange[1] - 1, g.edges.length), d = !1);var p = u;do {a.push(g.edges[p]), c.push(d), p = (0, o.modulus)(p + h, g.edges.length);} while (p !== l);} else if (r[i].connectionEdges) for (p = 0; p < r[i].connectionEdges.length; p++) {a.push(r[i].connectionEdges[p]), c.push(r[i].connectionOrientation[p]);}}return { topologyEdges: a, edgeOrientedFlags: c };}(n, t);return { edges: s.topologyEdges, edgeOrientedFlags: s.edgeOrientedFlags, score: n.cost };},v = function v(e, t) {var r,n = function (e, t) {for (var r = [], n = 0; n < e.length; n++) {for (var o = e[n], i = [], s = 0; s < o.length; s++) {var a = o[s],c = t.sketchEdges[a.edgeRef];c && i.push({ edgeRef: a.edgeRef, edgeOriented: a.edgeOriented, intersectionNumber: a.intersectionNumber, totalIntersections: a.totalIntersections, edge: c, topologyAlongEdge: l(c, t), endVertex: null, endVertexTopologyIndex: null });}r.push(i);}return r;}(e, t);if (c.DebugUtils.level("region_match") >= 2) {var o = u.default.pluck(u.default.flatten(n), "edge");for (r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}c.DebugUtils.render();}if (function (e) {for (var t = 0; t < e.length; t++) {for (var r = u.default.pluck(e[(t + 1) % e.length], "edge"), n = 0; n < e[t].length; n++) {var o = e[t][n],i = h(o.edge, r, o.topologyAlongEdge);if (0 === o.totalIntersections) o.endVertex = null;else if (i.length === o.totalIntersections) {var s = i[o.intersectionNumber];o.endVertexTopologyIndex = s.indexInTopology, o.endVertex = s.vertex;} else 0 === i.length || c.DebugUtils.warn("Region matching problem! Intersection counts do not match"), o.endVertex = null;}}}(n), c.DebugUtils.level("region_match") >= 2) {var i = u.default.pluck(u.default.flatten(n), "endVertex");for (r = 0; r < i.length; r++) {null !== i[r] && c.DebugUtils.drawVertex3D(i[r], { color: 65280, render: !1 });}c.DebugUtils.render();}var s = function (e) {for (var t = 1 / 0, r = void 0, n = 0; n < e.length; n++) {var o = e[n];if (0 !== o.length) {for (var i = 0, s = 0; s < o.length; s++) {null !== o[s].endVertex && i++;}var a = o.length - i;if (0 === a) return n;i > 0 && a < t && (t = a, r = n);}}return r;}(n);if (void 0 === s) {for (var a = 0; a < n[0].length; a++) {var d = n[0][a].edge;if (d.isClosed() && u.default.all(n, function (e) {for (var t = 0; t < e.length; t++) {if (e[t].edge === d) return !0;}return !1;})) {var g = n[0][a].topologyAlongEdge.edges,p = new Array(g.length);for (r = 0; r < p.length; r++) {p[r] = n[0][a].edgeOriented;}return n[0][a].edgeOriented || g.reverse(), c.DebugUtils.level("region_match") >= 2 && c.DebugUtils.drawEdge3D(d, { color: 16711680 }), { edges: g, edgeOrientedFlags: p, matchStatus: 2 };}}return { edges: void 0, edgeOrientedFlags: void 0, matchStatus: 0 };}var v,_ = f(n, s);if (c.DebugUtils.level("region_match") >= 2 && void 0 !== _.edges) {for (r = 0; r < _.edges.length; r++) {c.DebugUtils.drawEdge3D(_.edges[r], { color: 16711680, render: !1 });}c.DebugUtils.render();}return v = 0 === _.score ? 2 : _.score === 1 / 0 ? 0 : 1, { edges: _.edges, edgeOrientedFlags: _.edgeOrientedFlags, matchStatus: v };},_ = function _(e, t) {if (!e || !e.edges) return new Set();for (var r = new Set(), n = 0; n < e.edges.length; n++) {var o = e.edgeOrientedFlags[n] === t,i = e.edges[n].getCoedges();a.ConsoleUtils.assert(i.length >= 1 && i.length <= 2);for (var s = void 0, c = 0; c < i.length; c++) {if (i[c].isReversed() === o) {s = i[c].getFace();break;}}s && !r.has(s) && r.add(s);}var u = new Set(e.edges);return r.forEach(function (e) {for (var t = Array.from(e.collectEdges()), n = 0; n < t.length; n++) {var o = t[n];if (!u.has(o)) {var i = void 0,s = o.getFaces();a.ConsoleUtils.assert(s.length >= 1 && s.length <= 2), 1 === s.length ? a.ConsoleUtils.assert(s[0] === e) : 2 === s.length && (a.ConsoleUtils.assert(s[0] === e || s[1] === e), i = s[0] === e ? s[1] : s[0]), i && !r.has(i) && r.add(i);}}}), r;};t.createRecipeFromRegionFace = function (e, t) {for (var r = [], n = e.getLoops(), o = 0; o < n.length; o++) {for (var i = n[o].getCoedges(), s = [], a = 0; a < i.length; a++) {for (var c = i[a], d = c.getEdge().getAssociatedEdgeInfo(), g = c.getEndVertex(), p = i[(a + 1) % i.length].getEdge().getAssociatedEdgeInfo(), f = u.default.pluck(p, "edge"), v = [], _ = 0; _ < d.length; _++) {for (var y = l(d[_].edge, t), m = h(d[_].edge, f, y), E = 0, x = 0; x < m.length; x++) {if (m[x].vertex === g) {E = x;break;}}var R = { edgeRef: d[_].edge.getGuid(), edgeOriented: !(c.isReversed() ^ d[_].flipped), intersectionNumber: E, totalIntersections: m.length, edge: d[_].edge };v.push(R);}s.push(v);}r.push(s);}return r;}, t.serializeRegionFaceRecipe = function (e) {for (var t = [], r = 0; r < e.length; r++) {for (var n = [], o = e[r], i = 0; i < o.length; i++) {for (var s = [], a = o[i], c = 0; c < a.length; c++) {var u = a[c];s.push(u.edgeRef + "_" + (u.edgeOriented ? "t" : "f") + "_" + u.intersectionNumber + "_" + u.totalIntersections);}n.push(s.join(";"));}t.push(n.join("+"));}return t.join("/");}, t.deserializeRegionFaceRecipe = function (e) {for (var t = e.split("/"), r = 0; r < t.length; r++) {t[r] = t[r].split("+");for (var n = t[r], o = 0; o < n.length; o++) {n[o] = n[o].split(";");for (var i = n[o], s = 0; s < i.length; s++) {var a = i[s].split("_");i[s] = { edgeRef: a[0], edgeOriented: "t" === a[1], intersectionNumber: parseInt(a[2], 10), totalIntersections: parseInt(a[3], 10) };}}}return t;}, t.matchRegionFaceRecipe = function (e, t) {var r,n,o,i = 2,s = [];for (r = 0; r < e.length; r++) {var a = v(e[r], t);if (0 === a.matchStatus && 0 === r) return { regions: [], matchStatus: 0 };2 !== a.matchStatus && (i = 1), s.push(a);}if (c.DebugUtils.level("region_match") > 0) {for (c.DebugUtils.clearView(), o = u.default.values(t.sketchEdges), r = 0; r < o.length; r++) {c.DebugUtils.drawEdge3D(o[r], { color: 0, render: !1 });}for (r = 0; r < s.length; r++) {for (n = 0; n < s[r].edges.length; n++) {var l = 0 === r ? 65280 : 16711680;c.DebugUtils.drawEdge3D(s[r].edges[n], { color: l, render: !1 });}}c.DebugUtils.render();}var h = _(s[0], !1);for (n = 1; n < s.length; n++) {_(s[n], !0).forEach(function (e) {h.delete(e);});}if (h = Array.from(h), c.DebugUtils.level("region_match") > 0) {for (r = 0; r < h.length; r++) {for (o = Array.from(h[r].collectEdges()), n = 0; n < o.length; n++) {c.DebugUtils.drawEdge3D(o[n], { color: 13684736, render: !1 });}}c.DebugUtils.render();}return { regions: h, matchStatus: i };}, t.createRecipeFromRegionEdge = function (e, t) {var r,n,o = { startEdgeRefs: [], endEdgeRefs: [], edgeRef: [], edgeOriented: [], intersectionNumberStart: [], totalIntersectionsStart: [], intersectionNumberEnd: [], totalIntersectionsEnd: [] },i = e.getStartVertex(),s = [];i.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), "edge");for (r = 0; r < t.length; r++) {s.indexOf(t[r]) < 0 && (s.push(t[r]), o.startEdgeRefs.push(t[r].getGuid()));}});var a = e.getEndVertex(),c = [];a.getOtherEdges(e).forEach(function (e) {var t = u.default.pluck(e.getAssociatedEdgeInfo(), "edge");for (r = 0; r < t.length; r++) {c.indexOf(t[r]) < 0 && (c.push(t[r]), o.endEdgeRefs.push(t[r].getGuid()));}});var d = e.getAssociatedEdgeInfo(),g = u.default.pluck(d, "edge");for (r = 0; r < d.length; r++) {var p = g[r],f = !d[r].flipped,v = l(p, t),_ = u.default.unique(s.concat(g)),y = h(p, _, v),m = 0;for (n = 0; n < y.length; n++) {if (y[n].vertex === i) {m = n;break;}}var E = u.default.unique(c.concat(g)),x = h(p, E, v),R = 0;for (n = 0; n < x.length; n++) {if (x[n].vertex === a) {R = n;break;}}o.edgeRef.push(p.getGuid()), o.edgeOriented.push(f), o.intersectionNumberStart.push(m), o.totalIntersectionsStart.push(y.length), o.intersectionNumberEnd.push(R), o.totalIntersectionsEnd.push(x.length);}return o;}, t.serializeRegionEdgeRecipe = function (e) {var t = { edge: e.edgeRef, orient: e.edgeOriented, start: e.startEdgeRefs, end: e.endEdgeRefs, sIdx: e.intersectionNumberStart, sNum: e.totalIntersectionsStart, eIdx: e.intersectionNumberEnd, eNum: e.totalIntersectionsEnd };return JSON.stringify(t);}, t.deserializeRegionEdgeRecipe = function (e) {var t = JSON.parse(e);return { edgeRef: t.edge, edgeOriented: t.orient, startEdgeRefs: t.start, endEdgeRefs: t.end, intersectionNumberStart: t.sIdx, totalIntersectionsStart: t.sNum, intersectionNumberEnd: t.eIdx, totalIntersectionsEnd: t.eNum };}, t.matchRegionEdgeRecipe = function (e, t) {var r = [],n = 0,o = [];e.startEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && o.push(r);});var i = [];e.endEdgeRefs.forEach(function (e) {var r = t.sketchEdges[e];r && i.push(r);}), e.edgeRef.forEach(function (e) {var r = t.sketchEdges[e];r && o.indexOf(r) < 0 && o.push(r), r && i.indexOf(r) < 0 && i.push(r);});for (var s = 0; s < e.edgeRef.length; s++) {var a = t.sketchEdges[e.edgeRef[s]];if (a) {var u = l(a, t),d = void 0,g = void 0,p = h(a, o, u);if (0 === e.totalIntersectionsStart[s]) d = u.vertices[0], g = 0;else if (p.length === e.totalIntersectionsStart[s]) {var f = p[e.intersectionNumberStart[s]];d = f.vertex, g = f.indexInTopology;}var v = void 0,_ = void 0,y = h(a, i, u);if (0 === e.totalIntersectionsEnd[s]) v = u.vertices[0], _ = u.vertices.length;else if (y.length === e.totalIntersectionsEnd[s]) {var m = y[e.intersectionNumberEnd[s]];v = m.vertex, 0 === (_ = m.indexInTopology) && a.isClosed() && (_ = u.vertices.length);}if (!e.edgeOriented[s]) {var E = d;d = v, v = E, E = g, g = _, _ = E;}if (d && v) {if (!(g >= _)) {r = u.edges.slice(g, _), n = 2;break;}c.DebugUtils.warn("Edge recipe match should find start vertex before end vertex");}}}return { edges: r, matchStatus: n };};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = function n(e, t) {this.content = [], this.scoreFunction = e, this.lookupFunction = t, this.lookupFunction && (this.nodeDict = {});};n.prototype = { push: function push(e) {this.content.push(e), this.lookupFunction && (this.nodeDict[this.lookupFunction(e)] = this.content.length - 1), this.bubbleUp(this.content.length - 1);}, pop: function pop() {var e = this.content[0],t = this.content.pop();return this.content.length > 0 && (this.content[0] = t, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = 0), this.sinkDown(0)), this.lookupFunction && delete this.nodeDict[this.lookupFunction(e)], e;}, peek: function peek() {return this.content[0];}, getNodeIndex: function getNodeIndex(e) {if (this.lookupFunction) return this.nodeDict[this.lookupFunction(e)];for (var t = this.content.length, r = 0; r < t; r++) {if (this.content[r] === e) return r;}throw new Error("Node not found.");}, updated: function updated(e) {var t = this.getNodeIndex(e),r = this.scoreFunction(e),n = Math.floor((t + 1) / 2) - 1,o = this.content[n];if (t > 0 && r < this.scoreFunction(o)) this.bubbleUp(t);else {var i = 2 * (t + 1),s = i - 1,a = this.content[s],c = this.content[i];(a && r > this.scoreFunction(a) || c && r > this.scoreFunction(c)) && this.sinkDown(t);}}, remove: function remove(e) {var t = this.content.length,r = this.getNodeIndex(e),n = this.content.pop();r !== t - 1 && (this.content[r] = n, this.scoreFunction(n) < this.scoreFunction(e) ? this.bubbleUp(r) : this.sinkDown(r));}, size: function size() {return this.content.length;}, bubbleUp: function bubbleUp(e) {for (var t = this.content[e]; e > 0;) {var r = Math.floor((e + 1) / 2) - 1,n = this.content[r];if (!(this.scoreFunction(t) < this.scoreFunction(n))) break;this.content[r] = t, this.content[e] = n, this.lookupFunction && (this.nodeDict[this.lookupFunction(t)] = r, this.nodeDict[this.lookupFunction(n)] = e), e = r;}}, sinkDown: function sinkDown(e) {for (var t = this.content.length, r = this.content[e], n = this.scoreFunction(r);;) {var o = 2 * (e + 1),i = o - 1,s = null;if (i < t) {var a = this.content[i],c = this.scoreFunction(a);c < n && (s = i);}if (o < t) {var u = this.content[o];this.scoreFunction(u) < (null === s ? n : c) && (s = o);}if (null === s) break;this.content[e] = this.content[s], this.content[s] = r, this.lookupFunction && (this.nodeDict[this.lookupFunction(this.content[e])] = e, this.nodeDict[this.lookupFunction(this.content[s])] = s), e = s;}} }, t.BinaryHeap = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createBlock = void 0;var n = r(28),o = r(83),i = r(0),s = r(2);t.createBlock = function (e, t) {var r = [Math.min(e[0], t[0]), Math.min(e[1], t[1]), Math.min(e[2], t[2])],a = [Math.max(e[0], t[0]), Math.max(e[1], t[1]), Math.max(e[2], t[2])];s.ConsoleUtils.assert(a[0] - r[0] > i.KERNEL_TOLERANCE, "block is degenerate in x axis"), s.ConsoleUtils.assert(a[1] - r[1] > i.KERNEL_TOLERANCE, "block is degenerate in y axis"), s.ConsoleUtils.assert(a[2] - r[2] > i.KERNEL_TOLERANCE, "block is degenerate in z axis");var c = [[r[0], r[1], r[2]], [a[0], r[1], r[2]], [a[0], a[1], r[2]], [r[0], a[1], r[2]]],u = (0, n.createFaceFromPolyline)(c),l = a[2] - r[2];return (0, o.extrudeFace)(u, l);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createCylinder = t.createCone = void 0;var n = r(1),o = r(28),i = r(0),s = r(18),a = r(51),c = r(38),u = r(39),l = r(52),h = r(13),d = r(15),g = r(26),p = r(25),f = r(24),v = r(2),_ = function _(e, t, r, _2, y, m) {var E = e,x = t,R = Math.abs(r),A = void 0 === _typeof(_2) ? R : Math.abs(_2);if (R < i.KERNEL_TOLERANCE) {E = t, x = e;var P = R;R = A, A = P;}v.ConsoleUtils.assert(R > i.KERNEL_TOLERANCE);var V = n.Vector3.createFloat64();n.Vector3.subtract(V, x, E);var T = n.Vector3.length(V);v.ConsoleUtils.assert(T > i.KERNEL_TOLERANCE), n.Vector3.scale(V, V, 1 / T);var C = A - R,b = Math.abs(C) > i.KERNEL_TOLERANCE,L = 0;b && (L = Math.atan2(C, T));var O,S = n.Vector3.createFloat64();m && n.Vector3.subtract(S, m, n.Vector3.scale(S, V, n.Vector3.dot(m, V))), (!m || n.Vector3.squaredLength(S) < i.KERNEL_TOLERANCE * i.KERNEL_TOLERANCE) && n.Vector3.computeOrthogonal(S, V), n.Vector3.normalize(S, S), n.Vector3.scale(S, S, R);var M = y || 1;v.ConsoleUtils.assert(M > 0 && M <= 1);var w = Math.max(R, A);Math.abs(w * (1 - M)) < i.KERNEL_TOLERANCE ? b ? (O = new a.Cone()).set(E, R, V, L, S, 1) : (O = new c.Cylinder()).set(E, R, V, S, 1) : b ? (O = new l.EllipticalCone()).set(E, S, M, V, L, 1) : (O = new u.EllipticalCylinder()).set(E, S, M, V, 1);var N = [0, T / Math.cos(L)];O.limitRangeU(N);var F = (0, o.makeConeOrCylinderVParamLoop)(O, N[0]),I = (0, o.makeConeOrCylinderVParamLoop)(O, N[1]);F.getCoedges()[0].setReversed(!0);var D = [];D[0] = new d.Face(), D[0].setSurface(O), D[0].addLoops([F, I]);var j = F.getCoedges()[0].getEdge();if (j.getCurve()) {var B = new h.Loop();B.addCoedge((0, o.createCoedgeOnEdge)(j)), (G = new d.Face()).addLoop(B);var U = new s.Plane();U.set(E, V), G.setSurface(U), G.setReversed(!0), D.push(G), v.ConsoleUtils.assert(B.getCoedges()[0].uvAngleSubtended(E) < -i.KERNEL_TOLERANCE);}var k = I.getCoedges()[0].getEdge();if (k.getCurve()) {var G,z = new h.Loop();z.addCoedge((0, o.createCoedgeOnEdge)(k)), (G = new d.Face()).addLoop(z);var Y = new s.Plane();Y.set(x, V), G.setSurface(Y), D.push(G), v.ConsoleUtils.assert(z.getCoedges()[0].uvAngleSubtended(x) < -i.KERNEL_TOLERANCE);}var K = new g.Shell();K.addFaces(D);var q = new p.Lump();q.addShell(K);var W = new f.Body();return W.addLump(q), W;};t.createCone = _, t.createCylinder = function (e, t, r, n, o) {return _(e, t, r, r, n, o);};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.createPolyhedron = void 0;var n = r(24),o = r(25),i = r(15),s = r(13),a = r(16),c = r(18),u = r(6),l = r(28),h = r(3),d = r(2),g = r(8);function p(e, t) {var r,n = e.getCommonEdges(t);d.ConsoleUtils.assert(n.length <= 1), r = 0 === n.length ? (0, l.createLineEdgeBetweenVertices)(e, t) : n[0];var o = (0, l.createCoedgeOnEdge)(r);return d.ConsoleUtils.assert(o.getStartVertex() === e), d.ConsoleUtils.assert(o.getEndVertex() === t), o;}function f(e, t) {var r,n = [];for (r = 0; r < t.length; ++r) {n[r] = e[t[r]];}var o = (0, h.definePlaneThroughPoints)(n);if (o) {var i = new c.Plane();return i.set(o.origin, o.normal, o.uAxis), i.limitRangeU(o.uRange), i.limitRangeV(o.vRange), i;}g.DebugUtils.warn("Face is degenerate");}t.createPolyhedron = function (e, t) {var r,c = [];for (r = 0; r < e.length; ++r) {var h = new a.Vertex(new u.Point(e[r]));c.push(h);}var g = [];for (r = 0; r < t.length; ++r) {var v = t[r];d.ConsoleUtils.assert(v.length >= 3);for (var _ = new s.Loop(), y = [], m = 0; m < v.length; ++m) {var E = v[m],x = v[(m + 1) % v.length];d.ConsoleUtils.assert(E >= 0 && E < e.length), d.ConsoleUtils.assert(x >= 0 && x < e.length);var R = p(c[E], c[x]);y.push(R);}_.addCoedges(y);var A = f(e, v),P = new i.Face(A);P.addLoop(_), g.push(P);}var V = (0, l.createShellsFromFaces)(g),T = [];for (r = 0; r < V.length; ++r) {T[r] = new o.Lump(), T[r].addShell(V[r]);}var C = new n.Body();return C.addLumps(T), C;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologyStitcher = void 0;var n = r(1),o = r(119),i = r(41),s = r(2),a = function a() {this._shellSet = new Set(), this._lumpSet = new Set(), this._bodySet = new Set(), this._wireSet = new Set(), this._progenitorMap = new i.ProgenitorMap();};a.prototype.initMerge = function () {this._shellSet.clear(), this._lumpSet.clear(), this._bodySet.clear(), this._wireSet.clear();}, a.prototype.getEdgeOwnerToMerge = function (e) {var t = e.getWire();if (t) this._wireSet.add(t);else {var r = function (e) {var t = e.getCoedge();if (t) {var r = t.getFace();if (r) return r.getShell();}}(e);r && this._shellSet.add(r);}}, a.prototype.getVertexOwnerToMerge = function (e) {var t = e.getEdges();t.length > 0 && this.getEdgeOwnerToMerge(t[0]);}, a.prototype.stitchVertices = function (e, t) {var r;this.initMerge();var n = void 0;for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {n = e[r];break;}}s.ConsoleUtils.assert(n);var o = [];for (r = 0; r < e.length; ++r) {if (this.getVertexOwnerToMerge(e[r]), e[r] !== n) {for (var i = e[r], a = i.getEdges().slice(0), c = 0; c < a.length; ++c) {var u = a[c];u.getStartVertex() === i && u.setStartVertex(n), u.getEndVertex() === i && u.setEndVertex(n);}s.ConsoleUtils.assert(0 === i.getEdges().length), t && t.has(i) || o.push(i);}}o.length > 0 && this._progenitorMap.addEntry(n, o), this.mergeTopology();}, a.prototype.stitchEdges = function (e, t) {var r,o = e[0];for (r = 0; r < e.length; ++r) {if (!t || !t.has(e[r])) {o = e[r];break;}}var i = [],s = [];for (r = 0; r < e.length; ++r) {var a = e[r],c = !1;if (a.getStartVertex() !== o.getStartVertex() && a.getStartVertex() === o.getEndVertex()) {var u = a.evaluateDt(a.t0()),l = o.evaluateDt(o.t1());n.Vector3.dot(u, l) < 0 && (c = !0);}for (var h = a.getCoedge(); h;) {i.push(h), c && h.setReversed(!h.isReversed()), (h = h.getPartner()) === a.getCoedge() && (h = void 0);}a !== o && (a.setStartVertex(null), a.setEndVertex(null), s.push(a));}for (this.initMerge(), r = 0; r < i.length; ++r) {var d = i[r];this.getEdgeOwnerToMerge(d.getEdge()), d.setEdge(o);var g = (r + 1) % i.length;d.setPartner(i[g]);}this.mergeTopology(), this._progenitorMap.addEntry(o, s);}, a.prototype.mergeTopology = function () {if (this._shellSet.size > 1 && this.mergeShells(), this._wireSet.size > 1) throw new Error("Merging wires in TopologyStitcher is not yet supported.");}, a.prototype.mergeShells = function () {var e = new i.ProgenitorMap();if (this._shellSet.size > 1) {var t = Array.from(this._shellSet),r = t[0],n = r.getLump();n && this._lumpSet.add(n);for (var o = 1; o < t.length; ++o) {var s = t[o];r.addFaces(s.getFaces()), s.setFaces([]), (n = s.getLump()) && (n.removeShell(s), this._lumpSet.add(n));}e.addEntry(r, t.slice(1));}if (this._lumpSet.size > 1) {var a = Array.from(this._lumpSet),c = a[0],u = c.getBody();for (u && this._bodySet.add(u), o = 1; o < a.length; ++o) {var l = a[o];c.addShells(l.getShells()), l.setShells([]), (u = l.getBody()) && (u.removeLump(l), this._bodySet.add(u));}e.addEntry(c, a.slice(1));}if (this._bodySet.size > 1) {var h = Array.from(this._bodySet),d = h[0];for (o = 1; o < h.length; ++o) {for (var g = h[o], p = g.getLumps().slice(0), f = 0; f < p.length; ++f) {p[f].getShells().length > 0 && d.addLump(p[f]);}g.setLumps([]);}e.addEntry(d, h.slice(1));}e.size() > 0 && (this._progenitorMap = e.collapseMaps(this._progenitorMap, { keepIntermediates: !0, keepAllDescendants: !0 }));}, a.prototype.getProgenitorMap = function () {return this._progenitorMap;}, a.prototype.stitchTwoEdgeSets = function (e, t) {var r = new o.MatchFinder();r.setEdges(e, t), r.compute();for (var n = r.getVertexMatches(), i = r.getEdgeMatches(), s = r.getNewVertices(), a = new Set(r.getEdgeProgenitors().getAllNewTopology()), c = 0; c < n.length; ++c) {this.stitchVertices(n[c], s);}for (c = 0; c < i.length; ++c) {this.stitchEdges(i[c], a);}this._progenitorMap = this._progenitorMap.collapseMaps(r.getEdgeProgenitors(), { keepIntermediates: !1, keepAllDescendants: !0 });}, a.prototype.stitchTwoTopology = function (e, t) {s.ConsoleUtils.assert("function" == typeof e.collectEdges), s.ConsoleUtils.assert("function" == typeof t.collectEdges);var r = e.collectEdges(),n = t.collectEdges();this.stitchTwoEdgeSets(r, n);}, a.prototype.stitchEdgeSet = function (e) {this.stitchTwoEdgeSets(e, e);}, t.TopologyStitcher = a;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.MatchFinder = void 0;var n = r(1),o = r(0),i = r(120),s = r(82),a = r(41),c = r(2),u = function u() {this._edges1 = [], this._edges2 = [], this._verts1 = [], this._verts2 = [], this._vertexMatchMap = new Map(), this._edgeMatchMap = new Map(), this._sameEdgeLists = !1, this._newVertices = new Set(), this._edgeProgenitors = new a.ProgenitorMap();};u.prototype.addMergeToMap = function (e, t, r) {var n = r.get(e),o = r.get(t);if (n && !o) n.push(t), r.set(t, n);else if (!n && o) o.push(e), r.set(e, o);else if (n || o) {if (n && o && n !== o) for (var i = 0; i < o.length; ++i) {n.push(o[i]), r.set(o[i], n);}} else {var s = [e, t];r.set(e, s), r.set(t, s);}}, u.prototype.addVertexMerge = function (e, t) {this.addMergeToMap(e, t, this._vertexMatchMap);}, u.prototype.addEdgeMerge = function (e, t) {this.addMergeToMap(e, t, this._edgeMatchMap);}, u.prototype.verticesMatch = function (e, t) {var r = Math.max(e.getPrecision(), t.getPrecision(), o.KERNEL_TOLERANCE);return n.Vector3.squaredDistance(e.getPosition(), t.getPosition()) < r * r;}, u.prototype.findEdgeSplitParam = function (e, t) {var r = e.getStartVertex();if (r !== t) {var i = e.getEndVertex();if (i !== t) {var s = this._vertexMatchMap.get(r);if (!s || -1 === s.indexOf(t)) {var a = this._vertexMatchMap.get(i);if (!a || -1 === a.indexOf(t)) {var c = t.getPosition(),u = Math.max(t.getPrecision(), o.KERNEL_TOLERANCE),l = e.closestToPointParam(c);if (void 0 !== l) {var h = e.evaluatePosition(l);if (!(n.Vector3.squaredDistance(c, h) > u * u)) return { param: l, position: h };}}}}}}, u.prototype.matchVertices = function () {for (var e = new Set(), t = 0; t < this._edges1.length; ++t) {this._edges1[t].collectVertices(e);}this._verts1 = Array.from(e);var r = new Set();for (t = 0; t < this._edges2.length; ++t) {this._edges2[t].collectVertices(r);}this._verts2 = Array.from(r);var n = this;e.forEach(function (e) {r.forEach(function (t) {e !== t && n.verticesMatch(e, t) && n.addVertexMerge(e, t);});});}, u.prototype.findVertexOnEdgeSplits = function (e, t) {for (var r = t.length, n = 0; n < r; ++n) {for (var o = t[n], i = [], s = 0; s < e.length; ++s) {var a = e[s],c = this.findEdgeSplitParam(o, a);c && i.push({ vertex: a, param: c.param, position: c.position });}if (i.length > 0) {var u = this.splitEdgeAtParams(o, i);if (u.length > 0) {t[n] = u[0];for (var l = 1; l < u.length; ++l) {t.push(u[l]);}}}}}, u.prototype.doEdgeSplits = function () {this.findVertexOnEdgeSplits(this._verts1, this._edges2), this._sameEdgeLists || this.findVertexOnEdgeSplits(this._verts2, this._edges1);}, u.prototype.splitEdgeAtParams = function (e, t) {t.sort(function (e, t) {return e.param - t.param;});for (var r = [], s = e, a = 0; a < t.length; ++a) {var c = t[a].vertex,u = t[a].param,l = t[a].position,h = s.getStartVertex().getPosition();if (n.Vector3.squaredDistance(l, h) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) this.addVertexMerge(c, s.getStartVertex());else {0 === r.length && (s = (0, i.replaceEdge)(s), r.push(s), this._edgeProgenitors.addEntry(s, [e]));var d = (0, i.splitEdge)(s, u, l);r.push(d), this._edgeProgenitors.addEntry(d, [e]);var g = d.getStartVertex();this.addVertexMerge(c, g), this._newVertices.add(g), s = d;}}return r;}, u.prototype.edgesMatch = function (e, t) {return (0, s.edgesAreCoincident)(e, t);}, u.prototype.matchEdges = function () {for (var e = 0; e < this._edges1.length; ++e) {for (var t = this._edges1[e], r = t.getStartVertex(), n = t.getEndVertex(), o = 0; o < this._edges2.length; ++o) {var i = this._edges2[o],s = i.getStartVertex(),a = i.getEndVertex();if (!(this._sameEdgeLists && o <= e) && t !== i) {var c,u = r === s || r === a;if (!u) {var l = this._vertexMatchMap.get(r);l && (u = l === this._vertexMatchMap.get(s) || l === this._vertexMatchMap.get(a));}if (u && !(c = n === s || n === a)) {var h = this._vertexMatchMap.get(n);h && (c = h === this._vertexMatchMap.get(s) || h === this._vertexMatchMap.get(a));}u && c && this.edgesMatch(t, i) && this.addEdgeMerge(t, i);}}}}, u.prototype.setEdges = function (e, t) {e instanceof Set ? this._edges1 = Array.from(e) : e instanceof Array && (this._edges1 = e), t && t !== e ? t instanceof Set ? this._edges2 = Array.from(t) : t instanceof Array && (this._edges2 = t) : this._edges2 = this._edges1, this._sameEdgeLists = this._edges1 === this._edges2, c.ConsoleUtils.assert(this._edges1 && this._edges2);}, u.prototype.compute = function () {this.matchVertices(), this.doEdgeSplits(), this.matchEdges();}, u.prototype.getVertexMatches = function () {var e = new Set();return this._vertexMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getEdgeMatches = function () {var e = new Set();return this._edgeMatchMap.forEach(function (t, r) {e.add(t);}), Array.from(e);}, u.prototype.getNewVertices = function () {return this._newVertices;}, u.prototype.getEdgeProgenitors = function () {return this._edgeProgenitors;}, t.MatchFinder = u;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.replaceEdge = t.splitEdge = void 0;var n = r(16),o = r(20),i = r(27),s = r(6),a = function a(e, t) {var r = new i.Coedge();r.setEdge(t), e.getEdge().getCoedge() === e && t.setCoedge(r), r.setReversed(e.isReversed()), r.setLoop(e.getLoop());var n = e.getLoop().getCoedges(),o = n.indexOf(e);return r.isReversed() ? n.splice(o, 0, r) : n.splice((o + 1) % n.length, 0, r), r;};t.splitEdge = function (e, t, r) {var i = new n.Vertex(new s.Point(r)),c = [e.getRange()[0], e.getRange()[1]],u = e.getEndVertex();e.setRange([c[0], t]), e.setEndVertex(i);var l = new o.Edge();l.setCurve(e.getCurve()), l.setReversed(e.isReversed()), l.setRange([t, c[1]]), l.setStartVertex(i), l.setEndVertex(u), l.setPrecision(e.getPrecision()), l.setWire(e.getWire());for (var h = [], d = e.getCoedge(); d;) {h.push(a(d, l)), (d = d.getPartner()) === e.getCoedge() && (d = void 0);}for (var g = 0; g < h.length; ++g) {var p = (g + 1) % h.length;h[g].setPartner(h[p]);}if (l.getWire()) {var f = l.getWire().getEdges().slice(),v = f.indexOf(e);f.splice(v + 1, 0, l), l.getWire().setEdges(f);}return l;}, t.replaceEdge = function (e) {var t = new o.Edge();t.setCurve(e.getCurve()), t.setReversed(e.isReversed()), t.setRange([e.getRange()[0], e.getRange()[1]]), t.setStartVertex(e.getStartVertex()), t.setEndVertex(e.getEndVertex()), t.setPrecision(e.getPrecision()), t.setCoedge(e.getCoedge()), t.setWire(e.getWire()), e.setStartVertex(null), e.setEndVertex(null), e.setCoedge(void 0), e.setWire(void 0);for (var r = t.getCoedge(); r;) {r.setEdge(t), (r = r.getPartner()) === t.getCoedge() && (r = void 0);}if (t.getWire()) {var n = t.getWire().getEdges().slice();n[n.indexOf(e)] = t, t.getWire().setEdges(n);}return t;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.svgFromWire = void 0;var n = r(0),o = r(2);t.svgFromWire = function (e) {e.getTopologyType() === n.TOPOLOGY_TYPES.WIREBODY && console.warn("svgFromWire: Pass a wire, not a wire body."), o.ConsoleUtils.assert(e.getTopologyType() === n.TOPOLOGY_TYPES.WIRE, "Input topology is not a Wire");var t = e.getOrderedEdges();if (0 === t.edges.length) return "";for (var r = t.start, i = r.getPosition(), s = "M " + i[0] + " " + i[1], a = 0; a < t.edges.length; ++a) {var c = t.edges[a];i = (r = r === c.getStartVertex() ? c.getEndVertex() : c.getStartVertex()).getPosition();var u = c.getCurve();if (u) if (u.getGeometryType() === n.GEOMETRY_TYPES.LINE) s += " L " + i[0] + " " + i[1];else if (u.getGeometryType() !== n.GEOMETRY_TYPES.BCURVE || 3 !== u.getDegree() || u.isRational()) console.warn("Unhandled curve type in svgFromWire");else {for (var l = [], h = u.getBezierSegments(), d = 0; d < h.length; d++) {var g = h[d];if (g) for (var p = g.getControlPoints(), f = 0; f < p.length; f += 3) {l.push([p[f], p[f + 1]]);}}r === c.getStartVertex() !== c.isReversed() && l.reverse(), o.ConsoleUtils.assert(l.length === 4 * h.length, "Unexpected number of control points");for (var v = 0; v < h.length; ++v) {s += " C " + l[4 * v + 1][0] + " " + l[4 * v + 1][1] + " " + l[4 * v + 2][0] + " " + l[4 * v + 2][1] + " ", v === h.length - 1 ? s += i[0] + " " + i[1] : s += l[4 * v + 3][0] + " " + l[4 * v + 3][1];}}}return s;};}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.Path2D = void 0;var n = r(1),o = r(0),i = r(54),s = r(40),a = r(33),c = r(14),u = r(23),l = r(7),h = r(28),d = r(84),g = r(2),p = r(8),f = { assert: function assert(e, t) {if (!e) throw { message: t || "assertion failed" };}, assert_arg: function assert_arg(e, t, r, n) {var o = "Invalid argument '" + t + "': " + r + "\nUsage: " + n;this.assert(e, o);}, assert_number: function assert_number(e, t, r) {this.assert_arg("number" == typeof e, t, "should be a number", r);}, assert_boolean: function assert_boolean(e, t, r) {this.assert_arg("boolean" == typeof e, t, "should be a boolean", r);}, assert_string: function assert_string(e, t, r) {this.assert_arg("string" == typeof e, t, "should be a string", r);} },v = function v() {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0], this._mergeBCurves = !0, this._healPath = !1, this._tangentTol = o.KERNEL_ANGULAR_TOLERANCE;};function _(e, t, r) {var o = 3 * (t - 1),i = [e[o], e[o + 1], e[o + 2]],s = 3 * r,a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, -.1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], a, c, u);e[s - 3 * u] = l[0], e[s - 3 * u + 1] = l[1], e[s - 3 * u + 2] = l[2];}}function y(e, t, r) {var o = 3 * t,i = [e[o], e[o + 1], e[o + 2]],s = 3 * (r + 1),a = [e[s], e[s + 1], e[s + 2]],c = n.Vector3.sub([0, 0, 0], a, i);n.Vector3.scale(c, c, .1);for (var u = 1; u <= r - t; ++u) {var l = n.Vector3.scaleAndAdd([0, 0, 0], i, c, u);e[o + 3 * u] = l[0], e[o + 3 * u + 1] = l[1], e[o + 3 * u + 2] = l[2];}}function m(e, t) {for (var r, o, i, s = [], a = e.getControlPoints(), c = [a[0], a[1], a[2]], u = a.length / 3, l = 1; l < u; ++l) {r = [a[3 * l], a[3 * l + 1], a[3 * l + 2]];var h = l === u - 1;n.Vector3.squaredDistance(c, r) < t ? (void 0 === o && (o = l - 1), i = l) : h = !0, h && void 0 !== o && void 0 !== i && (s.push([o, i]), h = !1, o = void 0, i = void 0), c = r;}return s;}function E(e, t) {var r = m(e, t);if (1 === r.length && r[0][1] - r[0][0] == 1) {var n = r[0];0 === n[0] ? e.addControlPointOnCurve(e.evaluatePosition(.1)) : n[1] === e.getNumControlPoints() - 1 ? e.addControlPointOnCurve(e.evaluatePosition(.9)) : (e.addControlPointOnCurve(e.evaluatePosition(.45)), e.addControlPointOnCurve(e.evaluatePosition(.55)));}return r.length > 0;}function x(e, t) {for (var r = m(e, t), n = 0; n < r.length; ++n) {var o = r[n],i = e.getControlPoints().slice();o[0] > 0 ? _(i, o[0], o[1]) : o[1] < i.length / 3 - 1 ? y(i, o[0], o[1]) : p.DebugUtils.warn("Degenerate BCurve!"), e.setControlPoints(i);}}function R(e, t) {var r = e.getControlPoints(),o = [r[0], r[1], r[2]],i = [r[3], r[4], r[5]],s = n.Vector3.distance(o, i);r[3] = o[0] + t[0] * s, r[4] = o[1] + t[1] * s, r[5] = o[2] + t[2] * s, e.setControlPoints(r);}function A(e, t) {var r = e.getControlPoints(),o = e.getControlPoints().length,i = [r[o - 6], r[o - 5], r[o - 4]],s = [r[o - 3], r[o - 2], r[o - 1]],a = n.Vector3.distance(i, s);r[o - 6] = s[0] - t[0] * a, r[o - 5] = s[1] - t[1] * a, r[o - 4] = s[2] - t[2] * a, e.setControlPoints(r);}function P(e) {var t = new a.BCurve(),r = e.getRange(),o = e.evaluatePosition(r[0]),i = e.evaluatePosition(r[1]),s = n.Vector3.lerp([0, 0, 0], o, i, 1 / 3),c = n.Vector3.lerp([0, 0, 0], o, i, 2 / 3),u = [o[0], o[1], 0, s[0], s[1], 0, c[0], c[1], 0, i[0], i[1], 0];return t.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), t;}function V(e, t) {for (var r, o = e.getRange(), i = e.evaluatePosition(o[0]), s = e.evaluatePosition(o[1]), a = n.Vector3.distance(i, s), c = 0, u = t.getControlPoints(), l = [u[0], u[1], u[2]], h = u.length / 3, d = 1; d < h; ++d) {r = [u[3 * d], u[3 * d + 1], u[3 * d + 2]], c += n.Vector3.distance(l, r), l = r;}return a < c;}function T(e, t) {var r = e.getControlPoints().concat(t.getControlPoints().slice(3)),o = e.getWeights().concat(t.getWeights().slice(1)),i = e.getKnotVector().slice(0, -1),s = e.evaluateDt(e.getRange()[1]),a = t.evaluateDt(t.getRange()[0]),c = Math.sqrt(n.Vector3.squaredLength(a) / n.Vector3.squaredLength(s)),u = i[i.length - 1] - t.getKnotVector()[0] * c,l = t.getKnotVector().slice(t.getDegree() + 1);return l = l.map(function (e) {return e * c + u;}), i = i.concat(l), e.set(r, o, 3, i), e;}function C(e, t, r, i, s) {var a = n.Vector2.subtract([], s, e),u = n.Vector2.length(a);if (!(u < o.KERNEL_TOLERANCE)) {u > 2 * t && (t = u / 2);var l = n.Vector2.scaleAndAdd([], e, a, .5);if (u < 2 * t - n.FLOAT64_TOLERANCE) {var h = Math.sqrt(t * t - u * u / 4);!0 === i != (!1 === r) && (h = -h);var d = n.Vector2.normalize([], [-a[1], a[0]]);n.Vector2.scaleAndAdd(l, l, d, h);}var g = [0, 0, i ? 1 : -1],p = new c.Circle();p.set([l[0], l[1], 0], g, [t, 0, 0]);var f = p.closestToPointParam([e[0], e[1], 0]),v = p.closestToPointParam([s[0], s[1], 0]);return v <= f && (v += 2 * Math.PI), p.limitRange([f, v]), p;}}function b(e, t) {var r = e.slice(1);r = r.replace(/([^e])-/g, "$1 -");for (var n = 0; n < 2; ++n) {r = r.replace(/\.[0-9]*\./g, function (e) {return e.slice(0, -1) + " .";});}for (var o = r.split(/[,\s]/), i = [], s = 0; s < o.length; ++s) {if (o[s].length > 0) {var a = Number(o[s]);t(!isNaN(a), "could not parse command"), i.push(a);}}return i;}v.prototype.numWires = function () {var e = this._wireBody.getWires().length;return this._curves.length > 0 && (e += 1), e;}, v.prototype.numClosed = function () {for (var e = 0, t = 0; t < this._wireBody.getWires().length; ++t) {this._wireBody.getWires()[t].isClosed() && (e += 1);}return this._areCurvesClosed() && (e += 1), e;}, v.prototype._fixCoincidentControlPoints = function () {for (var e = o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE, t = 0; t < this._curves.length; ++t) {var r = this._curves[t];r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && 3 === r.getDegree() && 4 === r.getNumControlPoints() && !1 === r.isRational() && E(r, e) && x(r, e);}}, v.prototype._snapBCurvesTangent = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && (r.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE ? (n.Vector3.normalize(s, s), R(i, s)) : r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() !== o.GEOMETRY_TYPES.BCURVE && (n.Vector3.normalize(a, a), A(r, a)));}}, v.prototype._areCurvesClosed = function () {if (0 === this._curves.length) return !1;var e = this._curves[this._curves.length - 1],t = this._curves[0];return n.Vector3.squaredDistance(e.evaluatePosition(e.getRange()[1]), t.evaluatePosition(t.getRange()[0])) < o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE;}, v.prototype._mergeShortLinesWithBCurves = function () {for (var e = !1, t = 0; t < this._curves.length; ++t) {var r = (t + 1) % this._curves.length;if (0 === r && !this._areCurvesClosed()) break;var i = this._curves[t],s = this._curves[r],a = i.evaluateDt(i.getRange()[1]),c = s.evaluateDt(s.getRange()[0]);n.Vector3.isParallel(a, c, 1, o.KERNEL_ANGULAR_TOLERANCE) && (i.getGeometryType() === o.GEOMETRY_TYPES.LINE && s.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && V(i, s) ? (this._curves.splice(t, 1, T(P(i), s)), this._curves.splice(r, 1), t -= 1, e = !0) : i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && s.getGeometryType() === o.GEOMETRY_TYPES.LINE && V(s, i) && (this._curves.splice(t, 1, T(i, P(s))), this._curves.splice(r, 1), t -= 1, e = !0));}return e;}, v.prototype._mergeAdjacentBCurves = function () {for (var e = 0; e < this._curves.length; ++e) {var t = (e + 1) % this._curves.length;if (0 === t && !this._areCurvesClosed()) break;var r = this._curves[e],i = this._curves[t],s = r.evaluateDt(r.getRange()[1]),a = i.evaluateDt(i.getRange()[0]);n.Vector3.isParallel(s, a, 1, this._tangentTol) && r.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && i.getGeometryType() === o.GEOMETRY_TYPES.BCURVE && (n.Vector3.squaredLength(s) < n.Vector3.squaredLength(a) ? (n.Vector3.normalize(s, s), R(i, s)) : (n.Vector3.normalize(a, a), A(r, a)), r !== i && (T(r, i), this._curves.splice(t, 1), e -= 1));}}, v.prototype.setMergeBCurves = function (e) {this._mergeBCurves = e;}, v.prototype.setHealForASM = function (e, t) {this._healPath = e, this._tangentTol = void 0 !== t ? t : .01745240643728351;}, v.prototype._addWire = function () {if (0 !== this._curves.length) {this._healPath && (this._fixCoincidentControlPoints(), this._snapBCurvesTangent()), (this._mergeBCurves || this._healPath) && this._mergeAdjacentBCurves(), this._healPath && this._mergeShortLinesWithBCurves() && this._mergeAdjacentBCurves();var e = (0, h.createWiresFromEdges)((0, h.createEdgesFromCurves)(this._curves));g.ConsoleUtils.assert(1 === e.length), this._wireBody.addWire(e[0]), this._curves = [];}}, v.prototype._discardIfOpen = function () {if (0 !== this._curves.length) {var e = this._curves[0].evaluatePosition(this._curves[0].getRange()[0]),t = [this._xy[0], this._xy[1], 0];n.Vector3.squaredDistance(e, t) >= o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE && (this._curves = []);}}, v.prototype.moveTo = function (e, t) {var r = "Path2D.moveTo(x, y)";return f.assert_number(e, "x", r), f.assert_number(t, "y", r), this._addWire(), this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.lineTo = function (e, t) {var r = "Path2D.lineTo(x, y)";f.assert_number(e, "x", r), f.assert_number(t, "y", r);var n = e - this._xy[0],i = t - this._xy[1];if (n * n + i * i > o.KERNEL_TOLERANCE * o.KERNEL_TOLERANCE) {var s = new l.Line();s.set([this._xy[0], this._xy[1], 0], [n, i, 0]), s.limitRange([0, 1]), this._curves.push(s);}return this._xy[0] = e, this._xy[1] = t, this;}, v.prototype.quadraticCurveTo = function (e, t, r, n) {var o = "Path2D.quadraticCurveTo(cpx, cpy, x, y)";f.assert_number(e, "cpx", o), f.assert_number(t, "cpy", o), f.assert_number(r, "x", o), f.assert_number(n, "y", o);var i = new a.BCurve(),s = 1 / 3 * this._xy[0] + 2 / 3 * e,c = 1 / 3 * this._xy[1] + 2 / 3 * t,u = 1 / 3 * r + 2 / 3 * e,l = 1 / 3 * n + 2 / 3 * t,h = [this._xy[0], this._xy[1], 0, s, c, 0, u, l, 0, r, n, 0];return i.set(h, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(i), this._xy[0] = r, this._xy[1] = n, this;}, v.prototype.bezierCurveTo = function (e, t, r, n, o, i) {var s = "Path2D.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)";f.assert_number(e, "cp1x", s), f.assert_number(t, "cp1y", s), f.assert_number(r, "cp2x", s), f.assert_number(n, "cp2y", s), f.assert_number(o, "x", s), f.assert_number(i, "y", s);var c = new a.BCurve(),u = [this._xy[0], this._xy[1], 0, e, t, 0, r, n, 0, o, i, 0];return c.set(u, [1, 1, 1, 1], 3, [0, 0, 0, 0, 1, 1, 1, 1]), this._curves.push(c), this._xy[0] = o, this._xy[1] = i, this;}, v.prototype.circleArcTo = function (e, t, r, n, o) {var i = "Path2D.circleArcTo(radius, longest, anticlockwise, x, y)";f.assert_number(e, "radius", i), f.assert_arg(e > 0, "radius", "must be positive", i), f.assert_boolean(t, "longest", i), f.assert_boolean(r, "anticlockwise", i), f.assert_number(n, "x", i), f.assert_number(o, "y", i);var s = C(this._xy, e, t, r, [n, o]);return s && (this._curves.push(s), this._xy[0] = n, this._xy[1] = o), this;}, v.prototype.ellipseArcTo = function (e, t, r, o, i, s, a) {var c = "Path2D.ellipseArcTo(xRadius, yRadius, rotation, longest, anticlockwise, x, y)";if (f.assert_number(e, "xRadius", c), f.assert_arg(e > 0, "xRadius", "must be positive", c), f.assert_number(t, "yRadius", c), f.assert_arg(t > 0, "yRadius", "must be positive", c), f.assert_number(r, "rotation", c), f.assert_boolean(o, "longest", c), f.assert_boolean(i, "anticlockwise", c), f.assert_number(s, "x", c), f.assert_number(a, "y", c), e < t) {var l = e;e = t, t = l, r += Math.PI / 2;}var h = Math.cos(r),d = Math.sin(r),g = e / t,p = n.Matrix22.multiply([], [1, 0, 0, g], [h, -d, d, h]),v = C(n.Vector2.transformMatrix22([], this._xy, p), e, o, i, n.Vector2.transformMatrix22([], [s, a], p));if (v) {var _ = [v.getCenter()[0], v.getCenter()[1]];n.Matrix22.invert(p, p), n.Vector2.transformMatrix22(_, _, p), _[2] = 0;var y = v.getRadius(),m = [y * h, y * d, 0],E = new u.Ellipse();E.set(_, v.getNormal(), m, 1 / g), E.limitRange(v.getRange()), this._curves.push(E), this._xy[0] = s, this._xy[1] = a;}return this;}, v.prototype.closePath = function () {if (this._curves.length > 0) {var e = this._curves[0],t = e.evaluatePosition(e.getRange()[0]);this.lineTo(t[0], t[1]), this._addWire();}return this;}, v.prototype.addCircle = function (e, t, r) {var n = "Path2D.addCircle(x, y, radius)";f.assert_number(e, "x", n), f.assert_number(t, "y", n), f.assert_number(r, "radius", n), f.assert_arg(r > 0, "radius", "must be positive", n), this._addWire();var o = new c.Circle();return o.set([e, t, 0], [0, 0, 1], [r, 0, 0]), this._curves.push(o), this._addWire(), this;}, v.prototype.addEllipse = function (e, t, r, n, o) {o = void 0 === o ? 0 : o;var i = "Path2D.addEllipse(x, y, xRadius, yRadius, rotation)";if (f.assert_number(e, "x", i), f.assert_number(t, "y", i), f.assert_number(r, "xRadius", i), f.assert_arg(r > 0, "xRadius", "must be positive", i), f.assert_number(n, "yRadius", i), f.assert_arg(n > 0, "yRadius", "must be positive", i), f.assert_number(o, "rotation", i), this._addWire(), r < n) {var s = r;r = n, n = s, o += Math.PI / 2;}var a = new u.Ellipse(),c = Math.cos(o),l = Math.sin(o),h = n / r;return a.set([e, t, 0], [0, 0, 1], [r * c, r * l, 0], h), this._curves.push(a), this._addWire(), this;}, v.prototype.addSVGPath = function (e, t) {t = void 0 !== t && t;var r = "Path2D.addSVGPath(pathString, [includeOpen])";f.assert_string(e, "pathString", r), f.assert_boolean(t, "includeOpen", r), this._addWire(), this._xy[0] = 0, this._xy[1] = 0;var n = function (e) {for (var t = []; e.length > 0;) {var r = e.slice(1).search(/[MmZzLlHhVvCcSsQqTtAa]/) + 1;r <= 0 && (r = e.length);var n = e.slice(0, r).trim();n.length > 0 && t.push(n), e = e.slice(r).trim();}return t;}(e);f.assert_arg(n.length > 0, "pathString", "cannot be empty string", r);for (var i = [this._xy[0], this._xy[1]], s = [this._xy[0], this._xy[1]], a = 0; a < n.length; ++a) {var c,u,l,h,d,g,p,v = function v(e, t) {f.assert_arg(e, "pathString", t + ' "' + n[a] + '"', r);},_ = n[a].charAt(0).toUpperCase(),y = _ !== n[a].charAt(0),m = b(n[a], v),E = y ? this._xy : [0, 0];switch (_) {case "M":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of x,y arguments"), t || this._discardIfOpen(), this.moveTo(m[0] + E[0], m[1] + E[1]), p = 2; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case "Z":v(0 === m.length, "command should not have arguments"), this.closePath();break;case "L":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of x,y arguments"), p = 0; p < m.length; p += 2) {this.lineTo(m[p] + E[0], m[p + 1] + E[1]);}break;case "H":for (v(m.length >= 1, "insufficient arguments in command"), p = 0; p < m.length; p += 1) {this.lineTo(m[p] + E[0], this._xy[1]);}break;case "V":for (v(m.length >= 1, "insufficient arguments in command"), p = 0; p < m.length; p += 1) {this.lineTo(this._xy[0], m[p] + E[1]);}break;case "C":for (v(m.length >= 6, "insufficient arguments in command"), v(m.length % 6 == 0, "command requires sets of 6 arguments"), p = 0; p < m.length; p += 6) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], d = m[p + 4] + E[0], g = m[p + 5] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case "S":for (v(m.length >= 4, "insufficient arguments in command"), v(m.length % 4 == 0, "command requires sets of 4 arguments"), p = 0; p < m.length; p += 4) {c = 2 * this._xy[0] - s[0], u = 2 * this._xy[1] - s[1], l = m[p] + E[0], h = m[p + 1] + E[1], d = m[p + 2] + E[0], g = m[p + 3] + E[1], this.bezierCurveTo(c, u, l, h, d, g), s[0] = l, s[1] = h;}break;case "Q":for (v(m.length >= 4, "insufficient arguments in command"), v(m.length % 4 == 0, "command requires sets of 4 arguments"), p = 0; p < m.length; p += 4) {c = m[p] + E[0], u = m[p + 1] + E[1], l = m[p + 2] + E[0], h = m[p + 3] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case "T":for (v(m.length >= 2, "insufficient arguments in command"), v(m.length % 2 == 0, "command requires pairs of arguments"), p = 0; p < m.length; p += 2) {c = 2 * this._xy[0] - i[0], u = 2 * this._xy[1] - i[1], l = m[p] + E[0], h = m[p + 1] + E[1], this.quadraticCurveTo(c, u, l, h), i[0] = c, i[1] = u;}break;case "A":for (v(m.length >= 7, "insufficient arguments in command"), v(m.length % 7 == 0, "command requires sets of 7 arguments"), p = 0; p < m.length; p += 7) {var x = Math.abs(m[p]),R = Math.abs(m[p + 1]),A = m[p + 2] * Math.PI / 180,P = 0 !== m[p + 3],V = 0 !== m[p + 4],T = m[p + 5] + E[0],C = m[p + 6] + E[1];x < o.KERNEL_TOLERANCE || R < o.KERNEL_TOLERANCE ? this.lineTo(T, C) : this.ellipseArcTo(x, R, A, P, V, T, C);}break;default:v(!1, "unrecognised command");}"Q" !== _ && "T" !== _ && (i = [this._xy[0], this._xy[1]]), "C" !== _ && "S" !== _ && (s = [this._xy[0], this._xy[1]]);}return t || this._discardIfOpen(), this._addWire(), this;}, v.prototype.getWireBody = function () {return this._addWire(), this._wireBody;}, v.prototype.computeRegionizedWireBody = function () {this.getWireBody();for (var e = new i.WireBody(), t = (0, d.mergeSketchRegions)(this._wireBody.getWires()), r = 0; r < t.length; ++r) {for (var n = t[r].getLoops(), o = 0; o < n.length; ++o) {var a = n[o],c = new s.Wire();c.addEdges(Array.from(a.collectEdges())), e.addWire(c);}}return e;}, v.prototype.reset = function () {this._wireBody = new i.WireBody(), this._curves = [], this._xy = [0, 0];}, t.Path2D = v;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.SolidDefLoader = t.getTopologyRank = void 0;var n = r(6),o = r(7),i = r(14),s = r(23),a = r(33),c = r(18),u = r(38),l = r(39),h = r(74),d = r(51),g = r(52),p = r(75),f = r(53),v = r(24),_ = r(25),y = r(26),m = r(15),E = r(13),x = r(27),R = r(20),A = r(16),P = r(54),V = r(40),T = r(79),C = r(0),b = r(85),L = r(124),O = r(125),S = r(45),M = function () {var e = {};return e[C.TOPOLOGY_TYPES.BODY] = 10, e[C.TOPOLOGY_TYPES.WIREBODY] = 9, e[C.TOPOLOGY_TYPES.LUMP] = 8, e[C.TOPOLOGY_TYPES.SHELL] = 7, e[C.TOPOLOGY_TYPES.FACE] = 6, e[C.TOPOLOGY_TYPES.WIRE] = 5, e[C.TOPOLOGY_TYPES.LOOP] = 4, e[C.TOPOLOGY_TYPES.COEDGE] = 3, e[C.TOPOLOGY_TYPES.EDGE] = 2, e[C.TOPOLOGY_TYPES.VERTEX] = 1, function (t) {var r = void 0;return "function" == typeof t.getTopologyType && (r = e[t.getTopologyType()]), r || 0;};}(),w = function w() {this._runTimeMap = new Map(), this._typeidToFuncMap = {}, this.addLoader("body", L.TopologySetters.setBodyData, v.Body), this.addLoader("wirebody", L.TopologySetters.setWireBodyData, P.WireBody), this.addLoader("wire", L.TopologySetters.setWireData, V.Wire), this.addLoader("lump", L.TopologySetters.setLumpData, _.Lump), this.addLoader("shell", L.TopologySetters.setShellData, y.Shell), this.addLoader("face", L.TopologySetters.setFaceData, m.Face), this.addLoader("loop", L.TopologySetters.setLoopData, E.Loop), this.addLoader("coedge", L.TopologySetters.setCoedgeData, x.Coedge), this.addLoader("edge", L.TopologySetters.setEdgeData, R.Edge), this.addLoader("vertex", L.TopologySetters.setVertexData, A.Vertex), this.addLoader("point", b.GeometrySetters.setPointFromProperty, n.Point), this.addLoader("line", b.GeometrySetters.setLineFromProperty, o.Line), this.addLoader("circle", b.GeometrySetters.setCircleFromProperty, i.Circle), this.addLoader("ellipse", b.GeometrySetters.setEllipseFromProperty, s.Ellipse), this.addLoader("bcurve", b.GeometrySetters.setBCurveFromProperty, a.BCurve), this.addLoader("plane", b.GeometrySetters.setPlaneFromProperty, c.Plane), this.addLoader("sphere", b.GeometrySetters.setSphereFromProperty, h.Sphere), this.addLoader("torus", b.GeometrySetters.setTorusFromProperty, p.Torus), this.addLoader("cylinder", b.GeometrySetters.setCylinderFromProperty, u.Cylinder), this.addLoader("cone", b.GeometrySetters.setConeFromProperty, d.Cone), this.addLoader("ellipticalcylinder", b.GeometrySetters.setEllipticalCylinderFromProperty, l.EllipticalCylinder), this.addLoader("ellipticalcone", b.GeometrySetters.setEllipticalConeFromProperty, g.EllipticalCone), this.addLoader("bsurface", b.GeometrySetters.setBSurfaceFromProperty, f.BSurface), this.addLoader("nmiattributestr", O.AttributeSetters.setNMIAttributeStr, T.Attribute), this.addLoader("nmiattributearr", O.AttributeSetters.setNMIAttributeArr, T.Attribute), this.addLoader("textattribute", O.AttributeSetters.setTextAttribute, T.Attribute);};w.prototype.addLoader = function (e, t, r) {this._typeidToFuncMap[e] = [t, r];}, w.prototype._reset = function () {this._runTimeMap.clear();}, w.prototype.getDataSettingFunction = function (e) {var t = this._typeidToFuncMap[e];if (t) return t[0];}, w.prototype.createRunTimeObject = function (e) {var t = this.getTypeContructor(e);if (t) return new t();}, w.prototype.getTypeContructor = function (e) {var t = this._typeidToFuncMap[e];if (t && 2 === t.length) return t[1];}, w.prototype.setObjectProperties = function (e, t, r) {var n = this.getDataSettingFunction(e, r);var o = this;"function" == typeof n && n(t, r, function (e) {if (!e) return;var t = e;return t ? o._runTimeMap.get(t) : void 0;});}, w.prototype.makeGeometryObjectsProto = function (e) {var _this2 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.geometry],o = _this2.createRunTimeObject(r.geometry);o && (_this2._runTimeMap.set(t, o), _this2.setObjectProperties(r.geometry, o, n), o.setGuid(t));});}, w.prototype.makeGeometryObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r ? this.setObjectProperties(t, r, e) : console.error("No constructor"), r;}, w.prototype.makeTopologyObject = function (e) {var t = e.getTypeid(),r = this.createRunTimeObject(t);return r || console.error("No constructor"), r;}, w.prototype.makeAttributeObjectsProto = function (e) {var _this3 = this;Object.keys(e).forEach(function (t) {var r = e[t],n = r[r.attribute],o = new T.Attribute();_this3._runTimeMap.set(t, o), _this3.setObjectProperties(r.attribute, o, n), o.setGuid(t);});}, w.prototype.makeTopologyObjectsProto = function (e) {var _this4 = this;var t = [];Object.keys(e).forEach(function (r) {var n = e[r],o = n[n.topology],i = _this4.createRunTimeObject(n.topology);i && (_this4._runTimeMap.set(r, i), t.push({ type: n.topology, obj: i, prop: o }), i.setGuid(r));});for (var r = 0; r < t.length; ++r) {this.setObjectProperties(t[r].type, t[r].obj, t[r].prop);}}, w.prototype._collectGeometries = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getGeometryType && e.set(t.getGuid(), t);});}, w.prototype._collectTopologies = function (e) {this._runTimeMap.forEach(function (t) {void 0 !== t.getTopologyType && e.set(t.getGuid(), t);});}, w.prototype.loadModelPSet = function (e, t, r) {var n = e.get("geometries");if (n) {var o = e.get("attributes"),i = e.get("topologies");if (i) return this.makeGeometryObjects(n), o && this.makeAttributeObjects(o), this.makeTopologyObjects(i), this.getHighestObject(t, r);}}, w.prototype.getHighestObject = function (e, t) {var r = void 0,n = 0;return this._runTimeMap.forEach(function (e) {if (10 !== n) {var t = M(e);t > n && t > 0 && (n = t, r = e);}}), e && this._collectGeometries(e), t && this._collectTopologies(t), this._reset(), r;}, w.prototype.loadModelProtoMessage = function (e, t, r) {var n = e.geometries;if (!n) return;var o = e.attributes,i = e.topologies;return i ? (this.makeGeometryObjectsProto(n), o && this.makeAttributeObjectsProto(o), this.makeTopologyObjectsProto(i), this.getHighestObject(t, r)) : void 0;}, w.prototype.loadProtoBinary = function (e, t, r) {var n = e;n instanceof ArrayBuffer && (n = new Uint8Array(n));var o = S.Autodesk.lookupType("SolidDef.model_1_0_0").decode(n);return this.loadModelProtoMessage(o, t, r);}, t.getTopologyRank = M, t.SolidDefLoader = w;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.TopologySetters = void 0;var n = r(85);var o = {},i = function i(e, t, r) {var n = t.attributes;if (n) {e.removeAllAttributes();for (var o = 0; o < n.length; ++o) {var _t9 = r(n[o]);e.addAttribute(_t9);}}};o.setBodyData = function (e, t, r) {for (var n = t.lumps, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setBody(e);}e.setLumps(o), i(e, t, r);}, o.setLumpData = function (e, t, r) {for (var n = t.shells, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLump(e);}e.setShells(o), i(e, t, r);}, o.setShellData = function (e, t, r) {for (var n = t.faces, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setShell(e);}e.setFaces(o), i(e, t, r);}, o.setFaceData = function (e, t, r) {for (var n = t.loops, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setFace(e);}e.setLoops(o), e.setReversed(t.reversed), e.setSurface(r(t.geometry)), i(e, t, r);}, o.setLoopData = function (e, t, r) {for (var n = t.coedges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setLoop(e);}e.setCoedges(o), i(e, t, r);}, o.setCoedgeData = function (e, t, r) {e.setEdge(r(t.edge)), e.setReversed(t.reversed), e.setPartner(r(t.partner)), e.getEdge() && !e.getEdge().getCoedge() && e.getEdge().setCoedge(e), i(e, t, r);}, o.setEdgeData = function (e, t, r) {e.setVertex(0, r(t.vertex0)), e.setVertex(1, r(t.vertex1));var o = (0, n.propertyToRange)(t, "range");e.sett0(o[0]), e.sett1(o[1]), e.setReversed(t.reversed), e.setPrecision(t.precision), e.setCurve(r(t.geometry)), i(e, t, r);}, o.setVertexData = function (e, t, r) {e.setPrecision(t.precision), e.setPoint(r(t.geometry)), i(e, t, r);}, o.setWireBodyData = function (e, t, r) {for (var n = t.wires, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWireBody(e);}e.setWires(o), i(e, t, r);}, o.setWireData = function (e, t, r) {for (var n = t.edges, o = new Array(n.length), s = 0; s < n.length; ++s) {var a = n[s];o[s] = r(a), o[s].setWire(e);}e.setEdges(o), i(e, t, r);}, t.TopologySetters = o;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 });var n = { setNMIAttributeStr: function setNMIAttributeStr(e, t) {e.typeid = "autodesk.brep:nmiattributestr-1.0.0", e.values = { primaryId: t.primaryId, secondaryId: t.secondaryId, approachId: t.approachId, operationIds: t.operationIds };}, setNMIAttributeArr: function setNMIAttributeArr(e, t) {e.typeid = "autodesk.brep:nmiattributearr-1.0.0";for (var r = t.tagInfo, n = new Array(r.length), o = 0; o < r.length; ++o) {var i = r[o];n[o] = { primaryId: i.primaryId, secondaryId: i.secondaryId, approachId: i.approachId, operationIds: i.operationIds };}e.values = { tagInfo: n };}, setTextAttribute: function setTextAttribute(e, t) {e.typeid = "autodesk.brep:textattribute-1.0.0", e.values = { text: t.text };} };t.AttributeSetters = n;}, function (e, t, r) {"use strict";Object.defineProperty(t, "__esModule", { value: !0 }), t.saveToProtoBinary = t.saveToProtoMessage = t.SolidDefSaver = void 0;var n = r(45),o = function o() {};o.prototype.setVersion = function (e) {console.warn("SolidDefSaver.prototype.setVersion is deprecated,");};var i = function i(e) {var t = n.Autodesk.lookupType("SolidDef.model_1_0_0"),r = { topologies: {}, geometries: {}, attributes: {} };return e.addToModelObject(r), t.create(r);};t.SolidDefSaver = o, t.saveToProtoMessage = i, t.saveToProtoBinary = function (e) {var t = n.Autodesk.lookupType("SolidDef.model_1_0_0"),r = i(e);return t.encode(r).finish();};}]);});

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader!./node_modules/sass-loader/dist/cjs.js!./extensions/Edit2D/Edit2D.css ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".adsk-viewing-viewer .edge-gizmo:hover {\n  background-color: lime; }\n\n.adsk-viewing-viewer .edge-gizmo {\n  position: absolute;\n  background-color: #009bff;\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  cursor: move;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.adsk-viewing-viewer .edge-gizmo.selected {\n  background-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo:hover.vertex-gizmo.enable-hover {\n  border-color: lime; }\n\n.adsk-viewing-viewer .vertex-gizmo {\n  display: inline-block;\n  position: absolute;\n  width: 7px;\n  height: 7px;\n  left: -2px;\n  top: -2px;\n  background-color: #009bff;\n  border-style: solid;\n  border-width: 2px;\n  border-color: #FFFFFF;\n  border-radius: 100px;\n  box-shadow: 0 2px 5px 0 #182A3D;\n  z-index: 1;\n  /* Place above the viewer but below the measure labels, which are at 2 */\n  cursor: move; }\n\n.adsk-viewing-viewer .ellipse-arc-gizmo {\n  display: inline-block;\n  position: absolute;\n  width: 5px;\n  height: 5px;\n  left: -1px;\n  top: -1px;\n  background-color: #ff00ff;\n  border-style: solid;\n  border-width: 1px;\n  border-color: #000000;\n  border-radius: 100px;\n  box-shadow: 0 2px 5px 0 #182A3D;\n  z-index: 2;\n  /* Must always be in front of the EdgeMove gizmo. Otherwise it would become unreachable on low radii.*/\n  cursor: move; }\n\n.adsk-viewing-viewer .vertex-gizmo.selected {\n  border-color: lime; }\n\n.adsk-viewing-viewer .edge-move-gizmo {\n  width: 20px;\n  /* width along the edge */\n  height: 6px;\n  /* height vertical to the edge */ }\n\n.adsk-viewing-viewer .edit2d-label {\n  display: none;\n  position: absolute;\n  height: 19px;\n  left: 0px;\n  top: 0px;\n  padding: 2px 0 2px 0;\n  background-color: #009bff;\n  box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.25);\n  color: #f4f4f4;\n  font-size: 12px;\n  text-align: center;\n  line-height: 1.2;\n  white-space: nowrap;\n  border-radius: 8px;\n  pointer-events: none;\n  cursor: pointer;\n  z-index: 2;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.adsk-viewing-viewer .edit2d-label.visible {\n  display: block; }\n\n.adsk-viewing-viewer .edit2d-label-text {\n  display: inline-block;\n  margin: 0 5px 0 5px;\n  vertical-align: middle;\n  font-size: 16px;\n  pointer-events: none; }\n\n/* Mark area labels for invalid shapes with red background */\n.adsk-viewing-viewer .edit2d-label.error-indicator {\n  background-color: red; }\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })

/******/ });
//# sourceMappingURL=Edit2D.js.map