/*!
 * LMV v7.34.2
 * 
 * Copyright 2021 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.ModelAlignmentService =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/ModelAlignmentService/ModelAlignmentService.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/ModelAlignmentService/AlignmentCache.js":
/*!************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentCache.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentCache; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

// Helper class to implement batching and caching of alignment items (alignment transforms, locked-flags, and possible other service-specific data). 
//
// Main purpose is to provide implementation of loadTransform/saveTransform in a way that
// we don't fire a single request per call. Instead, all transforms can be prefetched in a single batch and loadTransform gets them from memory as soon as available.
//
// Note: Batching and caching is currently only supported for 3D model alignments. For those, it's most important to make sure that aggregated 3D views with >60 3D models are
//       not slowed down by lots of alignment service requests.
var AlignmentCache = /*#__PURE__*/function () {

  // The actual content of cached items is left to the client. The cache cannot add items itself.
  //
  // @param {async function(string[])} fetchItems - Async function to make batch requests. On success it returns a map from versionUrn to data items.
  function AlignmentCache(fetchItems) {_classCallCheck(this, AlignmentCache);

    // Keep callback to fetch items
    this._fetchItems = fetchItems;

    // AlignmentItems in memory. Indexed by versionUrn.
    this.cache = {};

    // If the alignment for an urn is not in memory, but already requested, this[urnToRequestIndex] gives us the index
    // of the corresponding request in this.pendingRequests.
    this.urnToRequestIndex = {};

    // For each pending fetchItems-call, this array contains a promise that resolves when the request is finished.
    this.pendingRequests = [null];
  }

  // Caching is only supported for 3D alignments which are solely indexed by versionUrn.
  _createClass(AlignmentCache, [{ key: "itemSupported", value: function () {var _itemSupported = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:return _context.abrupt("return",
                !viewablePartId);case 1:case "end":return _context.stop();}}}, _callee);}));function itemSupported(_x, _x2) {return _itemSupported.apply(this, arguments);}return itemSupported;}()


    // Prefetch alignment items for a given list of urns and add them to the cache.
  }, { key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(urns) {var _this = this;var needsLoad, requestIndex, promise, result;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:

                // Skip urls that we already know
                needsLoad = function needsLoad(urn) {return !_this.cache[urn];};
                urns = urns.filter(needsLoad);

                // If all is in cache, we are done here
                if (urns.length) {_context2.next = 4;break;}return _context2.abrupt("return");case 4:



                // find free request index
                requestIndex = 1;
                while (this.pendingRequests[requestIndex]) {requestIndex++;}

                // Mark all urns as pending and allow finding the request for a given urn
                urns.forEach(function (urn) {return _this.urnToRequestIndex[urn] = requestIndex;});

                // Do the actual request
                promise = this._fetchItems(urns);

                // Keep promise so that later fetchSingleItem() calls to any of the urns can return it.
                this.pendingRequests[requestIndex] = promise;

                // Wait for request result
                _context2.next = 11;return promise;case 11:result = _context2.sent;

                // remove promise from pendingRequests
                this.pendingRequests[requestIndex] = null;


                // If fetching succeeded, add results to cache.
                // Otherwise, do nothing: It's up to the client to deal with errors
                if (result) {
                  urns.forEach(function (urn) {
                    _this.cache[urn] = result[urn];
                  });
                }

                // Mark urn as resolved and not pending anymore. Note that this always needs to happen, no matter whether successful or not.
                urns.forEach(function (urn) {
                  // Use delete here to keep the dictionary cleaner. 
                  // Although it's a bit slower than setting to undefined, this doesn't matter here,
                  // because the the call frequency is not critically high.
                  delete _this.urnToRequestIndex[urn];
                });case 15:case "end":return _context2.stop();}}}, _callee2, this);}));function fetchItems(_x3) {return _fetchItems.apply(this, arguments);}return fetchItems;}()


    // Return immediately whatever we have in cache
  }, { key: "getCachedItem", value: function getCachedItem(versionUrn) {
      return this.cache[versionUrn];
    } }, { key: "getItem", value: function () {var _getItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(

      versionUrn) {var item, requestIndex;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:

                // Return from memory if possible
                item = this.getCachedItem(versionUrn);if (!
                item) {_context3.next = 3;break;}return _context3.abrupt("return",
                item);case 3:


                // Ideally, this item should already be handled by a pending batch request.
                // If so, we just wait for it to finish.
                requestIndex = this.urnToRequestIndex[versionUrn];if (!
                requestIndex) {_context3.next = 9;break;}_context3.next = 7;return (

                  this.pendingRequests[requestIndex]);case 7:_context3.next = 11;break;case 9:_context3.next = 11;return (



                  this.fetchItems([versionUrn]));case 11:return _context3.abrupt("return",

                this.getCachedItem(versionUrn));case 12:case "end":return _context3.stop();}}}, _callee3, this);}));function getItem(_x4) {return _getItem.apply(this, arguments);}return getItem;}() }, { key: "setItem", value: function setItem(


    versionUrn, item) {
      this.cache[versionUrn] = item;
    } }]);return AlignmentCache;}();
;

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentService.js":
/*!**************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentService.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentService; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
/* Interface for alignment service implementations. */var
AlignmentService = /*#__PURE__*/function () {

  function AlignmentService() {_classCallCheck(this, AlignmentService);}

  /**
                                                                          * Changes to false if any connection errors happened. As long as it returns true, you can safely assume that
                                                                          * any returned results from getTransform() reflect the latest service state. 
                                                                          */_createClass(AlignmentService, [{ key: "isWorking", value: function isWorking()
    {return true;}

    /**
                   * Fetch alignment data for a batch of urns. This can be used to avoid individual requests for individual loadTransform()/isAlignmentLocked() calls. 
                   *  @param {string[]} urns
                   *  @throws {Object} error
                   */ }, { key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      urns) {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:case "end":return _context.stop();}}}, _callee);}));function fetchItems(_x) {return _fetchItems.apply(this, arguments);}return fetchItems;}()

    /**
                                                                                                                                                                                                                                                                                 * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                 * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                 * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                 * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.
                                                                                                                                                                                                                                                                                 */ }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:return _context2.abrupt("return",
                null);case 1:case "end":return _context2.stop();}}}, _callee2);}));function loadTransform(_x2, _x3) {return _loadTransform.apply(this, arguments);}return loadTransform;}()


    /**
                                                                                                                                                                                             * Direct access to cached transform in memory: If a transform was loaded by loadTransform or fetch() before, this function allows to get it directly
                                                                                                                                                                                             * within a sync function. However, note that it might return undefined if the transform state is not in memory yet.
                                                                                                                                                                                             *  
                                                                                                                                                                                             * NOTE: Once a transform was loaded, the AlignmentService implementation has to ensure that the result is cached and can be obtained again by this function.
                                                                                                                                                                                             * 
                                                                                                                                                                                             * @returns {LmvMatrix|null|undefined} - Null: "not set", undefined: "not in memory yet".
                                                                                                                                                                                             */ }, { key: "getTransform", value: function getTransform(
    versionUrn, viewablePartId, regionId) {
      return null;
    }

    /**
       * @param {string} versionUrn            - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
       * @param {string} [viewablePartId]      - encoded viewableName of the model.
       * @param {LmvMatrix4|null} transform    - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.
       * @throws {Object}         error        - some implementation may throw. error.msg should provide an error message.
       */ }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(
      versionUrn, viewablePartId, transform) {return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:case "end":return _context3.stop();}}}, _callee3);}));function saveTransform(_x4, _x5, _x6) {return _saveTransform.apply(this, arguments);}return saveTransform;}()

    /**
                                                                                                                                                                                                                                                                                                                                            * Mark alignment as locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                                                                                            * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                            * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                            * @throws {Object}
                                                                                                                                                                                                                                                                                                                                            */ }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:case "end":return _context4.stop();}}}, _callee4);}));function lockAlignment(_x7, _x8) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()

    /**
                                                                                                                                                                                                                                                                                                                            * Check if alignment is locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                                                                                            * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                            * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                            * @throws {Object}
                                                                                                                                                                                                                                                                                                                            * @returns {boolean}
                                                                                                                                                                                                                                                                                                                            */ }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:case "end":return _context5.stop();}}}, _callee5);}));function isAlignmentLocked(_x9, _x10) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()

    /**
                                                                                                                                                                                                                                                                                                                                         * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                         * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                                                                                         * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                                                                                         * @param {THREE.Box3} boundingBox  - bounding box of the viewport in model space.
                                                                                                                                                                                                                                                                                                                                         * @param {string} units            - unit string of the bounding box, e.g. 'mm'.
                                                                                                                                                                                                                                                                                                                                         * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                                                                                                         */ }, { key: "saveViewport", value: function () {var _saveViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(
      versionUrn, viewablePartId, regionId, boundingBox, units) {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:case "end":return _context6.stop();}}}, _callee6);}));function saveViewport(_x11, _x12, _x13, _x14, _x15) {return _saveViewport.apply(this, arguments);}return saveViewport;}()

    /**
                                                                                                                                                                                                                                                                                                                                                                           * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                                                                                                                           * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                                                                                                                           * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                                                                                                                           * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                                                                                                           * @returns {Object|null}           - Null means that no custom viewport was stored.
                                                                                                                                                                                                                                                                                                                                                                           */ }, { key: "loadViewport", value: function () {var _loadViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(
      versionUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:return _context7.abrupt("return",
                null);case 1:case "end":return _context7.stop();}}}, _callee7);}));function loadViewport(_x16, _x17, _x18) {return _loadViewport.apply(this, arguments);}return loadViewport;}()


    /**
                                                                                                                                                                                                 * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                 * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                 * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                 * @returns {object[]}               - Empty array means that no matching viewport was found.
                                                                                                                                                                                                 */ }, { key: "loadViewports", value: function () {var _loadViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(
      versionUrn, viewablePartId) {return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:return _context8.abrupt("return",
                []);case 1:case "end":return _context8.stop();}}}, _callee8);}));function loadViewports(_x19, _x20) {return _loadViewports.apply(this, arguments);}return loadViewports;}()


    /**
                                                                                                                                                                                            * @param {string} modelLineageUrn       - encoded lineageUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                            * @param {string} modelViewablePartId   - encoded viewableName of the 3D model
                                                                                                                                                                                            * @param {string} sheetLineageUrn       - encoded lineageUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                            * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                            * @param {string} [regionId]            - A UUID of the sheet's region.
                                                                                                                                                                                            * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                            */ }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(
      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:case "end":return _context9.stop();}}}, _callee9);}));function saveRelationship(_x21, _x22, _x23, _x24, _x25) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()

    /**
                                                                                                                                                                                                                                                                                                                                                                                                                   * Given a model urn & viewablePartId, return all the relationships that it's part of.
                                                                                                                                                                                                                                                                                                                                                                                                                   * 
                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {string} type              - `viewable` or `region`.
                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {string} viewablePartId    - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                                                                                                                                                   * @param {string} [regionId]        - A UUID of the sheet's region.
                                                                                                                                                                                                                                                                                                                                                                                                                   * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                                                                                                                                                   * @returns {Object[]}
                                                                                                                                                                                                                                                                                                                                                                                                                   */ }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(
      type, lineageUrn, viewablePartId, regionId) {return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:return _context10.abrupt("return",
                null);case 1:case "end":return _context10.stop();}}}, _callee10);}));function getRelationships(_x26, _x27, _x28, _x29) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }]);return AlignmentService;}();

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentServiceLS.js":
/*!****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentServiceLS.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentServiceLS; });
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/index.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(uuid__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}


var avp = Autodesk.Viewing.Private;

// Prefix used for LocalStorage entries for model-alignment
var keyPrefix = 'Autodesk.Viewing.ModelAlignment';
var APIs = {
  Transform: 'transform',
  Relationship: 'relationship' };


var RelationshipDomain = 'hypermodeling';
var RelationshipEntityTypes = {
  Viewable: "viewPart3D",
  Region: "viewPartRegion2D" };


var TokenSeparator = '__';

// get LocalStorage key from model version urn
var getKey = function getKey(api, urn) {var viewablePartId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "".concat(keyPrefix).concat(TokenSeparator).concat(api).concat(TokenSeparator).concat(urn).concat(viewablePartId.length ? "".concat(TokenSeparator).concat(viewablePartId) : "");
};

// An single alignment item stored as json in LocalStorage  
var newTransformItem = function newTransformItem(transform) {
  return {
    // Optional: Array of floats
    transform: transform ? transform.elements : null,

    // If true, we forbid changing
    isLocked: false };

};

var loadItem = function loadItem(api, urn, viewablePartId) {
  var key = getKey(api, urn, viewablePartId);
  var itemStr = avp.LocalStorage.getItem(key);
  var item = itemStr && JSON.parse(itemStr);

  // Convert array elements into LmvMatrix
  if (item === null || item === void 0 ? void 0 : item.transform) {
    item.transform = new avp.LmvMatrix4(true).fromArray(item.transform);
  }

  if (item === null || item === void 0 ? void 0 : item.regions) {
    item.regions = item.regions.map(function (region) {
      // If region contains a matrix (and it should), convert it into LmvMatrix
      if (region.transform) {
        region.transform = new avp.LmvMatrix4(true).fromArray(region.transform);
      }

      // Convert array into THREE.Box2
      region.boundingBox = new THREE.Box2().set(
      { x: region.boundingBox[0], y: region.boundingBox[1] },
      { x: region.boundingBox[2], y: region.boundingBox[3] });


      return region;
    });
  }

  return item;
};

var saveItem = function saveItem(api, urn, viewablePartId, item) {var _item, _item2;

  // If the item contains a matrix, convert it to number array first
  if ((_item = item) === null || _item === void 0 ? void 0 : _item.transform) {
    item = Object.assign({}, item);

    // Note that the Array.from(...) makes a difference here:
    // TypedArrays (like matrix.elements) are not saved as arrays by JSON-stringify, but as objects,
    // i.e., it would look like '{"0": 1, "1": 1, ... }' 
    // By converting to a JS array, the resulting json contains an actual array, i.e. "[1, 0, 0, ... ]"
    item.transform = Array.from(item.transform.elements);
  }

  if ((_item2 = item) === null || _item2 === void 0 ? void 0 : _item2.regions) {
    item = Object.assign({}, item);
    item.regions = item.regions.map(function (r) {
      var region = Object.assign({}, r);

      // If region contains a matrix (and it should), convert it to number array first
      if (region.transform) {
        region.transform = Array.from(region.transform.elements);
      }

      // Convert THREE.Box2 into a flat array.
      region.boundingBox = [region.boundingBox.min.x, region.boundingBox.min.y, region.boundingBox.max.x, region.boundingBox.max.y];
      return region;
    });
  }

  var key = getKey(api, urn, viewablePartId);
  var itemStr = JSON.stringify(item);
  avp.LocalStorage.setItem(key, itemStr);
};

// Relationship entity ID is defined by lineageUrn + viewablePart + region.
var getRelationshipEntityId = function getRelationshipEntityId(lineageUrn, viewablePart, region) {
  return "lineageUrn=".concat(lineageUrn, "&viewablePart=").concat(viewablePart).concat(region ? "&region=".concat(region) : '');
};

/* Implements model-alignment storage based on LocalStorage. */var
AlignmentServiceLS = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceLS, _AlignmentService);var _super = _createSuper(AlignmentServiceLS);

  function AlignmentServiceLS() {_classCallCheck(this, AlignmentServiceLS);return _super.call(this);

  }_createClass(AlignmentServiceLS, [{ key: "getTransform", value: function getTransform(

    versionUrn, viewablePartId, regionId) {
      // just read directly from localStorage
      // Note: It's essential to return null (not undefined) if no matrix is set,
      //       because "undefined" would indicate that the state is not in memory yet.
      var item = loadItem(APIs.Transform, versionUrn, viewablePartId, regionId);
      return (item === null || item === void 0 ? void 0 : item.transform) || null;
    }

    /**
      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
      * @param {string} [viewablePartId] - encoded viewableName of the model.
      * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
      * @returns {LmvMatrix|null}        - Null means that no custom matrix was stored. Model will use its refPointTransform in this case.
      */ }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(
      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                item = loadItem(APIs.Transform, versionUrn, viewablePartId);return _context.abrupt("return",
                item === null || item === void 0 ? void 0 : item.transform);case 2:case "end":return _context.stop();}}}, _callee);}));function loadTransform(_x, _x2) {return _loadTransform.apply(this, arguments);}return loadTransform;}()


    /**
                                                                                                                                                                                                                                               * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                               * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                               * @param {LmvMatrix4|null} transform  - LmvMatrix with 64 bit precision. Call with null to reset alignment, so that the source-file refPointTransform is used again.
                                                                                                                                                                                                                                               * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                               */ }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(
      versionUrn, viewablePartId, transform) {var item;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                item = loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();
                item.transform = transform;
                saveItem(APIs.Transform, versionUrn, viewablePartId, item);case 3:case "end":return _context2.stop();}}}, _callee2);}));function saveTransform(_x3, _x4, _x5) {return _saveTransform.apply(this, arguments);}return saveTransform;}()


    /**
                                                                                                                                                                                                                                                      * Mark alignment as locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                      * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                      * @throws {Object}
                                                                                                                                                                                                                                                      */ }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(
      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                item = loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();
                item.isLocked = true;
                saveItem(APIs.Transform, versionUrn, viewablePartId, item);case 3:case "end":return _context3.stop();}}}, _callee3);}));function lockAlignment(_x6, _x7) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}()


    /**
                                                                                                                                                                                                                                                 * Check if alignment is locked, so that it cannot be changed anymore.
                                                                                                                                                                                                                                                 * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                 * @param {string} [viewablePartId] - encoded viewableName of the model.
                                                                                                                                                                                                                                                 * @throws {Object}
                                                                                                                                                                                                                                                 * @returns {boolean}
                                                                                                                                                                                                                                                 */ }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(
      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:

                // item may be null if nothing was saved for this urn so far. In this case, isLocked is always false. 
                item = loadItem(APIs.Transform, versionUrn, viewablePartId);return _context4.abrupt("return",
                Boolean(item === null || item === void 0 ? void 0 : item.isLocked));case 2:case "end":return _context4.stop();}}}, _callee4);}));function isAlignmentLocked(_x8, _x9) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}()


    /**
                                                                                                                                                                                                                                                                      * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                      * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                      * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                      * @param {THREE.Box3} boundingBox         - bounding box of the viewport in model space.
                                                                                                                                                                                                                                                                      * @param {string} units            - unit string of the bounding box, e.g. 'mm'.
                                                                                                                                                                                                                                                                      * @throws {Object}         error   - some implementation may throw. error.msg should provide an error message.
                                                                                                                                                                                                                                                                      */ }, { key: "saveViewport", value: function () {var _saveViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(
      versionUrn, viewablePartId, regionId, boundingBox, transform) {var item, index;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
                item = loadItem(APIs.Transform, versionUrn, viewablePartId) || newTransformItem();

                if (!item.regions) {
                  item.regions = [];
                }

                // In case that this regionId already exists in the service, we'll override its content.
                index = item.regions.findIndex(function (region) {return region.regionId === regionId;});

                if (index === -1) {
                  // Otherwise, we'll create a new entry to the array.
                  index = item.regions.length;
                }

                item.regions[index] = {
                  regionId: regionId,
                  boundingBox: boundingBox,
                  transform: transform };


                saveItem(APIs.Transform, versionUrn, viewablePartId, item);case 6:case "end":return _context5.stop();}}}, _callee5);}));function saveViewport(_x10, _x11, _x12, _x13, _x14) {return _saveViewport.apply(this, arguments);}return saveViewport;}()


    /**
                                                                                                                                                                                                                                                                  * @param {string} versionUrn       - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                                                                                  * @param {string} viewablePartId   - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                                                                                  * @param {string} regionId         - unique region id.
                                                                                                                                                                                                                                                                  * @throws {Object} error           - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                  * @returns {Object|null}           - Null means that no custom viewport was stored.
                                                                                                                                                                                                                                                                  */ }, { key: "loadViewport", value: function () {var _loadViewport = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(
      versionUrn, viewablePartId, regionId) {var viewports, region;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
                viewports = this.loadViewports(versionUrn, viewablePartId);

                region = viewports.find(function (r) {return r.regionId === regionId;});if (

                region) {_context6.next = 4;break;}return _context6.abrupt("return",
                null);case 4:return _context6.abrupt("return",


                region);case 5:case "end":return _context6.stop();}}}, _callee6, this);}));function loadViewport(_x15, _x16, _x17) {return _loadViewport.apply(this, arguments);}return loadViewport;}()


    /**
                                                                                                                                                                                                         * @param {string} [versionUrn]      - encoded versionUrn, e.g. dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE
                                                                                                                                                                                                         * @param {string} [viewablePartId]  - encoded viewableName of the 2d sheet.
                                                                                                                                                                                                         * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                         * @returns {object[]}               - Empty array means that no matching viewport was found.
                                                                                                                                                                                                         */ }, { key: "loadViewports", value: function () {var _loadViewports = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(
      versionUrn, viewablePartId) {var item, regions;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
                item = loadItem(APIs.Transform, versionUrn, viewablePartId);

                regions = item === null || item === void 0 ? void 0 : item.regions;return _context7.abrupt("return",

                regions || []);case 3:case "end":return _context7.stop();}}}, _callee7);}));function loadViewports(_x18, _x19) {return _loadViewports.apply(this, arguments);}return loadViewports;}()


    ////////// Relationship Service //////////////

    /**
    * @param {string} modelLineageUrn       - encoded versionUrn of the 3D model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
    * @param {string} modelViewablePartId   - encoded viewableName of the 3D model
    * @param {string} sheetLineageUrn       - encoded versionUrn of the 2D sheet, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
    * @param {string} sheetViewablePartId   - encoded viewableName of the 2d sheet.
    * @param {string} [regionId]            - A UUID of the sheet's region.
    * @throws {Object} error                - some implementation may throw. error.msg should provide an error message.
    */ }, { key: "saveRelationship", value: function () {var _saveRelationship = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(
      modelLineageUrn, modelViewablePartId, sheetLineageUrn, sheetViewablePartId, regionId) {var sheetEntityId, modelEntityId, relationshipId, item;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:

                sheetEntityId = getRelationshipEntityId(sheetLineageUrn, sheetViewablePartId, regionId);
                modelEntityId = getRelationshipEntityId(modelLineageUrn, modelViewablePartId);

                relationshipId = Object(uuid__WEBPACK_IMPORTED_MODULE_1__["v4"])();

                // this is how this structure that it is stored in real Relationship service.
                item = {
                  id: relationshipId,
                  entities: [
                  {
                    domain: RelationshipDomain,
                    type: RelationshipEntityTypes.Region,
                    id: sheetEntityId },

                  {
                    domain: RelationshipDomain,
                    type: RelationshipEntityTypes.Viewable,
                    id: modelEntityId }] };




                // In the mock service we save the relationship according to a unique key, just like it's gonna be saved in the relationship service.
                saveItem(APIs.Relationship, relationshipId, undefined, item);case 5:case "end":return _context8.stop();}}}, _callee8);}));function saveRelationship(_x20, _x21, _x22, _x23, _x24) {return _saveRelationship.apply(this, arguments);}return saveRelationship;}()


    /**
                                                                                                                                                                                                                                                                                * Given a model urn & viewablePartId, return all the relationships that it's part of.
                                                                                                                                                                                                                                                                                * 
                                                                                                                                                                                                                                                                                * @param {string} type              - `viewable` or `region`.
                                                                                                                                                                                                                                                                                * @param {string} lineageUrn        - encoded lineageUrn of the model, e.g. dXJuOmFkc2sud2lwcWE6ZG0ubGluZWFnZTp2SlhCdld6WVFCV3FPVWd2NERyZndR
                                                                                                                                                                                                                                                                                * @param {string} viewablePartId    - encoded viewableName of the model.
                                                                                                                                                                                                                                                                                * @param {string} [regionId]        - A UUID of the sheet's region.
                                                                                                                                                                                                                                                                                * @throws {Object} error            - some implementation may throw. error.msg should provide an error message for logs.
                                                                                                                                                                                                                                                                                * @returns {Object[]}
                                                                                                                                                                                                                                                                                */ }, { key: "getRelationships", value: function () {var _getRelationships = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(
      type, lineageUrn, viewablePartId, regionId) {var results, entityId, keys, i, key, _candidate$entities, itemStr, candidate;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:
                results = [];

                entityId = getRelationshipEntityId(lineageUrn, viewablePartId, regionId);

                keys = avp.LocalStorage.getAllKeys();

                // Simulates Relationship Service `search` API. The API can look for relationships according to `domain`, `type` & `entityId`.
                for (i = 0; i < keys.length; i++) {
                  key = keys[i];

                  if (key.indexOf(APIs.Relationship) !== -1) {
                    itemStr = avp.LocalStorage.getItem(key);
                    candidate = itemStr && JSON.parse(itemStr);

                    if (candidate === null || candidate === void 0 ? void 0 : (_candidate$entities = candidate.entities) === null || _candidate$entities === void 0 ? void 0 : _candidate$entities.some(function (entity) {return entity.id === entityId && entity.type === type;})) {
                      results.push(candidate);
                    }
                  }
                }return _context9.abrupt("return",

                results);case 5:case "end":return _context9.stop();}}}, _callee9);}));function getRelationships(_x25, _x26, _x27, _x28) {return _getRelationships.apply(this, arguments);}return getRelationships;}() }]);return AlignmentServiceLS;}(_AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/ModelAlignmentService/AlignmentServiceNucleus.js":
/*!*********************************************************************!*\
  !*** ./extensions/ModelAlignmentService/AlignmentServiceNucleus.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlignmentServiceNucleus; });
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var _AlignmentCache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AlignmentCache */ "./extensions/ModelAlignmentService/AlignmentCache.js");
/* harmony import */ var _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NucleusAlignmentAPI */ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}

// Using the cache in the LocalCS implementation is primarily for testing and as a reference implementation
// for other (slower) services.




// Implements model-alignment storage based on Nucleus backend.
var AlignmentServiceNucleus = /*#__PURE__*/function (_AlignmentService) {_inherits(AlignmentServiceNucleus, _AlignmentService);var _super = _createSuper(AlignmentServiceNucleus);

  function AlignmentServiceNucleus(_ref) {var _this;var projectId = _ref.projectId,getAccessToken = _ref.getAccessToken,env = _ref.env;_classCallCheck(this, AlignmentServiceNucleus);
    _this = _super.call(this);

    // Activate error state if an error occurs
    var onError = _this.onError.bind(_assertThisInitialized(_this));
    _this.connection = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_2__["NucleusAlignmentAPI"]({ projectId: projectId, getAccessToken: getAccessToken, env: env, onError: onError });

    // Define function that the cache can use to perform batch requests 
    var fetchItems = /*#__PURE__*/function () {var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(urns) {var itemIds;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
                itemIds = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_2__["AlignedItemID"].fromUrns(urns);_context.next = 3;return (
                  _this.connection.fetchItems(itemIds));case 3:return _context.abrupt("return", _context.sent);case 4:case "end":return _context.stop();}}}, _callee);}));return function fetchItems(_x) {return _ref2.apply(this, arguments);};}();

    _this.cache = new _AlignmentCache__WEBPACK_IMPORTED_MODULE_1__["default"](fetchItems);return _this;
  }_createClass(AlignmentServiceNucleus, [{ key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(

      urns) {return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
                this.cache.fetchItems(urns);case 1:case "end":return _context2.stop();}}}, _callee2, this);}));function fetchItems(_x2) {return _fetchItems.apply(this, arguments);}return fetchItems;}() }, { key: "getTransform", value: function getTransform(


    versionUrn, viewablePartId, regionId) {
      // return transform - or undefined if not in cache
      var item = this.cache.getCachedItem(versionUrn);

      // Note: It's important to distinguish undefined vs. null here:
      //  - If the item does not exists, we don't know the state                                 => return undefined
      //  - If the item exists, but has no transform, we know that no alignment transform is set => return null.
      return item && (item.transform || null);
    } }, { key: "loadTransform", value: function () {var _loadTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(

      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.next = 2;return (
                  this.cache.getItem(versionUrn));case 2:item = _context3.sent;return _context3.abrupt("return",
                item === null || item === void 0 ? void 0 : item.transform);case 4:case "end":return _context3.stop();}}}, _callee3, this);}));function loadTransform(_x3, _x4) {return _loadTransform.apply(this, arguments);}return loadTransform;}() }, { key: "saveTransform", value: function () {var _saveTransform = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(


      versionUrn, viewablePartId, transform) {var item;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return (


                  this.cache.getItem(versionUrn));case 2:item = _context4.sent;

                // Update item in cache or create a new one
                if (item) {
                  item.transform = transform;
                } else {
                  // Transform was not saved before: Create a new item
                  item = new _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_2__["AlignedItem"]().createNew(versionUrn, transform);
                  this.cache.setItem(versionUrn, item);
                }

                // Note: If the server has changed meanwhile, we will overwrite it.
                //       Ideally, we should have some conflict handling workflow for this case.
                this.connection.saveItem(item);case 5:case "end":return _context4.stop();}}}, _callee4, this);}));function saveTransform(_x5, _x6, _x7) {return _saveTransform.apply(this, arguments);}return saveTransform;}() }, { key: "lockAlignment", value: function () {var _lockAlignment = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(


      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:_context5.next = 2;return (
                  this.cache.getItem(versionUrn));case 2:item = _context5.sent;
                item.isLocked = true;
                this.connection.saveItem(item);case 5:case "end":return _context5.stop();}}}, _callee5, this);}));function lockAlignment(_x8, _x9) {return _lockAlignment.apply(this, arguments);}return lockAlignment;}() }, { key: "isAlignmentLocked", value: function () {var _isAlignmentLocked = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(


      versionUrn, viewablePartId) {var item;return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:_context6.next = 2;return (
                  this.cache.getItem(versionUrn));case 2:item = _context6.sent;return _context6.abrupt("return",
                Boolean(item === null || item === void 0 ? void 0 : item.isLocked));case 4:case "end":return _context6.stop();}}}, _callee6, this);}));function isAlignmentLocked(_x10, _x11) {return _isAlignmentLocked.apply(this, arguments);}return isAlignmentLocked;}() }, { key: "onError", value: function onError()


    {
      // Report error state
      this.error = true;
    } }, { key: "isWorking", value: function isWorking()

    {
      return !this.error;
    } }]);return AlignmentServiceNucleus;}(_AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./extensions/ModelAlignmentService/ModelAlignmentService.js":
/*!*******************************************************************!*\
  !*** ./extensions/ModelAlignmentService/ModelAlignmentService.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelAlignmentService; });
/* harmony import */ var _AlignmentService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlignmentService */ "./extensions/ModelAlignmentService/AlignmentService.js");
/* harmony import */ var _AlignmentServiceLS__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AlignmentServiceLS */ "./extensions/ModelAlignmentService/AlignmentServiceLS.js");
/* harmony import */ var _AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AlignmentServiceNucleus */ "./extensions/ModelAlignmentService/AlignmentServiceNucleus.js");
/* harmony import */ var _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NucleusAlignmentAPI */ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js");
function _typeof(obj) {"@babel/helpers - typeof";if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _createSuper(Derived) {var hasNativeReflectConstruct = _isNativeReflectConstruct();return function _createSuperInternal() {var Super = _getPrototypeOf(Derived),result;if (hasNativeReflectConstruct) {var NewTarget = _getPrototypeOf(this).constructor;result = Reflect.construct(Super, arguments, NewTarget);} else {result = Super.apply(this, arguments);}return _possibleConstructorReturn(this, result);};}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct() {if (typeof Reflect === "undefined" || !Reflect.construct) return false;if (Reflect.construct.sham) return false;if (typeof Proxy === "function") return true;try {Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));return true;} catch (e) {return false;}}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}
var av = Autodesk.Viewing;
var namespace = AutodeskNamespace('Autodesk.ModelAlignmentService');
var myExtensionName = 'Autodesk.ModelAlignmentService';






/** 
                                                                           * This extension defines the API for managing storage of model alignment transform
                                                                           * on a backend or in local storage. It provides a local-storage based implementation for reference. 
                                                                           * The extension id is: `Autodesk.ModelAlignmentServiceAPI`
                                                                           */var
ModelAlignmentService = /*#__PURE__*/function (_av$Extension) {_inherits(ModelAlignmentService, _av$Extension);var _super = _createSuper(ModelAlignmentService);
  function ModelAlignmentService(viewer, options) {_classCallCheck(this, ModelAlignmentService);return _super.call(this,
    viewer, options);
  }return ModelAlignmentService;}(av.Extension);


// Register the extension with the extension manager.
av.theExtensionManager.registerExtension(myExtensionName, ModelAlignmentService);

namespace.AlignmentService = _AlignmentService__WEBPACK_IMPORTED_MODULE_0__["default"];
namespace.AlignmentServiceLS = _AlignmentServiceLS__WEBPACK_IMPORTED_MODULE_1__["default"];
namespace.NucleusAlignmentAPI = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["NucleusAlignmentAPI"];
namespace.AlignmentServiceNucleus = _AlignmentServiceNucleus__WEBPACK_IMPORTED_MODULE_2__["default"];
namespace.AlignedItem = _NucleusAlignmentAPI__WEBPACK_IMPORTED_MODULE_3__["AlignedItem"];

/***/ }),

/***/ "./extensions/ModelAlignmentService/NucleusAlignmentAPI.js":
/*!*****************************************************************!*\
  !*** ./extensions/ModelAlignmentService/NucleusAlignmentAPI.js ***!
  \*****************************************************************/
/*! exports provided: AlignedItemID, AlignedItem, NucleusAlignmentAPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignedItemID", function() { return AlignedItemID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignedItem", function() { return AlignedItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NucleusAlignmentAPI", function() { return NucleusAlignmentAPI; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var av = Autodesk.Viewing;
var avp = av.Private;

// We use the DefaultSpaceId for all requests
var DefaultSpaceId = 'default';

// For debugging: Display reports of fetched/posted transforms
var DEBUG_OUTPUT = false;

// Only for debugging: Find model name for given encoded urn
var urnToModelName = function urnToModelName(urn) {
  var nodes = LMV_MAIN_VIEW.getVisibleNodes();
  var node = nodes.find(function (node) {return node.getRootNode().urn() == urn;});
  return (node === null || node === void 0 ? void 0 : node.getModelName()) || "Unknown urn: ".concat(urn);
};

// Combines strings to uniquely address an AlignedItem for 2D or 3D.
var AlignedItemID = /*#__PURE__*/function () {

  // @param {string} urn - base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
  function AlignedItemID(versionUrn) {var viewablePartId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;var regions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;_classCallCheck(this, AlignedItemID);

    // base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
    this.versionUrn = versionUrn;

    // Only used for 2D: Id of view and region within the model
    this.viewablePartId = viewablePartId;
    this.regions = regions;
  }

  // Convert array of urn strings to AlignedItem (if no partIds are needed) 
  //  @param {string[]} 
  _createClass(AlignedItemID, [{ key: "toObject",



    // Convert into object that we can serialize into a json request body
    value: function toObject() {
      return {
        // Note that (unlike most LMV code) alignment service backend works with decoded urns.
        versionUrn: avp.fromUrlSafeBase64(this.versionUrn),

        // Make sure they are set to undefined unless actually specified
        viewablePartId: this.viewablePartId || undefined,
        regions: this.regions || undefined };

    } }], [{ key: "fromUrns", value: function fromUrns(urns) {return urns && urns.map(function (urn) {return new AlignedItemID(urn);});} }]);return AlignedItemID;}();


// All data that is stored by the service per aligned item. 
var AlignedItem = /*#__PURE__*/function () {

  function AlignedItem(versionUrn) {_classCallCheck(this, AlignedItem);
    this.init(versionUrn);
  }_createClass(AlignedItem, [{ key: "init", value: function init(

    versionUrn) {
      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., "51a0d0bea901804d3e1870ea337b965d"
      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.
      this.checksum = undefined;

      // {LMVMatrix4} Initially assume null = "no alignment transform set".
      this.transform = null;

      // {bool} whether alignment is locked
      this.isLocked = false;

      // {string} e.g., "2020-11-23T21:54:28.9862331+00:00"
      this.updatedAt = undefined;

      // {string} oxygenId of the last user who updated it
      this.updatedBy = undefined;

      // base64-encoded versionUrn, e.g. "dXJuOmFkc2sud2lwc3RnOmZzLmZpbGU6dmYuYi1oeldxakxTS0c2VlZvVTRZNm5KQT92ZXJzaW9uPTE"
      this.versionUrn = versionUrn;
    }

    // Init new item before saving a transform for the first time
    //  @param {string}     versionUrn - base64-encoded versionUrn
    //  @param {LmvMatrix4} transform
  }, { key: "createNew", value: function createNew(versionUrn, transform) {
      this.init();
      this.versionUrn = versionUrn;
      this.transform = transform;
      return this;
    }

    // Set from data that we got from alignment service
  }, { key: "load", value: function load(data) {

      // Note: The serivce works with unencoded versionUrns, e.g. 'urn:adsk.wipstg:fs.file:vf.vSenZnaYQAOAZqzHB54kLQ?version=1'.
      //       However, the rest of LMV usually uses encoded ones. So, we only use the decoded ones when receiving or sending service data.
      this.versionUrn = avp.toUrlSafeBase64(data.versionUrn);

      // {string} Generated by AlignmentSerivce. Needed to send requests to change this item, e.g., "51a0d0bea901804d3e1870ea337b965d"
      //          May be undefined if item was not saved before. Mandatory if item exists on the backend.
      this.checksum = data.checksum;

      // {bool} whether alignment is locked
      this.isLocked = data.isLocked || false;

      // {string} e.g., "2020-11-23T21:54:28.9862331+00:00"
      this.updatedAt = data.updatedAt;

      // {string} oxygenId of the last user who updated it
      this.updatedBy = data.updatedBy;

      // Create LmvMatrix4 from float array
      this.transform = Array.isArray(data === null || data === void 0 ? void 0 : data.transform) ? new avp.LmvMatrix4(true).fromArray(data === null || data === void 0 ? void 0 : data.transform) : null;

      return this;
    }

    // Returns true if the item was not saved to alignment service before. In this case, we
    // need to create the item in order to save it.
  }, { key: "isNew", value: function isNew() {
      return !this.checksum;
    }

    // Convert into object that we can serialize into a json request body
  }, { key: "toObject", value: function toObject() {
      return {
        checksum: this.checksum,
        isLocked: this.isLocked,
        transform: this.transform && Array.from(this.transform.elements),
        versionUrn: avp.fromUrlSafeBase64(this.versionUrn) // alignmentService requires decoded urns
      };
    } }]);return AlignedItem;}();


// Helper class for retrying requests
var Retry = /*#__PURE__*/function () {

  function Retry() {_classCallCheck(this, Retry);

    // Maximum number of attempts before giving up
    this.maxAttempts = 10;

    // Waiting time in ms for first retry
    this.startDelay = 100;

    // Exponential grow factor for the waiting time per attempt
    this.growFactor = 1.1;
  }

  // Returns the waiting time in ms before retrying.    
  _createClass(Retry, [{ key: "getWaitingTime", value: function getWaitingTime(numFailedAttempts) {
      return numFailedAttempts ? this.startDelay * Math.pow(this.growFactor, numFailedAttempts - 1) : 0;
    }

    // Try the given (async) callback until either successful or until maximum retry count is reached.
    //  - Return value is the last result of callback
    //  - Callback is considered successful if isSuccess(result) is true.
  }, { key: "run", value: function run(callback, isSuccess) {var _this = this;

      return new Promise(function (resolve) {

        // track number of attempts
        var numFailedAttempts = 0;

        var nextTry = /*#__PURE__*/function () {var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {var result, delayInMs;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                      callback());case 2:result = _context.sent;if (!


                    isSuccess(result)) {_context.next = 5;break;}return _context.abrupt("return",
                    resolve(result));case 5:


                    // Give up if we reached the limit
                    numFailedAttempts++;if (!(
                    numFailedAttempts >= _this.maxAttempts)) {_context.next = 8;break;}return _context.abrupt("return",
                    resolve(result));case 8:


                    // schedule next attempt
                    delayInMs = _this.getWaitingTime(numFailedAttempts);
                    window.setTimeout(nextTry, delayInMs);case 10:case "end":return _context.stop();}}}, _callee);}));return function nextTry() {return _ref.apply(this, arguments);};}();

        nextTry();
      });
    } }]);return Retry;}();


// Choose serviceUrl based on lmv environment (e.g. 'https://developer-stg.api.autodesk.com/construction/alignment' for staging)
var getDefaultServiceUrl = function getDefaultServiceUrl() {
  var envConfig = av.EnvironmentConfigurations[av.getEnv()];
  var baseUrl = envConfig.UPSTREAM || envConfig.ROOT;
  return baseUrl + '/construction/alignment';
};

var getDefaultToken = function getDefaultToken() {
  return av.token.accessToken;
};

// Helper class to communicate with Nucleus AlignmentService backend
//
// Note:
//  - All urns must belong to the same projectUrn
//  - Particularly, projectUrn must not change at runtime.
var NucleusAlignmentAPI = /*#__PURE__*/function () {

  // @param {string}           projectId             - E.g., 'e8c04026-1dc3-473b-bf1e-deedac2576ee'.
  // @param {async ()=>string} [getAccessToken]      - By default, we get the token from LMV.
  // @param {string}           [serviceBaseUrl]      - Automatically derived from LMV env by default. E.g. 'https://developer-stg.api.autodesk.com/construction/alignment'
  // @param {string}           [serviceVersion="v1"]
  // @param {function()}       [onError]
  function NucleusAlignmentAPI()





  {var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},projectId = _ref2.projectId,_ref2$getAccessToken = _ref2.getAccessToken,getAccessToken = _ref2$getAccessToken === void 0 ? getDefaultToken : _ref2$getAccessToken,_ref2$serviceBaseUrl = _ref2.serviceBaseUrl,serviceBaseUrl = _ref2$serviceBaseUrl === void 0 ? getDefaultServiceUrl() : _ref2$serviceBaseUrl,_ref2$serviceVersion = _ref2.serviceVersion,serviceVersion = _ref2$serviceVersion === void 0 ? "v1" : _ref2$serviceVersion,_ref2$onError = _ref2.onError,onError = _ref2$onError === void 0 ? null : _ref2$onError;_classCallCheck(this, NucleusAlignmentAPI);

    this.projectId = projectId;
    this.getAccessToken = getAccessToken;
    this.onError = onError;

    this.serviceUrl = "".concat(serviceBaseUrl, "/").concat(serviceVersion);

    // Endpoint to read/write alignment items
    this.itemsEndPoint = "/projects/".concat(projectId, "/spaces/").concat(DefaultSpaceId, "/items");

    // Use default request retry settings
    this.retry = new Retry();
  }

  // Result is an object { success, response }.
  _createClass(NucleusAlignmentAPI, [{ key: "sendRequest", value: function () {var _sendRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(operation) {var body,postfix,result,url,token,_args2 = arguments;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:body = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;postfix = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : '';

                result = {
                  success: false,
                  data: null };


                url = this.serviceUrl + this.itemsEndPoint + postfix;_context2.next = 6;return (
                  this.getAccessToken());case 6:token = _context2.sent;_context2.next = 9;return (

                  new Promise(function (resolve) {

                    var xhr = new XMLHttpRequest();
                    xhr.open(operation, url, true);
                    xhr.setRequestHeader('Content-Type', 'application/json');
                    xhr.setRequestHeader('accept', 'application/json');
                    xhr.setRequestHeader('Access-Control-Allow-Origin', '*');
                    xhr.setRequestHeader('Authorization', 'Bearer ' + token);

                    // On failure: resolve with result.success == false
                    var onFailure = function onFailure() {
                      resolve(result);
                    };

                    // Parse response as json on success
                    var onLoad = function onLoad() {

                      // Even if the request didn't trigger an error callback,
                      // the server response may still indicate an error (e.g. this happens on authorization failure) 
                      if (xhr.status < 200 || xhr.status >= 300) {
                        onFailure();
                        return;
                      }

                      try {
                        // If json parsing succeeds, return success
                        // Some requests (e.g. DELETE) may also get an empty string as result on success, but JSON.parse() would
                        // fail on those. Therefore, we accept empty responses as well and just set data to null for this case. 
                        result.data = xhr.response ? JSON.parse(xhr.response) : null;
                        result.success = true;
                        resolve(result);
                      } catch (e) {
                        // json parsing failed.
                        onFailure();
                      }
                    };

                    xhr.onload = onLoad;
                    xhr.onerror = function () {return onFailure;};
                    xhr.ontimeout = function () {return onFailure;};
                    xhr.onabort = function () {return onFailure;};

                    xhr.send(body && JSON.stringify(body));
                  }));case 9:return _context2.abrupt("return", _context2.sent);case 10:case "end":return _context2.stop();}}}, _callee2, this);}));function sendRequest(_x) {return _sendRequest.apply(this, arguments);}return sendRequest;}() }, { key: "sendRequestWithRetry", value: function () {var _sendRequestWithRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(


      operation) {var _this2 = this;var body,postfix,doRequest,isSuccess,_args3 = arguments;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:body = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;postfix = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : '';
                doRequest = function doRequest() {return _this2.sendRequest(operation, body, postfix);};
                isSuccess = function isSuccess(res) {return res.success;};_context3.next = 6;return (
                  this.retry.run(doRequest, isSuccess));case 6:return _context3.abrupt("return", _context3.sent);case 7:case "end":return _context3.stop();}}}, _callee3, this);}));function sendRequestWithRetry(_x2) {return _sendRequestWithRetry.apply(this, arguments);}return sendRequestWithRetry;}()


    // Batch-request multiple items
    //
    // @param {AlignedItemID[]} items
    // @returns {Object|undefined} A dictionary of AlignedItems, indexed by (encoded) versionUrn. Undefined on failure. 
  }, { key: "fetchItems", value: function () {var _fetchItems = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(items) {var result, body, i, postFix, res, response, loadedItems, _i, urn, data, report, _i2, name, _data;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:

                result = {};

                // Avoid sending a request if the list is empty anyway.
                if (items.length) {_context4.next = 3;break;}return _context4.abrupt("return",
                result);case 3:


                // List items in request body
                body = {};
                for (i = 0; i < items.length; i++) {
                  body[i] = items[i].toObject();
                }

                postFix = ':getBatch';_context4.next = 8;return (
                  this.sendRequestWithRetry('POST', body, postFix));case 8:res = _context4.sent;if (


                res.success) {_context4.next = 12;break;}
                this.onError();return _context4.abrupt("return");case 12:



                // get response data (should exist)
                response = res.data;if (
                response) {_context4.next = 16;break;}
                // Even if there are no alignments at all, the return value should be an empty object at the minimum
                console.warn('Unepxected request response: items:getBatch should get an empty response');return _context4.abrupt("return");case 16:


                loadedItems = response.results;

                // get alignment data from each item.
                // Response is not an array, but the keys for indexing are the same as we used in the body,
                // so that they will just be indexed by array indices into the items array.
                for (_i = 0; _i < items.length; _i++) {

                  // get encoded versionUrn 
                  urn = items[_i].versionUrn;

                  // Add items to result map, indexed by versionUrn.
                  // data will be null if no data was saved for this item before.
                  // In this case, we return a new "blank" AlignedItem, i.e. no transform and isLocked = false.
                  data = loadedItems && loadedItems[_i];
                  result[urn] = data ? new AlignedItem().load(data) : new AlignedItem(urn);
                }

                // Optional debug output
                if (DEBUG_OUTPUT) {
                  report = {};
                  for (_i2 = 0; _i2 < items.length; _i2++) {
                    name = urnToModelName(items[_i2].versionUrn);
                    _data = loadedItems && loadedItems[_i2];
                    report[name] = _data || 'No alignment';
                  }
                  console.log('Fetch successful:', report);
                }return _context4.abrupt("return",

                result);case 20:case "end":return _context4.stop();}}}, _callee4, this);}));function fetchItems(_x3) {return _fetchItems.apply(this, arguments);}return fetchItems;}()


    // Store alignment item or create a new one.
  }, { key: "saveItem", value: function () {var _saveItem = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(item) {var body, operation, res, name, report;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:

                body = item.toObject();

                // Decide which operation to perform:
                //  - POST:   Item doesn't exist on alignment service yet => Create a new one.
                //  - PATCH:  Modify transform of existing item.
                //  - DELETE: When reverting a previously saved transform, we delete the alignment item.
                //            Note that this can only happen if the isLocked flag is false anyway, so we don't need the item anymore.
                operation = item.isNew() ? 'POST' : item.transform ? 'PATCH' : 'DELETE';_context5.next = 4;return (
                  this.sendRequestWithRetry(operation, body));case 4:res = _context5.sent;if (

                res.success) {_context5.next = 8;break;}
                this.onError();return _context5.abrupt("return");case 8:



                // On success, update item with response from AlignmentService. Transform should usually
                // keep the same, but checksum and timestamp will change.
                if (res.data) {
                  item.load(res.data);
                } else {
                  // If operation is delete, the response will be empty. In this case, we can keep the cache
                  // item as it is, because it already indicates that no transform is set.
                  operation == 'DELETE' || console.warn('Unexpected request result: POST or PATCH should always respond an update item state');
                }

                // Optional debug output
                if (DEBUG_OUTPUT) {
                  name = urnToModelName(item.versionUrn);
                  report = {
                    model: name,
                    response: res.data,
                    operation: operation };


                  console.log('Transform saved: ', report);
                }case 10:case "end":return _context5.stop();}}}, _callee5, this);}));function saveItem(_x4) {return _saveItem.apply(this, arguments);}return saveItem;}() }]);return NucleusAlignmentAPI;}();

/***/ }),

/***/ "./node_modules/uuid/index.js":
/*!************************************!*\
  !*** ./node_modules/uuid/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(/*! ./v1 */ "./node_modules/uuid/v1.js");
var v4 = __webpack_require__(/*! ./v4 */ "./node_modules/uuid/v4.js");

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/uuid/v4.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ })

/******/ });
//# sourceMappingURL=ModelAlignmentService.js.map