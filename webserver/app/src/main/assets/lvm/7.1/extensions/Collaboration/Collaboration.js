/*!
 * LMV v7.1.1
 * 
 * Copyright 2019 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Collaboration =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Collaboration/Collaboration.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/Collaboration/CollabClient.js":
/*!**************************************************!*\
  !*** ./extensions/Collaboration/CollabClient.js ***!
  \**************************************************/
/*! exports provided: InteractionInterceptor, ViewTransceiver */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InteractionInterceptor", function() { return InteractionInterceptor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ViewTransceiver", function() { return ViewTransceiver; });


var av = Autodesk.Viewing,
avp = av.Private;

function InteractionInterceptor(viewtx) {

  this.getNames = function () {
    return ["intercept"];
  };

  this.getName = function () {
    return "intercept";
  };

  this.activate = function (name) {};
  this.deactivate = function (name) {};
  this.update = function (timeStamp) {return false;};

  this.handleSingleClick = function (event, button) {return false;};
  this.handleDoubleClick = function (event, button) {return false;};
  this.handleSingleTap = function (tap) {return false;};
  this.handleDoubleTap = function (tap1, tap2) {return false;};
  this.handleKeyDown = function (event, keyCode) {return false;};
  this.handleKeyUp = function (event, keyCode) {return false;};

  this.handleWheelInput = function (delta) {
    viewtx.takeControl();
    return false;
  };

  this.handleButtonDown = function (event, button) {
    viewtx.takeControl();
    return false;
  };

  this.handleButtonUp = function (event, button) {return false;};
  this.handleMouseMove = function (event) {
    viewtx.updatePointer(event);
    return false;
  };

  this.handleGesture = function (event) {
    viewtx.takeControl();
    return false;
  };

  this.handleBlur = function (event) {return false;};
  this.handleResize = function () {};
};

function ViewTransceiver(client) {

  var _this = this;
  var _viewer = this.viewer = null;
  var _blockEvents = false;
  var _haveControl = false;
  var _isDisconnected = false;
  var _lastInControl;
  var _client = this.client = client;
  var _ray = new THREE.Ray();
  var _pointer = null;
  var _pointerOn = false;

  this.channelId = null;

  var _viewerState;
  var VIEWER_STATE_FILTER = {
    seedURN: false,
    objectSet: true,
    viewport: false,
    cutplanes: true,
    renderOptions: {
      environment: false,
      ambientOcclusion: false,
      toneMap: {
        exposure: false },

      appearance: false } };




  function onViewerState(evt) {
    _blockEvents = true;
    var state = JSON.parse(evt.data.msg);
    _viewerState.restoreState(state);
    _viewer.impl.invalidate(true, false, true);
    _blockEvents = false;
  }

  function reduceBits(v) {
    return Math.round(v * 1000) / 1000;
  }

  function reduceBitsV(v) {
    for (var i = 0; i < v.length; i++) {
      v[i] = reduceBits(v[i]);}
  }

  function onCamera(e) {
    var v = e.data.msg;

    if (v[1] === true || _isDisconnected)
    {
      return;
    }

    if (v[0] != _lastInControl)
    {
      _lastInControl = v[0];
      e.data.lastInControl = v[0];
      _this.dispatchEvent({ type: "controlChange", channelId: _this.channelId, data: e.data });
    }

    //For now, automatically relinquish camera control if we receive a remote command to move the camera
    _haveControl = false;

    /*
                                      viewer.navigation.setRequestTransitionWithUp(true, new THREE.Vector3().set(v[1+0],v[1+1],v[1+2]),
                                                                                          new THREE.Vector3().set(v[1+3],v[1+4],v[1+5]),
                                                                                          _viewer.navigation.getCamera().fov,
                                                                                          new THREE.Vector3().set(v[1+6],v[1+7],v[1+8]));
                          */

    _viewer.navigation.setView(new THREE.Vector3().set(v[2 + 0], v[2 + 1], v[2 + 2]),
    new THREE.Vector3().set(v[2 + 3], v[2 + 4], v[2 + 5]));
    _viewer.navigation.setCameraUpVector(new THREE.Vector3().set(v[2 + 6], v[2 + 7], v[2 + 8]));
  }

  function sendCamera(evt) {
    if (!_haveControl && !_isDisconnected)
    return;

    var c = evt.camera;
    var camParams = [c.position.x, c.position.y, c.position.z,
    c.target.x, c.target.y, c.target.z,
    c.up.x, c.up.y, c.up.z];


    reduceBitsV(camParams);
    camParams.unshift(_isDisconnected);
    camParams.unshift(client.getLocalId());

    _client.sendMessage("camera", camParams, _this.channelId);

    if (_lastInControl != camParams[0]) {
      _lastInControl = camParams[0];
      _this.dispatchEvent({ type: "controlChange", channelId: _this.channelId, data: { lastInControl: _lastInControl } });
    }
  }


  function showPointer(show, x, y) {

    if (show && !_pointer) {
      _pointer = document.createElement("div");
      _pointer.classList.add("collabPointer");
    }

    if (show && !_pointerOn) {
      _viewer.container.appendChild(_pointer);
      _pointerOn = true;
    } else
    if (!show && _pointerOn) {
      _viewer.container.removeChild(_pointer);
      _pointerOn = false;
    }

    if (show) {
      //Note the 4px is half the width/height specified in the CSS,
      //so that the pointer is centered.
      _pointer.style.left = x - 6 + "px";
      _pointer.style.top = y - 6 + "px";
    }

  }

  function onPointer(e) {

    if (_haveControl)
    return; //shouldn't get here in theory, but let's check just in case

    if (_isDisconnected)
    return; //we can't show the pointer if the views don't match

    var v = e.data.msg;
    _ray.origin.set(v[1], v[2], v[3]);
    _ray.direction.set(v[4], v[5], v[6]);

    var pt = _ray.at(_viewer.getCamera().near);
    pt.project(_viewer.getCamera());

    pt = _viewer.impl.viewportToClient(pt.x, pt.y);

    //console.log(pt.x + " " + pt.y);
    showPointer(true, pt.x, pt.y);
  }


  function sendPointer(evt) {
    if (!_haveControl)
    return;

    //Note canvasX/Y are set by the ToolController to clientX/Y - canvas left/top.
    var vpVec = _viewer.impl.clientToViewport(evt.canvasX, evt.canvasY);
    _viewer.impl.viewportToRay(vpVec, _ray);

    var rayParams = [_ray.origin.x, _ray.origin.y, _ray.origin.z,
    _ray.direction.x, _ray.direction.y, _ray.direction.z];

    reduceBitsV(rayParams);
    rayParams.unshift(client.getLocalId());

    _client.sendMessage("pointer", rayParams, _this.channelId);
  }


  function sendViewerState(e) {
    //if (!_haveControl)
    //    return;
    if (_blockEvents)
    return;

    var state = _viewerState.getState(VIEWER_STATE_FILTER);

    // TODO: if we kill the socket.io code path, this could be optimized
    // too by removing the JSON.stringify of the state. Pubnub automatically
    // does JSON serialization for us, with optimizations accordingly to their manual.
    client.sendMessage("state", JSON.stringify(state), _this.channelId);
  }


  this.takeControl = function () {
    _haveControl = true;
    showPointer(false);
  };

  this.updatePointer = function (e) {
    sendPointer(e);
  };

  this.connectCamera = function (set) {
    _isDisconnected = !set;
  };

  this.attach = function (viewer) {

    if (_viewer)
    this.detach();

    this.viewer = _viewer = viewer;
    _viewerState = new avp.ViewerState(_viewer);

    _client.addEventListener("cameraChange", onCamera);
    _client.addEventListener("pointerMove", onPointer);
    _client.addEventListener("viewerState", onViewerState);


    if (!_viewer.hasEventListener(av.CAMERA_CHANGE_EVENT, sendCamera))
    _viewer.addEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

    if (!_viewer.hasEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState)) {
      _viewer.addEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
      _viewer.addEventListener(av.ISOLATE_EVENT, sendViewerState);
      _viewer.addEventListener(av.HIDE_EVENT, sendViewerState);
      _viewer.addEventListener(av.SHOW_EVENT, sendViewerState);
      _viewer.addEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
      _viewer.addEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
      _viewer.addEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);
    }
  };


  this.detach = function () {

    if (_client) {
      _client.removeEventListener("cameraChange", onCamera);
      _client.removeEventListener("viewerState", onViewerState);
    }

    if (_viewer) {
      _viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

      _viewer.removeEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
      _viewer.removeEventListener(av.ISOLATE_EVENT, sendViewerState);
      _viewer.removeEventListener(av.HIDE_EVENT, sendViewerState);
      _viewer.removeEventListener(av.SHOW_EVENT, sendViewerState);
      _viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
      _viewer.removeEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
      _viewer.removeEventListener(av.CUTPLANES_CHANGE_EVENT, sendViewerState);

      this.viewer = _viewer = null;
      _viewerState = null;
    }
  };

};

ViewTransceiver.prototype.constructor = ViewTransceiver;
Autodesk.Viewing.EventDispatcher.prototype.apply(ViewTransceiver.prototype);

/***/ }),

/***/ "./extensions/Collaboration/CollabUI.css":
/*!***********************************************!*\
  !*** ./extensions/Collaboration/CollabUI.css ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./CollabUI.css */ "./node_modules/css-loader/index.js!./extensions/Collaboration/CollabUI.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Collaboration/CollabUI.js":
/*!**********************************************!*\
  !*** ./extensions/Collaboration/CollabUI.js ***!
  \**********************************************/
/*! exports provided: DockingCollabPanel, CollabPromptBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DockingCollabPanel", function() { return DockingCollabPanel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollabPromptBox", function() { return CollabPromptBox; });

var av = Autodesk.Viewing,
ave = av.Extensions,
avp = av.Private,
avec = ave.Collaboration;

/**
                           *  Start a Live Review Session.
                           */
Autodesk.Viewing.startLiveReviewSession = function () {
  if (!avec.Panel) return;
  avec.Panel.startSession();
};

/**
    *  End a Live Review Session.
    */
Autodesk.Viewing.endLiveReviewSession = function () {
  if (!avec.Panel) return;
  avec.Panel.endSession();
};

//==================================================================================

function DockingCollabPanel(viewer, client, viewtx) {

  this.viewer = viewer;
  this.client = client;
  this.viewtx = viewtx;

  var panelId = 'CollabPanel';
  av.UI.DockingPanel.call(this, viewer.container, panelId, 'Live review');

  this.container.classList.add('collabPanel');

  this.container.style.height = "auto";
  this.container.dockRight = true;

  this.content = document.createElement("div");
  this.container.appendChild(this.content);
  this.content.classList.add("collabPanelContent");

  //Users list
  this.tableContainer = document.createElement("div");
  this.tableContainer.classList.add("userListTable", "docking-panel-scroll");

  this.table = document.createElement("table");
  this.table.classList.add("adsk-lmv-tftable");
  this.tbody = document.createElement("tbody");
  this.table.appendChild(this.tbody);

  this.tableContainer.appendChild(this.table);
  this.content.appendChild(this.tableContainer);

  // Invite button
  this.inviteDiv = document.createElement('div');
  this.inviteDiv.className = 'collabBoxOK';
  this.inviteDiv.style.float = 'left';
  this.inviteDiv.style.width = '232px';
  this.inviteDiv.setAttribute("data-i18n", "Invite");
  this.inviteDiv.textContent = Autodesk.Viewing.i18n.translate("Invite");
  this.content.appendChild(this.inviteDiv);
  this.inviteDiv.addEventListener("click", function (event) {
    var w = new CollabPromptBox();
    var container = viewer.container;
    w.start(container, function () {
      var subject = Autodesk.Viewing.i18n.translate("Please Join My Live Review");
      document.location.href = "mailto:?subject=" + subject;
    }, "Invite Others", "Email Invite", true);
  });

  //Chat history
  this.chatHistory = document.createElement("div");
  this.chatHistory.classList.add("chatHistory");
  this.chatHistory.classList.add("textEntry");
  this.chatHistory.classList.add("docking-panel-scroll");
  this.content.appendChild(this.chatHistory);


  //Text input entry
  this.chatPanel = document.createElement("div");
  this.chatPanel.classList.add("chatPanel");

  this.textInput = document.createElement("input");
  this.textInput.type = "text";
  this.textInput.classList.add("textEntry");
  this.textInput.placeholder = Autodesk.Viewing.i18n.translate("Type a message");
  this.chatPanel.appendChild(this.textInput);

  this.content.appendChild(this.chatPanel);

  this.isCameraConnected = true;

  var scope = this;

  this.addEventListener(client, "userListChange", function (e) {

    //Collab panel only cares about events on the collaboration channel
    if (e.channelId && e.channelId !== scope.viewtx.channelId)
    return;

    var ci = scope.client.getChannelInfo(scope.viewtx.channelId);
    if (!ci)
    return;

    scope.updateUsers(ci.users);
  });

  this.addEventListener(this.viewtx, "controlChange", function (e) {

    //Collab panel only cares about events on the collaboration channel
    if (e.channelId !== scope.viewtx.channelId)
    return;

    scope.updateUserInControl(e.data.lastInControl);
  });

  this.addEventListener(client, "chatReceived", function (e) {

    //Collab panel only cares about events on the collaboration channel
    if (e.channelId !== scope.viewtx.channelId)
    return;

    scope.updateChatHistory(e);
  });

  this.textInput.onkeyup = function (e) {
    scope.handleChatInput(e);
  };

}

DockingCollabPanel.prototype = Object.create(av.UI.DockingPanel.prototype);
DockingCollabPanel.prototype.constructor = DockingCollabPanel;

DockingCollabPanel.prototype.startSession = function () {
  var scope = this;
  var isVisible = this.isVisible();
  if (isVisible) return;
  var w = new CollabPromptBox();
  var container = this.viewer.container;
  w.start(container, function () {
    scope.setVisible(true, true);
  }, "Start a Live Review", "Start Review");
};

DockingCollabPanel.prototype.endSession = function () {
  var isVisible = this.isVisible();
  if (!isVisible) return;
  this.setVisible(false, true);
  this.reset();
};

DockingCollabPanel.prototype.updateUsers = function (users) {

  var scope = this;

  var tbody = document.createElement("tbody");

  for (var i = 0; i < users.length; i++) {
    var row = tbody.insertRow(-1);
    row.id = users[i].id;

    var statusCell = row.insertCell(0);
    statusCell.style.width = "14px";
    statusCell.style.cursor = "default";
    var statusIcon = document.createElement("div");
    statusIcon.classList.add("statusBase");
    statusIcon.classList.add("statusNormal");
    statusIcon.innerHTML = "&#9679";
    statusCell.appendChild(statusIcon);

    var nameCell = row.insertCell(1);
    nameCell.textContent = users[i].name;
  }

  this.table.replaceChild(tbody, this.tbody);
  this.tbody = tbody;

  this.fixComponentPlacement();
};

DockingCollabPanel.prototype.updateUserInControl = function (id) {
  for (var i = 0; i < this.tbody.rows.length; i++) {
    var r = this.tbody.rows[i];
    var icon = r.cells[0].childNodes[0];
    if (r.id == id) {
      icon.classList.remove("statusNormal");
      icon.classList.add("statusInControl");
      icon.innerHTML = "&#9784";
      r.cells[1].style.color = "#4CBA36";
    } else {
      icon.classList.remove("statusInControl");
      icon.classList.add("statusNormal");
      icon.innerHTML = "&#9679";
      r.cells[1].style.color = "#ffffff";
    }

  }
};

DockingCollabPanel.prototype.updateChatHistory = function (e) {

  var user = this.client.getUserById(e.data.from, e.channelId);

  //skip command strings
  if (e.data.msg.charAt(0) == "/")
  return;

  //        var line = user.name + ": " + e.data.msg;

  if (this.chatHistory.lastUser != user.name) {

    var pEl = document.createElement("p");

    var nameEl = document.createElement("div");
    nameEl.classList.add("heading");
    nameEl.style.float = "left";
    nameEl.style.fontStyle = "normal";
    nameEl.style.color = "#857E7E";
    nameEl.textContent = user.name;
    pEl.appendChild(nameEl);

    var timeEl = document.createElement("div");
    timeEl.classList.add("heading");
    timeEl.style.textAlign = "right";
    timeEl.style.fontStyle = "normal";
    timeEl.style.color = "#857E7E";
    timeEl.textContent = new Date().toLocaleTimeString();
    pEl.appendChild(timeEl);

    this.chatHistory.appendChild(pEl);

    this.chatHistory.lastUser = user.name;
  } else {
    var br = document.createElement("br");
    this.chatHistory.appendChild(br);
  }

  var msgEl = document.createElement("span");
  msgEl.classList.add("messageText");
  msgEl.textContent = e.data.msg;
  this.chatHistory.appendChild(msgEl);

  this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
};

DockingCollabPanel.prototype.handleChatInput = function (e) {
  if (e.which != 13)
  return;
  if (this.textInput.value.length == 0)
  return;

  this.client.sendChatMessage(this.textInput.value, this.viewtx.channelId);
  this.textInput.value = "";
  this.textInput.placeholder = "";
};

DockingCollabPanel.prototype.fixComponentPlacement = function (e) {

  var heightAdj = this.tableContainer.offsetHeight + this.chatPanel.offsetHeight;

  if (this.videoPanel) {
    heightAdj += this.videoPanel.offsetHeight;
    this.chatHistory.style.height = "calc(100% - " + heightAdj + "px)";
  } else
  {
    this.chatHistory.style.height = "calc(100% - " + heightAdj + "px)";
  }

};

DockingCollabPanel.prototype.removeCollabPrompt = function () {
  var box = document.getElementById("collabBox");
  if (box) {
    box.style.visibility = "hidden";
    this.viewer.container.removeChild(box);
  }
};

DockingCollabPanel.prototype.removeVideoPanel = function () {
  if (this.videoPanel)
  this.content.removeChild(this.videoPanel);
  this.videoPanel = null;
};

DockingCollabPanel.prototype.reset = function (e) {
  if (this.tbody) {
    var empty = document.createElement("tbody");
    this.table.replaceChild(empty, this.tbody);
    this.tbody = empty;
  }
  this.chatHistory.textContent = "";
  this.textInput.value = "";
  this.removeVideoPanel();
  this.removeCollabPrompt();
};


function CollabPromptBox() {};
CollabPromptBox.prototype.start = function (container, cb, titleText, buttonText, isInviteWindow) {
  if (!container) return;

  // Prevent multiple instantiations of invite boxes by spamming the 'Invite' button in collab panel.
  if (document.getElementById("collabBox")) {
    return;
  }

  var box = document.createElement("div");
  // If you change this id, make sure this.collabButton.onClick also updated to reflect new id.
  box.id = "collabBox";
  box.className = "collabBox";
  container.appendChild(box);

  var title = document.createElement("div");
  title.className = "collabBoxTitle";
  title.textContent = Autodesk.Viewing.i18n.translate(
  titleText,
  { "defaultValue": titleText });
  box.appendChild(title);

  var text = document.createElement("span");
  text.className = "collabBoxText";
  var label = "Enter your name";
  if (isInviteWindow) {
    label = "Review URL";
  }
  text.textContent = Autodesk.Viewing.i18n.translate(
  label,
  { "defaultValue": label });
  box.appendChild(text);

  var inputContainer = document.createElement("span");
  inputContainer.className = "collabBoxInputContainer";
  box.appendChild(inputContainer);
  var input = document.createElement("input");
  input.type = "text";
  input.className = "collabBoxInputText";
  if (isInviteWindow) {
    var url = window.location.toString();
    if (url.indexOf("?") == -1) {
      url += "?invited=true";
    } else {
      url += "&invited=true";
    }
    if (Autodesk.Viewing.Private.docItemId) {
      url += "&itemid=" + Autodesk.Viewing.Private.docItemId;
    }

    //Prevent Helios forwarding to Mobile app when the link is for RTC session (no RTC on Mobile)
    url += "&doNotRedirect=true";

    input.value = url;
  }
  inputContainer.appendChild(input);

  input.onkeyup = function (e) {
    if (e.keyCode == 13) {
      box.style.visibility = "hidden";
      container.removeChild(box);
      avp.setUserName(input.value);
      cb();
    }
  };

  var close = document.createElement("div");
  close.className = "collabBoxClose";
  close.innerHTML = "&times;";
  close.addEventListener("click", function (event) {
    box.style.visibility = "hidden";
    container.removeChild(box);
  });
  box.appendChild(close);

  if (isInviteWindow) {
    /*
                       var copy = document.createElement("div");
                       copy.className = "collabBoxCopy";
                       copy.textContent = Autodesk.Viewing.i18n.translate( "Copy", { "defaultValue" : "Copy" } );
                       copy.addEventListener("click", function(event) {
                         });
                       box.appendChild(copy);
                       */

    var text = document.createElement("span");
    text.className = "collabBoxText";
    text.style.marginTop = "0px";
    var label = "Copy and send this URL to invite others";

    text.textContent = Autodesk.Viewing.i18n.translate(
    label,
    { "defaultValue": label });
    box.appendChild(text);
  } else {
    var ok = document.createElement("div");
    ok.className = "collabBoxOK";
    ok.textContent = Autodesk.Viewing.i18n.translate(buttonText, { "defaultValue": buttonText });

    ok.addEventListener("click", function (event) {
      box.style.visibility = "hidden";
      container.removeChild(box);
      if (input.value.trim() !== "") {
        avp.setUserName(input.value);
      }
      cb();
    });
    box.appendChild(ok);
  }
  box.style.visibility = "visible";

  input.focus();
  if (isInviteWindow)
  input.select();
};

/***/ }),

/***/ "./extensions/Collaboration/Collaboration.js":
/*!***************************************************!*\
  !*** ./extensions/Collaboration/Collaboration.js ***!
  \***************************************************/
/*! exports provided: Collaboration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Collaboration", function() { return Collaboration; });
/* harmony import */ var _CollabClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CollabClient */ "./extensions/Collaboration/CollabClient.js");
/* harmony import */ var _CollabUI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CollabUI */ "./extensions/Collaboration/CollabUI.js");
/* harmony import */ var _CollabUI_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CollabUI.css */ "./extensions/Collaboration/CollabUI.css");
/* harmony import */ var _CollabUI_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CollabUI_css__WEBPACK_IMPORTED_MODULE_2__);


 // REQUIRED!

var av = Autodesk.Viewing,
avp = av.Private,
avu = av.UI;

//==================================================================================
//Extension interface

/** @constructor */
function Collaboration(viewer, options) {
  av.Extension.call(this, viewer, options);
  if (options && options.rtc && options.rtc.disableRTCToolbarButton) {
    this.disableRTCToolbarButton = true;
  }
  this.name = 'collaboration';
};

Collaboration.prototype = Object.create(av.Extension.prototype);
Collaboration.prototype.constructor = Collaboration;

var proto = Collaboration.prototype;

proto.initNetwork = function (force) {

  if (this.viewtx && !force)
  return;

  this.viewtx = new _CollabClient__WEBPACK_IMPORTED_MODULE_0__["ViewTransceiver"](this.client);
  this.interceptor = new _CollabClient__WEBPACK_IMPORTED_MODULE_0__["InteractionInterceptor"](this.viewtx);
  this.viewer.toolController.registerTool(this.interceptor);
};

proto.createUI = function () {

  var scope = this;
  var viewer = this.viewer;

  this.initNetwork(false);

  this.panel = new _CollabUI__WEBPACK_IMPORTED_MODULE_1__["DockingCollabPanel"](this.viewer, this.client, this.viewtx);
  Collaboration.Panel = this.panel;

  // Create a comment toolbar button.
  this.collabButton = new avu.Button('toolbar-collaborateTool');
  this.collabButton.setToolTip('Live review');
  this.collabButton.setIcon("adsk-icon-live-review");
  this.collabButton.onClick = function (e) {
    var isVisible = scope.panel.isVisible();

    // Prevent instantiating multiple 'enter your name' box by
    // spamming collab button.
    if (document.getElementById("collabBox")) {
      return;
    }
    if (!isVisible && !scope.inviteDivInstantiated && !scope.activeStatus) {
      scope.activate();
    } else {
      scope.deactivate();
    }
  };
  if (this.disableRTCToolbarButton) {
    this.collabButton.setVisible(false, true);
  }

  this.panel.addVisibilityListener(function (state) {
    if (state) {

      if (viewer.model) {
        var svf = viewer.model.getData();

        scope.viewtx.channelId = svf.basePath;
        scope.viewtx.attach(viewer);

        scope.client.connect(scope.viewtx.channelId); //use the just the URN as load balancer session ID for now.
        scope.client.join(scope.viewtx.channelId);
      }

      viewer.toolController.activateTool(scope.interceptor.getName());

      var getColumbusURL = function getColumbusURL() {
        var ret;
        switch (window.location.hostname) {
          case "columbus-dev.autodesk.com":
            ret = "http://columbus-dev.autodesk.com/collab.html?";
            break;
          case "columbus-staging.autodesk.com":
            ret = "http://columbus-staging.autodesk.com/collab-stg.html?";
            break;
          default:
            ret = "http://columbus-dev.autodesk.com/collab.html?";}


        return ret + "document=urn:";
      };

      var generateSharedURL = function generateSharedURL() {
        var baseURL = getColumbusURL();
        var urn = viewer.model.getData().urn;
        var ret = baseURL + urn;
        if (avp.comment2Token) {
          ret += "&comment2Token=" + encodeURIComponent(avp.comment2Token);
        }
        return ret;
      };

      /*
         window.prompt("Send this URL to people you want to share and collaborate on this file!",
           generateSharedURL());
         */

      scope.collabButton.setState(avu.Button.State.ACTIVE);

      avp.logger.track({ category: "viewer_rtc_start" });
    } else
    {

      if (avp.logger && scope.client.isConnected())
      avp.logger.track({ category: "viewer_rtc_stop" });

      scope.viewtx.detach(viewer);
      scope.viewtx.channelId = null;
      scope.client.disconnect();
      scope.panel.reset();
      viewer.toolController.deactivateTool(scope.interceptor.getName());

      scope.collabButton.setState(avu.Button.State.INACTIVE);
    }
  });

  viewer.modelTools.addControl(this.collabButton);

  if (Autodesk.Viewing.Private.getParameterByName("invited")) {
    var w = new _CollabUI__WEBPACK_IMPORTED_MODULE_1__["CollabPromptBox"]();
    var container = viewer.container;
    w.start(container, function () {
      scope.panel.setVisible(true, true);
    }, "Join a Live Review", "Join Review");
  }
};


proto.close = function () {
  this.panel.setVisible(false, true);
  this.panel.reset();
};

proto.load = function () {
  var viewer = this.viewer;
  var scope = this;

  function init() {

    scope.client = avp.MessageClient.GetInstance(scope.options ? scope.options.messageServerURL : undefined);

    scope.socketErrorHandler = function (evt) {
      avp.ErrorHandler.reportError(viewer.container, Autodesk.Viewing.ErrorCodes.RTC_ERROR, evt.data);
      scope.close();
    };

    scope.client.addEventListener("socketError", scope.socketErrorHandler);

    scope.presenceChannelId = window.location.host;

    if (scope.client.isConnected()) {
      //If the client is already connected, we assume that a presence service
      //is already joined by the embedding application.
      /*
      scope.client.addEventListener("userListChange", function(e) {
          if (e.data.user && e.channelId == scope.presenceChannelId)
              console.log(e.data.user.name + " is online.");
          else if (e.userStatus == "left")
              console.log(e.data.user.name + " went offline.");
      });
      */
    } else
      {





      } //Standalone configuration, where no embedding application exists
      //Used for testing.
      //Moved to launch of the collaboration panel so we can connect with session ID for load balancing
      //this.client.connect();
      //this.client.join(this.presenceChannelId);
      // add the button to the toolbar
    if (viewer.modelTools) {scope.createUI();} else {viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
    }

    function onToolbarCreated(e) {
      viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
      scope.createUI();
    }
  }

  //Load the socket.io library if needed
  avp.loadDependency("lmv_io", "socket.io-1.3.5.js", init);

  return true;
};

proto.unload = function () {

  var viewer = this.viewer;

  this.client.removeEventListener("socketError", this.socketErrorHandler);
  this.socketErrorHandler = null;

  this.viewtx.detach(viewer);
  this.client.disconnect();

  if (this.panel) {
    this.panel.reset();
    this.panel.setVisible(false);
    this.panel.uninitialize();
    this.panel = null;
  }

  viewer.toolController.deactivateTool(this.interceptor.getName());
  this.interceptor = null;

  this.collabButton.removeFromParent();
  this.collabButton = null;

  return true;
};

proto.activate = function () {
  if (!this.activeStatus) {
    var viewer = this.viewer;
    var w = new _CollabUI__WEBPACK_IMPORTED_MODULE_1__["CollabPromptBox"]();
    var container = viewer.container;
    w.start(container, function () {
      this.panel.setVisible(true, true);
    }.bind(this), "Start a Live Review", "Start Review");
    this.activeStatus = true;
  }
  return true;
};

proto.deactivate = function () {
  if (this.activeStatus) {
    this.panel.setVisible(false, true);
    this.panel.reset();
    this.activeStatus = false;
  }
  return true;
};
av.theExtensionManager.registerExtension('Autodesk.Viewing.Collaboration', Collaboration);

/***/ }),

/***/ "./node_modules/css-loader/index.js!./extensions/Collaboration/CollabUI.css":
/*!*************************************************************************!*\
  !*** ./node_modules/css-loader!./extensions/Collaboration/CollabUI.css ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, ".collabPanel {\r\n    width: 240px;\r\n    min-width: 240px;\r\n    top: 180px;\r\n    left: 220px;\r\n    line-height: 14px;\r\n    border-spacing: 1px;\r\n    border-collapse: separate;\r\n    color: #f4f4f4;\r\n    resize: none;\r\n    background: rgba(34, 34, 34, 0.8);\r\n}\r\n\r\n.collabPanel .adsk-lmv-tftable{\r\n    margin: 0;\r\n    width: 100%;\r\n}\r\n\r\n/* overwrite chat window style that is reset by bootstrap from Helios. */\r\n.adsk-lmv-tftable td {\r\n    width: auto;\r\n}\r\n\r\n.collabPanelContent {\r\n    width: 100%;\r\n    height: calc(100% - 55px);\r\n    resize:none;\r\n    position: relative;\r\n}\r\n\r\n.userListTable {\r\n    max-height:180px;\r\n    overflow-y: auto;\r\n}\r\n\r\n.textEntry {\r\n    color:#ffffff;\r\n    font-size:12px;\r\n    background: rgba(34, 34, 34, 0.5);\r\n}\r\n\r\n.chatPanel {\r\n    margin: 1px;\r\n    width: 100%;\r\n}\r\n\r\n.collabPanel input {\r\n\r\n    width: calc(100% - 12px);\r\n    border: 0;\r\n    padding: 5px;\r\n    resize:none;\r\n}\r\n\r\n.videoPanel {\r\n    position:relative;\r\n    margin: 1px;\r\n    width:100%;\r\n    /*min-height: 240px;*/\r\n    max-height: 720px;\r\n}\r\n\r\n.videoMain {\r\n    width:100%;\r\n    height:100%;\r\n}\r\n\r\n.videoInset {\r\n    position: absolute;\r\n    width: 25%;\r\n    height: 25%;\r\n    right:1px;\r\n    bottom:1px;\r\n}\r\n\r\n.chatHistory {\r\n    margin: 1px;\r\n    width: 100%;\r\n    min-height: 80px;\r\n    max-height: 180px;\r\n    resize:none;\r\n    border:0;\r\n    overflow-y: auto;\r\n}\r\n\r\n.chatHistory p {\r\n    display: block;\r\n    margin-top: 6px;\r\n    margin-bottom: 1px;\r\n    margin-left: 0;\r\n    margin-right: 0;\r\n    font-style: italic;\r\n    font-weight:bold;\r\n    color: #dddddd;\r\n}\r\n\r\n.chatHistory .messageText {\r\n    margin-top: 2px;\r\n}\r\n\r\n.statusBase {\r\n    font-size:15px;\r\n    text-align: center;\r\n    /*border-radius: 50%;*/\r\n}\r\n\r\n.statusNormal {\r\n    /*background: limegreen;*/\r\n    color:lime;\r\n}\r\n\r\n.statusInControl {\r\n    /*background : red;*/\r\n    color:lime;\r\n}\r\n\r\n.callButton {\r\n    width:14px;\r\n    color: #008000;\r\n    cursor: pointer;\r\n}\r\n\r\n.callButton:hover {\r\n    color: #00ff00;\r\n    cursor: pointer;\r\n}\r\n\r\n.cameraButton {\r\n    width:14px;\r\n    color: #008000;\r\n    cursor: pointer;\r\n}\r\n\r\n.cameraButton:hover {\r\n    color: #00ff00;\r\n    cursor: pointer;\r\n}\r\n\r\n.cameraDisconnectButton {\r\n    color: #ffffff;\r\n    cursor: pointer;\r\n}\r\n\r\n.collabPointer {\r\n    background-color: #ff0000;\r\n    position:absolute;\r\n    width: 12px;\r\n    height: 12px;\r\n    border-radius: 50%;\r\n}\r\n\r\n.collabBox\r\n{\r\n    position: absolute;\r\n    z-index: 1;\r\n    left: 50%;\r\n    top: 50%;\r\n    width: 280px;\r\n    height: auto;\r\n    max-width: 80%;\r\n    background: rgba(34, 34, 34, 0.8);\r\n    padding: 10px;\r\n    visibility: hidden;\r\n\r\n    border-radius: 5px;\r\n    border-width: 1px;\r\n    border-color: #b8b8b8;\r\n    border-style: solid;\r\n\r\n    white-space: -moz-pre-wrap; /* Mozilla */\r\n    white-space: pre-line; /* CSS 3 (and 2.1 as well, actually) */\r\n    word-wrap: break-word; /* IE */\r\n    word-break: break-all;\r\n\r\n    transform: translate(-50%, -50%);\r\n    -webkit-transform: translate(-50%, -50%);\r\n    -moz-transform: translate(-50%, -50%);\r\n}\r\n\r\n\r\n.collabBoxTitle\r\n{\r\n    color: #ffffff;\r\n    display: block;\r\n    word-wrap: break-word;\r\n    word-break: break-all;\r\n    font-size: 14px;\r\n    min-height: 14px;\r\n    padding: 1px 1px 5px 1px;\r\n    border-bottom: 1px solid rgba(200,200,200, 1);\r\n    text-transform: uppercase;\r\n\r\n    font-weight:bold;\r\n    line-height: 14px;\r\n    resize: none;\r\n    white-space: nowrap;\r\n    overflow: hidden;\r\n    text-overflow: ellipsis;\r\n}\r\n\r\n.collabBoxText\r\n{\r\n    display: block;\r\n    color: #ffffff;\r\n    word-wrap: break-word;\r\n    word-break: break-word;\r\n    font-size: 12px;\r\n    font-weight: bold;\r\n    min-height: 12px;\r\n    margin: 10px 0px 5px 0px;\r\n    padding: 3px;\r\n}\r\n\r\n.collabBoxContent\r\n{\r\n    color: #ffffff;\r\n    margin-top: 10px;\r\n    font-size: 12px;\r\n    min-height: 12px;\r\n    list-style: disc;\r\n}\r\n\r\n.collabBoxOK\r\n{\r\n    display: block;\r\n\r\n    z-index: 2;\r\n    width: 120px;\r\n    height: auto;\r\n    margin-left: auto;\r\n    float: right;\r\n\r\n    line-height: 20px;\r\n    text-align: center;\r\n    color: #ffffff;\r\n    font-size: 14px;\r\n    background: rgba(0,0,0,0.0);\r\n    border-radius: 2px;\r\n    border-width: 1px;\r\n    border-color: #505050;\r\n    border-style: solid;\r\n    padding: 3px;\r\n    cursor: pointer;\r\n\r\n    -webkit-transition: all .2s ease-in-out;\r\n    -moz-transition: all .2s ease-in-out;\r\n    -ms-transition: all .2s ease-in-out;\r\n    -o-transition: all .2s ease-in-out;\r\n    transition: all .2s ease-in-out;\r\n}\r\n\r\n.collabBoxCopy\r\n{\r\n    z-index: 2;\r\n    width: 100px;\r\n    height: auto;\r\n    float: right;\r\n    margin-left: auto;\r\n\r\n    line-height: 20px;\r\n    text-align: center;\r\n    color: #ffffff;\r\n    font-size: 14px;\r\n    background: rgba(0,0,0,0.0);\r\n    border-radius: 2px;\r\n    border-width: 1px;\r\n    border-color: #505050;\r\n    border-style: solid;\r\n    padding: 3px;\r\n    cursor: pointer;\r\n\r\n    -webkit-transition: all .2s ease-in-out;\r\n    -moz-transition: all .2s ease-in-out;\r\n    -ms-transition: all .2s ease-in-out;\r\n    -o-transition: all .2s ease-in-out;\r\n    transition: all .2s ease-in-out;\r\n}\r\n\r\n.collabBoxCopy:hover\r\n{\r\n    border-color: #eeeeee;\r\n    background: #484848;\r\n}\r\n\r\n.collabBoxOK:hover\r\n{\r\n    border-color: #eeeeee;\r\n    background: #484848;\r\n}\r\n\r\n.collabBoxClose {\r\n    position: absolute;\r\n    top: 0px;\r\n    right: 0px;\r\n    padding: 5px 10px 5px 0px;\r\n\r\n    text-transform: uppercase;\r\n    font-size:24px;\r\n    font-weight:bold;\r\n    line-height:24px;\r\n\r\n    color: rgba(224,224,224,1);\r\n    cursor:pointer;\r\n}\r\n\r\n.collabBoxClose:hover {\r\n    color:#E2580B;\r\n}\r\n\r\n.collabBoxInputContainer input {\r\n    background: rgba(55,55,55,0.5);\r\n    color: #ffffff;\r\n    width: 97%;\r\n    margin: 2px 0 13px 0;\r\n    padding: 3px;\r\n}\r\n\r\n.collabInviteButton {\r\n    height: 20px;\r\n    display: block;\r\n    font-size: 14px;\r\n    text-align: center;\r\n}\r\n\r\n.collabInviteButton:hover {\r\n    background-color: rgba(166,194,255, 0.7);\r\n    transition: all 0.2s ease;\r\n    color: #ffffff;\r\n    display: block;\r\n    font-size: 14px;\r\n    text-align: center;\r\n    cursor: pointer;\r\n}\r\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })

/******/ });
//# sourceMappingURL=Collaboration.js.map