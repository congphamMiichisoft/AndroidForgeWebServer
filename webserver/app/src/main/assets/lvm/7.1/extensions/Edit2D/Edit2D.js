/*!
 * LMV v7.1.1
 * 
 * Copyright 2019 Autodesk, Inc.
 * All rights reserved.
 * 
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 * 
 * Autodesk Forge Viewer Usage Limitations:
 * 
 * The Autodesk Forge viewer can only be used to view files generated by
 * Autodesk Forge services. The Autodesk Forge Viewer JavaScript must be
 * delivered from an Autodesk hosted URL.
 */
Autodesk.Extensions.Edit2D =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./extensions/Edit2D/Edit2D.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./extensions/Edit2D/Actions.js":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Actions.js ***!
  \**************************************/
/*! exports provided: Actions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Actions", function() { return Actions; });
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;} // Collection of basic edit actions that support undo/redo.
//
// Each action provides undo() and redo() functions. UndoStack takes care that actions are always called in consistent order. 
// I.e., an individual action can assume that undo/redo is only called if the state allows it. (e.g. target shape exists and has expected number of vertices etc.)
var
Action = /*#__PURE__*/function () {
  function Action(layer) {_classCallCheck(this, Action);
    this.layer = layer;
  }_createClass(Action, [{ key: "undo", value: function undo()

    {
      throw new Error('Abstract method invoked');
    } }, { key: "redo", value: function redo()

    {
      throw new Error('Abstract method invoked');
    } }]);return Action;}();var


AddShape = /*#__PURE__*/function (_Action) {_inherits(AddShape, _Action);
  function AddShape(layer, shape) {var _this;_classCallCheck(this, AddShape);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(AddShape).call(this, layer));
    _this.shape = shape;return _this;
  }_createClass(AddShape, [{ key: "undo", value: function undo()

    {
      this.layer.removeShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.addShape(this.shape);
    } }]);return AddShape;}(Action);var


AddShapes = /*#__PURE__*/function (_Action2) {_inherits(AddShapes, _Action2);

  // @param {Shape[]} shapes
  function AddShapes(layer, shapes) {var _this2;_classCallCheck(this, AddShapes);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AddShapes).call(this, layer));
    _this2.shapes = shapes;return _this2;
  }_createClass(AddShapes, [{ key: "undo", value: function undo()

    {var _this3 = this;
      this.shapes.forEach(function (s) {return _this3.layer.removeShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this4 = this;
      this.shapes.forEach(function (s) {return _this4.layer.addShape(s);});
    } }]);return AddShapes;}(Action);var


MoveShape = /*#__PURE__*/function (_Action3) {_inherits(MoveShape, _Action3);
  function MoveShape(layer, shape, dx, dy) {var _this5;_classCallCheck(this, MoveShape);
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(MoveShape).call(this, layer));
    _this5.shape = shape;
    _this5.delta = { x: dx, y: dy };

    // Note that transforming back and forth is not always exactly 1:1. 
    _this5.beforeState = _this5.shape.clone();
    _this5.afterState = _this5.shape.clone();

    _this5.afterState.move(dx, dy);return _this5;
  }_createClass(MoveShape, [{ key: "undo", value: function undo()

    {
      this.shape.copy(this.beforeState);
    } }, { key: "redo", value: function redo()

    {
      this.shape.copy(this.afterState);
    } }]);return MoveShape;}(Action);var


RemoveShape = /*#__PURE__*/function (_Action4) {_inherits(RemoveShape, _Action4);
  function RemoveShape(layer, shape) {var _this6;_classCallCheck(this, RemoveShape);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveShape).call(this, layer));
    _this6.shape = shape;return _this6;
  }_createClass(RemoveShape, [{ key: "undo", value: function undo()

    {
      this.layer.addShape(this.shape);
    } }, { key: "redo", value: function redo()

    {
      this.layer.removeShape(this.shape);
    } }]);return RemoveShape;}(Action);var



RemoveShapes = /*#__PURE__*/function (_Action5) {_inherits(RemoveShapes, _Action5);
  function RemoveShapes(layer, shapes) {var _this7;_classCallCheck(this, RemoveShapes);
    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveShapes).call(this, layer));
    _this7.shapes = shapes;return _this7;
  }_createClass(RemoveShapes, [{ key: "undo", value: function undo()

    {var _this8 = this;
      this.shapes.forEach(function (s) {return _this8.layer.addShape(s);});
    } }, { key: "redo", value: function redo()

    {var _this9 = this;
      this.shapes.forEach(function (s) {return _this9.layer.removeShape(s);});
    } }]);return RemoveShapes;}(Action);var


AddVertex = /*#__PURE__*/function (_Action6) {_inherits(AddVertex, _Action6);
  function AddVertex(layer, poly, vIndex, p) {var _this10;_classCallCheck(this, AddVertex);
    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(AddVertex).call(this, layer));
    _this10.poly = poly;
    _this10.vIndex = vIndex;
    _this10.point = p.clone();return _this10;
  }_createClass(AddVertex, [{ key: "undo", value: function undo()

    {
      this.poly.removePoint(this.vIndex);
    } }, { key: "redo", value: function redo()

    {
      this.poly.insertPoint(this.vIndex, this.point);
    } }]);return AddVertex;}(Action);


// Only for polygons and polylines
var MoveVertex = /*#__PURE__*/function (_Action7) {_inherits(MoveVertex, _Action7);
  function MoveVertex(layer, poly, vIndex, newPos) {var _this11;_classCallCheck(this, MoveVertex);
    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(MoveVertex).call(this, layer));
    _this11.poly = poly;
    _this11.vIndex = vIndex;
    _this11.posBefore = poly.getPoint(vIndex);
    _this11.posAfter = newPos.clone();return _this11;
  }_createClass(MoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.updatePoint(this.vIndex, this.posBefore.x, this.posBefore.y);
    } }, { key: "redo", value: function redo()
    {
      this.poly.updatePoint(this.vIndex, this.posAfter.x, this.posAfter.y);
    } }]);return MoveVertex;}(Action);var


RemoveVertex = /*#__PURE__*/function (_Action8) {_inherits(RemoveVertex, _Action8);
  function RemoveVertex(layer, poly, vIndex) {var _this12;_classCallCheck(this, RemoveVertex);
    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(RemoveVertex).call(this, layer));
    _this12.poly = poly;
    _this12.vIndex = vIndex;
    _this12.point = poly.getPoint(vIndex);return _this12;
  }_createClass(RemoveVertex, [{ key: "undo", value: function undo()

    {
      this.poly.insertPoint(this.vIndex, this.point);
    } }, { key: "redo", value: function redo()

    {
      this.poly.removePoint(this.vIndex);
    } }]);return RemoveVertex;}(Action);var


MoveEdge = /*#__PURE__*/function (_Action9) {_inherits(MoveEdge, _Action9);
  function MoveEdge(layer, poly, edgeIndex, newPosA, newPosB) {var _this13;_classCallCheck(this, MoveEdge);
    _this13 = _possibleConstructorReturn(this, _getPrototypeOf(MoveEdge).call(this, layer));
    _this13.poly = poly;

    // store edge indices
    _this13.ia = edgeIndex;
    _this13.ib = (edgeIndex + 1) % poly.length;

    // get edge 
    var a = poly.getPoint(_this13.ia);
    var b = poly.getPoint(_this13.ib);

    _this13.edgeBefore = {
      a: a,
      b: b };

    _this13.edgeAfter = {
      a: newPosA.clone(),
      b: newPosB.clone() };return _this13;

  }_createClass(MoveEdge, [{ key: "undo", value: function undo()

    {
      this.poly.updatePoint(this.ia, this.edgeBefore.a.x, this.edgeBefore.a.y);
      this.poly.updatePoint(this.ib, this.edgeBefore.b.x, this.edgeBefore.b.y);
    } }, { key: "redo", value: function redo()

    {
      this.poly.updatePoint(this.ia, this.edgeAfter.a.x, this.edgeAfter.a.y);
      this.poly.updatePoint(this.ib, this.edgeAfter.b.x, this.edgeAfter.b.y);
    } }]);return MoveEdge;}(Action);


var Actions = {
  Action: Action,
  AddShape: AddShape,
  AddShapes: AddShapes,
  MoveShape: MoveShape,
  RemoveShape: RemoveShape,
  RemoveShapes: RemoveShapes,
  AddVertex: AddVertex,
  MoveVertex: MoveVertex,
  RemoveVertex: RemoveVertex,
  MoveEdge: MoveEdge };

/***/ }),

/***/ "./extensions/Edit2D/AngleSnapper.js":
/*!*******************************************!*\
  !*** ./extensions/Edit2D/AngleSnapper.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AngleSnapper; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



// AngleSnapper is responsible for snapping based on angles and alignment on hover while choosing the position of a vertex. 
//
// If pMov is the vertex being moved, the snapping behavior includes:
//
//  1. Angle to previous edge: Snap if edge ending at pMov forms a snapAngle (0, 45, 90,...) with its predecessor edge.
//
//  2. Angle to next edge: Snap if the edge starting at pMov forms a snapAngle with its successor edge.
//
//  3. Collinear Align: Snap if for pMov is collinear with any (non-adjacent) edge.
//
//  4. Vertical Align: Snap if pMov is collinear with the edge normal at start/center/end of any non-adjacent edge.
//

// A SnapLine is a line that we consider for snapping. 
var SnapLine = /*#__PURE__*/function () {

  function SnapLine(a, b) {_classCallCheck(this, SnapLine);

    // start and end point
    this.a = a.clone();
    this.b = b.clone();

    // normalized edge direction
    this.dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b);
  }

  // Check for intersection with another SnapLine. If found, intersection point is written to outPoint.
  // @returns {bool} true on success
  _createClass(SnapLine, [{ key: "intersect", value: function intersect(line, outPoint) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].intersectLines(this.a, this.dir, line.a, line.dir, outPoint);
    }

    // project point to SnapLine
  }, { key: "snapToLine", value: function snapToLine(p) {
      _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].projectToLine(p, this.a, this.dir);
    }

    // Checks if SnapLine is close enough to p to allow snapping. snapRadius is in layer-coords.
  }, { key: "isUsable", value: function isUsable(p, snapRadius) {
      return _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].pointLineDistance(p, this.a, this.dir) < snapRadius;
    } }]);return SnapLine;}();
;

// Snap position based on 1 or 2 SnapLines.
//  @param {Vector2}  pos         - Initial position in layer coords. Modified in-place
//  @param {SnapLine} snapLine1   - First line to snap to
//  @param {SnapLine} [snapLine2] - If there are 2 SnapLines, we snap to the intersection of both lines.
// Preconditions:
//  - SnapLine1: Is close to pos (wrt. to snap tolerance)
//  - SnapLine2: If existing, its intersection with SnapLine1 is close to the position  
var snapToLines = function snapToLines(pos, snapLine1, snapLine2) {

  // No snaplines => keep original pos
  if (!snapLine1) {
    return;
  }

  // If only one SnapLine...
  if (!snapLine2) {
    // project pos to snapLine1
    snapLine1.snapToLine(pos);
    return;
  }

  // Snap pos to line intersection.
  snapLine1.intersect(snapLine2, pos);
};

// Get point i within a polygon, whereby indices outside [0, ..., this.poly.length-1] are auto-corrected using modulo.
// Accepts negative indices up to -this.poly.length.
var getPointMod = function getPointMod(poly, index) {
  index = (index + poly.length) % poly.length;
  return poly.getPoint(index);
};

// Returns an array of SnapLines used to align with each edge of the given polygon.
//  @param {Polygon} poly
//  @param {vIndex}  vIndex - index of the vertex being moved. We exclude edges directly adjacent to this vertex, because they are not fixed.
var findSnapLines = function findSnapLines(poly, vIndex) {

  // tmp vectors
  var normal = new THREE.Vector2();
  var center = new THREE.Vector2();
  var pEnd = new THREE.Vector2();

  var snapLines = [];

  // Given an edge of a polygon/polyline, this function collects snapping lines for alignment with this this edge.
  // and adds it to snapLines.
  // Generated snapLines are:
  //  - Line spanned by the edge
  //  - Orthogonal lines at start, center, and end point.
  var addEdgeSnapLines = function addEdgeSnapLines(a, b) {

    // add line spanned by the edge
    snapLines.push(new SnapLine(a, b));

    // get edge normal and center point
    normal = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].turnLeft(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(a, b, normal));
    center = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeCenter(a, b, center);

    // add orthogonal line add edge start
    pEnd.copy(a).add(normal); // pEnd = p1 + normal
    snapLines.push(new SnapLine(a, pEnd));

    // add orthogonal line at edge center
    pEnd.copy(center).add(normal); // pEnd = center + normal
    snapLines.push(new SnapLine(center, pEnd));

    // add orthogonal line at edge end
    pEnd.copy(b).add(normal); // pEnd = p2 + normal
    snapLines.push(new SnapLine(b, pEnd));
  };

  poly.enumEdges(function (a, b, ia, ib) {

    // Exclude edges containing the moved vertex: These edges are not fixed yet and should not
    // be used for alignment.
    if (ia == vIndex || ib == vIndex) {
      return;
    }

    // skip edge if degenerate
    if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(a, b)) {
      return;
    }

    addEdgeSnapLines(a, b);
  });
  return snapLines;
};

// Checks if the given SnapLine candidate is suitable to be used - assuming that another snapLine1 was already chosen.
// A candidate is only suitable if...
//  1. The intersection with snapLine1 is within snapping tolerance
//  2. The angle formed with snapLine1 is as closer to 90° than all other candidates. This makes sure that we rather 
//     snap to orthogonal SnapLines than trying to snap to two nearly parallel ones.
// 
// If the candidate is better suitable than the given bestCandidate, 
//
//  @param {SnapLine} candidate       - SnapLine candidates to be compared    
//  @param {SnapLine} [bestCandidate] - Best candidate found so far (may be null)
//  @param {SnapLine} snapLine1       - First SnapLine that has already been chosen to snap to.    
//  @param {Vector2}  pos             - position to be snapped
//  @param {number}   snapRadius      - in layer coords
//  @returns {SnapLine} Returns the best candidate - either bestCandidate or snapLineCandidate
var checkSecondSnapCandidate = function checkSecondSnapCandidate(candidate, bestCandidate, snapLine1, pos, snapRadius) {

  // If candidate does not intersect snapLine1, we cannot use it.
  var pIntersect = new THREE.Vector2();
  if (!snapLine1.intersect(candidate, pIntersect)) {
    return bestCandidate;
  }

  // If intersection point is outside snapRadius, discard candidate
  if (pIntersect.distanceTo(pos) > snapRadius) {
    return bestCandidate;
  }

  // If there is no competitor, the candidate made it.
  if (!bestCandidate) {
    return candidate;
  }

  // Check which of the candidates is "less parallel" to snapLine1
  var dp1 = Math.abs(snapLine1.dir.dot(candidate.dir));
  var dp2 = Math.abs(snapLine1.dir.dot(bestCandidate.dir));
  return dp1 > dp2 ? candidate : bestCandidate;
};

var xAxis = new THREE.Vector2(1, 0);

// AngleSnapper helps to draw right angles, parallel lines etc.
var AngleSnapper = /*#__PURE__*/function () {

  function AngleSnapper(gizmoLayer) {_classCallCheck(this, AngleSnapper);
    // Polygon/Polyline being edited. We assume that it includes the vertex being moved.
    this.poly = null;

    // Index of the vertex in this.poly that is beging moved.
    this.vIndex = -1;

    // If an edge forms one of these angles with the previous one, we display the helper line and snap to the angle
    this.snapAngles = [0, 45, 90, 135, 180, 225, 270, 315, 360];

    // We consider an angle "close to" another one if they differ by this value or less.
    this.snapAngleTolerance = 2; // in degrees

    // Allow snapping to lines within x pixels.
    this.snapRadius = 10;

    this.gizmoLayer = gizmoLayer;

    // reused tmp points
    this.movedPoint = new THREE.Vector2(); // the vertex being moved
    this.prevPoint = new THREE.Vector2(); // the vertex before movedPoint
    this.prevPoint2 = new THREE.Vector2(); // the vertex before prevPoint

    this.edgeDir = new THREE.Vector2(); // direction of new edge ending at movedPoint
    this.alignAxis = new THREE.Vector2(); // direction that we align to: Either the direction of the previous edge or the x-axis

    // Array of snapLines to align a vertex position with other edges
    this.edgeSnapLines = [];

    // SnapLines that contributed to last snapping call. Used to update the SnapLine gizmos.
    this.snapLine1 = null;
    this.snapLine2 = null;

    // Gizmos to display the lines considered for snapping
    this.snapLineStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineColor: 'rgb(255, 0, 0)',
      lineWidth: 1.0,
      lineStyle: 10 });

    this.snapLineGizmo1 = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.snapLineStyle);
    this.snapLineGizmo2 = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.snapLineStyle);
  }

  // Configures snapping to align to edges of the given polygon/polyline
  //  @param {Polygon|Polyline} poly   - shape being edited. Expected to include the vertex being moved.
  //  @param {number}           vIndex - index into poly that marks the vertex that is moved and to which snapping should be applied.
  _createClass(AngleSnapper, [{ key: "startSnapping", value: function startSnapping(poly, vIndex) {
      this.poly = poly;
      this.vIndex = vIndex;

      // precompute snapLines for alignment. These don't change while moving a vertex.
      this.edgeSnapLines = findSnapLines(poly, vIndex);
    } }, { key: "stopSnapping", value: function stopSnapping()

    {

      this.poly = null;
      this.vIndex = -1;

      // Discard any outdated results and hide gizmos
      this.snapLine1 = null;
      this.snapLine2 = null;
      this.clearSnappingGizmos();
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {
      this.gizmoLayer.removeShape(this.snapLineGizmo1);
      this.gizmoLayer.removeShape(this.snapLineGizmo2);
    }

    // Discard latest snapping results, but polygon, vIndex, and edge snapLines. This is used when temporarily hiding the SnapLines when
    // snapping while snapping is bypassed.
  }, { key: "clearSnappingResult", value: function clearSnappingResult() {
      this.snapLine1 = null;
      this.snapLine2 = null;
    } }, { key: "snapToAngle",





    // Given a new position in layer-coords to be assigned to the moved vertex, this function checks if the adjacent edges of the moved
    // vertex are close to a snap angle. If so, the movedPoint is corrected to match the snap angle exactly.
    value: function snapToAngle(pMov) {

      // Reset the two lines that we consider for snapping.
      this.snapLine1 = null;
      this.snapLine2 = null;

      if (!this.active || this.poly.length <= 1) {
        return;
      }

      // Get point before the moved one.
      var pPrev = getPointMod(this.poly, this.vIndex - 1);

      // If we just have a single edge, we can only snap to angles relative to x-axis
      var isFirstEdge = this.poly.length == 2;
      if (isFirstEdge) {
        this.snapLine1 = this.computeAngleSnapLine(pMov, pPrev, xAxis);
        snapToLines(pMov, this.snapLine1);
        return;
      }

      // Get vertices of two edges before and after the moved vertex 
      var pPrev2 = getPointMod(this.poly, this.vIndex - 2);
      var pNext = getPointMod(this.poly, this.vIndex + 1);
      var pNext2 = getPointMod(this.poly, this.vIndex + 2);

      // When moving one of the last two vertices of a polyline, there is actually no "next edge", because start and end
      // vertex are not connected. Therefore, we skip snapping to "next edge" for this case.
      var ignoreNextEdge = this.poly.isPolyline() && this.vIndex >= this.poly.length - 2;

      // Snap angles relatie to previous edge:
      //   Check angle between (pPrev, pMov) and its predecessor edge before (pPrev2, pPrev)
      var alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pPrev2, pPrev);
      var prevSnapLine = this.computeAngleSnapLine(pMov, pPrev, alignAxis);

      // Snap to angle wrt. to next edge: (only for polygons)
      //   Check angle between (pNext, pMov) and its successor edge (pNext, pNext2);
      var nextSnapLine = null;
      if (!ignoreNextEdge) {
        alignAxis = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].getEdgeDirection(pNext, pNext2, alignAxis);
        nextSnapLine = this.computeAngleSnapLine(pMov, pNext, alignAxis);
      }

      // get snapRadius in layer-coords. This is the maximum distance that we allow
      // between mouse pos and the final snap position that we obtain by projecting
      // to a SnapLine or by intersecting two SnapLines.
      var snapRadiusLC = this.snapRadius * this.gizmoLayer.getUnitsPerPixel();

      // Filter to lines that are close enough to pMov
      var snapLineUsable = function snapLineUsable(snapLine) {
        return snapLine.isUsable(pMov, snapRadiusLC);
      };
      var candidates = this.edgeSnapLines.filter(snapLineUsable);

      // choose first snapLine
      this.snapLine1 = prevSnapLine || nextSnapLine || candidates[0];

      // Stop here if there is no snapping candidate at all
      if (!this.snapLine1) {
        return;
      }

      // If prev and next edge allow angle snapping, check if we can snap to both
      if (prevSnapLine && nextSnapLine) {
        this.snapLine2 = checkSecondSnapCandidate(nextSnapLine, null, this.snapLine1, pMov, snapRadiusLC);
      }

      // If prevEdge and nextEdge already gave us 2 SnapLines, give these two preference. Otherwise,
      // check if we can snap to another edge to be aligned with other edges.
      if (!this.snapLine2) {
        for (var i = 0; i < candidates.length; i++) {
          var c = candidates[i];
          this.snapLine2 = checkSecondSnapCandidate(c, this.snapLine2, this.snapLine1, pMov, snapRadiusLC);
        }
      }

      // We selected one or two SnapLines. Now, use them to decide snapped position
      return snapToLines(pMov, this.snapLine1, this.snapLine2);
    } }, { key: "updateSnapLineGizmos", value: function updateSnapLineGizmos(

    snappedPos) {var _this = this;

      // Clear any outdated gizmos
      this.gizmoLayer.removeShape(this.snapLineGizmo1);
      this.gizmoLayer.removeShape(this.snapLineGizmo2);

      // A SnapLine indicator is constructed as follows:
      //  - It starts at the snapLine start point, which "explains where the SnapLine comes from". 
      //    This may be start/center/end of another edge.
      //  - It should always point towards the moved vertex (note that an original edge normal may point away from the moved vertex)
      //  - It is enlarged to overshoot pMov 

      // Get diagonal of the whole document - we choose this as line length to make sure that 
      // the line doesn't end somewhere within the screen.
      var w = this.gizmoLayer.viewport.width;
      var h = this.gizmoLayer.viewport.height;
      var diag = Math.sqrt(w * w + h * h);

      var showSnapLine = function showSnapLine(line, gizmo) {
        if (!line) {
          return;
        }

        var a = line.a;

        // Choose direction so that it points towards moved vertex
        //const dir = snappedPos.clone().sub(a).normalize();

        // Let line start at a, point towards dir, and be long enough to leave screen
        gizmo.makeLine(
        a.x - diag * line.dir.x,
        a.y - diag * line.dir.y,
        a.x + diag * line.dir.x,
        a.y + diag * line.dir.y);

        _this.gizmoLayer.addShape(gizmo);
      };

      showSnapLine(this.snapLine1, this.snapLineGizmo1);
      showSnapLine(this.snapLine2, this.snapLineGizmo2);
    } }, { key: "dtor", value: function dtor()

    {
      this.clearSnapping();
    }

    // Checks if the angle between edge (pPrev, p) and alignment direction is close to a snapping angle.
    // If so, it returns a SnapLine from pPrev towards the snapped direction, otherwise null.
    //  @param {Vector2} p              - vertex being moved
    //  @param {Vector2} pPrev          - vertex connected to p
    //  @param {Vector2} alignAxis      - direction that we align to. Must be normalized.
  }, { key: "computeAngleSnapLine", value: function computeAngleSnapLine(p, pPrev, alignAxis) {

      // Don't try angle snapping with degenerated edges
      if (_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].edgeIsDegenerated(pPrev, p)) {
        return null;
      }

      // get direction of new edge (ending at pMov)
      var edgeDir = p.clone().sub(pPrev);

      // Compute angle between new edge and alignment direction
      var angle = THREE.Math.radToDeg(_Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].angleBetweenDirections(edgeDir, alignAxis));

      // Check if angle matches with any index in snapAngles array
      var snapIndex = -1;
      for (var i = 0; i < this.snapAngles.length; i++) {
        var _snapAngle = this.snapAngles[i];

        var dif = Math.abs(_snapAngle - angle);
        if (dif < this.snapAngleTolerance) {
          snapIndex = i;
          break;
        }
      }

      // Stop here if no snapAngle is found
      if (snapIndex == -1) {
        return null;
      }

      // Rotate alignment axis by selected snapAngle
      var snapAngle = THREE.Math.degToRad(this.snapAngles[snapIndex]);
      var snapDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_1__["Math2D"].rotateAround(alignAxis.clone(), snapAngle);

      // scale snapLine direction to the same length as (pPrev, p)
      var dist = pPrev.distanceTo(p);
      var snapLineEnd = snapDir.multiplyScalar(dist).add(pPrev);

      // Return snapline from pPrev pointing towards snapped direction
      return new SnapLine(pPrev, snapLineEnd);
    } }, { key: "active", get: function get() {return this.poly;} }]);return AngleSnapper;}();

/***/ }),

/***/ "./extensions/Edit2D/CanvasGizmo.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/CanvasGizmo.js ***!
  \******************************************/
/*! exports provided: AlignX, AlignY, CanvasGizmo, PolygonLabel, AreaLabel, EdgeGizmo, EdgeMoveGizmo, EdgeLabel, VertexGizmo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignX", function() { return AlignX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlignY", function() { return AlignY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasGizmo", function() { return CanvasGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolygonLabel", function() { return PolygonLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AreaLabel", function() { return AreaLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeGizmo", function() { return EdgeGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeMoveGizmo", function() { return EdgeMoveGizmo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgeLabel", function() { return EdgeLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexGizmo", function() { return VertexGizmo; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


// int value to string, e.g. 50 => "50px" - to used for style assignments.
var toPixels = function toPixels(val) {
  return val.toString() + 'px';
};

var AlignX = {
  Left: 1,
  Center: 2,
  Right: 3 };


var AlignY = {
  Top: 1,
  Center: 2,
  Bottom: 3 };


// A CanvasGizmo is an html div anchored at a position in layer-coords
var CanvasGizmo = /*#__PURE__*/function () {
  function CanvasGizmo(layer) {var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, CanvasGizmo);
    this.layer = layer;

    // position in layer-coords. The transform origin of the div will appear at this position.
    this.layerPos = new THREE.Vector2();

    // position in canvas-coords (updated based on this.layerPos and camera)
    this.canvasPos = new THREE.Vector2();

    // html content to be shown
    this.container = document.createElement('div');

    // Make sure that label is displayed on top of the canvas and not "pushed away" by it.
    this.container.style.position = 'absolute';

    // Rotate around gizmo center
    this.container.style.transformOrigin = '50% 50%';

    // Show immediately if wanted
    this.visible = false;

    this.alignX = AlignX.Center;
    this.alignY = AlignY.Center;

    // Clockwise rotation angle in degress. Rotates around center.
    this.angle = 0;

    if (visible) {
      this.setVisible(true, false);
    }
  }_createClass(CanvasGizmo, [{ key: "dtor", value: function dtor()

    {
      this.setVisible(false);
    } }, { key: "setVisible", value: function setVisible(

    visible) {var autoUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (visible == this.visible) {
        return;
      }

      if (visible) {
        // Note: It's essential that we add it to viewer.canvasWrap instead of viewer.container:
        //       ToolController listens to events on canvasWrap. Therefore, if we would add
        //       it to viewer.container, all mouse events captured would never reach the ToolController
        //       no matter whether the gizmo handles them or not.
        this.layer.viewer.canvasWrap.appendChild(this.container);
        this.layer.addCanvasGizmo(this);

        // Make sure that position is correct
        if (autoUpdate) {
          this.update();
        }
      } else
      {
        this.layer.viewer.canvasWrap.removeChild(this.container);
        this.layer.removeCanvasGizmo(this);
      }
      this.visible = visible;
    } }, { key: "setAlignX", value: function setAlignX(

    alignX) {
      this.alignX = alignX;
      this.update();
    } }, { key: "setAlignY", value: function setAlignY(

    alignY) {
      this.alignY = alignY;
      this.update();
    }

    // @param {number} angle - Clockwise angle in degrees
    // 
    // Note: Do not use 'position:absolute' in child html elements.
    //       Otherwise, the content box will be empty and it will not rotate around anymore.
  }, { key: "setRotation", value: function setRotation(angle) {
      this.angle = angle;
      this.update();
    } }, { key: "update", value: function update()

    {
      this.canvasPos.copy(this.layer.layerToCanvas(this.layerPos.x, this.layerPos.y));

      var p = this.canvasPos;
      var style = this.container.style;

      // set left/top to gizmo position
      style.left = toPixels(p.x);
      style.top = toPixels(p.y);

      // Choose translation offset in % based on X-alignment
      var tx;
      switch (this.alignX) {
        case AlignX.Left:tx = '0%';break;
        case AlignX.Center:tx = '-50%';break;
        case AlignX.Right:tx = '-100%';break;}


      var ty;
      switch (this.alignY) {
        case AlignY.Top:ty = '0%';break;
        case AlignY.Center:ty = '-50%';break;
        case AlignY.Bottom:ty = '-100%';break;}


      // Update transform based on rotation angle and alignment
      style.transform = "translate(".concat(tx, ", ").concat(ty, ") rotate(").concat(this.angle, "deg)");
    }

    // Set position in layer coords
  }, { key: "setPosition", value: function setPosition(x, y) {
      this.layerPos.set(x, y);
      this.update();
    } }, { key: "hitTestCanvas", value: function hitTestCanvas(

    canvasX, canvasY) {

      // Convert from canvas to window coordinates
      var canvasRect = this.layer.viewer.impl.getCanvasBoundingClientRect();
      var x = canvasX + canvasRect.x;
      var y = canvasY + canvasRect.y;

      var rect = this.container.getBoundingClientRect();
      return (
        x >= rect.left && x <= rect.right &&
        y >= rect.top && y <= rect.bottom);

    }

    // Hit test using layer coords
  }, { key: "hitTestLayer", value: function hitTestLayer(x, y) {
      var p = this.layer.layerToCanvas(x, y);
      return this.hitTestCanvas(p.x, p.y);
    } }, { key: "setClassEnabled", value: function setClassEnabled(

    className, enabled) {
      if (enabled) {
        this.container.classList.add(className);
      } else {
        this.container.classList.remove(className);
      }
    }

    // Selection state is managed using a css-class 'selected'. 
    // Note that this only has an effect if the css style used for the gizmo supports it.
  }, { key: "setSelected", value: function setSelected(selected) {
      this.setClassEnabled('selected', selected);
    } }, { key: "isSelected", value: function isSelected()

    {
      return this.container.classList.contains('selected');
    }

    // Optional: Hover-effect for gizmos that can be clicked or dragged.
  }, { key: "setHoverEnabled", value: function setHoverEnabled(enabled) {
      this.setClassEnabled('enable-hover', enabled);
    } }]);return CanvasGizmo;}();


// Configure CanvasGizmo as a text label.
var initTextLabel = function initTextLabel(gizmo) {

  // Use measure-tool styles by default
  gizmo.container.classList.add('measure-length');
  gizmo.container.classList.add('visible');

  // Create textDiv child div
  gizmo.textDiv = document.createElement('div');
  gizmo.textDiv.classList.add('measure-length-text');
  gizmo.container.appendChild(gizmo.textDiv);

  // Add setText convenience function
  gizmo.setText = function (str) {
    this.textDiv.textContent = str;
  }.bind(gizmo);
};

var PolygonLabel = /*#__PURE__*/function (_CanvasGizmo) {_inherits(PolygonLabel, _CanvasGizmo);

  function PolygonLabel(polygon, layer) {var _this;var visible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;_classCallCheck(this, PolygonLabel);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonLabel).call(this, layer, visible));

    initTextLabel(_assertThisInitialized(_assertThisInitialized(_this)));

    _this.polygon = polygon;
    _this.update();

    // Can be set to hidden to temporarily hide the label
    _this.valueValid = true;return _this;
  }_createClass(PolygonLabel, [{ key: "update", value: function update()

    {
      if (this.polygon && this.valueValid) {
        // Set it to visible (in case polygon was null before)
        this.container.style.visibility = 'visible';

        // For a start, simply use the bbox center of the polygon. In some cases, this might end up outside the
        // polygon, so we may consider something smarter later.
        this.polygon.computeBBox();
        this.polygon.bbox.center(this.layerPos);
        _get(_getPrototypeOf(PolygonLabel.prototype), "update", this).call(this);
      } else {
        this.container.style.visibility = 'hidden';
      }
    } }, { key: "setPolygon", value: function setPolygon(

    poly) {
      this.polygon = poly;
      this.update();
    } }]);return PolygonLabel;}(CanvasGizmo);


var AreaLabel = /*#__PURE__*/function (_PolygonLabel) {_inherits(AreaLabel, _PolygonLabel);

  // @param {Polygon}  polygon
  // @param {EditLyer} layer
  // @param {UnitHandler} unitHandler - unitHandler.areaToString() is required to define how to display area values as string.
  // @param {bool}     [visible]
  function AreaLabel(polygon, layer, unitHandler) {var _this2;var visible = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;_classCallCheck(this, AreaLabel);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(AreaLabel).call(this, polygon, layer, visible));
    _this2.unitHandler = unitHandler;return _this2;
  }_createClass(AreaLabel, [{ key: "update", value: function update()

    {

      var area = this.polygon && this.polygon.getArea();

      // Hide label if polygon is degenerated
      this.valueValid = Boolean(area);

      if (this.valueValid) {
        var text = this.unitHandler.areaToString(area);
        this.setText(text);
      }

      // Let base class update position
      _get(_getPrototypeOf(AreaLabel.prototype), "update", this).call(this);
    } }]);return AreaLabel;}(PolygonLabel);


// A html element for which position and rotation is aligned with an edge
var EdgeGizmo = /*#__PURE__*/function (_CanvasGizmo2) {_inherits(EdgeGizmo, _CanvasGizmo2);

  // @param {EditLayer} layer
  // @param {bool} visible
  function EdgeGizmo(layer) {var _this3;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeGizmo);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeGizmo).call(this, layer, visible));

    _this3.posA = new THREE.Vector2();
    _this3.posB = new THREE.Vector2();

    // Indicates if a position has been set. If not, we temporarily hide the gizmo. If the gizmo is
    // attached to an edge, this flag is set automatically.
    _this3.posValid = false;

    // Temp vectors used in update
    _this3.edgeDir = new THREE.Vector2();

    // Optional: Positions can be synchronized with an edge of a polygon or polyline
    _this3.poly = null;
    _this3.edgeIndex = 0;

    // Use measure-length css style by default
    _this3.container.classList.add('edge-gizmo');

    // Optional: If specified, this limits the size of the gizmo relative to the edge length on screen:
    // We hide the gizmo if it exceeds x * edgeLength on screen.
    _this3.maxRelativeLength = undefined; // in [0,1]
    return _this3;}

  // If a poly is set, the gizmo is automatically synchronized with the edge.
  // As long as the poly is visible in the same layer, the edge is automatically kept in sync with the edge.
  //
  //  @param {PolyBase} poly     - polygon or polyline containing the edge that we want to attach to. If null, positions can be set manually.
  //  @param {number} edgeIndex  - edgeIndex in poly. If not valid, gizmo is hidden.
  //  @param {bool} [autoUpdate] - update position immediately
  _createClass(EdgeGizmo, [{ key: "attachToEdge", value: function attachToEdge(poly, edgeIndex) {
      this.poly = poly;
      this.edgeIndex = edgeIndex;
      this.update();
    } }, { key: "detachFromEdge", value: function detachFromEdge()

    {
      this.poly = null;
      this.edgeIndex = -1;
      this.posValid = false; // hide unless a position is explicitly set
      this.update();
    } }, { key: "update", value: function update()

    {

      // If a polygon is set, obtain positions automatically from it - or hide gizmo if edge does not exist anymore
      if (this.poly && this.poly.edgeIndexValid(this.edgeIndex)) {
        this.poly.getEdge(this.edgeIndex, this.posA, this.posB);
        this.posValid = true;
      }

      // If edge is invalid or too small on screen, just hide the gizmo
      var show = this._shouldBeShown();
      this.container.style.visibility = show ? 'visible' : 'hidden';
      if (!show) {
        return;
      }

      // Center gizmo at edge center
      this.layerPos.set(0.5 * (this.posA.x + this.posB.x), 0.5 * (this.posA.y + this.posB.y));

      // Set rotation angle
      this._updateRotation();

      _get(_getPrototypeOf(EdgeGizmo.prototype), "update", this).call(this);
    }

    // Check if the gizmo should be shown: We hide it if the edge is too small or if the edge does not exist at all.
  }, { key: "_shouldBeShown", value: function _shouldBeShown() {

      // Positions must be properly set - either automatically from an attached edge or manually using setEdge()
      if (!this.posValid) {
        return false;
      }

      // Show/Hide gizmo depending on zoom:
      // Gizmo has constant screen-size. So, we hide it if the screen-size of the edge becomes too small.
      if (this.maxRelativeLength) {
        var aScreen = this.layer.layerToCanvas(this.posA.x, this.posA.y);
        var bScreen = this.layer.layerToCanvas(this.posB.x, this.posB.y);
        var edgeLengthScreen = aScreen.distanceTo(bScreen);
        var maxAllowedPixels = edgeLengthScreen * this.maxRelativeLength;
        var width = parseFloat(window.getComputedStyle(this.container).width);
        return width < maxAllowedPixels;
      }
      return true;
    }

    // Set style rotation to align gizmo along edge direction, so that 'width' is along the edge
  }, { key: "_updateRotation", value: function _updateRotation() {

      // Compute counterClockwise angle in radians that rotates the positive x-axis to the edge direction a->b
      var dir = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeDirection(this.posA, this.posB, this.edgeDir);
      var angle = Math.atan2(dir.y, dir.x);

      // Avoid upside-down rotation: Flip by 180 degrees if b is left of a. This is import if gizmo contains text.
      if (dir.x < 0) {
        angle += Math.PI;
      }

      // Convert angle to clockwise degrees and apply it to style
      // Just set the angle here, but don't call setAngle, becaue we don't want to trigger auto-update.
      this.angle = -THREE.Math.radToDeg(angle);
    } }]);return EdgeGizmo;}(CanvasGizmo);


var EdgeMoveGizmo = /*#__PURE__*/function (_EdgeGizmo) {_inherits(EdgeMoveGizmo, _EdgeGizmo);

  function EdgeMoveGizmo(layer) {var _this4;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeMoveGizmo);
    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeMoveGizmo).call(this, layer, visible));
    _this4.container.classList.add('edge-move-gizmo');

    // Hide gizmo if its screenWidth exceeds 0.3 * edgeLength
    _this4.maxRelativeLength = 0.3; // in [0,1]
    return _this4;}return EdgeMoveGizmo;}(EdgeGizmo);


// An EdgeGizmo to display text
var EdgeLabel = /*#__PURE__*/function (_EdgeGizmo2) {_inherits(EdgeLabel, _EdgeGizmo2);

  function EdgeLabel(layer) {var _this5;var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;_classCallCheck(this, EdgeLabel);
    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(EdgeLabel).call(this, layer, visible));
    initTextLabel(_assertThisInitialized(_assertThisInitialized(_this5)));

    // Hide label if it would exceed the edge length
    _this5.maxRelativeLength = 1.0;return _this5;
  }return EdgeLabel;}(EdgeGizmo);


var VertexGizmo = /*#__PURE__*/function (_CanvasGizmo3) {_inherits(VertexGizmo, _CanvasGizmo3);

  // @param {number}  x,y       - Position in layer coords
  // @param {string}  id        - id string used to tag shapes that represent this gizmo
  function VertexGizmo(layer, x, y, name) {var _this6;_classCallCheck(this, VertexGizmo);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(VertexGizmo).call(this, layer, true));
    _this6.setPosition(x, y);
    _this6.name = name;

    name && _this6.container.setAttribute('id', name);
    _this6.container.classList.add('vertex-gizmo');return _this6;
  }return VertexGizmo;}(CanvasGizmo);

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.css":
/*!**************************************!*\
  !*** ./extensions/Edit2D/Edit2D.css ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader!./Edit2D.css */ "./node_modules/css-loader/index.js!./extensions/Edit2D/Edit2D.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./extensions/Edit2D/Edit2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Edit2D.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DExtension; });
/* harmony import */ var _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditLayer.js */ "./extensions/Edit2D/EditLayer.js");
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Edit2DSnapper.js */ "./extensions/Edit2D/Edit2DSnapper.js");
/* harmony import */ var _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UnitHandler.js */ "./extensions/Edit2D/UnitHandler.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tools/MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/PolygonTool.js */ "./extensions/Edit2D/tools/PolygonTool.js");
/* harmony import */ var _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/PolygonEditTool.js */ "./extensions/Edit2D/tools/PolygonEditTool.js");
/* harmony import */ var _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/InsertSymbolTool.js */ "./extensions/Edit2D/tools/InsertSymbolTool.js");
/* harmony import */ var _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tools/RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./tools/UndoTool.js */ "./extensions/Edit2D/tools/UndoTool.js");
/* harmony import */ var _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./tools/CopyTool.js */ "./extensions/Edit2D/tools/CopyTool.js");
/* harmony import */ var _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tools/LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Edit2D.css */ "./extensions/Edit2D/Edit2D.css");
/* harmony import */ var _Edit2D_css__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_Edit2D_css__WEBPACK_IMPORTED_MODULE_17__);
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function _next(value) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);}function _throw(err) {asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);}_next(undefined);});};}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}




















 // IMPORTANT!!

var myExtensionName = 'Autodesk.Edit2D';
var namespace = AutodeskNamespace('Autodesk.Edit2D');
var av = Autodesk.Viewing;

var OverlayName = 'Edit2D';var

ToolSet =
function ToolSet(name, autoReactivate) {_classCallCheck(this, ToolSet);
  this.name = name;
  this.autoReactivate = autoReactivate;
  this.context = null;
  this.tools = {};
};


/** 
    * Edit2D extension provides API for implementing 2D vector editing. 
    * Loading the extension does not add UI or changes behavior in the viewer. Its purpose is only
    * to provide a basis for other extensions and client applications.
    * 
    * The extension id is: `Autodesk.Edit2D`
    * 
    * @example
    *   viewer.loadExtension('Autodesk.Edit2D')
    *
    * @memberof Autodesk.Viewing.Extensions
    * @see {@link Autodesk.Viewing.Extension} for common inherited methods.
    * @alias Autodesk.Viewing.Extensions.Edit2DExtension
    * @class
    */var
Edit2DExtension = /*#__PURE__*/function (_av$Extension) {_inherits(Edit2DExtension, _av$Extension);
  function Edit2DExtension(viewer, options) {var _this;_classCallCheck(this, Edit2DExtension);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Edit2DExtension).call(this, viewer, options));

    _this.undoStack = new _UndoStack_js__WEBPACK_IMPORTED_MODULE_5__["default"]();

    // A map containing all registered Edit 3D tools (value as ToolSet) for a specific tool set name (key)
    _this._registeredTools = new Map();
    _this._boundOnModelAdded = _this._onModelAdded.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._boundOnModelRemoved = _this._onModelRemoved.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._boundOnSelectionChanged = _this._onSelectionChanged.bind(_assertThisInitialized(_assertThisInitialized(_this)));return _this;
  }_createClass(Edit2DExtension, [{ key: "load", value: function () {var _load = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:



                // The overlay "Edit2D" contains subscenes for each edit layer.
                this.viewer.impl.createOverlayScene(OverlayName);

                // Required for geometry tessellation.
                _context.next = 3;return this.viewer.loadExtension('Autodesk.CompGeom');case 3:

                this.viewer.addEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
                this.viewer.addEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

                // activate UndoTool immediately, because it runs in parallel to other tools and for all tools
                this.undoTool = new _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_14__["default"](this.undoStack);
                this.viewer.toolController.registerTool(this.undoTool);
                this.viewer.toolController.activateTool(this.undoTool.getName());case 8:case "end":return _context.stop();}}}, _callee, this);}));return function load() {return _load.apply(this, arguments);};}() }, { key: "unload", value: function unload()


    {var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
        for (var _iterator = this._registeredTools.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var toolSetName = _step.value;
          this.unregisterTools(toolSetName);
        }} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator.return != null) {_iterator.return();}} finally {if (_didIteratorError) {throw _iteratorError;}}}

      this.viewer.toolController.deregisterTool(this.undoTool);
      this.undoTool = null;

      this.viewer.removeEventListener(av.MODEL_ADDED_EVENT, this._boundOnModelAdded);
      this.viewer.removeEventListener(av.MODEL_REMOVED_EVENT, this._boundOnModelRemoved);

      return true;
    } }, { key: "_onModelAdded", value: function _onModelAdded()

    {var _this2 = this;
      if (this.viewer.getVisibleModels().length !== 1) {
        // Do the reactivation only when the first model got loaded.
        return;
      }var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {

        for (var _iterator2 = this._registeredTools.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var toolSet = _step2.value;
          if (toolSet.autoReactivate) {
            toolSet.toolsToReactivate.forEach(function (name) {return _this2.viewer.toolController.activateTool(name);});
          }
        }} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2.return != null) {_iterator2.return();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}
    } }, { key: "_onModelRemoved", value: function _onModelRemoved()

    {
      if (this.viewer.getVisibleModels().length !== 0) {
        // Only deactivate tools when no model is active anymore.
        return;
      }

      var controller = this.viewer.toolController;var _iteratorNormalCompletion3 = true;var _didIteratorError3 = false;var _iteratorError3 = undefined;try {
        for (var _iterator3 = this._registeredTools.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {var toolSet = _step3.value;
          if (toolSet.autoReactivate) {
            // The next statement gets all possible names of all tools of a toolSet,
            // flatten the resulting array
            // and returns a list tool names that are active.
            toolSet.toolsToReactivate = Object.values(toolSet.tools).
            map(function (t) {return t.getNames();}).
            reduce(function (res, names) {return res.concat(names);}, []) // flatten
            .filter(function (name) {return controller.isToolActivated(name);});

            toolSet.toolsToReactivate.forEach(function (name) {return controller.deactivateTool(name);});
          }
        }} catch (err) {_didIteratorError3 = true;_iteratorError3 = err;} finally {try {if (!_iteratorNormalCompletion3 && _iterator3.return != null) {_iterator3.return();}} finally {if (_didIteratorError3) {throw _iteratorError3;}}}
    }

    // If multiple tools are registered, we have to clear the other selections as the mouse events are handled on the first one.
  }, { key: "_onSelectionChanged", value: function _onSelectionChanged(_ref) {var selectionSource = _ref.target;var _iteratorNormalCompletion4 = true;var _didIteratorError4 = false;var _iteratorError4 = undefined;try {
        for (var _iterator4 = this._registeredTools.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {var toolSet = _step4.value;
          if (selectionSource !== toolSet.context.selection && !selectionSource.empty()) {
            toolSet.context.selection.clear();
          }
        }} catch (err) {_didIteratorError4 = true;_iteratorError4 = err;} finally {try {if (!_iteratorNormalCompletion4 && _iterator4.return != null) {_iterator4.return();}} finally {if (_didIteratorError4) {throw _iteratorError4;}}}
    } }, { key: "registerDefaultTools", value: function registerDefaultTools()

    {
      this.defaultContext = this.registerTools('default');
    } }, { key: "registerTools", value: function registerTools(

    toolSetName) {var autoReactivate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var toolSet = this._registeredTools.get(toolSetName);
      if (toolSet) {
        console.warn("Edit 2D tools are already registered for tool set '".concat(toolSetName, "'"));
        return toolSet.context;
      }

      toolSet = new ToolSet(toolSetName, autoReactivate);
      this._registeredTools.set(toolSetName, toolSet);

      // create context
      var context = toolSet.context = new Edit2DContext(this, toolSetName);
      context.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      // create tools
      toolSet.tools.polygonTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_10__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_10__["default"].Mode.Polygon);
      toolSet.tools.polylineTool = new _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_10__["default"](context, _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_10__["default"].Mode.Polyline);
      toolSet.tools.moveTool = new _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_9__["default"](context);
      toolSet.tools.polygonEditTool = new _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_11__["default"](context);
      toolSet.tools.insertSymbolTool = new _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_12__["default"](context);
      toolSet.tools.copyTool = new _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_15__["default"](context);

      // register them
      var controller = this.viewer.toolController;
      controller.registerTool(toolSet.tools.polygonTool);
      controller.registerTool(toolSet.tools.polylineTool);
      controller.registerTool(toolSet.tools.moveTool);
      controller.registerTool(toolSet.tools.polygonEditTool);
      controller.registerTool(toolSet.tools.insertSymbolTool);
      controller.registerTool(toolSet.tools.copyTool);

      // activate CopyTool immediately, because they run parallel to other tools
      controller.activateTool(toolSet.tools.copyTool.getName());

      return context;
    } }, { key: "unregisterDefaultTools", value: function unregisterDefaultTools()

    {
      this.unregisterTools('default');
      this.defaultContext = null;
    } }, { key: "unregisterTools", value: function unregisterTools(

    toolSetName) {
      var toolSet = this._registeredTools.get(toolSetName);
      if (!toolSet) {
        return;
      }

      var controller = this.viewer.toolController;
      controller.deregisterTool(toolSet.tools.polygonTool);
      controller.deregisterTool(toolSet.tools.polylineTool);
      controller.deregisterTool(toolSet.tools.moveTool);
      controller.deregisterTool(toolSet.tools.polygonEditTool);
      controller.deregisterTool(toolSet.tools.insertSymbolTool);
      controller.deregisterTool(toolSet.tools.copyTool);

      toolSet.context.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"].Events.SELECTION_CHANGED, this._boundOnSelectionChanged);

      this._registeredTools.delete(toolSetName);
    } }, { key: "createLayer", value: function createLayer()

    {

      var model = this.viewer.model;
      if (!model || !model.is2d()) {
        console.error("A 2D model is needed to adjust viewport");
      }

      // determine drawing viewport from model bbox
      var box = model.getBoundingBox();
      var width = box.max.x - box.min.x;
      var height = box.max.y - box.min.y;

      // create new overlay scene to show
      var layer = new _EditLayer_js__WEBPACK_IMPORTED_MODULE_0__["default"](width, height, this.viewer);

      // add layer scene to our overlay scene
      this.viewer.impl.overlayScenes[OverlayName].scene.add(layer.scene);

      return layer;
    } }]);return Edit2DExtension;}(av.Extension);


// Common set of objects usually needed by tools
var Edit2DContext =

// @param {Edit2D} ext - Edit2d extension
function Edit2DContext(ext, toolSetName) {_classCallCheck(this, Edit2DContext);
  this.toolSetName = toolSetName;
  this.viewer = ext.viewer;
  this.layer = ext.createLayer();
  this.gizmoLayer = ext.createLayer();
  this.undoStack = ext.undoStack;
  this.selection = new _Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"](this.layer, this.undoStack);
  this.snapper = new _Edit2DSnapper_js__WEBPACK_IMPORTED_MODULE_6__["default"](this.viewer, this.layer, this.gizmoLayer);
  this.unitHandler = new _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__["DefaultUnitHandler"](this.viewer);
};


// Register the extension with the extension manager.
Autodesk.Viewing.theExtensionManager.registerExtension(myExtensionName, Edit2DExtension);

namespace.Polygon = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polygon"];
namespace.Polyline = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Polyline"];
namespace.PolyBase = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["PolyBase"];
namespace.Circle = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Circle"];
namespace.Style = _EditShapes_js__WEBPACK_IMPORTED_MODULE_1__["Style"];
namespace.PolygonTool = _tools_PolygonTool_js__WEBPACK_IMPORTED_MODULE_10__["default"];
namespace.Selection = _Selection_js__WEBPACK_IMPORTED_MODULE_2__["default"];
namespace.MoveTool = _tools_MoveTool_js__WEBPACK_IMPORTED_MODULE_9__["default"];
namespace.PolygonEditTool = _tools_PolygonEditTool_js__WEBPACK_IMPORTED_MODULE_11__["default"];
namespace.InsertSymbolTool = _tools_InsertSymbolTool_js__WEBPACK_IMPORTED_MODULE_12__["default"];
namespace.Math2D = _Math2D_js__WEBPACK_IMPORTED_MODULE_3__["Math2D"];
namespace.VertexGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["VertexGizmo"];
namespace.RectangleTool = _tools_RectangleTool_js__WEBPACK_IMPORTED_MODULE_13__["default"];
namespace.LineTool = _tools_LineTool_js__WEBPACK_IMPORTED_MODULE_16__["default"];
namespace.CopyTool = _tools_CopyTool_js__WEBPACK_IMPORTED_MODULE_15__["default"];
namespace.Actions = _Actions_js__WEBPACK_IMPORTED_MODULE_4__["Actions"];
namespace.UndoStack = _UndoStack_js__WEBPACK_IMPORTED_MODULE_5__["default"];
namespace.UndoTool = _tools_UndoTool_js__WEBPACK_IMPORTED_MODULE_14__["default"];
namespace.Edit2DContext = Edit2DContext;
namespace.CanvasGizmo = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["CanvasGizmo"];
namespace.PolygonLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["PolygonLabel"];
namespace.AlignX = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["AlignX"];
namespace.AlignY = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["AlignY"];
namespace.AreaLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["AreaLabel"];
namespace.EdgeLabel = _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_8__["EdgeLabel"];
namespace.UnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__["UnitHandler"];
namespace.DefaultUnitHandler = _UnitHandler_js__WEBPACK_IMPORTED_MODULE_7__["DefaultUnitHandler"];

/***/ }),

/***/ "./extensions/Edit2D/Edit2DSnapper.js":
/*!********************************************!*\
  !*** ./extensions/Edit2D/Edit2DSnapper.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Edit2DSnapper; });
/* harmony import */ var _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AngleSnapper.js */ "./extensions/Edit2D/AngleSnapper.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


// Edit2DSnapper combines 3 different types of snapping:
//  1. Snapping to sheet geometry
//  2. Snapping to other geometry in the same layer
//  3. Snapping to angles and alignments
var

Edit2DSnapper = /*#__PURE__*/function () {

  // @param {Viewer3D} viewer
  // @param {Layer} layer
  // @param {EditLayer} gizmoLayer - used to add temporary snapping indicators (e.g., dashed lines for angle snapping)
  function Edit2DSnapper(viewer, layer, gizmoLayer) {_classCallCheck(this, Edit2DSnapper);

    this.viewer = viewer;
    this.layer = layer;
    this.gizmoLayer = gizmoLayer;

    // Used for sheet geometry
    this.sheetSnapper = new Autodesk.Viewing.MeasureCommon.Snapper(viewer);

    // Used for layer geometry
    this.layerSnapper = new Autodesk.Viewing.MeasureCommon.Snapper(viewer);

    // Used for snapping to angles and alignments
    this.angleSnapper = new _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_0__["default"](gizmoLayer);

    // tmp box reused for snapping
    this.snapBox = new THREE.Box2();

    // make sure SnapperIndicator exists. Note that angleSnapper does not need this - only the standard LMV snapper.
    this.sheetSnapper.activate();
    this.layerSnapper.activate();

    // update Snapper indicator on camera changes (otherwise, it grows/shrinks on camera zoom)
    this.onCameraChangeCb = this.onCameraChange.bind(this);
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);
  }_createClass(Edit2DSnapper, [{ key: "dtor", value: function dtor()

    {
      this.sheetSnapper.deactivate();
      this.layerSnapper.deactivate();
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChangeCb);
    } }, { key: "onCameraChange", value: function onCameraChange()

    {
      this.updateSnapperIndicators();
    } }, { key: "updateSnapperIndicators", value: function updateSnapperIndicators()

    {
      // Note: All LMV snappers use (and clear) the same overlay scene. Therefore, we can call render() only on one of the Snapper
      // indicators. Otherwise, when snapping to sheet geometry, calling layerSnapper.indicator.render() afterwards would clear 
      // the sheet-snapping indicator again.
      if (this.sheetSnapper.isSnapped()) {
        this.sheetSnapper.indicator.render();
      } else {
        // If none is snapped, it doesn't matter which indicator we call: Both will just clear the overlay.
        this.layerSnapper.indicator.render();
      }
    }

    // Returns snapPosition as Vector2 in layer-coords. If no snapping happens, it just maps the position directly.
    //  @param {function(shape)} [snappingFilter] - Option filter to restrict EditLayer snapping to certain EditLayer shapes.
  }, { key: "getSnapPosition", value: function getSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this._getSnapPosition(canvasX, canvasY, snappingFilter);

      // keep snapping gizmos up to date
      this.angleSnapper.updateSnapLineGizmos(p);

      this.updateSnapperIndicators();

      return p;
    } }, { key: "clearSnappingGizmos", value: function clearSnappingGizmos()

    {
      this.angleSnapper.clearSnappingGizmos();
      this.sheetSnapper.clearSnapped();
      this.sheetSnapper.indicator && this.sheetSnapper.indicator.clearOverlays();
      this.layerSnapper.clearSnapped();
      this.layerSnapper.indicator && this.layerSnapper.indicator.clearOverlays();
    }

    // Angle and Alignment snapping can only be used when explicitly activated for a given polygon.
    // Otherwise, it has no effect.
  }, { key: "startAngleSnapping", value: function startAngleSnapping(poly, draggedVertex) {
      this.angleSnapper.startSnapping(poly, draggedVertex);
    }

    // Stop snapping to angles. (No effect if angleSnapping is already off).
  }, { key: "stopAngleSnapping", value: function stopAngleSnapping() {
      this.angleSnapper.stopSnapping();
    }

    // Like getSnapPosition, but excluding Snapping gizmo updates.
  }, { key: "_getSnapPosition", value: function _getSnapPosition(canvasX, canvasY, snappingFilter) {

      // Discard any outdated snapping results
      this.angleSnapper.clearSnappingResult();
      this.sheetSnapper.clearSnapped();
      this.layerSnapper.clearSnapped();

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Check if geom-snapping is possible (pGeom is in layer-coords)
      var pGeom = this._getGeomSnapPosition(canvasX, canvasY, snappingFilter);
      if (pGeom) {
        return pGeom;
      }

      // apply angle-snapping (if configured)
      this.angleSnapper.snapToAngle(p);
      return p;
    }

    // Gets snap position from mouse event. 
    //  @returns {Vector2|null} Snapped position or null if not snapped.
  }, { key: "_getGeomSnapPosition", value: function _getGeomSnapPosition(canvasX, canvasY, snappingFilter) {

      var p = this.layer.canvasToLayer(canvasX, canvasY);

      // Compute snap position for model geom and edit layer. 
      // Both may be undefined if there was nothing to snap to.
      var pSheet = this._getSheetSnapPosition(canvasX, canvasY);
      var pLayer = this._getEditLayerSnapPosition(canvasX, canvasY, snappingFilter);

      // If nothing is snapped, don't snap
      if (!pSheet && !pLayer) {
        return null;
      }

      // If only one snap point was found, use it
      if (!pLayer) {
        return pSheet;
      } else if (!pSheet) {
        return pLayer;
      }

      // Get distances of snapPoints to accurate position
      var distSheet = THREE.Vector2.prototype.distanceToSquared.call(pSheet, p);
      var distLayer = THREE.Vector2.prototype.distanceToSquared.call(pLayer, p);

      // Choose the closer snap. If equal, prefer edit layer snap.
      // We discard unused snap results here, so that snapper indicator keeps correct
      if (distSheet < distLayer) {
        // Use sheet snap and discard the other snap result
        this.layerSnapper.clearSnapped();
        return pSheet;
      } else {
        // Use layer snap and discard the other snap result
        this.sheetSnapper.clearSnapped();
        return pLayer;
      }
    }

    // Snaps to 2D edit layer geometry. Returns the snapped point in world coordinates or undefined if not snapped.
  }, { key: "_getEditLayerSnapPosition", value: function _getEditLayerSnapPosition(canvasX, canvasY, snappingFilter) {

      // get world position. 
      // Note that we cannot use layer.canvasToLayer here, because snapper needs a Vector3 to work.
      var point = this.viewer.impl.intersectGround(canvasX, canvasY);

      // compute snap radius in world (=layer) coords
      var radius = this.layerSnapper.setDetectRadius(point);

      // create bbox centered at the point and expanded by snapRadius in each direction
      this.snapBox.min.set(point.x - radius, point.y - radius);
      this.snapBox.max.set(point.x + radius, point.y + radius);

      // Build dictionary of dbIds of all shapes intersecting the snapBox
      var dbIds = {};
      this.layer.enumShapes(this.snapBox, function (shape) {
        // Collect dbId - unless shape is excluded from snapping
        if (!snappingFilter || snappingFilter(shape)) {
          dbIds[shape.id] = true;
        }
      });

      // Collect all triangulated meshes intersecting the snapBox
      var meshes = [];
      this.layer.enumMeshes(this.snapBox, function (mesh) {return meshes.push(mesh);});

      // Edit geometry is created by LmvCanvasContext, which does not use instancing.
      var useInstancing = false;

      // Only consider edges/arcs/vertices within snapRadius
      var filter = function filter(dbId) {return Boolean(dbIds[dbId]);};

      // Run snapper on the given meshes/dbIds
      this.layerSnapper.clearSnapped();
      this.layerSnapper.snapping2DOverlay(point, meshes, filter, useInstancing);

      // Stop here if nothing was snapped
      if (!this.layerSnapper.isSnapped()) {
        return undefined;
      }

      // return snapped 2d world position
      var res = this.layerSnapper.getSnapResult();
      return Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer);
    }

    // Snaps to sheet geometry. Returns the snapped point in world coordinates or undefined if not snapped.
  }, { key: "_getSheetSnapPosition", value: function _getSheetSnapPosition(canvasX, canvasY) {
      // Update snapper
      this.sheetSnapper.onMouseMove({ x: canvasX, y: canvasY });

      // If not snapped, just return current position
      if (!this.sheetSnapper.isSnapped()) {
        return undefined;
      }

      // get snapped position
      var res = this.sheetSnapper.getSnapResult();
      var p3D = Autodesk.Viewing.MeasureCommon.getSnapResultPosition(res, this.viewer); // returns Vector3

      // Make sure that we consistently return 2D for all snapping types. Otherwise, we produce traps when using things like distanceTo()
      return new THREE.Vector2().copy(p3D);
    } }]);return Edit2DSnapper;}();

/***/ }),

/***/ "./extensions/Edit2D/EditLayer.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/EditLayer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditLayer; });
/* harmony import */ var _PDF_LmvCanvasContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../PDF/LmvCanvasContext.js */ "./extensions/PDF/LmvCanvasContext.js");
/* harmony import */ var _PDF_test_pattern_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../PDF/test-pattern.js */ "./extensions/PDF/test-pattern.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}



var nextLayerId = 1;

// Radius in pixels used for hit-tests of thin lines. Hits within this distance are always considered, even if actual lineWidth is smaller.
var DefaultLineHitRadius = 10;

// A layer manages a set of 2D shapes like polygons, polylines etc. for editing and display.
var EditLayer = /*#__PURE__*/function () {

  // @param {LmvCanvasContext} ctx  - LmvCanvasContext used for converting the polygons into renderable 2d geometry    
  // @param {number} width, height  - Extents of the drawable area
  // @param {number} toPageUnit     - Scale factor applied to all generated geometry.
  // @param {Viewer3D} viewer       - Viewer instance needed to create materials
  function EditLayer(width, height, viewer) {var _this = this;_classCallCheck(this, EditLayer);

    // Contains the triangulated geometry ready for rendering.
    this.scene = new THREE.Scene();

    // @param {Shape[]}
    this.shapes = [];

    // @param {CanvasGizmo[]}
    this.canvasGizmos = [];

    this.id = nextLayerId++;

    // We don't use font rendering so far
    var fontEngine = null;

    this.viewport = {
      width: width,
      height: height };


    // Always use client coords for drawing
    var toPageUnits = 1.0;

    this.context = new _PDF_LmvCanvasContext_js__WEBPACK_IMPORTED_MODULE_0__["LmvCanvasContext"](this.viewport, toPageUnits, this._processMesh.bind(this), fontEngine);

    this.viewer = viewer;

    // By default, we always update on modification operations. But it can (and should) be temporarily disabled 
    // for batch operations. 
    this.autoUpdate = true;

    this.toPageUnits = toPageUnits;

    this.styleModifiers = [];

    Object(_PDF_test_pattern_js__WEBPACK_IMPORTED_MODULE_1__["addContextCurrentTransform"])(this.context.canvasContext);

    // Update gizmo positions on camera changes
    this.onCameraChange = function () {return _this.updateCanvasGizmos();};
    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
  }_createClass(EditLayer, [{ key: "dtor", value: function dtor()

    {
      this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    }

    // @param {Shape} shape
    // @returns {number} - The id of the shape. Used to access this shape later.
  }, { key: "addShape", value: function addShape(shape) {
      this.shapes.push(shape);

      this._onModified();
    }

    // Removes the given shape. 
    //  @returns {bool} true if shape was found and removed, otherwise false.
  }, { key: "removeShape", value: function removeShape(shape) {
      var index = this.shapes.indexOf(shape);
      if (index === -1) {
        return false;
      }
      this.shapes.splice(index, 1);

      this._onModified();
      return true;
    } }, { key: "clear", value: function clear()

    {
      this.shapes.length = 0;

      this._onModified();
    }

    // Must be called after modifications to update the scene.
  }, { key: "update", value: function update() {

      // clear scene
      this.scene.children.length = 0;

      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // apply override style if specified
        var overrideStyle = this._getOverrideStyle(shape);

        shape.draw(this.context, overrideStyle);
      }

      // Make sure that all shapes are processed
      this.context.flushBuffer(0, true);

      // Currently, we only draw to overlay scenes. We may generalize that if we use it for planes in 3D later.
      this.viewer.impl.invalidate(false, false, true);

      // Update CanvasGizmos, e.g., to update polygon gizmo position if a polygon changed
      this.updateCanvasGizmos();
    } }, { key: "updateCanvasGizmos", value: function updateCanvasGizmos()

    {
      for (var i = 0; i < this.canvasGizmos.length; i++) {
        this.canvasGizmos[i].update();
      }
    } }, { key: "addCanvasGizmo", value: function addCanvasGizmo(

    gizmo) {
      this.canvasGizmos.push(gizmo);
    } }, { key: "removeCanvasGizmo", value: function removeCanvasGizmo(

    gizmo) {
      var index = this.canvasGizmos.indexOf(gizmo);
      if (index === -1) {
        return false;
      }
      this.canvasGizmos.splice(index, 1);
      return true;
    } }, { key: "getViewport", value: function getViewport()

    {
      return this.viewport;
    }

    // Returns the topmost shape containing the point (x,y)
    //  @param {number} hitRadius - Used for hit-test of thin line-features. Points within this radius around a line are considered as hits - even if the actual lineWidth is smaller.
  }, { key: "hitTest", value: function hitTest(x, y) {var hitRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DefaultLineHitRadius;

      // process shapes backwards to find topmost first
      for (var i = this.shapes.length - 1; i >= 0; i--) {
        var shape = this.shapes[i];
        var radiusLC = this.getLineHitRadius(shape, hitRadius);

        if (shape.hitTest(x, y, radiusLC)) {
          return shape;
        }
      }
    }

    // Used for line-feature hit tests: 
    // We consider a point p to be "on edge e" if p is within a certain radius around e.
    // This radius depends on style and a certain min-distance in pixels used for thin lines. Result is in layer-coords.
  }, { key: "getLineHitRadius", value: function getLineHitRadius(shape) {var hitRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultLineHitRadius;

      var unitsPerPixel = this.getUnitsPerPixel();

      // Get line-width in layer coords
      var lineWidth = (shape.style.isScreenSpace ? unitsPerPixel : 1) * shape.style.lineWidth;

      // For thin lines, consider hits as long as they are within minPixels radius
      return Math.max(lineWidth, hitRadius * unitsPerPixel);
    }

    // Optional: Sets a callback to override the style for either all or a subset of shapes.
    //  @param {function(Shape, Style)} modifier - A callback that takes a shape as input and returns undefined (=no change) or a valid override style object.
  }, { key: "addStyleModifier", value: function addStyleModifier(modifier) {
      this.styleModifiers.push(modifier);
      this._onModified();
    } }, { key: "removeStyleModifier", value: function removeStyleModifier(

    modifier) {
      var index = this.styleModifiers.indexOf(modifier);
      if (index == -1) {
        return false;
      }
      this.styleModifiers.splice(index, 1);
      this._onModified();
      return true;
    }

    // Convert layer coordinates to canvas coords.
  }, { key: "layerToCanvas", value: function layerToCanvas(x, y) {
      // For now, worldCoords.xy is identical with layer coords. This will change once we extend it to planes that can be embedded into 3D.
      var res = this.viewer.impl.worldToClient(new THREE.Vector3(x, y, 0));
      return new THREE.Vector2(res.x, res.y);
    } }, { key: "getPixelsPerUnit", value: function getPixelsPerUnit()

    {
      if (!this.viewer.model) {
        console.warn('Accessing EditLayer.getPixelsPerUnit is impossible when no model is loaded.');
        return 1.0;
      }

      var camera = this.viewer.impl.camera;
      var worldBox = this.viewer.impl.getVisibleBounds();
      return this.viewer.impl.getPixelsPerUnit(camera, worldBox) / window.devicePixelRatio;
    } }, { key: "getUnitsPerPixel", value: function getUnitsPerPixel()

    {
      return 1.0 / this.getPixelsPerUnit();
    }

    // Convert canvas coordinates (from input events) to layer viewport coordinates
  }, { key: "canvasToLayer", value: function canvasToLayer(canvasX, canvasY)
    {
      // We use intersectGround, because clientToWorld returns null when clicking outside of the sheet
      var res = this.viewer.impl.intersectGround(canvasX, canvasY);
      return new THREE.Vector2(res.x, res.y);
    }

    // Runs the callback for all shapes in the layer that overlap the given bbox
    //  @param {Box2} bbox
    //  @param {function(Shape)} cb
  }, { key: "enumShapes", value: function enumShapes(bbox, cb) {
      for (var i = 0; i < this.shapes.length; i++) {
        var shape = this.shapes[i];

        // Make sure that bbox is up-to-date
        shape.updateBBox();

        if (bbox.isIntersectionBox(shape.bbox)) {
          cb(shape);
        }
      }
    }

    // Runs the callback for all triangulated 2D meshes created in the last update() call.
  }, { key: "enumMeshes", value: function enumMeshes(bbox, cb) {
      for (var i = 0; i < this.scene.children.length; i++) {
        var mesh = this.scene.children[i];
        var meshBox = mesh.geometry.boundingBox;

        // Note: The worldMatrix is not used for triangulated Edit2D meshes, so it will always be identity. Otherwise,
        //       we would need to compute a world-box using applyMatrixWorld() here.

        // Note that meshes have a 3D box, but we are only interested in 2D check. Therefore,
        // it's important to call intersectsBox on the input box and not on the mesh.
        if (bbox.isIntersectionBox(meshBox)) {
          cb(mesh);
        }
      }
    } }, { key: "findShapeById", value: function findShapeById(

    id) {
      return this.shapes.find(function (s) {return s.id == id;});
    }

    // 
    // --- Internal functions ---
    //

    // process meshData produced by LmvCanvasContext
  }, { key: "_processMesh", value: function _processMesh(meshData) {

      // create GeometryBuffer
      var mdata = { mesh: meshData, is2d: true, packId: "0", meshIndex: 0 };
      Autodesk.Viewing.Private.BufferGeometryUtils.meshToGeometry(mdata);
      var geom = mdata.geometry;

      // create 2D material
      var matman = this.viewer.impl.getMaterials();
      var model = this.viewer.model; // Todo: Check if it works to create a material without relying to a model
      var matName = matman.create2DMaterial(model, meshData.material);
      var material = matman.findMaterial(model, matName);

      // collect mesh
      var mesh = new THREE.Mesh(geom, material);
      this.scene.children.push(mesh);
    } }, { key: "_onModified", value: function _onModified()

    {
      if (this.autoUpdate) {
        this.update();
      }
    }

    // Apply one or more style modifiers
  }, { key: "_getOverrideStyle", value: function _getOverrideStyle(shape) {
      var style = shape.style;
      for (var i = 0; i < this.styleModifiers.length; i++) {
        var mod = this.styleModifiers[i];
        style = mod(shape, style) || style;
      }
      return style;
    } }]);return EditLayer;}();

/***/ }),

/***/ "./extensions/Edit2D/EditShapes.js":
/*!*****************************************!*\
  !*** ./extensions/Edit2D/EditShapes.js ***!
  \*****************************************/
/*! exports provided: Style, Shape, PolyBase, Polygon, Polyline, Circle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Style", function() { return Style; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyBase", function() { return PolyBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return Polygon; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Polyline", function() { return Polyline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circle", function() { return Circle; });
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math2D.js */ "./extensions/Edit2D/Math2D.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var nextShapeId = 1;

var toColor = function toColor(r, g, b) {
  return "rgb(" + r + "," + g + "," + b + ")";
};

var cloneVectorArray = function cloneVectorArray(src) {
  return src.map(function (p) {return { x: p.x, y: p.y };});
};

var Style = /*#__PURE__*/function () {

  /**
                                              * Creates a new Style for the Edit 2D tools.
                                              * @param {object} [params]           - various style values to overwrite the default style.
                                              * @param {string} [params.color]     - sets the color for the line and fill area
                                              * @param {number} [params.alpha]     - sets the alpha value for the line and fill area
                                              * @param {string} [params.lineColor] - sets the color for the line
                                              * @param {number} [params.lineAlpha] - sets the alpha value for the line
                                              * @param {number} [params.lineWidth] - sets the line width for the line.
                                              * @param {number} [params.lineStyle] - sets the style of the line
                                              * @param {string} [params.fillColor] - sets the color for the fill area
                                              * @param {number} [params.fillAlpha] - sets the alpha value for the fill area
                                              */
  function Style() {var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};_classCallCheck(this, Style);
    this.lineColor = params.lineColor || params.color || "rgb(0,0,64)";
    this.lineAlpha = params.lineAlpha !== undefined ? params.lineAlpha : params.alpha !== undefined ? params.alpha : 1.0;
    this.lineWidth = params.lineWidth !== undefined ? params.lineWidth : 3.0;

    this.fillColor = params.fillColor || params.color || "rgb(0,0,64)";
    this.fillAlpha = params.fillAlpha !== undefined ? params.fillAlpha : params.alpha !== undefined ? params.alpha : 0.2;

    // lineStyle is an index into a list of dash/dot patterns defined in See LineStyleDef.js.
    // Examples:
    //   0:  Solid line:    ______________
    //   10: Dashes long:   __ __ __ __ __
    //   11: Dashes short:  _ _ _ _ _ _ _
    //   12: Dashes longer: ___ ___ ___ ___
    //   16: Dots:          . . . . . . .
    //   17: Dots dense:    ..............
    //   18: Dots sparse:   .  .  .  .  .
    this.lineStyle = params.lineStyle || 0;

    // By default, we interpret line widths in screen-space
    this.isScreenSpace = params.isScreenSpace !== undefined ? params.isScreenSpace : true;
  }

  // Components r,b,g are in [0,255]
  _createClass(Style, [{ key: "setFillColor", value: function setFillColor(r, g, b) {
      this.fillColor = toColor(r, g, b);
    } }, { key: "setLineColor", value: function setLineColor(

    r, g, b) {
      this.lineColor = toColor(r, g, b);
    } }, { key: "clone", value: function clone()

    {
      return new Style().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.lineColor = from.lineColor;
      this.lineAlpha = from.lineAlpha;
      this.lineWidth = from.lineWidth;
      this.fillColor = from.fillColor;
      this.fillAlpha = from.fillAlpha;
      this.lineStyle = from.lineStyle;
      this.isScreenSpace = from.isScreenSpace;
      return this;
    } }]);return Style;}();


Style.toColor = toColor;

var DefaultStyle = new Style();

// Set dstBox to bbox of all points
var pointArrayBBox = function pointArrayBBox(points, dstBox) {
  dstBox.makeEmpty();
  for (var i = 0; i < points.length; i++) {
    dstBox.expandByPoint(points[i]);
  }
};

var Shape = /*#__PURE__*/function () {
  function Shape(style) {_classCallCheck(this, Shape);
    this.style = style;

    // assign unique id
    this.id = nextShapeId++;

    this.bbox = new THREE.Box2();
    this.bboxDirty = true;

    // Should be set by creator by something more descriptive.
    this.name = this.id.toString();
  }

  // Must be provided by derivaties
  _createClass(Shape, [{ key: "draw", value: function draw() /*ctx, overrideStyle*/{} }, { key: "hitTest", value: function hitTest()
    /*x, y, hitRadius*/{} // hitRadius is a distance in layer-coords used for line feature hit-tests.

    // Todo: Clarify whether Shapes should have an own matrix or always modified in-place
  }, { key: "move", value: function move() /*dx, dy*/{} }, { key: "clone", value: function clone()

    {
      return new Shape().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      this.style = from.style.clone();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      console.error("Must be implemented by derived class.");
    } }, { key: "modified", value: function modified()

    {
      this.bboxDirty = true;
    } }, { key: "updateBBox", value: function updateBBox()

    {
      if (this.bboxDirty) {
        this.computeBBox();
        this.bboxDirty = false;
      }
    } }]);return Shape;}();


// Common base class for Polygons and Polylines
var PolyBase = /*#__PURE__*/function (_Shape) {_inherits(PolyBase, _Shape);

  function PolyBase() {var _this;var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, PolyBase);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolyBase).call(this, style));

    // Array of points, each represented as an object {x, y}
    _this.points = points;return _this;
  }_createClass(PolyBase, [{ key: "isPolygon", value: function isPolygon()

    {
      return this instanceof Polygon;
    } }, { key: "isPolyline", value: function isPolyline()

    {
      return this instanceof Polyline;
    } }, { key: "addPoint", value: function addPoint(

    x, y) {
      this.points.push({ x: x, y: y });
      this.modified();
    } }, { key: "getPoint", value: function getPoint(

    index, target) {
      target = target || new THREE.Vector2();
      return target.copy(this.points[index]);
    } }, { key: "removePoint", value: function removePoint(

    index) {
      this.points.splice(index, 1);
    } }, { key: "updatePoint", value: function updatePoint(

    index, x, y) {
      var p = this.points[index];
      p.x = x;
      p.y = y;
      this.modified();
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {
      this.points.splice(index, 0, p);
    } }, { key: "clear", value: function clear()





    {
      this.points.length = 0;
      this.modified();
    }

    // Enumerate all edges (a,b). 
    //  @param {function(a, b, ai, bi)} cb - For each edge, we trigger cb(a, b, ai, bi), where (a,b) are the points and (ai, bi) the indices of the edge.
    //                                       If cb() returns true, the traversal stops.
  }, { key: "enumEdges", value: function enumEdges(cb) {

      // get edge count
      var edgeCount = this.isPolygon() ? this.length : this.length - 1;

      // check for each edge whether p is close to it.
      for (var i = 0; i < edgeCount; i++) {
        // get indices
        var ai = i;
        var bi = (i + 1) % this.length;

        // get points
        var a = this.getPoint(ai);
        var b = this.getPoint(bi);

        // pass all to cb
        var stop = cb(a, b, ai, bi);

        // allow early out
        if (stop) {
          return;
        }
      }
    }

    // Given a polyline or polygon, it checks if the position is close to any edge of the shape.
    // If so, it returns the index of that edge, otherwise -1.
    // All values are in layer coords.
  }, { key: "findEdgeIndex", value: function findEdgeIndex(p, precision) {

      var edgeIndex = -1;

      // Callback to find edge containing p
      var findEdgeCb = function findEdgeCb(a, b, ai) {

        // If edge contains p, store its edge index
        var containsP = _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].isPointOnEdge(p, a, b, precision);
        if (containsP) {
          edgeIndex = ai;
        }

        // Stop on success
        return containsP;
      };
      this.enumEdges(findEdgeCb);
      return edgeIndex;
    } }, { key: "move", value: function move(

    dx, dy) {
      for (var i = 0; i < this.points.length; i++) {
        this.points[i].x += dx;
        this.points[i].y += dy;
      }
      this.modified();
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(PolyBase.prototype), "copy", this).call(this, from);
      this.points = cloneVectorArray(from.points);
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      pointArrayBBox(this.points, this.bbox);
    } }, { key: "nextIndex", value: function nextIndex(

    index) {return (index + 1) % this.length;} }, { key: "prevIndex", value: function prevIndex(
    index) {return (index + this.length - 1) % this.length;} }, { key: "edgeIndexValid", value: function edgeIndexValid(

    edgeIndex) {
      var edgeCount = this.getEdgeCount();
      return edgeIndex >= 0 && edgeIndex < edgeCount;
    }

    // Copy start/end of an edge into outA, outB out params (Vector2).
    // edgeIndex must be valid.
  }, { key: "getEdge", value: function getEdge(edgeIndex, outA, outB) {
      var ia = edgeIndex;
      var ib = this.nextIndex(edgeIndex);
      this.getPoint(ia, outA);
      this.getPoint(ib, outB);
    } }, { key: "getEdgeCount", value: function getEdgeCount()

    {
      return this.isPolygon() ? this.length : this.length - 1;
    } }, { key: "length", get: function get() {return this.points.length;} }]);return PolyBase;}(Shape);


var Polygon = /*#__PURE__*/function (_PolyBase) {_inherits(Polygon, _PolyBase);

  function Polygon() {var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polygon);return _possibleConstructorReturn(this, _getPrototypeOf(Polygon).call(this,
    points, style));
  }

  // Draw Polygon into LmvCanvasContext
  _createClass(Polygon, [{ key: "draw", value: function draw(ctx, overrideStyle) {

      if (!this.length) {
        return;
      }

      var style = overrideStyle || this.style;

      ctx.dbId = this.id;
      ctx.lineStyle = style.lineStyle;
      ctx.isScreenSpace = style.isScreenSpace;

      ctx.beginPath();

      ctx.moveTo(this.points[0].x, this.points[0].y);

      for (var i = 1; i < this.points.length; i += 1) {
        ctx.lineTo(this.points[i].x, this.points[i].y);
      }

      ctx.closePath();

      var c = ctx.canvasContext;

      c.fillStyle = style.fillColor;
      c.globalAlpha = style.fillAlpha;

      ctx.fill();

      c.strokeStyle = style.lineColor;
      c.globalAlpha = style.lineAlpha;
      c.lineWidth = style.lineWidth;

      // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
      // For human eyes the line width is then the same width.
      if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

      ctx.stroke();

      // restore default values
      ctx.dbId = -1;
      ctx.lineStyle = 0;
      ctx.isScreenSpace = false;
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var cp = new Autodesk.Extensions.CompGeom.ComplexPolygon(this.points);

      // create dummy contour
      // TODO: Consider generalizing pointInCountour() to make it usable for non-indexed polygons
      var contour = [];
      for (var i = 0; i < this.length; i++) {
        contour.push(i);
      }

      return cp.pointInContour(x, y, contour);
    } }, { key: "clone", value: function clone()

    {
      return new Polygon().copy(this);
    } }, { key: "getArea", value: function getArea()

    {
      return Autodesk.Viewing.Extensions.CompGeom.polygonArea(this.points);
    } }]);return Polygon;}(PolyBase);


var Polyline = /*#__PURE__*/function (_PolyBase2) {_inherits(Polyline, _PolyBase2);

  function Polyline() {var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DefaultStyle.clone();_classCallCheck(this, Polyline);return _possibleConstructorReturn(this, _getPrototypeOf(Polyline).call(this,
    points, style));
  }_createClass(Polyline, [{ key: "makeLine", value: function makeLine()

    {var x0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var x1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;var y1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      if (this.length != 2) {
        this.clear();
        this.addPoint(x0, y0);
        this.addPoint(x1, y1);
      } else {
        this.updatePoint(0, x0, y0);
        this.updatePoint(1, x1, y1);
      }
      return this;
    }

    // Draw Polygon into LmvCanvasContext
  }, { key: "draw", value: function draw(ctx, overrideStyle) {

      if (!this.length) {
        return;
      }

      var style = overrideStyle || this.style;

      ctx.dbId = this.id;
      ctx.lineStyle = style.lineStyle;
      ctx.isScreenSpace = style.isScreenSpace;

      ctx.beginPath();

      ctx.moveTo(this.points[0].x, this.points[0].y);

      for (var i = 1; i < this.points.length; i++) {
        ctx.lineTo(this.points[i].x, this.points[i].y);
      }

      var c = ctx.canvasContext;

      c.strokeStyle = style.lineColor;
      c.globalAlpha = style.lineAlpha;
      c.lineWidth = style.lineWidth;

      // Adjust lineWidth so that specified 1px widths will be drawn as 3px on screens with devicePixelRatio == 3.
      // For human eyes the line width is then the same width.
      if (style.isScreenSpace) c.lineWidth *= window.devicePixelRatio;

      ctx.stroke();

      // restore default values
      ctx.dbId = -1;
      ctx.lineStyle = 0;
      ctx.isScreenSpace = false;
    } }, { key: "clone", value: function clone()

    {
      return new Polyline().copy(this);
    } }, { key: "computeBBox", value: function computeBBox()

    {
      pointArrayBBox(this.points, this.bbox);
    }

    // hitRadius is in layer-coords
  }, { key: "hitTest", value: function hitTest(x, y, hitRadius) {
      var edgeIndex = this.findEdgeIndex({ x: x, y: y }, hitRadius);
      return edgeIndex != -1;
    } }, { key: "getLength", value: function getLength()

    {
      var sum = 0;
      for (var i = 0; i < this.points.length - 1; i++) {
        var a = this.points[i];
        var b = this.points[i + 1];
        sum += _Math2D_js__WEBPACK_IMPORTED_MODULE_0__["Math2D"].getEdgeLength(a, b);
      }
      return sum;
    } }]);return Polyline;}(PolyBase);


var Circle = /*#__PURE__*/function (_Shape2) {_inherits(Circle, _Shape2);

  // Note: The tessSegments parameter will be removed later when the implementation uses arcs from LineShader directly.
  function Circle(centerX, centerY, radius) {var _this2;var style = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DefaultStyle.clone();var tessSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;_classCallCheck(this, Circle);
    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Circle).call(this, style));

    _this2.polygon = new Polygon([], style);

    // Force polygon.id to be the same, so that its geometry is associated with this Circle.
    // This is a bit hacky, but can be removed as soon as we use native arcs for circle rendering.
    _this2.polygon.id = _this2.id;

    _this2.centerX = centerX;
    _this2.centerY = centerY;
    _this2.radius = radius;
    _this2.tessSegments = tessSegments;

    _this2.needsUpdate = true;return _this2;
  }_createClass(Circle, [{ key: "draw", value: function draw(

    ctx, overrideStyle) {

      this.polygon.points.length = 0;

      // angle delta in degrees
      var stepSize = 360 / this.tessSegments;
      for (var angle = 0; angle < 360; angle += stepSize) {

        var a = angle * Math.PI / 180;
        var x = this.radius * Math.cos(a);
        var y = this.radius * Math.sin(a);

        this.polygon.addPoint(this.centerX + x, this.centerY + y);
      }

      this.needsUpdate = false;

      this.polygon.draw(ctx, overrideStyle);
    } }, { key: "setCenter", value: function setCenter(

    x, y) {
      this.centerX = x;
      this.centerY = y;
      this.modified();
    } }, { key: "move", value: function move(

    dx, dy) {
      this.centerX += dx;
      this.centerY += dy;
      this.modified();
    } }, { key: "hitTest", value: function hitTest(

    x, y) {
      var dx = x - this.centerX;
      var dy = y - this.centerY;
      return dx * dx + dy * dy < this.radius * this.radius;
    } }, { key: "clone", value: function clone()

    {
      return new Circle().copy(this);
    } }, { key: "copy", value: function copy(

    from) {
      _get(_getPrototypeOf(Circle.prototype), "copy", this).call(this, from);
      this.polygon = from.polygon.clone();
      this.centerX = from.centerX;
      this.centerY = from.centerY;
      this.radius = from.radius;
      this.tessSegments = from.tessSegments;
      this.modified();
      return this;
    } }, { key: "computeBBox", value: function computeBBox()

    {
      this.bbox.min.set(this.centerX - this.radius, this.centerY - this.radius);
      this.bbox.max.set(this.centerX + this.radius, this.centerY + this.radius);
    } }]);return Circle;}(Shape);

/***/ }),

/***/ "./extensions/Edit2D/Math2D.js":
/*!*************************************!*\
  !*** ./extensions/Edit2D/Math2D.js ***!
  \*************************************/
/*! exports provided: Math2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math2D", function() { return Math2D; });

// Collection of simple helper functions for 2D math functions.

// Return normalized edge direction vector (b-a).normalized
var getEdgeDirection = function getEdgeDirection(a, b, target) {
  target = target || new THREE.Vector2();

  return target.copy(b).sub(a).normalize();
};

var getEdgeCenter = function getEdgeCenter(a, b, target) {
  target = target || new THREE.Vector2();

  return target.set(0.5 * (a.x + b.x), 0.5 * (a.y + b.y));
};

// Get edge length. (a, b) can just be {x, y} pairs, i.e., not required to be THREE.Vector2
var getEdgeLength = function getEdgeLength(a, b) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt(dx * dx + dy * dy);
};

// Rotates direction vector p 90 degrees to the left. (in-place)
var turnLeft = function turnLeft(p) {
  var tmp = p.x;
  p.x = -p.y;
  p.y = tmp;
  return p;
};

// Projects a point p to a line. Works in-place
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var projectToLine = function projectToLine(p, linePoint, lineDir) {

  // dp = dot(p-linePoint, lineDir)
  var dp = (p.x - linePoint.x) * lineDir.x + (p.y - linePoint.y) * lineDir.y;

  // return linePoint + lineDir * dp
  p.set(
  linePoint.x + dp * lineDir.x,
  linePoint.y + dp * lineDir.y);

};

// Get distance between the point p and a line given by point and direction.
//  @param {Vector2} p
//  @param {Vector2} linePoint - point on the line
//  @param {Vector2} lineDir   - line direction. Must be normalized
var pointLineDistance = function () {
  var pProj = new THREE.Vector2();
  return function (p, linePoint, lineDir) {
    projectToLine(pProj.copy(p), linePoint, lineDir);
    return p.distanceTo(pProj);
  };
}();

// Calculates the intersection point of both given lines
// assumes that the lines are not parallel
// see: http://www.paulbourke.net/geometry/pointlineplane/
var intersectLines = function intersectLines(linePoint1, lineDir1, linePoint2, lineDir2, outPoint) {

  var denom = lineDir2.y * lineDir1.x - lineDir2.x * lineDir1.y;
  if (Math.abs(denom) < 1.0e-8) {return false;}

  // diff = linePoint1 - linePoint2
  var diffX = linePoint1.x - linePoint2.x;
  var diffY = linePoint1.y - linePoint2.y;

  var u = lineDir2.x * diffY - lineDir2.y * diffX;

  if (outPoint) {
    outPoint.x = linePoint1.x + u / denom * lineDir1.x;
    outPoint.y = linePoint1.y + u / denom * lineDir1.y;
  }
  return true;
};

// Rotate a vector p around origin or a given center. Works in-place.
//  @param {Vector2} p
//  @param {number}  angle in radians
//  @param [Vector2] center 
var rotateAround = function rotateAround(p, angle, center) {

  var c = Math.cos(angle);
  var s = Math.sin(angle);

  if (center) {
    p.sub(center);
  }

  var x = p.x;
  var y = p.y;

  p.x = x * c - y * s;
  p.y = x * s + y * c;

  if (center) {
    p.add(center);
  }
  return p;
};

// Returns angle in radians formed by two direction vectors. No normalization required.
//  @param {Vector2} dir1, dir2
//  @returns {number} result in [0, 2*Pi]
var angleBetweenDirections = function angleBetweenDirections(dir1, dir2) {

  // get angle formed with positive x-axis. 
  // angle1/2 are in [-Pi, Pi]
  var angle1 = Math.atan2(dir1.y, dir1.x);
  var angle2 = Math.atan2(dir2.y, dir2.x);

  // Difference is in [-2*Pi, 2*Pi]
  var angle = angle1 - angle2;

  // Map result to [0, 2*Pi] range
  if (angle < 0) angle += 2 * Math.PI;

  return angle;
};

// Returns true if p lies close to the edge (p1, p2). 
var isPointOnEdge = function isPointOnEdge(p, a, b, precision) {

  // Compute edge length
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  var length = Math.sqrt(dx * dx + dy * dy);

  var e = {
    v1: a,
    dx: dx,
    dy: dy,
    length: length,
    length2: length * length };

  return Autodesk.Extensions.CompGeom.pointOnLine(p.x, p.y, e, true, precision);
};

var edgeIsDegenerated = function edgeIsDegenerated(a, b) {var eps2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0e-10;
  return a.distanceToSquared(b) < eps2;
};

var Math2D = {
  getEdgeDirection: getEdgeDirection,
  projectToLine: projectToLine,
  pointLineDistance: pointLineDistance,
  intersectLines: intersectLines,
  rotateAround: rotateAround,
  angleBetweenDirections: angleBetweenDirections,
  getEdgeCenter: getEdgeCenter,
  getEdgeLength: getEdgeLength,
  turnLeft: turnLeft,
  isPointOnEdge: isPointOnEdge,
  edgeIsDegenerated: edgeIsDegenerated };

/***/ }),

/***/ "./extensions/Edit2D/Selection.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/Selection.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Selection; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var av = Autodesk.Viewing;var

Selection = /*#__PURE__*/function () {

  function Selection(layer, undoStack) {var _this = this;_classCallCheck(this, Selection);

    av.EventDispatcher.prototype.apply(this);

    // Keys: shapeIds, Values: shapes
    this.isSelected = {};

    // Reused as temporary override style for shapes
    this.tmpStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();

    // Callback function that controls how to modify the style on selected shapes
    this.modifier = function (shape, style) {
      // only modify style for selected shapes
      if (!_this.isSelected[shape.id]) {
        return undefined;
      }

      // Create a tmp copy of the initial shape style that is modified to indicate highlighting
      _this.tmpStyle.copy(style);

      _this.tmpStyle.fillAlpha = Math.min(_this.tmpStyle.fillAlpha + 0.3, 1);
      _this.tmpStyle.lineWidth *= 1.5;

      return _this.tmpStyle;
    };

    this.layer = layer;

    this.layer.addStyleModifier(this.modifier);

    // Make sure that selection doesn't keep deleted objects, e.g., if creation has undone
    // or a RemoveShape action happened.
    this.undoStack = undoStack;
    this.onActionCb = function (a) {return _this.onAction(a);};
    this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
  }_createClass(Selection, [{ key: "dtor", value: function dtor()

    {
      this.layer.removeStyleModifier(this.modifier);
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
    } }, { key: "setSelection", value: function setSelection(

    shapes) {

      // This works for null as well (unlike ES6 default params)
      shapes = shapes || [];

      var selected = this.getSelectedShapes();

      // Check if the set of ids changed
      var changed = false;
      if (selected.length != shapes.length) {
        changed = true;
      } else {
        // Check if any new shape was not selected before
        for (var i = 0; i < shapes.length; i++) {
          var shape = shapes[i];
          if (!this.isSelected[shape.id]) {
            changed = true;
          }
        }
      }

      if (!changed) {
        return;
      }

      // Add all shapes to this.isSelected
      this.isSelected = {};
      for (var _i = 0; _i < shapes.length; _i++) {
        var _shape = shapes[_i];
        this.isSelected[_shape.id] = _shape;
      }
      this.modified();
    } }, { key: "empty", value: function empty()

    {
      return !Object.keys(this.isSelected).length;
    }

    // Set selection to a single shape. Calling with null clears the selection.
  }, { key: "selectOnly", value: function selectOnly(shape) {
      this.setSelection(shape && [shape]);
    } }, { key: "clear", value: function clear()

    {
      this.setSelection([]);
    }

    // Passes all selected shapes to the callback
  }, { key: "getSelectedShapes", value: function getSelectedShapes() {
      return Object.values(this.isSelected);
    } }, { key: "getSelectedIds", value: function getSelectedIds()

    {
      return Object.keys(this.isSelected);
    } }, { key: "modified", value: function modified()

    {
      this.layer.update();
      this.dispatchEvent({ type: Selection.Events.SELECTION_CHANGED });
    } }, { key: "onAction", value: function onAction()

    {

      if (this.empty()) {
        return;
      }

      // Single-selection: Clear selection if selected shape has gone
      var selected = this.getSelectedShapes();
      if (selected.length == 1) {
        var exists = this.layer.findShapeById(selected[0].id);
        if (!exists) {
          this.clear();
        }
        return;
      }

      // Multi-selection: Same principle, but avoiding n^2 runtime for large selections

      // Create dictionary of all shapes in the layer
      var shapeIdExists = {};
      this.layer.shapes.forEach(function (s) {return shapeIdExists[s.id] = true;});

      // Clear all shapes from selection that don't exist anymore
      selected = selected.filter(function (s) {return shapeIdExists[s.id];});
      this.setSelection(selected);
    } }]);return Selection;}();


Selection.Events = {
  SELECTION_CHANGED: 'selectionChanged' };

/***/ }),

/***/ "./extensions/Edit2D/UndoStack.js":
/*!****************************************!*\
  !*** ./extensions/Edit2D/UndoStack.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoStack; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing;var

UndoStack = /*#__PURE__*/function () {

  function UndoStack() {_classCallCheck(this, UndoStack);

    av.EventDispatcher.prototype.apply(this);

    // Array of action objects
    this.stack = [];

    // By default, this simply points to the end of this.stack. Only if undo has been called, 
    // it points to the next operation to be run on a redo() call
    this.current = 0;
  }

  // Executes an action and pushes it to the undo stack
  _createClass(UndoStack, [{ key: "run", value: function run(action) {
      // If we did a couple of undos before, a new operation will clear all redo steps
      this.stack.length = this.current;

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action });

      this.stack.push(action);
      this.current = this.stack.length;
    } }, { key: "undo", value: function undo()

    {
      if (!this.current) {
        // We reached the beginning of the stack
        return false;
      }
      this.current--;

      var action = this.stack[this.current];

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: true });

      action.undo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: true });

      action.layer.update();

      return true;
    } }, { key: "redo", value: function redo()

    {
      var action = this.stack[this.current];
      if (!action) {
        // Nothing to redo
        return false;
      }

      this.dispatchEvent({ type: UndoStack.BEFORE_ACTION, action: action, isUndo: false });

      action.redo();

      this.dispatchEvent({ type: UndoStack.AFTER_ACTION, action: action, isUndo: false });

      this.current++;

      action.layer.update();

      return true;
    } }, { key: "clear", value: function clear()

    {
      this.stack.length = 0;
      this.current = 0;
    } }]);return UndoStack;}();


// Events sent before/after any action is executed by UndoStack
UndoStack.BEFORE_ACTION = 'beforeAction';
UndoStack.AFTER_ACTION = 'afterAction';

/***/ }),

/***/ "./extensions/Edit2D/UnitHandler.js":
/*!******************************************!*\
  !*** ./extensions/Edit2D/UnitHandler.js ***!
  \******************************************/
/*! exports provided: UnitHandler, SimpleUnitHandler, DefaultUnitHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnitHandler", function() { return UnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SimpleUnitHandler", function() { return SimpleUnitHandler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultUnitHandler", function() { return DefaultUnitHandler; });
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var avp = Autodesk.Viewing.Private;

// Interface to control display of length/area units.
var UnitHandler = /*#__PURE__*/function () {

  function UnitHandler() {_classCallCheck(this, UnitHandler);}

  // @param   {number} val - length in layer coords
  // @returns {string} String to display, including units.
  _createClass(UnitHandler, [{ key: "lengthToString", value: function lengthToString(val) {
      console.error('Not implemented');
    }

    // @param   {number} val - area in layer coords
    // @returns {string} String to display - including units.
  }, { key: "areaToString", value: function areaToString(val) {
      console.error('Not implemented');
    } }]);return UnitHandler;}();
;

// If nothing is specified, we display with 2 digits and assume all unit in inches.
var DefaultPrecision = 2;
var DefaultUnits = "inch";

// Format length / area strings based on:
//  - layerUnits:  We assume the layer to be specified in these units.
//  - displayUnit: Values are converted from layerUnits to displayUnits for display
//  - precision:   Number of digits shown
//  - scaleFactor: Optional scale factor applied to all values
var SimpleUnitHandler = /*#__PURE__*/function (_UnitHandler) {_inherits(SimpleUnitHandler, _UnitHandler);

  function SimpleUnitHandler(viewer) {var _this;_classCallCheck(this, SimpleUnitHandler);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(SimpleUnitHandler).call(this));

    _this.viewer = viewer;

    _this.config = {
      // {string} We assume layers to be in these units (in GNU units format)
      layerUnits: DefaultUnits,

      // {string} Units in which we display lengths/areas (in GNU units format)
      displayUnits: DefaultUnits,

      // {number} Number of digits that we display
      precision: DefaultPrecision,

      // {number} Optional scale factor applied to all values
      scaleFactor: 1.0 };return _this;

  }_createClass(SimpleUnitHandler, [{ key: "lengthToString", value: function lengthToString(

    val) {
      var cfg = this.config;

      // Convert length units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val);

      // Format length value with unit string				
      return avp.formatValueWithUnits(val, cfg.displayUnits, 3, cfg.precision);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      var cfg = this.config;

      // Convert area units
      val = avp.convertUnits(cfg.layerUnits, cfg.displayUnits, cfg.scaleFactor, val, 'square');

      // Format length value with unit string
      return avp.formatValueWithUnits(val, cfg.displayUnits + '^2', 3, cfg.precision);
    } }]);return SimpleUnitHandler;}(UnitHandler);
;

// The DefaultUnitHandler synchronizes the unit configuration based on current viewer model 
// and current settings from MeasureToolExtension:
//  - If MeasureExtension is loaded, it displays in the same way as Measure tools
//  - If MeasureExtension is not loaded, it just uses units of the current model without unit conversion.
//  - If there is not even a model, it falls back to a fixed default configuration (see SimpleUnitHandler)
var DefaultUnitHandler = /*#__PURE__*/function (_SimpleUnitHandler) {_inherits(DefaultUnitHandler, _SimpleUnitHandler);

  function DefaultUnitHandler(viewer) {_classCallCheck(this, DefaultUnitHandler);return _possibleConstructorReturn(this, _getPrototypeOf(DefaultUnitHandler).call(this,
    viewer));
  }_createClass(DefaultUnitHandler, [{ key: "updateConfig", value: function updateConfig()

    {
      var cfg = this.config;

      // Assume values to be in model units or default units
      var model = this.viewer.model;
      cfg.layerUnits = model ? model.getUnitString() : DefaultUnits;

      // Set other configuration values
      var ext = this.viewer.getExtension('Autodesk.Measure');
      var msrCfg = ext && ext.sharedMeasureConfig;
      if (msrCfg) {
        // get from measure extension
        cfg.displayUnits = msrCfg.units;
        cfg.precision = msrCfg.precision;
        cfg.scaleFactor = msrCfg.calibrationFactor;
      } else {
        // No Measure extension available => use defaults
        cfg.displayUnits = this.config.layerUnits;
        cfg.precision = DefaultPrecision;
        cfg.scaleFactor = 1.0;
      }
    } }, { key: "lengthToString", value: function lengthToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "lengthToString", this).call(this, val);
    } }, { key: "areaToString", value: function areaToString(

    val) {
      this.updateConfig();
      return _get(_getPrototypeOf(DefaultUnitHandler.prototype), "lengthToString", this).call(this, val);
    } }]);return DefaultUnitHandler;}(SimpleUnitHandler);

/***/ }),

/***/ "./extensions/Edit2D/tools/CopyTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/CopyTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CopyTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}

var CopyToolName = 'Edit2_CopyTool';

var av = Autodesk.Viewing;

// Apply constant offset in x/y for each paste step, so that shape copies are not exactly on top of the src shapes.
var PasteOffset = 30;var

CopyTool = /*#__PURE__*/function () {

  function CopyTool(ctx) {_classCallCheck(this, CopyTool);

    Autodesk.Viewing.EventDispatcher.prototype.apply(this);

    this.viewer = ctx.viewer;
    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // {Shape[]}
    this.clipBoard = [];
  }_createClass(CopyTool, [{ key: "copy", value: function copy()

    {
      this.clipBoard.length = 0;

      var shapes = this.selection.getSelectedShapes();
      // Store the original shapes that get copied for event handlers
      this.originalShapes = shapes;
      // Clone the original shapes to the clipboard, as they will be modified in the course of pasting
      this.clipBoard = shapes.map(function (s) {return s.clone();});
    } }, { key: "paste", value: function paste()

    {

      // Offsets applied to all pasted copies
      var offset = PasteOffset / this.layer.getPixelsPerUnit();

      // Insert copies of shapes in the clipboard (+ add offset per paste steps)
      var shapes = [];

      var eventArgs = { type: CopyTool.BEFORE_PASTE, originalShapes: this.originalShapes, veto: false };
      this.dispatchEvent(eventArgs);
      if (eventArgs.veto) {
        return;
      }

      for (var i = 0; i < this.clipBoard.length; i++) {
        var shape = this.clipBoard[i];

        // Apply offset before cloning, so that another paste will add another offset
        shape.move(offset, offset);

        // Insert copy
        var newShape = shape.clone();
        shapes.push(newShape);

        // Change selection to new shape
        this.selection.selectOnly(newShape);
      }

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].AddShapes(this.layer, shapes));

      this.dispatchEvent({ type: CopyTool.AFTER_PASTE, originalShapes: this.originalShapes, shapes: shapes });
    }

    // delete all selected shapes
  }, { key: "delete", value: function _delete() {
      var shapes = this.selection.getSelectedShapes();
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].RemoveShapes(this.layer, shapes));
      this.selection.clear();
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (!this.selection.empty()) {
        if (keyCode === av.KeyCode.DELETE) {
          this.delete();
          return true;
        }

        if (event.ctrlKey && keyCode === av.KeyCode.c) {
          this.copy();
          return true;
        }
      }

      if (this.clipBoard.length !== 0) {
        if (event.ctrlKey && keyCode === av.KeyCode.v) {
          this.paste();
          return true;
        }
      }
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return CopyToolName + this.nameSuffix;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return CopyTool;}();
;

CopyTool.BEFORE_PASTE = "BEFORE_PASTE";
CopyTool.AFTER_PASTE = "AFTER_PASTE";

/***/ }),

/***/ "./extensions/Edit2D/tools/EditToolBase.js":
/*!*************************************************!*\
  !*** ./extensions/Edit2D/tools/EditToolBase.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EditToolBase; });
/* harmony import */ var _Selection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Selection.js */ "./extensions/Edit2D/Selection.js");
/* harmony import */ var _UndoStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UndoStack.js */ "./extensions/Edit2D/UndoStack.js");
/* harmony import */ var _AngleSnapper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AngleSnapper.js */ "./extensions/Edit2D/AngleSnapper.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}





var av = Autodesk.Viewing;


// Utility class shared by Edit2D tools to facilitate snapping
var EditToolBase = /*#__PURE__*/function () {

  function EditToolBase(ctx) {var _this = this;_classCallCheck(this, EditToolBase);

    this.viewer = ctx.viewer;
    this.layer = ctx.layer;
    this.gizmoLayer = ctx.gizmoLayer;
    this.snapper = ctx.snapper;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.unitHandler = ctx.unitHandler;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // If true, all mouse-dragging handlers just return false, so that the events are handled by LMV navigation tools instead.
    this.ignoreDragging = false;

    // This flag is used to avoid triggering handleExternalAction if we triggered an action ourselves.
    this.ignoreActions = false;

    // If another tool applies changes while this tool is active, we want to keep the tool state consistent.
    // E.g., the UndoTool or CopyTool may be active in parallel and may modify/remove a polygon we are working on.
    // his event listener makes sure that handleExternalAction() is called in this case so that this tool can respond. 
    this.onActionCb = function (a) {
      if (!_this.ignoreActions) {
        _this.handleExternalAction(a);
      }
    };

    // indicates if snapping is currently suppressed by hold modifier key
    this.suppressSnapping = false;

    this.keyMap = {
      SnapKey: av.KeyCode.SHIFT, // Holding this key suppresses snapping
      PanKey: av.KeyCode.SPACE // Holding space bypasses all edit tools, so that default navigation (usually panning) steps in
    };

    // When using selection, register a handler to notify about selection changed
    if (this.selection) {
      this.selectionCb = function () {

        // Only respond if tool is activated
        if (!_this.active) {
          return;
        }

        // Call handler if derived class defines one
        _this.onSelectionChanged && _this.onSelectionChanged();
      };

      this.selection.addEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
    }

    this.active = false;

    // Track last mouse position in canvas coords. Note that derived classes must call
    // the base class mouse handlers to keep this value valid.
    this.canvasPos = new THREE.Vector2();
  }_createClass(EditToolBase, [{ key: "getSnapPosition", value: function getSnapPosition(

    canvasX, canvasY) {var _this2 = this;
      var useSnapper = this.snapper && !this.suppressSnapping;
      if (useSnapper) {
        return this.snapper.getSnapPosition(canvasX, canvasY, function (s) {return _this2.snappingFilter(s);});
      } else {
        // Make sure that we don't keep outdated snapping gizmos
        this.snapper.clearSnappingGizmos();

        // Just convert canvas pos to layer pos
        return this.layer.canvasToLayer(canvasX, canvasY);
      }
    } }, { key: "dtor", value: function dtor()

    {
      if (this.selectionCb) {
        this.selection.removeEventListener(_Selection_js__WEBPACK_IMPORTED_MODULE_0__["default"].Events.SELECTION_CHANGED, this.selectionCb);
      }
    } }, { key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Hold key to suppress snapping
      if (keyCode === this.keyMap.SnapKey && !this.suppressSnapping) {
        this.suppressSnapping = true;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      // While edit tools are active the BACKSPACE key should not make the browser go back in history, otherwise
      // the customer might lose his drawings when he's in an editing session, does a invalid selection and
      // hits backspace.
      if (keyCode === av.KeyCode.BACKSPACE) {
        return true;
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = true;
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      if (keyCode === this.keyMap.SnapKey && this.suppressSnapping) {
        this.suppressSnapping = false;

        // Let tool instantly update hover-gizmos
        this.onSnappingToggled && this.onSnappingToggled(this.canvasPos.x, this.canvasPos.y);
      }

      if (keyCode === this.keyMap.PanKey) {
        this.ignoreDragging = false;
      }
    }

    // Invoked whenever another tool triggered 
  }, { key: "handleExternalAction", value: function handleExternalAction(action) {}

    // Run an action without triggering handleExternalAction
  }, { key: "runAction", value: function runAction(action) {
      this.ignoreActions = true;
      this.undoStack.run(action);
      this.ignoreActions = false;
    } }, { key: "activate", value: function activate()

    {
      this.active = true;
      this.undoStack.addEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);
    } }, { key: "deactivate", value: function deactivate()

    {
      this.active = false;
      this.undoStack.removeEventListener(_UndoStack_js__WEBPACK_IMPORTED_MODULE_1__["default"].AFTER_ACTION, this.onActionCb);

      // Make sure we don't keep outdated snapping indicators
      this.snapper && this.snapper.clearSnappingGizmos();
    } }, { key: "register", value: function register()

    {}

    // Maps a key event to a function key in the key-map.
  }, { key: "mapKey", value: function mapKey(event, keyMap) {

      for (var key in keyMap) {
        var assigned = keyMap[key];

        // If a single key is assigned to this function and it matches, return the function key
        if (event.keyCode == assigned) {
          return key;
        }

        // If multiple keys are assigned, check if one matches.
        if (Array.isArray(assigned) && assigned.includes(event.keyCode)) {
          return key;
        }
      }
      // event does not match any assigned keyCode
      return null;
    } }, { key: "snappingFilter",

    // By default, we consider all EditShapes for snapping
    value: function snappingFilter() {
      return true;
    }

    // Remember last mouse position
  }, { key: "trackMousePos", value: function trackMousePos(e) {
      this.canvasPos.set(e.canvasX, e.canvasY);
    } }, { key: "handleMouseMove", value: function handleMouseMove(
    e) {this.trackMousePos(e);} }, { key: "handleSingleClick", value: function handleSingleClick(
    e) {this.trackMousePos(e);} }, { key: "handleDoubleClick", value: function handleDoubleClick(
    e) {this.trackMousePos(e);} }, { key: "handleButtonUp", value: function handleButtonUp(
    e) {this.trackMousePos(e);} }, { key: "handleButtonDown", value: function handleButtonDown(
    e) {this.trackMousePos(e);} }]);return EditToolBase;}();
;

/***/ }),

/***/ "./extensions/Edit2D/tools/InsertSymbolTool.js":
/*!*****************************************************!*\
  !*** ./extensions/Edit2D/tools/InsertSymbolTool.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InsertSymbolTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}



var InsertSymbolToolName = "Edit2_InsertSymbolTool";var

InsertSymbolTool = /*#__PURE__*/function (_EditToolBase) {_inherits(InsertSymbolTool, _EditToolBase);

  function InsertSymbolTool(ctx) {var _this;_classCallCheck(this, InsertSymbolTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(InsertSymbolTool).call(this, ctx));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_assertThisInitialized(_this)));

    _this.symbol = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Circle"](0, 0,
    0.2,
    new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      fillAlpha: 1.0,
      lineWidth: 0.01,
      fillColor: 'rgb(255, 255, 0)' }));return _this;

  }_createClass(InsertSymbolTool, [{ key: "getName", value: function getName()

    {
      return InsertSymbolToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "setSymbol", value: function setSymbol(

    symbol) {
      this.symbol = symbol;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    event) {

      var res = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var symbol = this.symbol.clone();
      symbol.move(res.x, res.y);

      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, symbol));

      this.dispatchEvent({ type: InsertSymbolTool.SYMBOL_INSERTED, symbol: symbol });

      return true;
    } }, { key: "handleDoubleClick", value: function handleDoubleClick()

    /*event , button */{

      return true;
    } }]);return InsertSymbolTool;}(_EditToolBase__WEBPACK_IMPORTED_MODULE_2__["default"]);


InsertSymbolTool.SYMBOL_INSERTED = "symbolInserted";

/***/ }),

/***/ "./extensions/Edit2D/tools/LineTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/LineTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LineTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}






var LineToolName = "Edit2_LineTool";

var av = Autodesk.Viewing;

// Draws lines with single drag
var LineTool = /*#__PURE__*/function (_EditToolBase) {_inherits(LineTool, _EditToolBase);

  function LineTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, LineTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(LineTool).call(this, ctx));

    _this.style = style;

    // New polyline created by dragging
    _this.line = null;

    // Start/Endpoint of the line being dragged
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;return _this;
  }_createClass(LineTool, [{ key: "getName", value: function getName()

    {
      return LineToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.line) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      this.line = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([startPos.clone(), startPos.clone()], this.style.clone());
      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.line);
    } }, { key: "updateLine", value: function updateLine()

    {

      if (!this.isDragging()) {
        return;
      }

      this.line.updatePoint(1, this.endPoint.x, this.endPoint.y);
      this.gizmoLayer.update();
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateLine();
    } }, { key: "endDrag", value: function endDrag()

    {

      if (!this.line) {
        return false;
      }

      // Remove temporary gizmo shape
      this.gizmoLayer.removeShape(this.line);

      // Add line shape if valid
      var lineValid = !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].edgeIsDegenerated(this.startPoint, this.endPoint);
      if (lineValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.line));
      }

      this.line = null;
      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.line) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.line);
        this.line = null;

        this.dragCanceled = true;
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.line);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateLine(false);
      }
    } }]);return LineTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/MoveTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/MoveTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MoveTool; });
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}


var MoveToolName = "Edit2_MoveTool";

var av = Autodesk.Viewing;var

MoveTool = /*#__PURE__*/function () {

  function MoveTool(ctx) {_classCallCheck(this, MoveTool);

    this.layer = ctx.layer;
    this.selection = ctx.selection;
    this.undoStack = ctx.undoStack;
    this.nameSuffix = "_".concat(ctx.toolSetName);

    // Only set during dragging
    this.shape = null;

    // drag-start position in layer coords
    this.dragStartPoint = new THREE.Vector2();

    // backup original shape on drag-start as long as we are modifying it on-hover
    this.backupShape = null;

    this.keyMap = {
      CancelEdit: av.KeyCode.ESCAPE };

  }_createClass(MoveTool, [{ key: "getNames", value: function getNames()

    {
      return [this.getName()];
    } }, { key: "getName", value: function getName()

    {
      return MoveToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var hitShape = this.layer.hitTest(p.x, p.y);

      if (hitShape) {
        this.startDrag(hitShape, p);
      }

      // Set selection to the shape that we picked
      if (this.shape) {
        this.selection.selectOnly(this.shape);
      } else {
        this.selection.clear();
      }

      return Boolean(this.shape);
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(shape, startPos) {
      this.shape = shape;
      this.dragStartPoint.copy(startPos);
      this.backupShape = shape.clone();
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p) {
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;

      // Apply this offset to shape. We always start with the original shape as a reference 
      // to avoid accumulating delta inaccuracies.
      this.shape.copy(this.backupShape);
      this.shape.move(dx, dy);
      this.layer.update();
    }

    // Clean up data hold during a drag interaction
  }, { key: "resetDragging", value: function resetDragging() {
      this.shape = null;
      this.backupShape = null;
    } }, { key: "endDrag", value: function endDrag(

    p) {
      // No drag active
      if (!this.shape) {
        return;
      }

      // Revert any temporary modifications done during mouse move
      this.shape.copy(this.backupShape);

      // Apply move operation
      var dx = p.x - this.dragStartPoint.x;
      var dy = p.y - this.dragStartPoint.y;
      this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_0__["Actions"].MoveShape(this.layer, this.shape, dx, dy));

      if (this.shape) {
        this.shape = null;
        return true;
      }
      return false;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.isDragging()) {

        // Revert shape o state when dragging was started
        this.shape.copy(this.backupShape);
        this.layer.update();

        this.resetDragging();
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.shape);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      if (!this.shape) {
        return false;
      }

      // get delta between last and current position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.moveDrag(p);

      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      // Only respond to left button
      if (button !== 0) {
        return;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      return this.endDrag(p);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
      }
    } }]);return MoveTool;}();

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonEditTool.js":
/*!****************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonEditTool.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonEditTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _Math2D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Math2D.js */ "./extensions/Edit2D/Math2D.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _MoveTool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MoveTool.js */ "./extensions/Edit2D/tools/MoveTool.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}







var PolygonEditToolName = 'Edit2_PolygonEditTool';

var av = Autodesk.Viewing;

// Allow to pick an edge within 
var EdgeSelectTolerance = 17;

var gizmoName = function gizmoName(index) {
  return 'PolygonEditTool.vertexGizmos[' + index.toString() + ']';
};

var updateGizmoNames = function updateGizmoNames(vertexGizmos) {
  for (var i = 0; i < vertexGizmos.length; i++) {
    var gizmo = vertexGizmos[i];
    gizmo.name = gizmoName(i);
    gizmo.update(false); // Make sure that the shapes get the name immediately - we don't need a layer update for this.
  }
};

// Return 2D edge normal
var getLeftEdgeNormal = function getLeftEdgeNormal(poly, edgeIndex, target) {
  // get start/end point of the edge
  var vi1 = edgeIndex;
  var vi2 = (edgeIndex + 1) % poly.length;
  var v1 = poly.getPoint(vi1);
  var v2 = poly.getPoint(vi2);

  // get edge direction
  target.subVectors(v2, v1).normalize();

  // rotate by 90 degrees
  var tmp = target.x;
  target.x = -target.y;
  target.y = tmp;

  return target;
};var

PolygonEditTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonEditTool, _EditToolBase);

  function PolygonEditTool(ctx) {var _this;_classCallCheck(this, PolygonEditTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonEditTool).call(this, ctx));

    _this.moveTool = new _MoveTool_js__WEBPACK_IMPORTED_MODULE_4__["default"](ctx);

    // Only set during dragging
    _this.poly = null;

    // Last drag position in layer coords
    _this.lastDragPoint = new THREE.Vector2();

    // Circles around each vertex
    _this.vertexGizmos = [];

    // Index of the vertex currently being dragged (or -1 if no dragging is active)
    _this.draggedVertex = -1;

    // When dragging a vertex, this stores a copy of its original position
    _this.dragVertexStartPos = new THREE.Vector2();

    // When dragging an edge, this stores a copy of its original position
    _this.dragEdgeStartPos = {
      a: new THREE.Vector2(),
      b: new THREE.Vector2() };


    // Index of the edge being dragged or -1
    _this.draggedEdge = -1;

    // Reused to store edge normal of dragged edge
    _this.draggedEdgeNormal = new THREE.Vector2();

    // selectedVertex is the one that was last clicked on. It is set together with draggedVertex, 
    // but (unlike draggedVertex) keeps the same after dragEnd.
    // selectedVertex is the one that is highlighted and which will be deleted when pressing backspace.
    _this.selectedVertex = -1;

    // When dragging vertices, we store the offset (in layer-coords) between the accurate click position and the center of the clicked vertex gizmo
    // Stored in pixels.
    _this.dragOffset = new THREE.Vector2(0, 0);

    // Used to highlight a dragged edge in a different color by drawing a single-edge overlay.
    _this.edgeGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]();
    _this.edgeGizmoShown = false; // indicates that gizmo is currently added to gizmoLayer

    _this.keyMap.DeleteSelectedVertex = av.KeyCode.BACKSPACE;
    _this.keyMap.CancelEdit = av.KeyCode.ESCAPE;

    // Track mouse position in layer-coords
    _this.mousePos = new THREE.Vector2();

    // Create area label. Default hidden - showing is optional.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["AreaLabel"](null, _this.layer, false, ctx.areaUnits);

    // {EdgeGizmo[]} Array of Gizmos used for moving edges. 
    _this.edgeGizmos = [];return _this;
  }_createClass(PolygonEditTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(

    visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "getName", value: function getName()

    {
      return PolygonEditToolName + this.nameSuffix;
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "deactivate", this).call(this);
      this.reset();
    } }, { key: "createVertexGizmos", value: function createVertexGizmos()

    {
      for (var i = 0; i < this.poly.points.length; i++) {
        // create new vertex gizmo
        var p = this.poly.points[i];
        var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, gizmoName(i), this.poly.style);
        this.vertexGizmos.push(vertex);

        // We implement drag-behavior, so we want hover-highlight
        vertex.setHoverEnabled(true);
      }
    }

    // Make sure that VertexGizmos reflect latest state of the shape
  }, { key: "updateVertexGizmos", value: function updateVertexGizmos() {
      var vertexCount = this.poly ? this.poly.length : 0;

      // If just the positions changed (e.g. while moving the shape), we just update the positions.
      var p = new THREE.Vector2();
      if (vertexCount == this.vertexGizmos.length) {
        for (var i = 0; i < vertexCount; i++) {
          this.poly.getPoint(i, p);
          this.vertexGizmos[i].setPosition(p.x, p.y);
        }
      } else {
        // just re-create all VertexGizmos
        this.clearVertexGizmos();
        this.createVertexGizmos();
      }
    } }, { key: "clearVertexGizmos", value: function clearVertexGizmos()

    {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    } }, { key: "clearEdgeGizmos", value: function clearEdgeGizmos()

    {
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        this.edgeGizmos[i].dtor();
      }
      this.edgeGizmos.length = 0;
    }

    // Update edgeGizmos to this.poly or hide all if poly is null
  }, { key: "createEdgeGizmos", value: function createEdgeGizmos() {
      // Make sure that we don't leak outdated ones
      this.clearEdgeGizmos();

      // Create gizmo per edge
      var edgeCount = this.poly ? this.poly.getEdgeCount() : 0;
      for (var i = 0; i < edgeCount; i++) {
        var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["EdgeMoveGizmo"](this.layer);
        gizmo.attachToEdge(this.poly, i);
        this.edgeGizmos.push(gizmo);
      }
    }

    // Make sure that only the vertexGizmo is only highlighted for the selectedVertex (if any)
  }, { key: "updateVertexHighlighting", value: function updateVertexHighlighting() {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].setSelected(i === this.selectedVertex);
      }
    } }, { key: "setSelectedVertex", value: function setSelectedVertex(

    index) {
      this.selectedVertex = this.poly ? index : -1;
      this.updateVertexHighlighting();
    }

    // Returns the index of the vertex gizmo at the given position (or -1 if no vertexGizmo is hit)
  }, { key: "getVertexIndex", value: function getVertexIndex(x, y) {
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        var gizmo = this.vertexGizmos[i];
        if (gizmo.hitTestLayer(x, y)) {
          return i;
        }
      }
      return -1;
    }

    // Returns the index of the edge gizmo under mouse (or -1 if no EdgeGizmo is hit)
    // (x,y) are in layer-coords
  }, { key: "getEdgeIndex", value: function getEdgeIndex(x, y) {
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        if (this.edgeGizmos[i].hitTestLayer(x, y)) {
          return i;
        }
      }
      return -1;
    }

    // Finishes editing of a previous polygon
  }, { key: "reset", value: function reset() {

      if (!this.poly) {
        return;
      }

      // Clear any vertexGizmos and edgeGizmos from a previous polygon
      this.clearVertexGizmos();
      this.clearEdgeGizmos();

      this.poly = null;
      this.draggedVertex = -1;
      this.selectedVertex = -1;

      this.snapper.stopAngleSnapping();
    }

    // Selects a new polygon / polyline for editing
  }, { key: "setEditPoly", value: function setEditPoly(poly) {

      this.reset();

      if (poly) {
        this.poly = poly;
        this.createVertexGizmos();
        this.createEdgeGizmos();
      }

      // Sync label with polygon. If this.poly is null or a polyline, it will be hidden
      var polygon = poly && poly.isPolygon() ? poly : null;
      this.areaLabel.setPolygon(polygon);
    } }, { key: "insertPoint", value: function insertPoint(

    index, p) {

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddVertex(this.layer, this.poly, index, p));

      // insert new VertexGizmo
      var gizmo = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_3__["VertexGizmo"](this.gizmoLayer, p.x, p.y, undefined, this.poly.style);
      updateGizmoNames(this.vertexGizmos);
      this.vertexGizmos.splice(index, 0, gizmo);

      // update edge gizmos
      this.createEdgeGizmos();

      // Display polygon change and new gizmo
      this.layer.update();
    } }, { key: "removePoint", value: function removePoint(

    index) {

      // If removing a vertex would make the shape degenerate, remove it completely
      var minVerts = this.poly.isPolygon() ? 3 : 2;
      if (this.poly.length <= minVerts) {
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveShape(this.layer, this.poly));
        this.reset();
        return;
      }

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].RemoveVertex(this.layer, this.poly, index));

      // remove vertex gizmo
      var gizmo = this.vertexGizmos.splice(index, 1)[0];

      // Display changed polygon and removed vertex gizmo
      gizmo.dtor();

      // Make sure that this vertex is not selected anymore
      if (this.selectedVertex === index) {
        this.setSelectedVertex(-1);
      }

      this.layer.update();
    } }, { key: "startDragVertex", value: function startDragVertex(

    event, draggedVertex) {

      // Configure angle snapping to consider latest state of the polygon
      this.snapper.startAngleSnapping(this.poly.clone(), draggedVertex);

      this.draggedVertex = draggedVertex;

      // Store offset between exact mouse pos and the vertex we are dragging
      var vpos = this.poly.points[this.draggedVertex];
      var vposScreen = this.layer.layerToCanvas(vpos.x, vpos.y);
      this.dragOffset.set(vposScreen.x - event.canvasX, vposScreen.y - event.canvasY);

      // highlight the vertex we clicked on
      this.setSelectedVertex(this.draggedVertex);

      this.lastDragPoint.copy(vpos);
      this.dragVertexStartPos.copy(vpos);
    } }, { key: "moveDragVertex", value: function moveDragVertex(

    canvasX, canvasY) {
      // Note that the vertex we are dragging does not always match exactly with the mouse position. E.g., we may have picked the bottom-left boundary of a vertex gizmo at drag-start.
      var x = canvasX + this.dragOffset.x;
      var y = canvasY + this.dragOffset.y;

      // get delta between last and current position
      var p = this.getSnapPosition(x, y);
      var dx = p.x - this.lastDragPoint.x;
      var dy = p.y - this.lastDragPoint.y;

      // apply this offset to polygon point
      var point = this.poly.points[this.draggedVertex];
      this.poly.updatePoint(this.draggedVertex, point.x + dx, point.y + dy);

      // re-center gizmo at new point position
      var vertexGizmo = this.vertexGizmos[this.draggedVertex];
      vertexGizmo.setPosition(point.x, point.y);

      this.gizmoLayer.update(); // we moved the vertex gizmo
      this.layer.update(); // we changed the main polygon

      this.lastDragPoint.copy(p);
    } }, { key: "restoreDragVertex", value: function restoreDragVertex()

    {
      this.poly.updatePoint(this.draggedVertex, this.dragVertexStartPos.x, this.dragVertexStartPos.y);
    } }, { key: "endDragVertex", value: function endDragVertex()

    {

      // First, restore "before move" position of the vertex
      this.restoreDragVertex();

      var pBefore = this.dragVertexStartPos;
      var pAfter = this.lastDragPoint;

      // don't add extra undo-operation if the vertex was hardly moved at all
      var minDist = this.layer.getUnitsPerPixel() * 0.5;
      var moved = pBefore.distanceTo(pAfter) > minDist;

      if (moved) {
        // Finalize vertex-move
        this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveVertex(this.layer, this.poly, this.draggedVertex, pAfter));
      }

      this.draggedVertex = -1;
      this.snapper.clearSnappingGizmos();
    } }, { key: "startDragEdge", value: function startDragEdge(

    event, draggedEdge) {

      this.setSelectedEdge(draggedEdge);

      // store edge normal for the edge being dragged
      this.draggedEdgeNormal = getLeftEdgeNormal(this.poly, draggedEdge, this.draggedEdgeNormal);
      this.lastDragPoint.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));

      // store original position of the two edge vertices
      var ia = this.draggedEdge;
      var ib = (this.draggedEdge + 1) % this.poly.length;
      this.dragEdgeStartPos.a.copy(this.poly.getPoint(ia));
      this.dragEdgeStartPos.b.copy(this.poly.getPoint(ib));
    } }, { key: "moveDragEdge", value: function moveDragEdge(

    event) {

      // get delta between last and current position
      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      var delta = p.clone().sub(this.lastDragPoint);

      // get indices of prev and next edge
      var prevEdgeIndex = this.poly.prevIndex(this.draggedEdge);
      var nextEdgeIndex = this.poly.nextIndex(this.draggedEdge);

      // get previous, current, and next edge vertices
      var prevEdgeA = new THREE.Vector2();
      var prevEdgeB = new THREE.Vector2();
      var curEdgeA = new THREE.Vector2();
      var curEdgeB = new THREE.Vector2();
      var nextEdgeA = new THREE.Vector2();
      var nextEdgeB = new THREE.Vector2();
      this.poly.getEdge(prevEdgeIndex, prevEdgeA, prevEdgeB);
      this.poly.getEdge(this.draggedEdge, curEdgeA, curEdgeB);
      this.poly.getEdge(nextEdgeIndex, nextEdgeA, nextEdgeB);

      // Compute line after applying edge move offset
      curEdgeA.add(delta);
      curEdgeB.add(delta);

      // Compute directions for each edge to intersect
      var prevEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(prevEdgeA, prevEdgeB);
      var curEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(curEdgeA, curEdgeB);
      var nextEdgeDir = _Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].getEdgeDirection(nextEdgeA, nextEdgeB);

      // Compute new edge endpoints as intersection of prev/next edge with the moved line
      var newEdgeA = new THREE.Vector2();
      var newEdgeB = new THREE.Vector2();

      if (!_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].intersectLines(prevEdgeA, prevEdgeDir, curEdgeA, curEdgeDir, newEdgeA) ||
      !_Math2D_js__WEBPACK_IMPORTED_MODULE_2__["Math2D"].intersectLines(nextEdgeA, nextEdgeDir, curEdgeA, curEdgeDir, newEdgeB)) {
        return;
      }

      // get indices of the points to modify
      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      // The intersections gives us the new position for the edge vertices
      this.poly.updatePoint(ia, newEdgeA.x, newEdgeA.y);
      this.poly.updatePoint(ib, newEdgeB.x, newEdgeB.y);

      // update affected vertex gizmos
      this.vertexGizmos[ia].setPosition(newEdgeA.x, newEdgeA.y);
      this.vertexGizmos[ib].setPosition(newEdgeB.x, newEdgeB.y);

      this.gizmoLayer.update();
      this.layer.update();

      this.lastDragPoint.copy(p);

      // We moved the edge => Keep gizmo in-sync
      this.updateEdgeGizmo();
    }

    // While dragging an edge, this function restores the original position at drag start
  }, { key: "restoreDragEdge", value: function restoreDragEdge() {
      var a = this.dragEdgeStartPos.a;
      var b = this.dragEdgeStartPos.b;

      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      this.poly.updatePoint(ia, a.x, a.y);
      this.poly.updatePoint(ib, b.x, b.y);
    } }, { key: "endDragEdge", value: function endDragEdge()

    {
      // get final position of the edge vertices
      var ia = this.draggedEdge;
      var ib = this.poly.nextIndex(ia);

      var newPos1 = this.poly.getPoint(ia);
      var newPos2 = this.poly.getPoint(ib);

      this.restoreDragEdge();

      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].MoveEdge(this.layer, this.poly, ia, newPos1, newPos2));
      this.setSelectedEdge(-1);
    } }, { key: "edgeMovePossible", value: function edgeMovePossible()

    {
      return this.poly && this.poly.length > 2;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key
      if (this.ignoreDragging) {
        return false;
      }

      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonDown", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      this.mousePos.copy(p);

      // Handle Vertex-Add: Check if we hold ctrl and hit an edge
      if (event.ctrlKey) {
        var precision = EdgeSelectTolerance * this.layer.getUnitsPerPixel();
        var edgeIndex = this.poly ? this.poly.findEdgeIndex(this.mousePos, precision) : -1;
        if (edgeIndex !== -1) {
          // insert new vertex after edge starting point
          var newVertex = edgeIndex + 1;
          this.insertPoint(newVertex, p);
        }
      }

      // If we created a new vertex or hit an existing one, start dragging it
      var draggedVertex = this.getVertexIndex(p.x, p.y);
      if (draggedVertex != -1) {
        this.startDragVertex(event, draggedVertex);
        return true;
      }

      // Reset vertex-highlighting: No vertex is selected anymore.
      this.setSelectedVertex(-1);

      // Handle Edge-Move: If we hit an EdgeGizmo, start dragging it
      var selectedEdgeGizmo = this.getEdgeIndex(p.x, p.y);
      if (this.edgeMovePossible() && selectedEdgeGizmo !== -1) {
        this.startDragEdge(event, selectedEdgeGizmo);
        return true;
      }

      // If we just clicked inside the already active polygon, delegate to MoveTool
      if (this.poly) {
        // Note: this.poly may be a Polyline. To allow moving it, it's essential to use a hitRadius for picking.
        var hitRadius = this.layer.getLineHitRadius(this.poly);
        if (this.poly.hitTest(p.x, p.y, hitRadius)) {
          this.moveTool.startDrag(this.poly, p);
          return true;
        }
      }

      // Check if we selected a new polygon
      var newPolygon = this.layer.hitTest(p.x, p.y);

      // If the clicked object is neither polygon nor polyline, ignore it.
      var isPolygon = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"];
      var isPolyline = newPolygon instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"];
      if (!isPolygon && !isPolyline) {
        newPolygon = null;
      }

      // Set selection to current polygon. This will also trigger setEditPoly() 
      // via selectionChanged event.
      this.selection.selectOnly(newPolygon);

      return Boolean(this.poly);
    } }, { key: "handleSingleClick", value: function handleSingleClick(

    e) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleSingleClick", this).call(this, e);

      return Boolean(this.poly);
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleMouseMove", this).call(this, event);

      this.mousePos.copy(this.layer.canvasToLayer(event.canvasX, event.canvasY));
      this.updateMouseOverHighlights();

      if (!this.poly) {
        return false;
      }

      if (this.draggedVertex != -1) {
        this.moveDragVertex(event.canvasX, event.canvasY);
        return true;
      }

      if (this.draggedEdge != -1) {
        this.moveDragEdge(event);
      }

      if (this.moveTool.isDragging()) {
        this.moveTool.moveDrag(this.mousePos);

        // keep vertex-gizmos in-sync
        this.updateVertexGizmos();
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      _get(_getPrototypeOf(PolygonEditTool.prototype), "handleButtonUp", this).call(this, event, button);

      if (this.draggedVertex !== -1) {
        this.endDragVertex();
        return true;
      }

      if (this.draggedEdge !== -1) {
        this.endDragEdge();
        return true;
      }

      if (this.moveTool.isDragging()) {
        var p = this.layer.canvasToLayer(event.canvasX, event.canvasY);

        // Avoid triggering the handler for external modifications, because we control the MoveTool ourselves
        this.ignoreActions = true;
        this.moveTool.endDrag(p);
        this.ignoreActions = false;

        // keep vertex-gizmos in-sync
        this.updateVertexGizmos();
        return true;
      }

      // Consider all left-button events as handled. E.g., if dragging was cancelled using Esc,
      // we do nothing here, but letting the mouseUp pass to navigation classes would cause camera jumps.
      return !this.ignoreDragging && this.poly && button == 0;
    }

    // Exclude currently edited polygon from snapping: The polygon shouldn't snap to itself, but rather
    // to geometry below it.
  }, { key: "snappingFilter", value: function snappingFilter(shape) {
      return shape !== this.poly;
    }

    // If selection changes (may also be triggered outside this tool), we choose the selected polyon for editing
  }, { key: "onSelectionChanged", value: function onSelectionChanged() {
      var selected = this.selection.getSelectedShapes();
      var shape = selected[0];
      if (shape instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["PolyBase"]) {
        this.setEditPoly(shape);
      } else {
        this.setEditPoly(null);
      }
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonEditTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      if (keyCode === this.keyMap.DeleteSelectedVertex) {
        if (this.poly && this.selectedVertex !== -1) {
          this.removePoint(this.selectedVertex);
          handled = true;
        }
      }

      if (keyCode === this.keyMap.CancelEdit) {
        this.cancelDrag();
        return true;
      }

      return handled;
    } }, { key: "onSnappingToggled",

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
    value: function onSnappingToggled(canvasX, canvasY) {

      // If we are dragging a vertex, toggling snapping will affect the result and 
      // we should update line gizmos and snapping lines.
      if (this.draggedVertex !== -1) {
        this.moveDragVertex(canvasX, canvasY);
      }
    } }, { key: "cancelDrag", value: function cancelDrag()

    {

      var needsUpdate = false;

      if (this.draggedVertex !== -1) {
        this.restoreDragVertex();
        this.draggedVertex = -1;
        needsUpdate = true;
      }

      if (this.draggedEdge !== -1) {
        this.restoreDragEdge();
        this.draggedEdge = -1;
        needsUpdate = true;
      }

      if (this.moveTool.isDragging()) {
        this.moveTool.cancelDrag();
        this.updateVertexGizmos();
      }

      if (needsUpdate) {
        this.layer.update();
        this.updateVertexGizmos();
      }

      this.snapper.clearSnappingGizmos();
    } }, { key: "handleExternalAction", value: function handleExternalAction()

    {
      // If nothing is active, we don't need to care
      if (!this.poly) {
        return;
      }

      // If shape was removed, reset state
      var shapeFound = Boolean(this.layer.findShapeById(this.poly.id));
      if (!shapeFound) {
        this.reset();
      }

      // Sync gizmos in case vertices were modified
      this.updateVertexGizmos();

      // Stop any ongoing drag-operations (e.g., an undo operation might have removed the vertex that we are just dragging)
      this.cancelDrag();

      this.snapper.clearSnappingGizmos();
    }

    // Make sure that EdgeGizmo is up-to-date: Its purpose is to highlight the edge being dragged.
  }, { key: "updateEdgeGizmo", value: function updateEdgeGizmo() {

      // Check if mouse is on an edge gizmo
      var edgeUnderMouse = this.getEdgeIndex(this.mousePos.x, this.mousePos.y);

      // Check if a vertex gizmo is under mouse or being dragged. If so, it has precedence, so that we don't highlight the edge anymore
      var vertexUnderMouse = this.getVertexIndex(this.mousePos.x, this.mousePos.y);
      var vertexHighlighted = vertexUnderMouse != -1 || this.draggedVertex != -1;
      var edgeMovePossible = this.edgeMovePossible();

      // Check if we need any highlight
      var edgeSelected = this.poly && this.draggedEdge != -1;
      var edgeHovered = edgeMovePossible && edgeUnderMouse != -1 && !vertexHighlighted;
      var gizmoNeeded = edgeSelected || edgeHovered;

      // Make sure that edge gizmo is shown if needed
      if (gizmoNeeded && !this.edgeGizmoShown) {
        this.gizmoLayer.addShape(this.edgeGizmo);
        this.edgeGizmoShown = true;
      } else
      if (!gizmoNeeded && this.edgeGizmoShown) {
        this.gizmoLayer.removeShape(this.edgeGizmo);
        this.edgeGizmoShown = false;
      }

      // If we just had to hide it, we are done here
      if (!gizmoNeeded) {
        return;
      }

      // Update edge gizmo position
      var edgeToHighlight = edgeSelected ? this.draggedEdge : edgeUnderMouse;

      // get the two vertex positions of the edge
      var a = new THREE.Vector2();
      var b = new THREE.Vector2();
      this.poly.getEdge(edgeToHighlight, a, b);

      // copy values to edge gizmo
      this.edgeGizmo.makeLine(a.x, a.y, b.x, b.y);

      // Adopt lineWidth from selected polygon
      this.edgeGizmo.style.lineWidth = this.poly.style.lineWidth;
      this.edgeGizmo.style.isScreenSpace = this.poly.style.isScreenSpace;

      if (edgeSelected) {
        // Override color by green
        this.edgeGizmo.style.lineColor = 'rgb(0, 255, 0)';
        this.edgeGizmo.style.lineAlpha = 1.0;
      } else {
        // Just make it a bit brighter using a semitransparent white overlay
        this.edgeGizmo.style.lineColor = 'rgb(0, 255, 0)';
        this.edgeGizmo.style.lineAlpha = 0.5;
      }

      this.gizmoLayer.update();
    } }, { key: "setSelectedEdge", value: function setSelectedEdge(

    edgeIndex) {
      this.draggedEdge = edgeIndex;
      this.updateEdgeGizmo();

      // Update selection state for edge gizmos
      for (var i = 0; i < this.edgeGizmos.length; i++) {
        var gizmo = this.edgeGizmos[i];
        gizmo.setSelected(i == this.draggedEdge);
      }
    } }, { key: "updateMouseOverHighlights", value: function updateMouseOverHighlights()

    {
      this.updateEdgeGizmo();
    } }]);return PolygonEditTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_5__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/PolygonTool.js":
/*!************************************************!*\
  !*** ./extensions/Edit2D/tools/PolygonTool.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CanvasGizmo.js */ "./extensions/Edit2D/CanvasGizmo.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
/* harmony import */ var _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RectangleTool.js */ "./extensions/Edit2D/tools/RectangleTool.js");
/* harmony import */ var _LineTool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineTool.js */ "./extensions/Edit2D/tools/LineTool.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _get(target, property, receiver) {if (typeof Reflect !== "undefined" && Reflect.get) {_get = Reflect.get;} else {_get = function _get(target, property, receiver) {var base = _superPropBase(target, property);if (!base) return;var desc = Object.getOwnPropertyDescriptor(base, property);if (desc.get) {return desc.get.call(receiver);}return desc.value;};}return _get(target, property, receiver || target);}function _superPropBase(object, property) {while (!Object.prototype.hasOwnProperty.call(object, property)) {object = _getPrototypeOf(object);if (object === null) break;}return object;}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}







var Mode = {
  Polyline: 1,
  Polygon: 2 };


var PolygonToolName = "Edit2_PolygonTool";
var PolylineToolName = "Edit2_PolylineTool";

var av = Autodesk.Viewing;
var DefaultStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();var

PolygonTool = /*#__PURE__*/function (_EditToolBase) {_inherits(PolygonTool, _EditToolBase);

  function PolygonTool(ctx) {var _this;var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Mode.Polygon;var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, PolygonTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonTool).call(this, ctx));

    // Delegate single-drag interactions: 
    _this.lineRectTool = mode === Mode.Polygon ?
    new _RectangleTool_js__WEBPACK_IMPORTED_MODULE_4__["default"](ctx, style) : // PolygonMode: Draw rect/quad on drag
    new _LineTool_js__WEBPACK_IMPORTED_MODULE_5__["default"](ctx, style) // PolylineMode: Draw simple line on drag
    ;

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_assertThisInitialized(_this)));

    // Circle shapes per vertex
    _this.vertexGizmos = [];

    // The polygon/polyline we are currently creating (if tool is active)
    _this.poly = undefined;

    // Style used for polygon creation
    _this.style = style;

    // Style used to display the thin line to connect last added vertex with current mouse position.        
    _this.edgePreviewStyle = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]({
      lineWidth: 2,
      isScreenSpace: true,
      lineStyle: 11 // dashed line
    });

    // whether editing Polylines or Polygons
    _this.mode = mode;

    // last canvas position where we added a vertex
    _this.lastClickX = undefined;
    _this.lastClickY = undefined;

    _this.keyMap.CANCEL_EDIT = av.KeyCode.ESCAPE;
    _this.keyMap.REMOVE_LAST_VERTEX = av.KeyCode.BACKSPACE;
    _this.keyMap.FINISH_EDIT = [av.KeyCode.ENTER, av.KeyCode.c];

    // FillGizmo: When editing a polygon, fillGizmo displays the polygon formed by all vertices + mousePos
    _this.fillGizmo = null;

    // OutlineGizmo: Polyline that connects all added vertices
    _this.outlineGizmo = null;

    // Line to connect last added vertex with mouse position
    _this.edgePreviewGizmo = null;

    // Last tracked mouse-pos in layer-coords (after considering snapping)
    _this.mousePos = new THREE.Vector2();

    // Label to display polygon area - hidden by default
    // Note that the polygon preview is in the gizmoLayer. So we add the areaLabel there as well to keep it in sync.
    _this.areaLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["AreaLabel"](null, _this.gizmoLayer, _this.unitHandler, false);

    // Label to display polyline length
    _this.lengthLabel = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["EdgeLabel"](_this.gizmoLayer, false);return _this;
  }_createClass(PolygonTool, [{ key: "setAreaLabelVisible", value: function setAreaLabelVisible(

    visible) {
      this.areaLabel.setVisible(visible);
    } }, { key: "deactivate", value: function deactivate()

    {
      _get(_getPrototypeOf(PolygonTool.prototype), "deactivate", this).call(this);
      this.cancelEdit();
    }

    // Returns true when editing a Polygon, false when editing a Polyline or nothing.
  }, { key: "isPolygon", value: function isPolygon() {
      return this.poly instanceof _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"];
    }

    /**
       * Set depending styles for the polygon / polyline tool. It will also set most of the styles to the temporary lines
       * that appear during drawing. Style.isScreenSpace won't be considered.
       * @param {Style} style         - a Style instance
       * @param {boolean} skipDefault - If set (default) just apply the style that differ from the default Style
       */ }, { key: "setStyles", value: function setStyles(
    style) {var skipDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (style.lineColor !== DefaultStyle.lineColor || !skipDefault) {
        this.style.lineColor = style.lineColor;
      }
      if (style.lineAlpha !== DefaultStyle.lineAlpha || !skipDefault) {
        this.style.lineAlpha = style.lineAlpha;
      }
      if (style.lineWidth !== DefaultStyle.lineWidth || !skipDefault) {
        this.style.lineWidth = style.lineWidth;
        this.lineRectTool.style.lineWidth = style.lineWidth;
        this.edgePreviewStyle.lineWidth = style.lineWidth * 2 / 3;
      }
      if (style.lineStyle !== DefaultStyle.lineStyle || !skipDefault) {
        this.style.lineStyle = style.lineStyle;
        this.lineRectTool.style.lineStyle = style.lineStyle;
        // skip this.edgePreviewStyle.lineStyle
      }

      if (style.fillColor !== DefaultStyle.fillColor || !skipDefault) {
        this.style.fillColor = style.fillColor;
      }
      if (style.fillAlpha !== DefaultStyle.fillAlpha || !skipDefault) {
        this.style.fillAlpha = style.fillAlpha;
      }

      // skip isScreenSpace
    }

    // Initialize all gizmos when starting to edit a Polygon/Polyline
  }, { key: "initGizmos", value: function initGizmos() {

      // FillGizmo: Draw fill of polygon formed by added vertices + mousePos
      if (this.isPolygon()) {
        this.fillGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
        this.fillGizmo.style.lineAlpha = 0;
        this.gizmoLayer.addShape(this.fillGizmo);
      }

      // OutlineGizmo: Connect added vertices
      this.outlineGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
      this.gizmoLayer.addShape(this.outlineGizmo);

      // CurrentEdgeGizmo: Draw dashed line from last vertex to mousePos.
      this.edgePreviewGizmo = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.edgePreviewStyle);
      this.edgePreviewGizmo.style.lineColor = this.poly.style.lineColor;
      this.gizmoLayer.addShape(this.edgePreviewGizmo);

      this.areaLabel.setPolygon(this.fillGizmo);

      // For Polylines, attach label to preview edge that displays the summed length
      if (this.poly && this.poly.isPolyline()) {
        this.lengthLabel.attachToEdge(this.edgePreviewGizmo, 0);
      }
    } }, { key: "clearGizmos", value: function clearGizmos()

    {
      if (this.fillGizmo) {
        this.gizmoLayer.removeShape(this.fillGizmo);
        this.fillGizmo = null;
      }

      this.areaLabel.setPolygon(null);
      this.lengthLabel.detachFromEdge();

      if (this.outlineGizmo) {
        this.gizmoLayer.removeShape(this.outlineGizmo);
        this.outlineGizmo = null;
      }

      if (this.edgePreviewGizmo) {
        this.gizmoLayer.removeShape(this.edgePreviewGizmo);
        this.edgePreviewGizmo = null;
      }

      // clear vertex gizmos
      for (var i = 0; i < this.vertexGizmos.length; i++) {
        this.vertexGizmos[i].dtor();
      }
      this.vertexGizmos.length = 0;
    }

    // Update gizmos and snapping if polygon was modified
  }, { key: "polyModified", value: function polyModified() {
      this.updateGizmos();

      // Configure angle snapping to consider latest state of the polygon
      // Note that angleSnapper requires the shape including "vertex under mouse", while
      // this.poly only contains the already added/clicked vertices.
      // Note that we cannot use fillGizmo here, because it does not exist for polylines.
      var snapGeom = this.poly.clone();
      snapGeom.addPoint(this.mousePos.x, this.mousePos.y);
      this.snapper.startAngleSnapping(snapGeom, this.poly.length);
    }

    // Update gizmos if vertices of current polygon/polyline have changed
  }, { key: "updateGizmos", value: function updateGizmos() {

      // FillGizmo: Show fill without outline for the polygon formed by all added
      // vertices + current mousePos
      if (this.fillGizmo) {
        // copy vertices of main polygon (not geom, not style)
        this.fillGizmo.clear();
        for (var i = 0; i < this.poly.length; i++) {
          var p = this.poly.getPoint(i);
          this.fillGizmo.addPoint(p.x, p.y);
        }
        // add additional point that traces mouse-pos
        this.fillGizmo.addPoint(this.mousePos.x, this.mousePos.y);
      }

      // OutlineGizmo: Solid polyline that connects all added vertices
      this.outlineGizmo.clear();
      if (this.poly.length >= 2) {
        for (var _i = 0; _i < this.poly.length; _i++) {
          var _p = this.poly.getPoint(_i);
          this.outlineGizmo.addPoint(_p.x, _p.y);
        }
      }

      // currentEdgeGizmo: Dashed line to connect last added vertex with mouse position
      this.edgePreviewGizmo.clear();
      if (this.poly.length >= 1) {
        var pLast = this.poly.getPoint(this.poly.length - 1);
        this.edgePreviewGizmo.addPoint(pLast.x, pLast.y);
        this.edgePreviewGizmo.addPoint(this.mousePos.x, this.mousePos.y);

        this.updateLengthLabel();
      }

      this.gizmoLayer.update();
    } }, { key: "updateLengthLabel", value: function updateLengthLabel()

    {
      // Compute resulting length of polyline including previewEdge
      if (this.poly && this.poly.isPolyline()) {
        var length = this.poly.getLength() + this.edgePreviewGizmo.getLength();
        var lengthStr = this.unitHandler.lengthToString(length);
        this.lengthLabel.setText(lengthStr);
      }
    } }, { key: "getName", value: function getName()

    {
      return (this.mode === Mode.Polygon ? PolygonToolName : PolylineToolName) + this.nameSuffix;
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleMouseMove", this).call(this, event);

      if (!event.buttons) {
        // When not dragging, we always return false here. Otherwise, the event will not propagated
        // to navigation tools, so that the zoom focus is not updated properly.
        this.onHover(event.canvasX, event.canvasY);
        return false;
      }
      return this.lineRectTool.handleMouseMove(event);
    } }, { key: "onHover", value: function onHover(

    canvasX, canvasY) {
      // Check if shape editing is already in progress
      if (!this.poly) {

        // Perform snapping check, so that SnappingIndicator reflects if the start point would be snapped.
        this.getSnapPosition(canvasX, canvasY);
        return;
      }

      var pLayer = this.layer.canvasToLayer(canvasX, canvasY);

      // When hovering the start vertex that will close the polygon (or line-loop), don't show any snapping indicators
      var closingAllowed = this.poly.length >= 3;
      var startVertexHit = closingAllowed && this.vertexGizmos[0].hitTestLayer(pLayer.x, pLayer.y);
      this.setStartVertexHighlighted(startVertexHit); // indicate when hoving closing-vertex
      if (startVertexHit) {
        // Remove snapping indicators
        this.snapper.clearSnappingGizmos();

        // snap position to vertex center
        pLayer.copy(this.vertexGizmos[0].layerPos);
      } else {
        // Standard case: If mouse is not on start vertex, allow standard snapping
        pLayer = this.getSnapPosition(canvasX, canvasY);
      }

      // track last mouse pos
      this.mousePos.copy(pLayer);

      // Just hover: Only update vertex-positions for fillGizmo, edgePreview and alignmentGizmo
      this.edgePreviewGizmo.updatePoint(1, pLayer.x, pLayer.y);
      this.fillGizmo && this.fillGizmo.updatePoint(this.fillGizmo.length - 1, pLayer.x, pLayer.y); // will be null if this.poly is a Polyline
      this.gizmoLayer.update();
      this.updateLengthLabel();
    }

    // Add vertex on single-click
  }, { key: "handleSingleClick", value: function handleSingleClick(event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleSingleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      // Avoid duplicate vertices on double-clicks
      if (this.vertexGizmos.length > 0 && event.canvasX === this.lastClickX && event.canvasY === this.lastClickY) {
        return true;
      }

      // If we have enough vertices, clicking on the first vertex gizmo again will finish the shape.
      if (this.poly && this.poly.length >= 3 && this.mouseOnStartVertex(event)) {

        // For polylines, we have to repeat the first vertex to close it
        if (this.poly.isPolyline()) {
          var pStart = this.poly.getPoint(0);
          this.addVertex(pStart.x, pStart.y);
        }

        // Finish editing
        this.finishPolygon();
        return true;
      }

      this.lastClickX = event.canvasX;
      this.lastClickY = event.canvasY;

      this.mousePos.copy(this.getSnapPosition(event.canvasX, event.canvasY));

      // Init polygon on first click
      if (!this.poly) {
        this.startPoly(this.mousePos.x, this.mousePos.y);
      }

      this.addVertex(this.mousePos.x, this.mousePos.y);
      return true;
    } }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {
      // Support suppressing mouse buttons by holding a key. Note that we only need that for dragging operations.
      if (this.ignoreDragging) {
        return false;
      }

      // If no clicks have been made so far, allow to drag line/rectangle.
      if (!this.poly) {
        // Clear the selection, this will make sure all other gizmos get removed
        this.selection.clear();

        return this.lineRectTool.handleButtonDown(event, button);
      }

      return false;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {
      return this.lineRectTool.handleButtonUp(event, button);
    } }, { key: "handleDoubleClick", value: function handleDoubleClick(

    event, button) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleDoubleClick", this).call(this, event, button);

      // Only respond to left mouse button.
      if (!button == 0) {
        return false;
      }

      this.finishPolygon();
      return true;
    }

    // Start new polyline or polygon
  }, { key: "startPoly", value: function startPoly(x, y) {

      if (this.mode === Mode.Polygon) {
        this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([], this.style.clone());
      } else {
        this.poly = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polyline"]([], this.style.clone());
      }

      this.initGizmos();
    } }, { key: "addVertex", value: function addVertex(

    x, y) {

      // add "next" point - which will follow the mouse motion 
      // until next click
      this.poly.addPoint(x, y);

      // add vertex-gizmo
      var name = 'PolygonTool.vertexGizmos[' + this.vertexGizmos.length + ']';
      var vertex = new _CanvasGizmo_js__WEBPACK_IMPORTED_MODULE_1__["VertexGizmo"](this.gizmoLayer, x, y, name);
      this.vertexGizmos.push(vertex);

      this.polyModified();
    } }, { key: "removeLastVertex", value: function removeLastVertex()

    {
      if (!this.poly || !this.poly.length) {
        return;
      }

      // Cancel edit if there was only the starting point.
      if (this.poly.length <= 1) {
        this.cancelEdit();
        return;
      }

      this.poly.removePoint(this.poly.length - 1);

      // remove last added vertex gizmo
      var lastGizmo = this.vertexGizmos[this.vertexGizmos.length - 1];
      lastGizmo.dtor();
      this.vertexGizmos.pop();

      this.polyModified();
    } }, { key: "finishPolygon", value: function finishPolygon()

    {

      // remove all vertex gizmos
      this.clearGizmos();

      // Stop snapping to edges of this polygon
      this.snapper.stopAngleSnapping();

      // move polygon to main layer
      this.runAction(new _Actions_js__WEBPACK_IMPORTED_MODULE_2__["Actions"].AddShape(this.layer, this.poly));

      this.dispatchEvent({ type: PolygonTool.POLYGON_ADDED, polygon: this.poly });

      // Start another polygon on next click
      this.poly = null;
    } }, { key: "cancelEdit", value: function cancelEdit()

    {

      if (this.lineRectTool.isDragging()) {
        this.lineRectTool.cancelDrag();
      }

      if (this.poly) {
        this.gizmoLayer.removeShape(this.poly);
        this.poly = null;
      }

      this.clearGizmos();
      this.snapper.stopAngleSnapping();
    } }, { key: "handleFinishKey", value: function handleFinishKey(

    event) {
      if (!this.poly) {
        return false;
      }

      // Avoid closing if it would result in a polygon that is degenerated to a line.
      if (this.isPolygon() && this.poly.length < 3) {
        return false;
      }

      this.finishPolygon();
      return true;
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      var handled = _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyDown", this).call(this, event, keyCode);

      // delegate to rectTool
      handled = this.lineRectTool.handleKeyDown(event, keyCode) || handled;

      // Map event to any known key in this.keyMap
      var funcKey = this.mapKey(event, this.keyMap);
      switch (funcKey) {
        case 'CANCEL_EDIT':this.cancelEdit();handled = true;break;
        case 'REMOVE_LAST_VERTEX':this.removeLastVertex();handled = true;break;
        case 'FINISH_EDIT':handled = this.handleFinishKey(event);break;}

      return handled;
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      _get(_getPrototypeOf(PolygonTool.prototype), "handleKeyUp", this).call(this, event, keyCode);
      this.lineRectTool.handleKeyUp(event, keyCode);
    }

    // If snapping has toggled on/off, we instantly "replay" hovering at current mouse position. Purpose is to
    // give instant feedback (e.g. hide/show SnapLine gizmos and adjust position of preview edge)
  }, { key: "onSnappingToggled", value: function onSnappingToggled(canvasX, canvasY) {
      this.onHover(canvasX, canvasY);
    } }, { key: "mouseOnStartVertex", value: function mouseOnStartVertex(

    event) {
      if (!this.vertexGizmos[0]) {
        return false;
      }

      // Check if start vertex was clicked
      var pLayer = this.layer.canvasToLayer(event.canvasX, event.canvasY);
      return this.vertexGizmos[0].hitTestLayer(pLayer.x, pLayer.y);
    } }, { key: "setStartVertexHighlighted", value: function setStartVertexHighlighted(

    enable) {
      if (this.vertexGizmos[0]) {
        this.vertexGizmos[0].setSelected(enable);
      }
    } }]);return PolygonTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_3__["default"]);


PolygonTool.POLYGON_ADDED = "polygonAdded";
PolygonTool.Mode = Mode;

/***/ }),

/***/ "./extensions/Edit2D/tools/RectangleTool.js":
/*!**************************************************!*\
  !*** ./extensions/Edit2D/tools/RectangleTool.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RectangleTool; });
/* harmony import */ var _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EditShapes.js */ "./extensions/Edit2D/EditShapes.js");
/* harmony import */ var _Actions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Actions.js */ "./extensions/Edit2D/Actions.js");
/* harmony import */ var _EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EditToolBase.js */ "./extensions/Edit2D/tools/EditToolBase.js");
function _typeof(obj) {if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;};}return _typeof(obj);}function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}function _possibleConstructorReturn(self, call) {if (call && (_typeof(call) === "object" || typeof call === "function")) {return call;}return _assertThisInitialized(self);}function _getPrototypeOf(o) {_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {return o.__proto__ || Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _inherits(subClass, superClass) {if (typeof superClass !== "function" && superClass !== null) {throw new TypeError("Super expression must either be null or a function");}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });if (superClass) _setPrototypeOf(subClass, superClass);}function _setPrototypeOf(o, p) {_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {o.__proto__ = p;return o;};return _setPrototypeOf(o, p);}function _assertThisInitialized(self) {if (self === void 0) {throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}






var RectangleToolName = "Edit2_RectangleTool";

var av = Autodesk.Viewing;

// Creates rectangles by dragging
var RectangleTool = /*#__PURE__*/function (_EditToolBase) {_inherits(RectangleTool, _EditToolBase);

  function RectangleTool(ctx) {var _this;var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Style"]();_classCallCheck(this, RectangleTool);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(RectangleTool).call(this, ctx));

    Autodesk.Viewing.EventDispatcher.prototype.apply(_assertThisInitialized(_assertThisInitialized(_this)));

    _this.style = style;

    // New polygon created by dragging
    _this.rect = null;

    // First corner of the new rectangle
    _this.startPoint = new THREE.Vector2();
    _this.endPoint = new THREE.Vector2();

    // Indicates that we interrupted dragging with Esc. In this case, we still consume the mouse-up
    // event to avoid inconsistencies in other tool.
    _this.dragCanceled = false;return _this;
  }_createClass(RectangleTool, [{ key: "getName", value: function getName()

    {
      return RectangleToolName + this.nameSuffix;
    } }, { key: "activate", value: function activate()

    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }, { key: "handleButtonDown", value: function handleButtonDown(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return;
      }

      var p = this.getSnapPosition(event.canvasX, event.canvasY);
      this.startDrag(p);
      return true;
    } }, { key: "handleButtonUp", value: function handleButtonUp(

    event, button) {

      // Only respond to left button
      if (button != 0) {
        return false;
      }

      // If drag has been interrupted, consider the endDrag() as handled
      if (this.dragCanceled) {
        this.dragCanceled = false;
        return true;
      }

      return this.endDrag();
    } }, { key: "handleMouseMove", value: function handleMouseMove(

    event) {

      // Get snapping position. Note that this even makes sense when not dragging: In this case, we 
      // just do it to update the snapping indicator.
      var p = this.getSnapPosition(event.canvasX, event.canvasY);

      if (!this.rect) {
        return false;
      }

      this.moveDrag(p, event.shiftKey);

      return true;
    }

    // Start dragging a shape
    //  @param {Shape}   shape
    //  @param {Vector2} startPos - in layer coords
  }, { key: "startDrag", value: function startDrag(startPos) {
      this.rect = new _EditShapes_js__WEBPACK_IMPORTED_MODULE_0__["Polygon"]([startPos.clone(), startPos.clone(), startPos.clone(), startPos.clone()], this.style.clone());
      this.startPoint.copy(startPos);
      this.endPoint.copy(startPos);

      this.gizmoLayer.addShape(this.rect);
    } }, { key: "updateRect", value: function updateRect(

    forceQuad) {

      if (!this.isDragging()) {
        return;
      }

      var p0 = this.startPoint;
      var p1 = this.endPoint;

      if (forceQuad) {

        // Use maximum of dx/dy as edge length
        var dx = p1.x - p0.x;
        var dy = p1.y - p0.y;

        var edgeLength = Math.max(Math.abs(dx), Math.abs(dy));

        // Consider drag direction to span quad right/left resp. up/down
        var sx = Math.sign(dx);
        var sy = Math.sign(dy);

        this.rect.updatePoint(1, p0.x + edgeLength * sx, p0.y);
        this.rect.updatePoint(2, p0.x + edgeLength * sx, p0.y + edgeLength * sy);
        this.rect.updatePoint(3, p0.x, p0.y + edgeLength * sy);

      } else {
        this.rect.updatePoint(1, p1.x, p0.y);
        this.rect.updatePoint(2, p1.x, p1.y);
        this.rect.updatePoint(3, p0.x, p1.y);
      }

      this.gizmoLayer.update();
    }

    // p is in layer coords
  }, { key: "moveDrag", value: function moveDrag(p, forceQuad) {

      // update rectangle
      this.endPoint.copy(p);
      this.updateRect(forceQuad);
    } }, { key: "endDrag", value: function endDrag()

    {

      if (!this.rect) {
        return false;
      }

      // Check if rect is valid
      var dx = this.endPoint.x - this.startPoint.x;
      var dy = this.endPoint.y - this.startPoint.y;
      var Eps = 1.e-10;
      var rectValid = Math.abs(dx) > Eps && Math.abs(dy) > Eps;

      // Move shape to main layer (or just remove if invalid)
      this.gizmoLayer.removeShape(this.rect);
      if (rectValid) {
        this.undoStack.run(new _Actions_js__WEBPACK_IMPORTED_MODULE_1__["Actions"].AddShape(this.layer, this.rect));
      }

      this.rect = null;
      return true;
    } }, { key: "cancelDrag", value: function cancelDrag()

    {
      if (this.rect) {
        // Remove temporary gizmo shape
        this.gizmoLayer.removeShape(this.rect);
        this.rect = null;

        this.dragCanceled = true;
      }
    } }, { key: "isDragging", value: function isDragging()

    {
      return Boolean(this.rect);
    } }, { key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(true);
      }
    } }, { key: "handleKeyUp", value: function handleKeyUp(

    event, keyCode) {
      // Update shape when toggling between rect and quad mode
      if (keyCode == av.KeyCode.SHIFT) {
        this.updateRect(false);
      }
    } }]);return RectangleTool;}(_EditToolBase_js__WEBPACK_IMPORTED_MODULE_2__["default"]);

/***/ }),

/***/ "./extensions/Edit2D/tools/UndoTool.js":
/*!*********************************************!*\
  !*** ./extensions/Edit2D/tools/UndoTool.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UndoTool; });
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}var UndoToolname = 'Edit2_UndoTool';

var av = Autodesk.Viewing;

// Simple tool that triggers undo/redo on ctrl-z/ctrl-shift-z
var UndoTool = /*#__PURE__*/function () {

  function UndoTool(undoStack) {_classCallCheck(this, UndoTool);
    this.undoStack = undoStack;
  }_createClass(UndoTool, [{ key: "handleKeyDown", value: function handleKeyDown(

    event, keyCode) {

      if (keyCode !== av.KeyCode.z || !event.ctrlKey) {
        return false;
      }

      if (event.shiftKey) {
        this.undoStack.redo();
      } else {
        this.undoStack.undo();
      }
    } }, { key: "getName",

    // Some paperwork for ToolController
    value: function getName() {
      return UndoToolname;
    } }, { key: "getNames", value: function getNames()
    {
      return [this.getName()];
    } }, { key: "activate", value: function activate()
    {} }, { key: "deactivate", value: function deactivate()
    {} }, { key: "register", value: function register()
    {} }]);return UndoTool;}();
;

/***/ }),

/***/ "./extensions/PDF/LmvCanvasContext.js":
/*!********************************************!*\
  !*** ./extensions/PDF/LmvCanvasContext.js ***!
  \********************************************/
/*! exports provided: hijackContextAPI, LmvCanvasContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hijackContextAPI", function() { return hijackContextAPI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LmvCanvasContext", function() { return LmvCanvasContext; });
/* harmony import */ var _path2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path2d */ "./extensions/PDF/path2d.js");
/* harmony import */ var _bezier__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bezier */ "./extensions/PDF/bezier.js");
function _classCallCheck(instance, Constructor) {if (!(instance instanceof Constructor)) {throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target, props) {for (var i = 0; i < props.length; i++) {var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);}}function _createClass(Constructor, protoProps, staticProps) {if (protoProps) _defineProperties(Constructor.prototype, protoProps);if (staticProps) _defineProperties(Constructor, staticProps);return Constructor;}
var av = Autodesk.Viewing,
avp = av.Private;

var VertexBufferBuilder = avp.VertexBufferBuilder;




//Custom implementation of HTML Canvas API used for rendering PDF geometry using the WebGL accelerated F2D renderer


//A custom context object that overloads standard HMTL Canvas 2D context to intercept draw
//calls and pipe them into LMV vertex buffers
function hijackContextAPI(inContext, lmvContext) {

  var fnList = [
  "fillRect",
  "strokeRect",
  "clearRect",
  "beginPath",
  "closePath",
  "moveTo",
  "lineTo",
  "arc",
  "arcTo",
  "quadraticCurveTo",
  "bezierCurveTo",
  "rect",
  "fill",
  "stroke",
  "clip",
  "strokeText",
  "fillText",
  "drawImage",
  "save",
  "restore"];


  fnList.forEach(function (fn) {
    inContext["_original" + fn] = inContext[fn];
    inContext[fn] = lmvContext[fn].bind(lmvContext);
  });

}


var _tmpXform = new Array(6);
var _tmpVec = new THREE.Vector2();
var _tmpBox = new THREE.Box2();


//Used for matrix decomposition in drawImage
var _offset = new THREE.Vector3();
var _quat = new THREE.Quaternion();
var _scale = new THREE.Vector3();
var _axis = new THREE.Vector3();
var _mtx4 = new THREE.Matrix4();

var LmvCanvasContext = /*#__PURE__*/function () {

  function LmvCanvasContext(viewport, toPageUnits, meshCallback, fontEngine, usingTextLayer) {_classCallCheck(this, LmvCanvasContext);

    //
    // Prepare canvas using PDF page dimensions
    //
    //TODO: Do we need that or can we just overload the entire CanvasContext API and skip the HTML element creation completely?
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    canvas.height = viewport.height;
    canvas.width = viewport.width;

    this.canvasContext = context; //REQUIRED for PDF.js interface
    this.viewport = viewport; //REQUIRED for PDF.js interface
    this.toPageUnits = toPageUnits;

    this.meshCallback = meshCallback;

    this.currentMeshIndex = 0;
    this.imageNumber = 0;
    this.currentVbb = new VertexBufferBuilder(false);
    this._curPath = null;
    this._curClip = null;
    this.first = true;
    this.states = [];
    this.glyphCache = {};
    this.usingTextLayer = usingTextLayer;

    //Fixed precision tolerance assuming the input is in typographic "point" units.
    this.precisionTolerance = 0.1;

    this.dbId = -1;

    // If true, dbId is automatically increased on each beginPath call.
    this.consecutiveIds = false;

    if (av.isMobileDevice()) {
      Object(_bezier__WEBPACK_IMPORTED_MODULE_1__["SetTesselationParams"])(undefined, 0.1);
    }

    this.fontEngine = fontEngine;

    // Use solid lines by default. See LineStyleDef.js for other line types (dashed etc.)
    this.lineStyle = 0;

    // If true, lines widths are applied in screen-space
    this.isScreenSpace = false;

    hijackContextAPI(context, this);
  }_createClass(LmvCanvasContext, [{ key: "save", value: function save()

    {
      //console.log("save");
      this.states.push({
        clip: this._curClip,
        consecutiveIds: this.consecutiveIds,
        dbId: this.dbId });


      this.canvasContext._originalsave();
    } }, { key: "restore", value: function restore()

    {

      var state = this.states.pop();

      if (state) {
        this._curClip = state.clip;
        this.consecutiveIds = state.consecutiveIds;
        this.dbId = state.dbId;
      }

      //console.log("restore");
      this.canvasContext._originalrestore();
    } }, { key: "flushBuffer", value: function flushBuffer(

    addCount, finalFlush)
    {
      if (!this.currentVbb.vcount && !finalFlush)
      {
        return;
      }

      var flush = finalFlush;
      flush = flush || this.currentVbb.isFull(addCount);

      if (flush) {
        if (this.currentVbb.vcount) {
          var mesh = this.currentVbb.toMesh();

          mesh.material = {
            skipEllipticals: !this.currentVbb.numEllipticals,
            skipCircles: !this.currentVbb.numCirculars,
            skipTriangleGeoms: !this.currentVbb.numTriangleGeoms,
            useInstancing: this.currentVbb.useInstancing,
            isScreenSpace: !this.currentImage,
            hasLineStyles: this.currentVbb.hasLineStyles };


          if (this.currentImage) {
            mesh.material.image = this.currentImage;
            mesh.material.image.name = this.imageNumber++;
            mesh.material.opacity = this.canvasContext.globalAlpha;
            this.currentImage = null;
          }

          this.meshCallback(mesh, this.currentMeshIndex++);

          this.currentVbb.reset(0);
        }
      }
    }

    //Polytriangle requires some post-processing depending on wheter instancing is used or not
    //TODO: This is copy-pasted from the same function in F2D.js. It's purely used to
    //add half width outline to polytriangles so that they look antialiased.
  }, { key: "addPolyTriangle", value: function addPolyTriangle(points, inds, color, dbId, layer, antialiasEdges) {

      var me = this;
      var edgeMap = null;

      var currentVpId = 0;

      var aaLineWeight = -0.5; //negative = in pixel units

      function processEdge(iFrom, iTo) {
        if (iFrom > iTo) {
          var tmp = iFrom;
          iFrom = iTo;
          iTo = tmp;
        }

        if (!edgeMap[iFrom])
        edgeMap[iFrom] = [iTo];else
        {
          var adjacentVerts = edgeMap[iFrom];
          var idx = adjacentVerts.lastIndexOf(iTo);
          if (idx == -1)
          adjacentVerts.push(iTo); //first time we see this edge, so remember it as exterior edge
          else
            adjacentVerts[idx] = -1; //the second time we see an edge mark it as interior edge
        }
      }


      function addAllAntialiasEdges() {

        for (var i = 0, iEnd = edgeMap.length; i < iEnd; i++) {

          var adjacentVerts = edgeMap[i];
          if (!adjacentVerts)
          continue;

          for (var j = 0; j < adjacentVerts.length; j++) {
            var iTo = adjacentVerts[j];
            if (iTo == -1)
            continue; //an interior edge was here -- skip
            else {
                //exterior edge -- add an antialiasing line for it
                me.flushBuffer(4);
                me.currentVbb.addSegment(points[2 * i], points[2 * i + 1],
                points[2 * iTo], points[2 * iTo + 1],
                0,
                aaLineWeight,
                color,
                dbId, layer, currentVpId, me.lineStyle);
              }
          }
        }
      }

      function antialiasOneEdge(iFrom, iTo) {
        if (iFrom > iTo) {
          var tmp = iFrom;
          iFrom = iTo;
          iTo = tmp;
        }

        var adjacentVerts = edgeMap[iFrom];
        if (!adjacentVerts)
        return;

        var idx = adjacentVerts.indexOf(iTo);
        if (idx != -1) {
          //exterior edge -- add an antialiasing line for it
          me.flushBuffer(4);
          me.currentVbb.addSegment(points[2 * iFrom], points[2 * iFrom + 1],
          points[2 * iTo], points[2 * iTo + 1],
          0,
          aaLineWeight,
          color,
          dbId, layer, currentVpId, me.lineStyle);
        }
      }

      if (antialiasEdges) {
        edgeMap = new Array(points.length / 2);

        for (var i = 0, iEnd = inds.length; i < iEnd; i += 3) {
          var i0 = inds[i];
          var i1 = inds[i + 1];
          var i2 = inds[i + 2];

          processEdge(i0, i1);
          processEdge(i1, i2);
          processEdge(i2, i0);
        }
      }

      if (this.currentVbb.useInstancing) {
        var count = inds.length;
        for (var i = 0; i < count; i += 3) {
          var i0 = inds[i];
          var i1 = inds[i + 1];
          var i2 = inds[i + 2];

          this.flushBuffer(4);

          this.currentVbb.addTriangleGeom(points[2 * i0], points[2 * i0 + 1],
          points[2 * i1], points[2 * i1 + 1],
          points[2 * i2], points[2 * i2 + 1],
          color, dbId, layer, currentVpId);

          if (antialiasEdges) {
            antialiasOneEdge(i0, i1);
            antialiasOneEdge(i1, i2);
            antialiasOneEdge(i2, i0);
          }
        }
      } else
      {
        var count = points.length / 2; // number of vertices

        this.flushBuffer(count);
        var vbb = this.currentVbb;
        var vbase = vbb.vcount;

        for (var i = 0; i < count; ++i) {
          var x = points[2 * i];
          var y = points[2 * i + 1];
          vbb.addVertexPolytriangle(x, y, color, dbId, layer, currentVpId);
        }

        vbb.addIndices(inds, vbase);

        if (antialiasEdges) {
          addAllAntialiasEdges();
        }

      }
    }

    //Extract colors from HTML Canvas state
  }, { key: "getFillColor", value: function getFillColor() {
      if (typeof this.canvasContext.fillStyle !== "string") {
        console.warn("Unsupported fill style.");
        return 0x00000000;
      }

      var rgb = parseInt(this.canvasContext.fillStyle.slice(1), 16);
      var a = 255 * this.canvasContext.globalAlpha << 24;
      var c = a | (rgb & 0xff) << 16 | rgb & 0xff00 | rgb >> 16 & 0xff;
      return c;
    } }, { key: "getStrokeColor", value: function getStrokeColor()

    {

      var ctx = this.canvasContext;

      if (this.lastStrokeStyle === ctx.strokeStyle && ctx.globalAlpha === this.lastAlpha) {
        return this.lastRgb;
      } else {
        var rgb = parseInt(ctx.strokeStyle.slice(1), 16);
        var a = 255 * ctx.globalAlpha << 24;
        var c = a | (rgb & 0xff) << 16 | rgb & 0xff00 | rgb >> 16 & 0xff;

        this.lastRgb = c;
        this.lastStrokeStyle = ctx.strokeStyle;
        this.lastAlpha = ctx.globalAlpha;

        return c;
      }

    } }, { key: "getCurrentTransform", value: function getCurrentTransform()

    {
      var xform = this.canvasContext.mozCurrentTransform;

      //Pay attention here: In case we are processing the path of a character and we want to
      //cache it for later use, we have to neutralize the part of the canvas transform that positions
      //the character in the page, but we need to keep the rest of the transform (that positions parts
      //of the character in its own em-box). This is what the inverse transform multiplication here does.
      //TODO: we can optimize this to only compute the multiplication in case mozCurrentTransform changes.
      if (this.isFontChar) {
        var m = this.invXform;
        var a = xform[0],b = xform[1],c = xform[2],d = xform[3],e = xform[4],f = xform[5];
        _tmpXform[0] = m[0] * a + m[2] * b;
        _tmpXform[1] = m[1] * a + m[3] * b;
        _tmpXform[2] = m[0] * c + m[2] * d;
        _tmpXform[3] = m[1] * c + m[3] * d;
        _tmpXform[4] = m[0] * e + m[2] * f + m[4];
        _tmpXform[5] = m[1] * e + m[3] * f + m[5];
        return _tmpXform;
      }

      return xform;
    } }, { key: "tx", value: function tx(

    x, y, xform) {
      xform = xform || this.getCurrentTransform();
      return (x * xform[0] + y * xform[2] + xform[4]) * (this.isFontChar ? 1 : this.toPageUnits);
    } }, { key: "ty", value: function ty(

    x, y, xform) {
      xform = xform || this.getCurrentTransform();
      return (x * xform[1] + y * xform[3] + xform[5]) * (this.isFontChar ? 1 : this.toPageUnits);
    } }, { key: "scaleValue", value: function scaleValue(

    v, xform) {
      xform = xform || this.getCurrentTransform();
      return this.toPageUnits * Math.sqrt(Math.abs(xform[0] * xform[3] - xform[1] * xform[2])) * v; //assumes uniform;
    } }, { key: "transformBox", value: function transformBox(

    bbox, xform, dst) {
      xform = xform || this.getCurrentTransform();

      _tmpBox.makeEmpty();

      _tmpVec.set(this.tx(bbox.min.x, bbox.min.y, xform), this.ty(bbox.min.x, bbox.min.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      _tmpVec.set(this.tx(bbox.max.x, bbox.min.y, xform), this.ty(bbox.max.x, bbox.min.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      _tmpVec.set(this.tx(bbox.max.x, bbox.max.y, xform), this.ty(bbox.max.x, bbox.max.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      _tmpVec.set(this.tx(bbox.min.x, bbox.max.y, xform), this.ty(bbox.min.x, bbox.max.y, xform));
      _tmpBox.expandByPoint(_tmpVec);

      if (dst) {
        dst.copy(_tmpBox);
        return dst;
      } else {
        return _tmpBox.clone();
      }
    } }, { key: "fillRect", value: function fillRect(


    x, y, w, h) {

      if (this.consecutiveIds) {
        this.dbId++;
      }

      var xform = this.getCurrentTransform();

      var points = [
      this.tx(x, y, xform), this.ty(x, y, xform),
      this.tx(x + w, y, xform), this.ty(x + w, y, xform),
      this.tx(x + w, y + h, xform), this.ty(x + w, y + h, xform),
      this.tx(x, y + h, xform), this.ty(x, y + h, xform)];


      var c = this.getFillColor();

      var indices = [0, 1, 2, 0, 2, 3];

      // Hack: Assumption here is that the first fillRect call is for the white background quad.
      //       For this, we don't want a dbI and use -1 instead. Unfortunately, this fillRect call happens
      //       inside PDF.js (see beginDrawing in display/canvas.js), so we cannot easily set this id from outside.
      var dbId = this.first ? -1 : this.dbId;

      this.addPolyTriangle(points, indices, c, dbId, 0, false);

      this.first = false;
    } }, { key: "strokeRect", value: function strokeRect(

    x, y, w, h) {
      //TODO:
      console.log("strokeRect");
    } }, { key: "clearRect", value: function clearRect(

    x, y, w, h) {
      console.log("clearRect");
      //TODO:
    } }, { key: "_beginTextChar", value: function _beginTextChar(

    character, x, y, font, fontSize) {
      if (this.usingTextLayer === true) {
        this.skipPath = true;
        return;
      }

      this.isFontChar = true;
      this.invXform = this.canvasContext.mozCurrentTransformInverse;
      this.hashKey = character.charCodeAt(0) + "/" + font.loadedName + "/" + fontSize;
      this.cachedGlyph = this.glyphCache[this.hashKey];

      if (this.cachedGlyph) {
        this.skipPath = true;
      } else {
        this.skipPath = false;
      }
      //console.log(character, x, y, font, fontSize);
    } }, { key: "beginPath", value: function beginPath(

    character, x, y, font, fontSize) {

      if (this.consecutiveIds) {
        this.dbId++;
      }

      if (typeof character === "string" && font && fontSize) {
        this._beginTextChar(character, x, y, font, fontSize);
      } else {
        this.skipPath = false;
        this.isFontChar = false;
      }

      if (this.skipPath)
      this._curPath = null;else

      this._curPath = new _path2d__WEBPACK_IMPORTED_MODULE_0__["Path2D"](this.isFontChar ? 0.0001 : this.precisionTolerance);
    } }, { key: "closePath", value: function closePath()

    {

      if (this.skipPath)
      return;

      this._curPath.closePath();
    } }, { key: "moveTo", value: function moveTo(

    x, y) {

      if (this.skipPath)
      return;

      if (!this._curPath)
      this.beginPath();

      var xform = this.getCurrentTransform();

      this._curPath.moveTo(this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "lineTo", value: function lineTo(

    x, y) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.lineTo(this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "arc", value: function arc(

    x, y, radius, startAngle, endAngle, anticlockwise) {

      if (this.skipPath)
      return;

      //TODO: transform

      this._curPath.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    } }, { key: "arcTo", value: function arcTo(

    x1, y1, x2, y2, radius) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.arcTo(this.tx(x1, y1, xform), this.ty(x1, y1, xform),
      this.tx(x2, y2, xform), this.ty(x2, y2, xform),
      this.scaleValue(radius, xform));
    } }, { key: "quadraticCurveTo", value: function quadraticCurveTo(

    cp1x, cp1y, x, y) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.quadraticCurveTo(this.tx(cp1x, cp1y, xform), this.ty(cp1x, cp1y, xform),
      this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "bezierCurveTo", value: function bezierCurveTo(

    cp1x, cp1y, cp2x, cp2y, x, y) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      this._curPath.bezierCurveTo(this.tx(cp1x, cp1y, xform), this.ty(cp1x, cp1y, xform),
      this.tx(cp2x, cp2y, xform), this.ty(cp2x, cp2y, xform),
      this.tx(x, y, xform), this.ty(x, y, xform));
    } }, { key: "rect", value: function rect(

    x, y, w, h) {

      if (this.skipPath)
      return;

      var xform = this.getCurrentTransform();

      if (!this._curPath)
      this.beginPath();

      this._curPath.moveTo(this.tx(x, y, xform), this.ty(x, y, xform));
      this._curPath.lineTo(this.tx(x + w, y, xform), this.ty(x + w, y, xform));
      this._curPath.lineTo(this.tx(x + w, y + h, xform), this.ty(x + w, y + h, xform));
      this._curPath.lineTo(this.tx(x + w, y, xform), this.ty(x + w, y, xform));
      this._curPath.closePath();
    } }, { key: "fill", value: function fill()

    {
      if (this.isFontChar && !this.cachedGlyph) {
        this.glyphCache[this.hashKey] = this._curPath;
        this.cachedGlyph = this._curPath;
        this.cachedGlyph.cacheTriangulation();
      }

      this.isFontChar = false;

      if (this.cachedGlyph) {
        this.cachedGlyph.fill(this, this.getFillColor(), this.dbId, 0, this._curClip, true);
      } else {
        this._curPath && this._curPath.fill(this, this.getFillColor(), this.dbId, 0, this._curClip, false);
      }

      this.cachedGlyph = null;
      this.skipPath = false;

      //this._curClip = null;
      //lmvContext._curPath = null;
    } }, { key: "stroke", value: function stroke()

    {
      if (this.isFontChar && !this.cachedGlyph) {
        this.glyphCache[this.hashKey] = this._curPath;
        this.cachedGlyph = this._curPath;
        this.cachedGlyph.cacheTriangulation();
      }

      this.isFontChar = false;

      // LineShader uses negative lineWidths to indicate screen-space line widths. Note that this.canvasContext.lineWidth does not allow negative values.
      // Therefore, we apply the sign separately.
      var sign = this.isScreenSpace ? -1.0 : 1.0;

      if (this.cachedGlyph) {
        this.cachedGlyph.stroke(this, sign * this.scaleValue(this.canvasContext.lineWidth), this.getStrokeColor(), this.dbId, 0, this._curClip, true, this.lineStyle);
      } else {
        this._curPath && this._curPath.stroke(this, sign * this.scaleValue(this.canvasContext.lineWidth), this.getStrokeColor(), this.dbId, 0, this._curClip, false, this.lineStyle);
      }

      this.cachedGlyph = null;
      this.skipPath = false;

      //lmvContext._curPath = null;
    } }, { key: "clip", value: function clip(

    param1, param2) {

      if (param2 !== undefined && param1 !== undefined) {
        this._curClip = param1;
        console.log("Probably unsupported use case");
      } else {

        //The clip region is also affected by any existing clip region,
        //i.e. we have to clip the clip.
        if (this._curClip) {
          this._curClip = this._curClip.clip(this._curPath, param1);
        } else {
          this._curClip = this._curPath;
        }

        this._curPath = null;
      }

      //console.log("CLIP", param1, param2);
    } }, { key: "strokeText", value: function strokeText(

    text, x, y, maxWidth, font, fontSize) {

      var ctx = this.canvasContext;
      ctx.save();
      ctx.translate(x, y);

      this.fontEngine.drawText(this, text, 0, 0, font, fontSize);
      this.stroke();

      ctx.restore();
    } }, { key: "fillText", value: function fillText(

    text, x, y, maxWidth, font, fontSize) {

      var ctx = this.canvasContext;
      ctx.save();
      ctx.translate(x, y);

      this.fontEngine.drawText(this, text, 0, 0, font, fontSize);
      this.fill();
      //this.stroke();

      ctx.restore();
    } }, { key: "drawImage", value: function drawImage(

    image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {


      if (image.width === 0 || image.height === 0) {
        console.warn("Zero size image, skipping");
        return;
      }

      if (dx === undefined) {
        dx = sx;
        dy = sy;
        dWidth = sWidth;
        dHeight = sHeight;
      }

      if (dWidth === undefined) {
        dWidth = image.width;
        dHeight = image.height;
      }

      if (!dWidth) {
        console.warn("Zero size image, skipping");
        return;
      }

      //console.log("Draw image", dWidth, dHeight);

      var xform = this.getCurrentTransform();

      //Get the transformed page space image center
      var cx = this.tx(dx + dWidth / 2, dy + dHeight / 2);
      var cy = this.ty(dx + dWidth / 2, dy + dHeight / 2);

      _mtx4.elements[0] = xform[0];
      _mtx4.elements[1] = xform[1];
      _mtx4.elements[4] = xform[2];
      _mtx4.elements[5] = xform[3];
      _mtx4.elements[12] = xform[4];
      _mtx4.elements[13] = xform[5];
      _mtx4.decompose(_offset, _quat, _scale);

      //Get scaled width/height. Note these scalings can result in negative numbers
      var w = dWidth * _scale.x * this.toPageUnits;
      var h = -dHeight * _scale.y * this.toPageUnits; //Image input is y-down, so we build in a y-inversion

      //Derive the rotation angle by converting the quaternion to axis-angle.
      var s = Math.sqrt(1.0 - _quat.w * _quat.w);
      _axis.set(_quat.x / s, _quat.y / s, _quat.z / s);
      var angle = 2.0 * Math.acos(Math.max(Math.min(1, _quat.w), -1));
      //Take care to negate the angle if the rotation axis is into the page.
      if (_quat.z < 0) {
        angle = -angle;
      }

      //Angle needs to be in the range 0-2pi for use by addTextureQuad below,
      //while input has domain [-pi, pi].
      if (angle < 0) {
        angle += 2 * Math.PI;
      }

      this.flushBuffer(0, true);

      this.currentVbb.addTexturedQuad(cx, cy, w, h, angle, 0xffff00ff, 0, 0, 0);
      this.currentImage = image;
      this.flushBuffer(0, true);

      //        console.log("draw Image", sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    } }]);return LmvCanvasContext;}();

/***/ }),

/***/ "./extensions/PDF/bezier.js":
/*!**********************************!*\
  !*** ./extensions/PDF/bezier.js ***!
  \**********************************/
/*! exports provided: SetTesselationParams, TesselateCubic, TesselateQuad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SetTesselationParams", function() { return SetTesselationParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateCubic", function() { return TesselateCubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TesselateQuad", function() { return TesselateQuad; });
//How many forward iterations to use when approximating Bezier curves
//More iterations are needed in case the min_seg_len setting below is smaller
//relative to mesh size. However, the two numbers need to be tuned together
//so that NUM_ITERATIONS is enough to result in segment lengths desired.

//Note that those values are tuned for PDF rendering, where text characters
//are drawn one by one. If a long piece of text is drawn all at once, then
//its bounding box will be quite large, so the relative min_seg_len will also
//be too large and the characters will look coarse. In such cases, we will need
//to better estimate this by using e.g. the font height only.


var NUM_ITERATIONS = 100;

//What fraction of the bounding sbox should be the minimum length of
//a segment
var MIN_SEG_LEN_FRACTION = 0.05;

function SetTesselationParams(num_iterations, min_seg_len_fraction) {
  if (num_iterations)
  NUM_ITERATIONS = num_iterations;

  if (min_seg_len_fraction)
  MIN_SEG_LEN_FRACTION = min_seg_len_fraction;
}


function TesselateCubic(ctx, px1, py1, px2, py2, px3, py3, px4, py4, maxdim)
{
  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / MIN_SEG_LEN_FRACTION;

  //minimum length of tesselation segment
  //set to 1/100 of the bounds
  var minSegLen = maxdim * MIN_SEG_LEN_FRACTION;

  //but for now we will iterate 100 times
  var dt = 1.0 / NUM_ITERATIONS;

  //double dt2 = dt*dt;
  var dt3 = dt * dt * dt;

  var pre1 = 3.0 * dt;
  var pre2 = pre1 * dt;
  var pre3 = pre2 + pre2;
  var pre4 = 6.0 * dt3;

  var temp1x = px1 - 2.0 * px2 + px3;
  var temp1y = py1 - 2.0 * py2 + py3;
  var temp2x = 3.0 * (px2 - px3) - px1 + px4;
  var temp2y = 3.0 * (py2 - py3) - py1 + py4;

  var fx = px1;
  var fy = py1;
  var dfx = (px2 - px1) * pre1 + temp1x * pre2 + temp2x * dt3;
  var dfy = (py2 - py1) * pre1 + temp1y * pre2 + temp2y * dt3;
  var ddfx = temp1x * pre3 + temp2x * pre4;
  var ddfy = temp1y * pre3 + temp2y * pre4;
  var dddfx = temp2x * pre4;
  var dddfy = temp2y * pre4;

  var error = 0.0;

  // forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;
    ddfy += dddfy;
    ddfx += dddfx;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) //add segment only if we have reached treshold length
      {
        // line to current
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px4, py4);
}

function TesselateQuad(ctx, px1, py1, px2, py2, px3, py3, maxdim)
{
  //we will base the max number of segments to use for approximation
  //on the bounds of the full line buffer contents
  //TODO: as an improvement we could take the bounds of this particular curve
  //with respect to the full bounds of the line buffer data.
  maxdim = maxdim || 1 / MIN_SEG_LEN_FRACTION;

  //minimum length of tesselation segment
  //set to a fraction of the bbox of the entire path (value chosen to work well for text at reasonable font size)
  var minSegLen = maxdim * MIN_SEG_LEN_FRACTION;

  //but for now we will iterate 100 times
  var dt = 1.0 / NUM_ITERATIONS;

  var dt2 = dt * dt;

  var ax = px1 - 2.0 * px2 + px3; //replace 2* by addition?
  var ay = py1 - 2.0 * py2 + py3; //replace 2* by addition?

  var bx = 2.0 * (px2 - px1);
  var by = 2.0 * (py2 - py1);

  var fx = px1;
  var fy = py1;
  var dfx = bx * dt + ax * dt2;
  var dfy = by * dt + ay * dt2;
  var ddfx = 2.0 * ax * dt2;
  var ddfy = 2.0 * ay * dt2;

  var error = 0.0;

  //forward differencing loop
  var tMax = 0 | 1.0 / dt - 0.5;
  for (var t = 0; t < tMax; t++)
  {
    fx += dfx;
    fy += dfy;
    dfx += ddfx;
    dfy += ddfy;

    error += Math.sqrt(dfx * dfx + dfy * dfy);

    if (error >= minSegLen) // how many pixels should each line be?)
      {
        ctx.lineTo(fx, fy);
        error = 0.0;
      }
  }

  ctx.lineTo(px3, py3);
}

/***/ }),

/***/ "./extensions/PDF/path2d.js":
/*!**********************************!*\
  !*** ./extensions/PDF/path2d.js ***!
  \**********************************/
/*! exports provided: Path2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path2D", function() { return Path2D; });
/* harmony import */ var _bezier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier */ "./extensions/PDF/bezier.js");




//Helper for converting complex HTML Canvas paths to simple polylines / polygons


var MOVETO = 0,
LINETO = 1,
ARC = 2,
ARCTO = 3,
QUADTO = 4,
CUBICTO = 5,
CLOSE = 7;


var _v2 = new THREE.Vector2();
var _tmpBox = new THREE.Box2();

function Path2D(precisionTolerance) {
  this.segTypes = [];
  this.segData = [];
  this.hasCurves = false;
  this.bbox = new THREE.Box2();
  this.precisionTolerance = precisionTolerance;
}

Path2D.prototype.closePath = function () {
  if (this.segTypes.length && this.segTypes[this.segTypes.length - 1] === CLOSE)
  return;
  this.segTypes.push(CLOSE);
};


Path2D.prototype.moveTo = function (x, y) {
  this.segTypes.push(MOVETO);
  this.segData.push(x, y);

  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.lineTo = function (x, y) {
  this.segTypes.push(LINETO);
  this.segData.push(x, y);

  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
  this.hasCurves = true;
  this.segTypes.push(ARC);
  this.segData.push(x, y, radius, startAngle, endAngle, anticlockwise);

  this.bbox.expandByPoint(_v2.set(x, y)); //TODO: all corners
};

Path2D.prototype.arcTo = function (x1, y1, x2, y2, radius) {
  this.hasCurves = true;
  this.segTypes.push(ARCTO);
  this.segData.push(x1, y1, x2, y2, radius);

  this.bbox.expandByPoint(_v2.set(x1, y1));
  this.bbox.expandByPoint(_v2.set(x2, y2));
};

Path2D.prototype.quadraticCurveTo = function (cp1x, cp1y, x, y) {
  this.hasCurves = true;
  this.segTypes.push(QUADTO);
  this.segData.push(cp1x, cp1y, x, y);

  this.bbox.expandByPoint(_v2.set(cp1x, cp1y));
  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
  this.hasCurves = true;
  this.segTypes.push(CUBICTO);
  this.segData.push(cp1x, cp1y, cp2x, cp2y, x, y);
  this.bbox.expandByPoint(_v2.set(cp1x, cp1y));
  this.bbox.expandByPoint(_v2.set(cp2x, cp2y));
  this.bbox.expandByPoint(_v2.set(x, y));
};

Path2D.prototype.flatten = function (forceCloseContours) {

  var ret = new Path2D(this.precisionTolerance);

  var dataOffset = 0;
  var lastX = 0;
  var lastY = 0;
  var contourStartX = lastX;
  var contourStartY = lastY;

  var segTypes = this.segTypes;
  var segData = this.segData;

  var sz = this.bbox.size().length();

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          if (forceCloseContours) {
            if (lastX !== contourStartX || lastY !== contourStartY) {
              ret.closePath();
            }
          }

          lastX = segData[dataOffset++];
          lastY = segData[dataOffset++];
          contourStartX = lastX;
          contourStartY = lastY;
          ret.moveTo(lastX, lastY);
        }
        break;
      case CLOSE:
        ret.closePath();
        break;
      case LINETO:{
          var x = segData[dataOffset++];
          var y = segData[dataOffset++];

          if (x !== lastX || y !== lastY) {
            ret.lineTo(x, y);

            lastX = x;
            lastY = y;
          }
        }
        break;
      case QUADTO:{
          var cp1x = segData[dataOffset++],cp1y = segData[dataOffset++],
          x = segData[dataOffset++],y = segData[dataOffset++];
          Object(_bezier__WEBPACK_IMPORTED_MODULE_0__["TesselateQuad"])(ret, lastX, lastY, cp1x, cp1y, x, y, sz);
          //ret.lineTo(cp1x, cp1y);ret.lineTo(x.y);

          lastX = x;
          lastY = y;
        }
        break;
      case CUBICTO:{
          var cp1x = segData[dataOffset++],cp1y = segData[dataOffset++],
          cp2x = segData[dataOffset++],cp2y = segData[dataOffset++],
          x = segData[dataOffset++],y = segData[dataOffset++];
          Object(_bezier__WEBPACK_IMPORTED_MODULE_0__["TesselateCubic"])(ret, lastX, lastY, cp1x, cp1y, cp2x, cp2y, x, y, sz);
          //ret.lineTo(cp1x, cp1y);ret.lineTo(cp2x,cp2y);ret.lineTo(x.y);

          lastX = x;
          lastY = y;
        }
        break;
      case ARC:
        console.warn("not implemented: arc");
        dataOffset += 6;
        break;
      case ARCTO:
        console.warn("not implemented: arcto");
        dataOffset += 4;
        break;}

  }

  if (forceCloseContours) {
    if (lastX !== contourStartX || lastY !== contourStartY) {
      ret.closePath();
    }
  }

  return ret;
};


Path2D.prototype.stroke = function (loader, lineWidth, color, dbId, layerId, clipPath, applyTransform, lineStyle) {

  if (clipPath) {
    var outCode = clipPath.isAABBContain(this.bbox);
    if (outCode === OUTSIDE)
    return;
  }

  var p = this;
  if (applyTransform || this.hasCurves) {
    p = this.flatten(false);
  }

  var xform;
  if (applyTransform) {
    xform = loader.getCurrentTransform();
  }

  var dataOffset = 0;
  var lastX = 0;
  var lastY = 0;
  var contourStartX = 0;
  var contourStartY = 0;

  var segTypes = p.segTypes;
  var segData = p.segData;

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          lastX = segData[dataOffset++];
          lastY = segData[dataOffset++];
          contourStartX = lastX;
          contourStartY = lastY;
        }
        break;
      case CLOSE:
      case LINETO:{
          var x = st === CLOSE ? contourStartX : segData[dataOffset++];
          var y = st === CLOSE ? contourStartY : segData[dataOffset++];

          if (x !== lastX || y !== lastY) {
            loader.flushBuffer(4);

            if (applyTransform) {
              loader.currentVbb.addSegment(
              loader.tx(lastX, lastY, xform), loader.ty(lastX, lastY, xform),
              loader.tx(x, y, xform), loader.ty(x, y, xform),
              /*totalDistance*/0, lineWidth, color, dbId, layerId, 0, lineStyle);

            } else {
              loader.currentVbb.addSegment(
              lastX, lastY,
              x, y,
              /*totalDistance*/0, lineWidth, color, dbId, layerId, 0, lineStyle);

            }

            lastX = x;
            lastY = y;
          }
        }
        break;
      default:{
          console.error("Path must be flattened before rendering");
        }}



  }

};


//Checks if the path is a simple AABB.
//Used to speed up polygon clipping operations.
Path2D.prototype.isAABB = function () {

  var EPS = 1e-10;
  var ANGLE_EPS = 1e-3;

  var st = this.segTypes;

  if (st.length !== 6 && st.length !== 5)
  return false;

  if (st[0] !== MOVETO)
  return false;

  if (st.length === 6 && st[5] !== CLOSE)
  return false;else
  if (st.length === 5 && st[4] !== CLOSE && st[4] !== LINETO)
  return false;

  for (var i = 1; i < st.length - 1; i++) {
    if (st[i] !== LINETO)
    return false;}


  var seg = this.segData;

  //check segments 1 and 3 for parallel and same length
  var dxA = seg[2] - seg[0];
  var dyA = seg[3] - seg[1];
  var dxC = seg[6] - seg[4];
  var dyC = seg[7] - seg[5];
  var lenA = Math.sqrt(dxA * dxA + dyA * dyA);
  var lenC = Math.sqrt(dxC * dxC + dyC * dyC);

  if (Math.abs(lenA - lenC) > EPS)
  return false;

  dxA /= lenA;dyA /= lenA;
  dxC /= lenC;dyC /= lenC;
  var dot = dxA * dxC + dyA * dyC;

  if (Math.abs(1 + dot) > ANGLE_EPS)
  return false;

  //check segments 2 and 4 for parallel and same length
  var dxB = seg[4] - seg[2];
  var dyB = seg[5] - seg[3];
  var dxD = seg[8] - seg[6];
  var dyD = seg[9] - seg[7];
  var lenB = Math.sqrt(dxB * dxB + dyB * dyB);
  var lenD = Math.sqrt(dxD * dxD + dyD * dyD);

  if (Math.abs(lenB - lenD) > EPS)
  return false;

  dxB /= lenB;dyB /= lenB;
  dxD /= lenD;dyD /= lenD;
  dot = dxB * dxD + dyB * dyD;

  if (Math.abs(1 + dot) > ANGLE_EPS)
  return false;

  //make sure there is a right angle
  dot = dxA * dxB + dyA * dyB;

  if (Math.abs(dot) > ANGLE_EPS)
  return false;

  //make sure segments are vertical/horizontal
  if (Math.abs(dxA) > EPS && Math.abs(dyA))
  return false;

  return true;
};

var INSIDE = 1;
var OUTSIDE = 2;
var UNKNOWN = 4;

function bboxOverlap(clipBox, pathBox, precisionTolerance) {

  if (clipBox.containsBox(pathBox))
  return INSIDE;

  //The above AABB containment check is exact
  //and sometimes misses cases where the bboxes are
  //almost exactly equal, with very slight numeric noise in the values
  //(which happens quite often with Revit PDFs)

  //So now do another check if our bbox contains the input bbox within a tolerance
  var EPS = precisionTolerance;

  if (EPS === undefined) {
    EPS = 1e-3 / clipBox.size().length();
  }

  if (pathBox.min.x - clipBox.max.x > EPS)
  return OUTSIDE;
  if (pathBox.min.y - clipBox.min.y > EPS)
  return OUTSIDE;

  if (pathBox.max.x - clipBox.max.x < -EPS)
  return OUTSIDE;
  if (pathBox.max.y - clipBox.max.y < -EPS)
  return OUTSIDE;

  if (pathBox.min.x - clipBox.min.x < -EPS)
  return UNKNOWN;
  if (pathBox.min.y - clipBox.min.y < -EPS)
  return UNKNOWN;

  if (pathBox.max.x - clipBox.max.x > EPS)
  return UNKNOWN;
  if (pathBox.max.y - clipBox.max.y > EPS)
  return UNKNOWN;

  return INSIDE;
}

Path2D.prototype.isAABBContain = function (bbox) {

  if (!this.isAABB())
  return UNKNOWN;

  return bboxOverlap(this.bbox, bbox, this.precisionTolerance);
};


Path2D.prototype._addToDCEL = function (dcel, dbId, skipClipping) {
  var segTypes = this.segTypes;
  var segData = this.segData;
  var dataOffset = 0;

  var startX = 0,startY = 0,lastX = 0,lastY = 0;

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          //Force close the contour if it's not closed.
          if (lastX !== startX || lastY !== startY) {
            dcel.addDirectedEdge(lastX, lastY, startX, startY, skipClipping, dbId);
          }

          lastX = startX = segData[dataOffset++];
          lastY = startY = segData[dataOffset++];
        }
        break;
      case CLOSE:{
          dcel.addDirectedEdge(lastX, lastY, startX, startY, skipClipping, dbId);
        }
        break;
      case LINETO:{
          var x = segData[dataOffset++];
          var y = segData[dataOffset++];
          dcel.addDirectedEdge(lastX, lastY, x, y, skipClipping, dbId);
          lastX = x;
          lastY = y;
        }
        break;}

  }

  //Force close the contour if it's not closed.
  if (lastX !== startX || lastY !== startY) {
    dcel.addDirectedEdge(lastX, lastY, startX, startY, skipClipping, dbId);
  }
};

//Attempts to triangulate a closed path using the simplest ComplexPolygon way
//assuming there are no self-intersecting edges (but there could be holes or multiple closed regions)
//Attempts to eliminate coincident points
function triangulateEasy(path) {

  if (!path.segTypes.length)
  return null;

  var ContourSet = Autodesk.Viewing.Extensions.CompGeom.ContourSet;
  var UniquePointList = Autodesk.Viewing.Extensions.CompGeom.UniquePointList;

  var cset = new ContourSet();
  var verts = new UniquePointList(path.bbox);

  var segTypes = path.segTypes;
  var segData = path.segData;
  var dataOffset = 0;

  var last;
  var curcntr = [];

  function addContour(c) {

    if (!c.length)
    return;

    //Detect degenerate contours which we sometimes get from opentype.js fonts
    var isDegenerate = false;
    var isClosed = c[0] === c[c.length - 1];

    //TODO: this needs to be extended to check for something like zero area
    //that will catch more degenerate cases.
    if (isClosed && c.length <= 3)
    isDegenerate = true;

    if (!isClosed)
    console.log("Unexpected non-closed polygon contour");

    if (!isDegenerate)
    cset.addContour(c, true);
  }

  for (var i = 0; i < segTypes.length; i++) {

    var st = segTypes[i];

    switch (st) {

      case MOVETO:{
          addContour(curcntr);
          last = verts.findOrAddPoint(segData[dataOffset], segData[dataOffset + 1]);
          dataOffset += 2;
          curcntr = [last];
        }
        break;
      case CLOSE:{
          if (curcntr[0] !== curcntr[curcntr.length - 1])
          curcntr.push(curcntr[0]);

          addContour(curcntr);
          curcntr = [];
        }
        break;
      case LINETO:{
          last = verts.findOrAddPoint(segData[dataOffset], segData[dataOffset + 1]);
          dataOffset += 2;

          if (last !== curcntr[curcntr.length - 1])
          curcntr.push(last);
        }
        break;
      default:{
          console.warn("Path must be flattened before triangulating.");
          break;
        }}

  }


  addContour(curcntr);

  cset.triangulate();

  return cset;
}

//Triangulates a closed path using the DCEL structure, which allows self-intersecting polygons
function triangulateComplex(path) {

  //CompGeom extension is delay loaded, so we have to get the namespace later.
  var DCEL = Autodesk.Viewing.Extensions.CompGeom.DCEL;

  var dcel = new DCEL(path.bbox);

  path._addToDCEL(dcel, 1, false);

  dcel.finalize(true);

  return dcel.closedAreas;
}

function triangulateComplexBoolean(pathA, pathB, booleanOp) {

  //CompGeom extension is delay loaded, so we have to get the namespace later.
  var DCEL = Autodesk.Viewing.Extensions.CompGeom.DCEL;

  if (!booleanOp)
  booleanOp = "AND";

  //Polygon - polygon clip.
  //This way of performing the polygon intersection leaves a lot
  //to be optimized -- in particularm, we can make do with a single
  //DCEL structure, or remember the starting DCEL for the clip region in case it's used multiple times, etc.

  //Get a DCEL containing edges and split edges
  //from both polygons
  var totalBox = pathA.bbox.clone().union(pathB.bbox);
  var dcel = new DCEL(totalBox, Math.min(pathA.precisionTolerance, pathB.precisionTolerance));
  pathA._addToDCEL(dcel, 1);
  pathB._addToDCEL(dcel, 2);

  //TODO: here we can try the easier way of only creating
  //and edge list or quad tree of edges for containment checks
  //without explicitly triangulating
  var csetA = triangulateEasy(pathA);
  var csetB = triangulateEasy(pathB);

  if (!csetA) {
    return csetB;
  }
  if (!csetB) {
    return csetA;
  }

  //Is it a degenerate polygon (e.g. line segment)
  if (!csetA.contours.length) {
    return booleanOp === "AND" ? csetA : csetB;
  }
  if (!csetB.contours.length) {
    return booleanOp === "AND" ? csetB : csetA;
  }


  var pA = csetA.polygon;
  var pB = csetB.polygon;

  var getPolygonOp = function getPolygonOp() {
    switch (booleanOp) {
      case "AND":
        return function (cx, cy) {
          return pA.pointInPolygon(cx, cy) && pB.pointInPolygon(cx, cy);
        };
      case "XOR":
        return function (cx, cy) {
          return pA.quadTreeEdges.pointInPolygon(cx, cy) ^ pB.quadTreeEdges.pointInPolygon(cx, cy);
        };
      case "OR":
        return function (cx, cy) {
          return pA.pointInPolygon(cx, cy) || pB.pointInPolygon(cx, cy);
        };
      default:
        return undefined;}

  };

  var customInsideChecker = {
    pointInPolygon: getPolygonOp() };


  dcel.finalize(true, customInsideChecker);

  return dcel.closedAreas;
}


//Used for caching triangulates font characters
Path2D.prototype.cacheTriangulation = function () {

  //Unfortunately we cannot skip the flattening
  //for text glyphs when hasCurves is false, because
  //we need to check that all the contour are closed.
  //Not all fonts are disciplined about explicitly closing
  //their glyph outlines.
  this.flattened = this.flatten(true);

  var cset;

  cset = triangulateEasy(this.flattened);

  //convert to a contour set and triangulate

  var polygon = cset ? cset.polygon : null;

  this.polygon = [polygon];
  if (polygon) {
    this.flattened.polygon = this.polygon;
  }
};


Path2D.prototype.clip = function (clipPath, mode) {

  var p = this;
  var clipBox = p.bbox;

  var clipOut = false;
  var nonClippedOutline;

  //Check usual simple cases where one of the clips is the whole page rectangle and completely
  //contains the other.
  if (clipPath.isAABB()) {

    var outCode = bboxOverlap(clipPath.bbox, clipBox, this.precisionTolerance);

    if (outCode === OUTSIDE) {
      clipOut = true;
    } else if (outCode === INSIDE) {
      nonClippedOutline = p;
    }

  } else if (p.isAABB()) {

    var _outCode = bboxOverlap(clipBox, clipPath.bbox, this.precisionTolerance);

    if (_outCode === OUTSIDE) {
      clipOut = true;
    } else if (_outCode === INSIDE) {
      nonClippedOutline = clipPath;
    }
  }

  if (clipOut) {
    //TODO: actually here the clip region should be an empty region,
    //that clips out everything, but I'd rather leave it like this
    //to see if this ever happens.
    return null;
  }

  if (nonClippedOutline) {
    return nonClippedOutline;
  }

  //Catch-all complex clip case
  if (!clipOut && !nonClippedOutline) {

    console.log("Complex clipped clip.");

    var closedAreas = triangulateComplexBoolean(clipPath, p, "AND");

    //convert the contour set back to Path2D so we can return a clip path
    var res = new Path2D(this.precisionTolerance);

    for (var i = 0; i < closedAreas.length; i++) {

      var subp = closedAreas[i];

      for (var j = 0; j < subp.contours.length; j++) {

        var pts = subp.contours[j];

        for (var _i = 0; _i < pts.length; _i++) {
          var x = pts[_i].x;
          var y = pts[_i].y;

          if (_i === 0)
          res.lineTo(x, y);else

          res.moveTo(x, y);
        }

        res.closePath();
      }
    }

    return res;
  }

};


Path2D.prototype.fill = function (loader, color, dbId, layerId, clipPathIn, applyTransform) {

  //Unfortunately we cannot skip the flattening
  //for text glyphs when hasCurves is false, because
  //we need to check that all the contour are closed.
  //Not all fonts are disciplined about explicitly closing
  //their glyph outlines.
  var p = this.flattened || this.flatten(true);
  var clipPath;
  if (clipPathIn) {
    clipPath = clipPathIn.flattened || clipPathIn.flatten(true);
    clipPathIn.flattened = clipPath;
  }


  var polygon = p.polygon; //did we already cache the triangulation?

  //If the path is from a glyph cache, we need to transform its bbox
  //to current model space for clipping purposes
  var myClipBox = this.bbox;
  var xform;
  if (applyTransform) {
    xform = loader.getCurrentTransform();
    //TODO: This will not work if there is a rotation and the path to
    //be drawn has a transform.
    myClipBox = loader.transformBox(myClipBox, xform, _tmpBox);
  }

  var cset;
  var nonClippedOutline;
  var clipOut = false;

  var flagged = false;

  //TODO: in case of complex clip we would have to apply the transform (if any) before
  //clipping the polygons with each other.
  var ignoreClip = false;
  if (applyTransform)
  ignoreClip = true;

  if (!ignoreClip && clipPath) {

    //Special cases -- in PDFs, the path is often a simple AABB
    //used to color-fill a complicated region polygon that is set as clip.
    //It's possible that the path being draw is a simple rectangle and the clip
    //region is super complex (as opposed to simple rect clip and a complex path),
    //so we have to check both cases.

    //TODO: This is kind of a copy of Path2D.clip(), but not exactly. It might be
    //possible to unify the logic.
    if (clipPath.isAABB()) {

      var outCode = bboxOverlap(clipPath.bbox, myClipBox, this.precisionTolerance);

      if (outCode === OUTSIDE) {
        clipOut = true;
      } else if (outCode === INSIDE) {

        if (!polygon) {
          cset = triangulateEasy(p);

          if (!cset.triangulationFailed) {
            nonClippedOutline = p;
          }
        }
      }

    } else if (p.isAABB()) {

      var _outCode2 = bboxOverlap(myClipBox, clipPath.bbox, this.precisionTolerance);

      if (_outCode2 === OUTSIDE) {
        clipOut = true;
      } else if (_outCode2 === INSIDE) {

        if (!polygon)
        cset = triangulateEasy(clipPath);

        if (cset && !cset.triangulationFailed) {
          nonClippedOutline = clipPath;
        }
      }
    }

    //Catch-all complex clip case or when triangulation
    //fails above
    if (!clipOut && !nonClippedOutline) {

      //console.log("Complex clip");

      //flagged = true;

      cset = triangulateComplexBoolean(clipPath, p, "AND");

      //DEBUG:
      //clipPath.stroke(loader, -2.0, /*color*/0xff00ffff, -2, layerId);
      //p.stroke(loader, -2.0, /*color*/0xffffff00, -2, layerId);
    }

  } else {

    if (!polygon)
    cset = triangulateEasy(p);

    if (cset && cset.triangulationFailed) {
      cset = triangulateComplex(p);
    }

    nonClippedOutline = p;
  }

  //convert to a contour set and triangulate
  if (cset) {
    if (Array.isArray(cset))
    polygon = cset.map(function (c) {return c.polygon;});else

    polygon = [cset.polygon];
  }

  if (clipOut || !polygon) {
    return;
  }

  for (var i = 0; i < polygon.length; i++) {

    var subp = polygon[i];

    if (subp && subp.indices && subp.indices.length) {

      var pts = subp.pts;

      var pts2d = [];
      for (var _i2 = 0; _i2 < pts.length; _i2++) {
        var x = pts[_i2].x;
        var y = pts[_i2].y;

        if (applyTransform)
        pts2d.push(loader.tx(x, y, xform), loader.ty(x, y, xform));else

        pts2d.push(x, y);
      }

      loader.addPolyTriangle(pts2d, subp.indices, color, dbId, layerId, !nonClippedOutline);

      //Add thin outline to achieve an antialias effect
      if (nonClippedOutline)
      nonClippedOutline.stroke(loader, -0.5, color, dbId, layerId, null, applyTransform);

    }

  }

  //Debug only
  if (flagged) {
    //This code path highlights failed triangulations
    if (clipPath) {
      clipPath.stroke(loader, -3.0, 0xff00ff00, dbId, layerId, applyTransform);
      p.stroke(loader, -3.0, 0xff0000ff, dbId, layerId, applyTransform);
    } else {
      p.stroke(loader, -3.0, 0xffff00ff, dbId, layerId, applyTransform);
    }
  }

};

/***/ }),

/***/ "./extensions/PDF/test-pattern.js":
/*!****************************************!*\
  !*** ./extensions/PDF/test-pattern.js ***!
  \****************************************/
/*! exports provided: addContextCurrentTransform, generateTestPattern */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addContextCurrentTransform", function() { return addContextCurrentTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateTestPattern", function() { return generateTestPattern; });
/* harmony import */ var _bezier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bezier */ "./extensions/PDF/bezier.js");



//Copied from pdf.js, because our 2D renderer relies on mozCurrentTransform being available
function addContextCurrentTransform(ctx) {
  if (!ctx.mozCurrentTransform) {
    ctx._originalSave = ctx.save;
    ctx._originalRestore = ctx.restore;
    ctx._originalRotate = ctx.rotate;
    ctx._originalScale = ctx.scale;
    ctx._originalTranslate = ctx.translate;
    ctx._originalTransform = ctx.transform;
    ctx._originalSetTransform = ctx.setTransform;
    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
    ctx._transformStack = [];
    Object.defineProperty(ctx, 'mozCurrentTransform', {
      get: function getCurrentTransform() {
        return this._transformMatrix;
      } });

    Object.defineProperty(ctx, 'mozCurrentTransformInverse', {
      get: function getCurrentTransformInverse() {
        var m = this._transformMatrix;
        var a = m[0],
        b = m[1],
        c = m[2],
        d = m[3],
        e = m[4],
        f = m[5];
        var ad_bc = a * d - b * c;
        var bc_ad = b * c - a * d;
        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
      } });

    ctx.save = function ctxSave() {
      var old = this._transformMatrix;
      this._transformStack.push(old);
      this._transformMatrix = old.slice(0, 6);
      this._originalSave();
    };
    ctx.restore = function ctxRestore() {
      var prev = this._transformStack.pop();
      if (prev) {
        this._transformMatrix = prev;
        this._originalRestore();
      }
    };
    ctx.translate = function ctxTranslate(x, y) {
      var m = this._transformMatrix;
      m[4] = m[0] * x + m[2] * y + m[4];
      m[5] = m[1] * x + m[3] * y + m[5];
      this._originalTranslate(x, y);
    };
    ctx.scale = function ctxScale(x, y) {
      var m = this._transformMatrix;
      m[0] = m[0] * x;
      m[1] = m[1] * x;
      m[2] = m[2] * y;
      m[3] = m[3] * y;
      this._originalScale(x, y);
    };
    ctx.transform = function ctxTransform(a, b, c, d, e, f) {
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];
      ctx._originalTransform(a, b, c, d, e, f);
    };
    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
      this._transformMatrix = [a, b, c, d, e, f];
      ctx._originalSetTransform(a, b, c, d, e, f);
    };
    ctx.rotate = function ctxRotate(angle) {
      var cosValue = Math.cos(angle);
      var sinValue = Math.sin(angle);
      var m = this._transformMatrix;
      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];
      this._originalRotate(angle);
    };
  }
}


function polygonVerts(N, radius, phase) {

  var res = [];
  radius = radius || 1;
  phase = phase || 0;

  for (var angle = phase; angle < 360 + phase; angle += 360 / N) {

    var a = angle * Math.PI / 180;
    var x = radius * Math.cos(a);
    var y = radius * Math.sin(a);

    res.push(x);
    res.push(y);

  }

  return res;
}


function drawPolygon(ctx, x, y, N, R, phase) {
  var pts = polygonVerts(N, R, phase);

  ctx.beginPath();
  ctx.moveTo(pts[0] + x, pts[1] + y);

  for (var i = 2; i < pts.length; i += 2) {
    ctx.lineTo(pts[i] + x, pts[i + 1] + y);
  }

  ctx.closePath();
}

function drawStarPolygon(ctx, x, y, N, R, phase) {

  var pts = polygonVerts(N, R, phase);

  ctx.beginPath();
  ctx.moveTo(pts[0] + x, pts[1] + y);

  var count = 0;
  var next = 2;
  var total = pts.length / 2;
  while (count < total) {

    ctx.lineTo(pts[2 * next] + x, pts[2 * next + 1] + y);

    next += 2;
    next = next % total;
    count++;
  }

  ctx.closePath();

}


function generateTestPattern(ctx) {

  //Long text strings used in this test need dense tesselation setting compared to their bounding box
  Object(_bezier__WEBPACK_IMPORTED_MODULE_0__["SetTesselationParams"])(300, 0.005);

  var c = ctx.canvasContext;

  addContextCurrentTransform(c);

  //1. Draw the page
  c.fillStyle = "rgba(255, 255, 255, 1)";
  var vp = ctx.viewport;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(vp.width, 0);
  ctx.lineTo(vp.width, vp.height);
  ctx.lineTo(0, vp.height);
  ctx.closePath();
  ctx.fill();

  c.strokeStyle = "rgba(0, 0, 0, 1)";

  //Simple polygon
  c.fillStyle = "rgba(3, 137, 255, 1)";
  drawPolygon(ctx, 120, 50, 5, 30, 90);
  ctx.fill();
  ctx.stroke();

  //Self-intersecting polygon
  c.fillStyle = "rgba(255, 95, 3, 1)";
  drawStarPolygon(ctx, 190, 50, 5, 30, 90);
  ctx.fill();
  ctx.stroke();

  //Simple polygon
  c.fillStyle = "rgba(255, 255, 0, 1)";
  drawPolygon(ctx, 240, 350, 7, 30, 0);
  ctx.fill();
  ctx.stroke();

  //Self-intersecting polygon
  c.fillStyle = "rgba(90, 255, 123, 1)";
  drawStarPolygon(ctx, 310, 350, 7, 30, 0);
  ctx.fill();

  ctx.stroke();

  //Text
  c.fillStyle = "rgba(66, 66, 66, 1)";
  c.save();
  c.translate(50, 150);
  c.scale(1, -1);
  ctx.fillText("The quick brown", 0, 0, 800, { name: "Arial" }, 24);
  c.restore();

  c.save();
  c.translate(50, 186);
  c.scale(1, -1);
  ctx.fillText("fox jumps", 0, 0, 800, { name: "Courier" }, 72);
  c.restore();

  c.save();
  c.translate(50, 350);
  c.scale(1, -1);
  c.rotate(13);
  ctx.fillText("over the lazy dog.", 0, 0, 800, { name: "Times" }, 36);
  c.restore();

  //Polygon clipping
  c.fillStyle = "rgba(91, 167, 255, 1)";
  c.save();

  //Draw a pentagon and use it as clip region also
  drawPolygon(ctx, 150, 450, 5, 30, 90);
  ctx.fill();
  ctx.stroke();
  ctx.clip();

  //Fill a hexagon, taking into account the clip region
  c.fillStyle = "rgba(255, 167, 91, 1)";
  drawPolygon(ctx, 170, 450, 6, 30, 90);
  ctx.fill();

  //Stroke the hexagon -- currently this will not work (i.e. it will draw the outline unclipped)
  c.strokeStyle = "rgba(255, 0, 0, 1)";
  ctx.stroke();

  c.restore();


}

/***/ }),

/***/ "./node_modules/css-loader/index.js!./extensions/Edit2D/Edit2D.css":
/*!****************************************************************!*\
  !*** ./node_modules/css-loader!./extensions/Edit2D/Edit2D.css ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/lib/css-base.js */ "./node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "\n.adsk-viewing-viewer .edge-gizmo:hover\n{\n    background-color: rgb(0, 255, 0);\n}\n\n.adsk-viewing-viewer .edge-gizmo {\n    position: absolute;\n\n    background-color: #009bff;\n    box-shadow: 0px 1px 3px 1px rgba(0,0,0,0.25);\n\n    border-radius: 8px;\n    cursor: pointer;\n    z-index: 2;\n\n    -webkit-tap-highlight-color: rgba(0,0,0,0);\n}\n\n.adsk-viewing-viewer .edge-gizmo.selected\n{\n    background-color: rgb(0, 255, 0);\n}\n\n\n.adsk-viewing-viewer .vertex-gizmo:hover.vertex-gizmo.enable-hover\n{\n    border-color: rgb(0, 255, 0);\n}\n\n.adsk-viewing-viewer .vertex-gizmo {\n    display: inline-block;\n    position: absolute;\n    width: 7px;\n    height: 7px;\n    left: -2px;\n    top: -2px;\n    background-color: #009bff;\n    border-style: solid;\n    border-width: 2px;\n    border-color: #FFFFFF;\n    border-radius:100px;\n    box-shadow: 0 2px 5px 0 #182A3D;\n    z-index: 2;\n}\n\n.adsk-viewing-viewer .vertex-gizmo.selected\n{\n    border-color: rgb(0, 255, 0);\n}\n\n.adsk-viewing-viewer .edge-move-gizmo\n{\n    width: 20px; /* width along the edge */\n    height: 6px; /* height vertical to the edge */\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })

/******/ });
//# sourceMappingURL=Edit2D.js.map